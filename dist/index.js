function _defineProperties$4(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;

        if ("value" in descriptor) descriptor.writable = true;

        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class$4(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$4(Constructor.prototype, protoProps);

    return Constructor;
}

function _set_prototype_of$3(o, p) {
    _set_prototype_of$3 = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;

        return o;
    };

    return _set_prototype_of$3(o, p);
}

function _inherits$3(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });

    if (superClass) _set_prototype_of$3(subClass, superClass);
}

/**
 * Defines how the bounding volumes intersects or contain one another.
 */ var ContainmentType = /*#__PURE__*/ function(ContainmentType) {
    /** Indicates that there is no overlap between two bounding volumes. */ ContainmentType[ContainmentType["Disjoint"] = 0] = "Disjoint";
    /** Indicates that one bounding volume completely contains another volume. */ ContainmentType[ContainmentType["Contains"] = 1] = "Contains";
    /** Indicates that bounding volumes partially overlap one another. */ ContainmentType[ContainmentType["Intersects"] = 2] = "Intersects";
    return ContainmentType;
}({});

/**
 * Defines the intersection between a plane and a bounding volume.
 */ var PlaneIntersectionType = /*#__PURE__*/ function(PlaneIntersectionType) {
    /** There is no intersection, the bounding volume is in the back of the plane. */ PlaneIntersectionType[PlaneIntersectionType["Back"] = 0] = "Back";
    /** There is no intersection, the bounding volume is in the front of the plane. */ PlaneIntersectionType[PlaneIntersectionType["Front"] = 1] = "Front";
    /** The plane is intersected. */ PlaneIntersectionType[PlaneIntersectionType["Intersecting"] = 2] = "Intersecting";
    return PlaneIntersectionType;
}({});

/**
 * Frustum face
 */ var FrustumFace = /*#__PURE__*/ function(FrustumFace) {
    /** Near face */ FrustumFace[FrustumFace["Near"] = 0] = "Near";
    /** Far face */ FrustumFace[FrustumFace["Far"] = 1] = "Far";
    /** Left face */ FrustumFace[FrustumFace["Left"] = 2] = "Left";
    /** Right face */ FrustumFace[FrustumFace["Right"] = 3] = "Right";
    /** Bottom face */ FrustumFace[FrustumFace["Bottom"] = 4] = "Bottom";
    /** Top face */ FrustumFace[FrustumFace["Top"] = 5] = "Top";
    return FrustumFace;
}({});

function _defineProperties$3(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;

        if ("value" in descriptor) descriptor.writable = true;

        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class$3(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$3(Constructor.prototype, protoProps);

    return Constructor;
}

/**
 * Common utility methods for math operations.
 */ var MathUtil = /*#__PURE__*/ function() {
    function MathUtil() {}
    /**
   * Clamps the specified value.
   * @param v - The specified value
   * @param min - The min value
   * @param max - The max value
   * @returns The result of clamping a value between min and max
   */ MathUtil.clamp = function clamp(v, min, max) {
        return Math.max(min, Math.min(max, v));
    };
    /**
   * Checks if a and b are almost equals.
   * The absolute value of the difference between a and b is close to zero.
   * @param a - The left value to compare
   * @param b - The right value to compare
   * @returns True if a almost equal to b, false otherwise
   */ MathUtil.equals = function equals(a, b) {
        return Math.abs(a - b) <= MathUtil.zeroTolerance;
    };
    /**
   * Determines whether the specified v is pow2.
   * @param v - The specified v
   * @returns True if the specified v is pow2, false otherwise
   */ MathUtil.isPowerOf2 = function isPowerOf2(v) {
        return (v & v - 1) === 0;
    };
    /**
   * Modify the specified r from radian to degree.
   * @param r - The specified r
   * @returns The degree value
   */ MathUtil.radianToDegree = function radianToDegree(r) {
        return r * MathUtil.radToDegreeFactor;
    };
    /**
   * Modify the specified d from degree to radian.
   * @param d - The specified d
   * @returns The radian value
   */ MathUtil.degreeToRadian = function degreeToRadian(d) {
        return d * MathUtil.degreeToRadFactor;
    };
    /**
   * Linearly interpolate between two values
   * @param start - Specify the start of the range in which to interpolate
   * @param end - Specify the end of the range in which to interpolate
   * @param t - The blend amount where 0 returns start and 1 end
   * @returns The result of linear blending between start and end
   */ MathUtil.lerp = function lerp(start, end, t) {
        return start + (end - start) * t;
    };
    return MathUtil;
}();
/** The value for which all absolute numbers smaller than are considered equal to zero. */ MathUtil.zeroTolerance = 1e-6;
/** The conversion factor that radian to degree. */ MathUtil.radToDegreeFactor = 180 / Math.PI;
/** The conversion factor that degree to radian. */ MathUtil.degreeToRadFactor = Math.PI / 180;

/**
 * Describes a 3D-vector.
 */ var Vector3 = /*#__PURE__*/ function() {
    function Vector3(x, y, z) {
        if (x === void 0) x = 0;
        if (y === void 0) y = 0;
        if (z === void 0) z = 0;
        /** @internal */ this._onValueChanged = null;
        this._x = x;
        this._y = y;
        this._z = z;
    }
    var _proto = Vector3.prototype;
    /**
   * Set the value of this vector.
   * @param x - The x component of the vector
   * @param y - The y component of the vector
   * @param z - The z component of the vector
   * @returns This vector
   */ _proto.set = function set(x, y, z) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * Determines the sum of this vector and the specified vector.
   * @param right - The specified vector
   * @returns This vector
   */ _proto.add = function add(right) {
        this._x += right._x;
        this._y += right._y;
        this._z += right._z;
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * Determines the difference of this vector and the specified vector.
   * @param right - The specified vector
   * @returns This vector
   */ _proto.subtract = function subtract(right) {
        this._x -= right._x;
        this._y -= right._y;
        this._z -= right._z;
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * Determines the product of this vector and the specified vector.
   * @param right - The specified vector
   * @returns This vector
   */ _proto.multiply = function multiply(right) {
        this._x *= right._x;
        this._y *= right._y;
        this._z *= right._z;
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * Determines the divisor of this vector and the specified vector.
   * @param right - The specified vector
   * @returns This vector
   */ _proto.divide = function divide(right) {
        this._x /= right._x;
        this._y /= right._y;
        this._z /= right._z;
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * Calculate the length of this vector.
   * @returns The length of this vector
   */ _proto.length = function length() {
        var _this = this, _x = _this._x, _y = _this._y, _z = _this._z;
        return Math.sqrt(_x * _x + _y * _y + _z * _z);
    };
    /**
   * Calculate the squared length of this vector.
   * @returns The squared length of this vector
   */ _proto.lengthSquared = function lengthSquared() {
        var _this = this, _x = _this._x, _y = _this._y, _z = _this._z;
        return _x * _x + _y * _y + _z * _z;
    };
    /**
   * Reverses the direction of this vector.
   * @returns This vector
   */ _proto.negate = function negate() {
        this._x = -this._x;
        this._y = -this._y;
        this._z = -this._z;
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * Converts this vector into a unit vector.
   * @returns This vector
   */ _proto.normalize = function normalize() {
        Vector3.normalize(this, this);
        return this;
    };
    /**
   * Scale this vector by the given value.
   * @param s - The amount by which to scale the vector
   * @returns This vector
   */ _proto.scale = function scale(s) {
        this._x *= s;
        this._y *= s;
        this._z *= s;
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * This vector performs a normal transformation using the given 4x4 matrix.
   * @remarks
   * A normal transform performs the transformation with the assumption that the w component
   * is zero. This causes the fourth row and fourth column of the matrix to be unused. The
   * end result is a vector that is not translated, but all other transformation properties
   * apply. This is often preferred for normal vectors as normals purely represent direction
   * rather than location because normal vectors should not be translated.
   * @param m - The transform matrix
   * @returns This vector
   */ _proto.transformNormal = function transformNormal(m) {
        Vector3.transformNormal(this, m, this);
        return this;
    };
    /**
   * This vector performs a transformation using the given 4x4 matrix.
   * @param m - The transform matrix
   * @returns This vector
   */ _proto.transformToVec3 = function transformToVec3(m) {
        Vector3.transformToVec3(this, m, this);
        return this;
    };
    /**
   * This vector performs a coordinate transformation using the given 4x4 matrix.
   * @remarks
   * A coordinate transform performs the transformation with the assumption that the w component
   * is one. The four dimensional vector obtained from the transformation operation has each
   * component in the vector divided by the w component. This forces the w-component to be one and
   * therefore makes the vector homogeneous. The homogeneous vector is often preferred when working
   * with coordinates as the w component can safely be ignored.
   * @param m - The transform matrix
   * @returns This vector
   */ _proto.transformCoordinate = function transformCoordinate(m) {
        Vector3.transformCoordinate(this, m, this);
        return this;
    };
    /**
   * This vector performs a transformation using the given quaternion.
   * @param quaternion - The transform quaternion
   * @returns This vector
   */ _proto.transformByQuat = function transformByQuat(quaternion) {
        Vector3.transformByQuat(this, quaternion, this);
        return this;
    };
    /**
   * Creates a clone of this vector.
   * @returns A clone of this vector
   */ _proto.clone = function clone() {
        return new Vector3(this._x, this._y, this._z);
    };
    /**
   * Copy from vector3 like object.
   * @param source - Vector3 like object.
   * @returns This vector
   */ _proto.copyFrom = function copyFrom(source) {
        this._x = source.x;
        this._y = source.y;
        this._z = source.z;
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * Copy to vector3 like object.
   * @param target - Vector3 like object
   * @returns This Vector3 like object
   */ _proto.copyTo = function copyTo(target) {
        target.x = this._x;
        target.y = this._y;
        target.z = this._z;
        return target;
    };
    /**
   * Copy the value of this vector from an array.
   * @param array - The array
   * @param offset - The start offset of the array
   * @returns This vector
   */ _proto.copyFromArray = function copyFromArray(array, offset) {
        if (offset === void 0) offset = 0;
        this._x = array[offset];
        this._y = array[offset + 1];
        this._z = array[offset + 2];
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * Copy the value of this vector to an array.
   * @param out - The array
   * @param outOffset - The start offset of the array
   */ _proto.copyToArray = function copyToArray(out, outOffset) {
        if (outOffset === void 0) outOffset = 0;
        out[outOffset] = this._x;
        out[outOffset + 1] = this._y;
        out[outOffset + 2] = this._z;
    };
    /**
   * Serialize this vector to a JSON representation.
   * @returns A JSON representation of this vector
   */ _proto.toJSON = function toJSON() {
        return {
            x: this._x,
            y: this._y,
            z: this._z
        };
    };
    /**
   * Determines the sum of two vectors.
   * @param left - The first vector to add
   * @param right - The second vector to add
   * @param out - The sum of two vectors
   */ Vector3.add = function add(left, right, out) {
        out._x = left._x + right._x;
        out._y = left._y + right._y;
        out._z = left._z + right._z;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Determines the difference between two vectors.
   * @param left - The first vector to subtract
   * @param right - The second vector to subtract
   * @param out - The difference between two vectors
   */ Vector3.subtract = function subtract(left, right, out) {
        out._x = left._x - right._x;
        out._y = left._y - right._y;
        out._z = left._z - right._z;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Determines the product of two vectors.
   * @param left - The first vector to multiply
   * @param right - The second vector to multiply
   * @param out - The product of two vectors
   */ Vector3.multiply = function multiply(left, right, out) {
        out._x = left._x * right._x;
        out._y = left._y * right._y;
        out._z = left._z * right._z;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Determines the divisor of two vectors.
   * @param left - The first vector to divide
   * @param right - The second vector to divide
   * @param out - The divisor of two vectors
   */ Vector3.divide = function divide(left, right, out) {
        out._x = left._x / right._x;
        out._y = left._y / right._y;
        out._z = left._z / right._z;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Determines the dot product of two vectors.
   * @param left - The first vector to dot
   * @param right - The second vector to dot
   * @returns The dot product of two vectors
   */ Vector3.dot = function dot(left, right) {
        return left._x * right._x + left._y * right._y + left._z * right._z;
    };
    /**
   * Determines the cross product of two vectors.
   * @param left - The first vector to cross
   * @param right - The second vector to cross
   * @param out - The cross product of two vectors
   */ Vector3.cross = function cross(left, right, out) {
        var ax = left._x;
        var ay = left._y;
        var az = left._z;
        var bx = right._x;
        var by = right._y;
        var bz = right._z;
        out.set(ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx);
    };
    /**
   * Determines the distance of two vectors.
   * @param a - The first vector
   * @param b - The second vector
   * @returns The distance of two vectors
   */ Vector3.distance = function distance(a, b) {
        var x = b._x - a._x;
        var y = b._y - a._y;
        var z = b._z - a._z;
        return Math.sqrt(x * x + y * y + z * z);
    };
    /**
   * Determines the squared distance of two vectors.
   * @param a - The first vector
   * @param b - The second vector
   * @returns The squared distance of two vectors
   */ Vector3.distanceSquared = function distanceSquared(a, b) {
        var x = b._x - a._x;
        var y = b._y - a._y;
        var z = b._z - a._z;
        return x * x + y * y + z * z;
    };
    /**
   * Determines whether the specified vectors are equals.
   * @param left - The first vector to compare
   * @param right - The second vector to compare
   * @returns True if the specified vectors are equals, false otherwise
   */ Vector3.equals = function equals(left, right) {
        return MathUtil.equals(left._x, right._x) && MathUtil.equals(left._y, right._y) && MathUtil.equals(left._z, right._z);
    };
    /**
   * Performs a linear interpolation between two vectors.
   * @param start - The first vector
   * @param end - The second vector
   * @param t - The blend amount where 0 returns start and 1 end
   * @param out - The result of linear blending between two vectors
   */ Vector3.lerp = function lerp(start, end, t, out) {
        var _x = start._x, _y = start._y, _z = start._z;
        out._x = _x + (end._x - _x) * t;
        out._y = _y + (end._y - _y) * t;
        out._z = _z + (end._z - _z) * t;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Calculate a vector containing the largest components of the specified vectors.
   * @param left - The first vector
   * @param right - The second vector
   * @param out - The vector containing the largest components of the specified vectors
   */ Vector3.max = function max(left, right, out) {
        out._x = Math.max(left._x, right._x);
        out._y = Math.max(left._y, right._y);
        out._z = Math.max(left._z, right._z);
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Calculate a vector containing the smallest components of the specified vectors.
   * @param left - The first vector
   * @param right - The second vector
   * @param out - The vector containing the smallest components of the specified vectors
   */ Vector3.min = function min(left, right, out) {
        out._x = Math.min(left._x, right._x);
        out._y = Math.min(left._y, right._y);
        out._z = Math.min(left._z, right._z);
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Reverses the direction of a given vector.
   * @param a - The vector to negate
   * @param out - The vector facing in the opposite direction
   */ Vector3.negate = function negate(a, out) {
        out._x = -a._x;
        out._y = -a._y;
        out._z = -a._z;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Converts the vector into a unit vector.
   * @param a - The vector to normalize
   * @param out - The normalized vector
   */ Vector3.normalize = function normalize(a, out) {
        var _x = a._x, _y = a._y, _z = a._z;
        var len = Math.sqrt(_x * _x + _y * _y + _z * _z);
        if (len > MathUtil.zeroTolerance) {
            len = 1 / len;
            out.set(_x * len, _y * len, _z * len);
        }
    };
    /**
   * Scale a vector by the given value.
   * @param a - The vector to scale
   * @param s - The amount by which to scale the vector
   * @param out - The scaled vector
   */ Vector3.scale = function scale(a, s, out) {
        out._x = a._x * s;
        out._y = a._y * s;
        out._z = a._z * s;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Performs a normal transformation using the given 4x4 matrix.
   * @remarks
   * A normal transform performs the transformation with the assumption that the w component
   * is zero. This causes the fourth row and fourth column of the matrix to be unused. The
   * end result is a vector that is not translated, but all other transformation properties
   * apply. This is often preferred for normal vectors as normals purely represent direction
   * rather than location because normal vectors should not be translated.
   * @param v - The normal vector to transform
   * @param m - The transform matrix
   * @param out - The transformed normal
   */ Vector3.transformNormal = function transformNormal(v, m, out) {
        var _x = v._x, _y = v._y, _z = v._z;
        var e = m.elements;
        out._x = _x * e[0] + _y * e[4] + _z * e[8];
        out._y = _x * e[1] + _y * e[5] + _z * e[9];
        out._z = _x * e[2] + _y * e[6] + _z * e[10];
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Performs a transformation using the given 4x4 matrix.
   * @param v - The vector to transform
   * @param m - The transform matrix
   * @param out - The transformed vector3
   */ Vector3.transformToVec3 = function transformToVec3(v, m, out) {
        var _x = v._x, _y = v._y, _z = v._z;
        var e = m.elements;
        out._x = _x * e[0] + _y * e[4] + _z * e[8] + e[12];
        out._y = _x * e[1] + _y * e[5] + _z * e[9] + e[13];
        out._z = _x * e[2] + _y * e[6] + _z * e[10] + e[14];
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Performs a transformation from vector3 to vector4 using the given 4x4 matrix.
   * @param v - The vector to transform
   * @param m - The transform matrix
   * @param out - The transformed vector4
   */ Vector3.transformToVec4 = function transformToVec4(v, m, out) {
        var _x = v._x, _y = v._y, _z = v._z;
        var e = m.elements;
        out._x = _x * e[0] + _y * e[4] + _z * e[8] + e[12];
        out._y = _x * e[1] + _y * e[5] + _z * e[9] + e[13];
        out._z = _x * e[2] + _y * e[6] + _z * e[10] + e[14];
        out._w = _x * e[3] + _y * e[7] + _z * e[11] + e[15];
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Performs a coordinate transformation using the given 4x4 matrix.
   *
   * @remarks
   * A coordinate transform performs the transformation with the assumption that the w component
   * is one. The four dimensional vector obtained from the transformation operation has each
   * component in the vector divided by the w component. This forces the w-component to be one and
   * therefore makes the vector homogeneous. The homogeneous vector is often preferred when working
   * with coordinates as the w component can safely be ignored.
   * @param v - The coordinate vector to transform
   * @param m - The transform matrix
   * @param out - The transformed coordinates
   */ Vector3.transformCoordinate = function transformCoordinate(v, m, out) {
        var _x = v._x, _y = v._y, _z = v._z;
        var e = m.elements;
        var w = _x * e[3] + _y * e[7] + _z * e[11] + e[15];
        w = 1.0 / w;
        out._x = (_x * e[0] + _y * e[4] + _z * e[8] + e[12]) * w;
        out._y = (_x * e[1] + _y * e[5] + _z * e[9] + e[13]) * w;
        out._z = (_x * e[2] + _y * e[6] + _z * e[10] + e[14]) * w;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Performs a transformation using the given quaternion.
   * @param v - The vector to transform
   * @param quaternion - The transform quaternion
   * @param out - The transformed vector
   */ Vector3.transformByQuat = function transformByQuat(v, quaternion, out) {
        var _x = v._x, _y = v._y, _z = v._z;
        var qx = quaternion._x, qy = quaternion._y, qz = quaternion._z, qw = quaternion._w;
        // calculate quat * vec
        var ix = qw * _x + qy * _z - qz * _y;
        var iy = qw * _y + qz * _x - qx * _z;
        var iz = qw * _z + qx * _y - qy * _x;
        var iw = -qx * _x - qy * _y - qz * _z;
        // calculate result * inverse quat
        out._x = ix * qw - iw * qx - iy * qz + iz * qy;
        out._y = iy * qw - iw * qy - iz * qx + ix * qz;
        out._z = iz * qw - iw * qz - ix * qy + iy * qx;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    _create_class$3(Vector3, [
        {
            key: "x",
            get: /**
   * The x component of the vector.
   */ function get() {
                return this._x;
            },
            set: function set(value) {
                this._x = value;
                this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
            }
        },
        {
            key: "y",
            get: /**
   * The y component of the vector.
   */ function get() {
                return this._y;
            },
            set: function set(value) {
                this._y = value;
                this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
            }
        },
        {
            key: "z",
            get: /**
   * The z component of the vector.
   */ function get() {
                return this._z;
            },
            set: function set(value) {
                this._z = value;
                this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
            }
        }
    ]);
    return Vector3;
}();
/** @internal */ Vector3._zero = new Vector3(0.0, 0.0, 0.0);
/** @internal */ Vector3._one = new Vector3(1.0, 1.0, 1.0);

/**
 * A bounding sphere.
 * */ var BoundingSphere = /*#__PURE__*/ function() {
    function BoundingSphere(center, radius) {
        if (center === void 0) center = null;
        if (radius === void 0) radius = 0;
        /** The center point of the sphere. */ this.center = new Vector3();
        /** The radius of the sphere. */ this.radius = 0;
        center && this.center.copyFrom(center);
        this.radius = radius;
    }
    var _proto = BoundingSphere.prototype;
    /**
   * Creates a clone of this sphere.
   * @returns A clone of this sphere
   */ _proto.clone = function clone() {
        return new BoundingSphere(this.center, this.radius);
    };
    /**
   * Copy this sphere from the specified sphere.
   * @param source - The specified sphere
   * @returns This sphere
   */ _proto.copyFrom = function copyFrom(source) {
        this.center.copyFrom(source.center);
        this.radius = source.radius;
        return this;
    };
    /**
   * Calculate a bounding sphere that fully contains the given points.
   * @param points - The given points
   * @param out - The calculated bounding sphere
   */ BoundingSphere.fromPoints = function fromPoints(points, out) {
        if (!points || points.length === 0) {
            throw new Error("points must be array and length must > 0");
        }
        var len = points.length;
        var center = BoundingSphere._tempVec30;
        center.x = center.y = center.z = 0;
        // Calculate the center of the sphere.
        for(var i = 0; i < len; ++i){
            Vector3.add(points[i], center, center);
        }
        // The center of the sphere.
        Vector3.scale(center, 1 / len, out.center);
        // Calculate the radius of the sphere.
        var radius = 0.0;
        for(var i1 = 0; i1 < len; ++i1){
            var distance = Vector3.distanceSquared(center, points[i1]);
            distance > radius && (radius = distance);
        }
        // The radius of the sphere.
        out.radius = Math.sqrt(radius);
    };
    /**
   * Calculate a bounding sphere from a given box.
   * @param box - The given box
   * @param out - The calculated bounding sphere
   */ BoundingSphere.fromBox = function fromBox(box, out) {
        var center = out.center;
        var min = box.min, max = box.max;
        center.x = (min.x + max.x) * 0.5;
        center.y = (min.y + max.y) * 0.5;
        center.z = (min.z + max.z) * 0.5;
        out.radius = Vector3.distance(center, max);
    };
    return BoundingSphere;
}();
BoundingSphere._tempVec30 = new Vector3();

/**
 * Axis Aligned Bound Box (AABB).
 */ var BoundingBox = /*#__PURE__*/ function() {
    function BoundingBox(min, max) {
        if (min === void 0) min = null;
        if (max === void 0) max = null;
        /** The minimum point of the box. */ this.min = new Vector3();
        /** The maximum point of the box. */ this.max = new Vector3();
        min && this.min.copyFrom(min);
        max && this.max.copyFrom(max);
    }
    var _proto = BoundingBox.prototype;
    /**
   * Get the center point of this bounding box.
   * @param out - The center point of this bounding box
   * @returns The center point of this bounding box
   */ _proto.getCenter = function getCenter(out) {
        var _this = this, min = _this.min, max = _this.max;
        var centerX = max._x + min._x;
        var centerY = max._y + min._y;
        var centerZ = max._z + min._z;
        out.set(Number.isNaN(centerX) ? 0 : centerX * 0.5, Number.isNaN(centerY) ? 0 : centerY * 0.5, Number.isNaN(centerZ) ? 0 : centerZ * 0.5);
        return out;
    };
    /**
   * Get the extent of this bounding box.
   * @param out - The extent of this bounding box
   * @returns The extent of this bounding box
   */ _proto.getExtent = function getExtent(out) {
        var _this = this, min = _this.min, max = _this.max;
        var extentX = max._x - min._x;
        var extentY = max._y - min._y;
        var extentZ = max._z - min._z;
        out.set(Number.isNaN(extentX) ? 0 : extentX * 0.5, Number.isNaN(extentY) ? 0 : extentY * 0.5, Number.isNaN(extentZ) ? 0 : extentZ * 0.5);
        return out;
    };
    /**
   * Get the eight corners of this bounding box.
   * @param out - An array of points representing the eight corners of this bounding box
   * @returns An array of points representing the eight corners of this bounding box
   */ _proto.getCorners = function getCorners(out) {
        if (out === void 0) out = [];
        var _this = this, min = _this.min, max = _this.max;
        var minX = min.x;
        var minY = min.y;
        var minZ = min.z;
        var maxX = max.x;
        var maxY = max.y;
        var maxZ = max.z;
        var len = out.length;
        // The array length is less than 8 to make up
        if (len < 8) {
            for(var i = 0, l = 8 - len; i < l; ++i){
                out[len + i] = new Vector3();
            }
        }
        out[0].set(minX, maxY, maxZ);
        out[1].set(maxX, maxY, maxZ);
        out[2].set(maxX, minY, maxZ);
        out[3].set(minX, minY, maxZ);
        out[4].set(minX, maxY, minZ);
        out[5].set(maxX, maxY, minZ);
        out[6].set(maxX, minY, minZ);
        out[7].set(minX, minY, minZ);
        return out;
    };
    /**
   * Transform a bounding box.
   * @param matrix - The transform to apply to the bounding box
   * @returns The transformed bounding box
   */ _proto.transform = function transform(matrix) {
        BoundingBox.transform(this, matrix, this);
        return this;
    };
    /**
   * Creates a clone of this box.
   * @returns A clone of this box
   */ _proto.clone = function clone() {
        return new BoundingBox(this.min, this.max);
    };
    /**
   * Copy this bounding box from the specified box.
   * @param source - The specified box
   * @returns This bounding box
   */ _proto.copyFrom = function copyFrom(source) {
        this.min.copyFrom(source.min);
        this.max.copyFrom(source.max);
        return this;
    };
    /**
   * Serialize this bounding box to a JSON representation.
   * @returns A JSON representation of this bounding box
   */ _proto.toJSON = function toJSON() {
        var min = this.min;
        var max = this.max;
        return {
            min: {
                x: min._x,
                y: min._y,
                z: min._z
            },
            max: {
                x: max._x,
                y: max._y,
                z: max._z
            }
        };
    };
    /**
   * Calculate a bounding box from the center point and the extent of the bounding box.
   * @param center - The center point
   * @param extent - The extent of the bounding box
   * @param out - The calculated bounding box
   */ BoundingBox.fromCenterAndExtent = function fromCenterAndExtent(center, extent, out) {
        Vector3.subtract(center, extent, out.min);
        Vector3.add(center, extent, out.max);
    };
    /**
   * Calculate a bounding box that fully contains the given points.
   * @param points - The given points
   * @param out - The calculated bounding box
   */ BoundingBox.fromPoints = function fromPoints(points, out) {
        if (!points || points.length === 0) {
            throw new Error("points must be array and length must > 0");
        }
        var min = out.min, max = out.max;
        min.x = min.y = min.z = Number.MAX_VALUE;
        max.x = max.y = max.z = -Number.MAX_VALUE;
        for(var i = 0, l = points.length; i < l; ++i){
            var point = points[i];
            Vector3.min(min, point, min);
            Vector3.max(max, point, max);
        }
    };
    /**
   * Calculate a bounding box from a given sphere.
   * @param sphere - The given sphere
   * @param out - The calculated bounding box
   */ BoundingBox.fromSphere = function fromSphere(sphere, out) {
        var center = sphere.center, radius = sphere.radius;
        var min = out.min, max = out.max;
        min.x = center.x - radius;
        min.y = center.y - radius;
        min.z = center.z - radius;
        max.x = center.x + radius;
        max.y = center.y + radius;
        max.z = center.z + radius;
    };
    /**
   * Transform a bounding box.
   * @param source - The original bounding box
   * @param matrix - The transform to apply to the bounding box
   * @param out - The transformed bounding box
   */ BoundingBox.transform = function transform(source, matrix, out) {
        // https://zeux.io/2010/10/17/aabb-from-obb-with-component-wise-abs/
        var center = BoundingBox._tempVec30;
        var extent = BoundingBox._tempVec31;
        source.getCenter(center);
        source.getExtent(extent);
        Vector3.transformCoordinate(center, matrix, center);
        var x = extent.x, y = extent.y, z = extent.z;
        var e = matrix.elements;
        // prettier-ignore
        var e0 = e[0], e1 = e[1], e2 = e[2], e4 = e[4], e5 = e[5], e6 = e[6], e8 = e[8], e9 = e[9], e10 = e[10];
        extent.set((e0 === 0 ? 0 : Math.abs(x * e0)) + (e4 === 0 ? 0 : Math.abs(y * e4)) + (e8 === 0 ? 0 : Math.abs(z * e8)), (e1 === 0 ? 0 : Math.abs(x * e1)) + (e5 === 0 ? 0 : Math.abs(y * e5)) + (e9 === 0 ? 0 : Math.abs(z * e9)), (e2 === 0 ? 0 : Math.abs(x * e2)) + (e6 === 0 ? 0 : Math.abs(y * e6)) + (e10 === 0 ? 0 : Math.abs(z * e10)));
        // set min、max
        Vector3.subtract(center, extent, out.min);
        Vector3.add(center, extent, out.max);
    };
    /**
   * Calculate a bounding box that is as large as the total combined area of the two specified boxes.
   * @param box1 - The first box to merge
   * @param box2 - The second box to merge
   * @param out - The merged bounding box
   * @returns The merged bounding box
   */ BoundingBox.merge = function merge(box1, box2, out) {
        Vector3.min(box1.min, box2.min, out.min);
        Vector3.max(box1.max, box2.max, out.max);
        return out;
    };
    return BoundingBox;
}();
BoundingBox._tempVec30 = new Vector3();
BoundingBox._tempVec31 = new Vector3();

/**
 * Contains static methods to help in determining intersections, containment, etc.
 */ var CollisionUtil = /*#__PURE__*/ function() {
    function CollisionUtil() {}
    /**
   * Calculate the intersection point of three plane.
   * @param  p1 - Plane 1
   * @param  p2 - Plane 2
   * @param  p3 - Plane 3
   * @param out - intersection point
   */ CollisionUtil.intersectionPointThreePlanes = function intersectionPointThreePlanes(p1, p2, p3, out) {
        var p1Nor = p1.normal;
        var p2Nor = p2.normal;
        var p3Nor = p3.normal;
        Vector3.cross(p2Nor, p3Nor, CollisionUtil._tempVec30);
        Vector3.cross(p3Nor, p1Nor, CollisionUtil._tempVec31);
        Vector3.cross(p1Nor, p2Nor, CollisionUtil._tempVec32);
        var a = -Vector3.dot(p1Nor, CollisionUtil._tempVec30);
        var b = -Vector3.dot(p2Nor, CollisionUtil._tempVec31);
        var c = -Vector3.dot(p3Nor, CollisionUtil._tempVec32);
        Vector3.scale(CollisionUtil._tempVec30, p1.distance / a, CollisionUtil._tempVec30);
        Vector3.scale(CollisionUtil._tempVec31, p2.distance / b, CollisionUtil._tempVec31);
        Vector3.scale(CollisionUtil._tempVec32, p3.distance / c, CollisionUtil._tempVec32);
        Vector3.add(CollisionUtil._tempVec30, CollisionUtil._tempVec31, out);
        Vector3.add(out, CollisionUtil._tempVec32, out);
    };
    /**
   * Calculate the distance from a point to a plane.
   * @param plane - The plane
   * @param point - The point
   * @returns The distance from a point to a plane
   */ CollisionUtil.distancePlaneAndPoint = function distancePlaneAndPoint(plane, point) {
        return Vector3.dot(plane.normal, point) + plane.distance;
    };
    /**
   * Get the intersection type between a plane and a point.
   * @param plane - The plane
   * @param point - The point
   * @returns The intersection type
   */ CollisionUtil.intersectsPlaneAndPoint = function intersectsPlaneAndPoint(plane, point) {
        var distance = CollisionUtil.distancePlaneAndPoint(plane, point);
        if (distance > 0) {
            return PlaneIntersectionType.Front;
        }
        if (distance < 0) {
            return PlaneIntersectionType.Back;
        }
        return PlaneIntersectionType.Intersecting;
    };
    /**
   * Get the intersection type between a plane and a box (AABB).
   * @param plane - The plane
   * @param box - The box
   * @returns The intersection type
   */ CollisionUtil.intersectsPlaneAndBox = function intersectsPlaneAndBox(plane, box) {
        var min = box.min, max = box.max;
        var normal = plane.normal;
        var front = CollisionUtil._tempVec30;
        var back = CollisionUtil._tempVec31;
        if (normal.x >= 0) {
            front.x = max.x;
            back.x = min.x;
        } else {
            front.x = min.x;
            back.x = max.x;
        }
        if (normal.y >= 0) {
            front.y = max.y;
            back.y = min.y;
        } else {
            front.y = min.y;
            back.y = max.y;
        }
        if (normal.z >= 0) {
            front.z = max.z;
            back.z = min.z;
        } else {
            front.z = min.z;
            back.z = max.z;
        }
        if (CollisionUtil.distancePlaneAndPoint(plane, front) < 0) {
            return PlaneIntersectionType.Back;
        }
        if (CollisionUtil.distancePlaneAndPoint(plane, back) > 0) {
            return PlaneIntersectionType.Front;
        }
        return PlaneIntersectionType.Intersecting;
    };
    /**
   * Get the intersection type between a plane and a sphere.
   * @param plane - The plane
   * @param sphere - The sphere
   * @returns The intersection type
   */ CollisionUtil.intersectsPlaneAndSphere = function intersectsPlaneAndSphere(plane, sphere) {
        var center = sphere.center, radius = sphere.radius;
        var distance = CollisionUtil.distancePlaneAndPoint(plane, center);
        if (distance > radius) {
            return PlaneIntersectionType.Front;
        }
        if (distance < -radius) {
            return PlaneIntersectionType.Back;
        }
        return PlaneIntersectionType.Intersecting;
    };
    /**
   * Get the intersection type between a ray and a plane.
   * @param ray - The ray
   * @param plane - The plane
   * @returns The distance from ray to plane if intersecting, -1 otherwise
   */ CollisionUtil.intersectsRayAndPlane = function intersectsRayAndPlane(ray, plane) {
        var normal = plane.normal;
        var zeroTolerance = MathUtil.zeroTolerance;
        var dir = Vector3.dot(normal, ray.direction);
        // Parallel
        if (Math.abs(dir) < zeroTolerance) {
            return -1;
        }
        var position = Vector3.dot(normal, ray.origin);
        var distance = (-plane.distance - position) / dir;
        if (distance < 0) {
            if (distance < -zeroTolerance) {
                return -1;
            }
            distance = 0;
        }
        return distance;
    };
    /**
   * Get the intersection type between a ray and a box (AABB).
   * @param ray - The ray
   * @param box - The box
   * @returns The distance from ray to box if intersecting, -1 otherwise
   */ CollisionUtil.intersectsRayAndBox = function intersectsRayAndBox(ray, box) {
        var zeroTolerance = MathUtil.zeroTolerance;
        var origin = ray.origin, direction = ray.direction;
        var min = box.min, max = box.max;
        var dirX = direction.x;
        var dirY = direction.y;
        var dirZ = direction.z;
        var oriX = origin.x;
        var oriY = origin.y;
        var oriZ = origin.z;
        var distance = 0;
        var tmax = Number.MAX_VALUE;
        if (Math.abs(dirX) < zeroTolerance) {
            if (oriX < min.x || oriX > max.x) {
                return -1;
            }
        } else {
            var inverse = 1.0 / dirX;
            var t1 = (min.x - oriX) * inverse;
            var t2 = (max.x - oriX) * inverse;
            if (t1 > t2) {
                var temp = t1;
                t1 = t2;
                t2 = temp;
            }
            distance = Math.max(t1, distance);
            tmax = Math.min(t2, tmax);
            if (distance > tmax) {
                return -1;
            }
        }
        if (Math.abs(dirY) < zeroTolerance) {
            if (oriY < min.y || oriY > max.y) {
                return -1;
            }
        } else {
            var inverse1 = 1.0 / dirY;
            var t11 = (min.y - oriY) * inverse1;
            var t21 = (max.y - oriY) * inverse1;
            if (t11 > t21) {
                var temp1 = t11;
                t11 = t21;
                t21 = temp1;
            }
            distance = Math.max(t11, distance);
            tmax = Math.min(t21, tmax);
            if (distance > tmax) {
                return -1;
            }
        }
        if (Math.abs(dirZ) < zeroTolerance) {
            if (oriZ < min.z || oriZ > max.z) {
                return -1;
            }
        } else {
            var inverse2 = 1.0 / dirZ;
            var t12 = (min.z - oriZ) * inverse2;
            var t22 = (max.z - oriZ) * inverse2;
            if (t12 > t22) {
                var temp2 = t12;
                t12 = t22;
                t22 = temp2;
            }
            distance = Math.max(t12, distance);
            tmax = Math.min(t22, tmax);
            if (distance > tmax) {
                return -1;
            }
        }
        return distance;
    };
    /**
   * Get the intersection type between a ray and a sphere.
   * @param ray - The ray
   * @param sphere - The sphere
   * @returns The distance from ray to sphere if intersecting, -1 otherwise
   */ CollisionUtil.intersectsRayAndSphere = function intersectsRayAndSphere(ray, sphere) {
        var origin = ray.origin, direction = ray.direction;
        var center = sphere.center, radius = sphere.radius;
        var m = CollisionUtil._tempVec30;
        Vector3.subtract(origin, center, m);
        var b = Vector3.dot(m, direction);
        var c = Vector3.dot(m, m) - radius * radius;
        if (b > 0 && c > 0) {
            return -1;
        }
        var discriminant = b * b - c;
        if (discriminant < 0) {
            return -1;
        }
        var distance = -b - Math.sqrt(discriminant);
        if (distance < 0) {
            distance = 0;
        }
        return distance;
    };
    /**
   * Check whether the boxes intersect.
   * @param boxA - The first box to check
   * @param boxB - The second box to check
   * @returns True if the boxes intersect, false otherwise
   */ CollisionUtil.intersectsBoxAndBox = function intersectsBoxAndBox(boxA, boxB) {
        if (boxA.min.x > boxB.max.x || boxB.min.x > boxA.max.x) {
            return false;
        }
        if (boxA.min.y > boxB.max.y || boxB.min.y > boxA.max.y) {
            return false;
        }
        return !(boxA.min.z > boxB.max.z || boxB.min.z > boxA.max.z);
    };
    /**
   * Check whether the spheres intersect.
   * @param sphereA - The first sphere to check
   * @param sphereB - The second sphere to check
   * @returns True if the spheres intersect, false otherwise
   */ CollisionUtil.intersectsSphereAndSphere = function intersectsSphereAndSphere(sphereA, sphereB) {
        var radiisum = sphereA.radius + sphereB.radius;
        return Vector3.distanceSquared(sphereA.center, sphereB.center) < radiisum * radiisum;
    };
    /**
   * Check whether the sphere and the box intersect.
   * @param sphere - The sphere to check
   * @param box - The box to check
   * @returns True if the sphere and the box intersect, false otherwise
   */ CollisionUtil.intersectsSphereAndBox = function intersectsSphereAndBox(sphere, box) {
        var center = sphere.center;
        var max = box.max;
        var min = box.min;
        var closestPoint = CollisionUtil._tempVec30;
        closestPoint.set(Math.max(min.x, Math.min(center.x, max.x)), Math.max(min.y, Math.min(center.y, max.y)), Math.max(min.z, Math.min(center.z, max.z)));
        var distance = Vector3.distanceSquared(center, closestPoint);
        return distance <= sphere.radius * sphere.radius;
    };
    /**
   * Get whether or not a specified bounding box intersects with this frustum (Contains or Intersects).
   * @param frustum - The frustum
   * @param box - The box
   * @returns True if bounding box intersects with this frustum, false otherwise
   */ CollisionUtil.intersectsFrustumAndBox = function intersectsFrustumAndBox(frustum, box) {
        var min = box.min, max = box.max;
        var p = CollisionUtil._tempVec30;
        for(var i = 0; i < 6; ++i){
            var plane = frustum.getPlane(i);
            var normal = plane.normal;
            p.set(normal.x >= 0 ? max.x : min.x, normal.y >= 0 ? max.y : min.y, normal.z >= 0 ? max.z : min.z);
            if (Vector3.dot(normal, p) < -plane.distance) {
                return false;
            }
        }
        return true;
    };
    /**
   * Get the containment type between a frustum and a point.
   * @param frustum - The frustum
   * @param point - The point
   * @returns The containment type
   */ CollisionUtil.frustumContainsPoint = function frustumContainsPoint(frustum, point) {
        var distance = CollisionUtil.distancePlaneAndPoint(frustum.near, point);
        if (Math.abs(distance) < MathUtil.zeroTolerance) {
            return ContainmentType.Intersects;
        } else if (distance < 0) {
            return ContainmentType.Disjoint;
        }
        distance = CollisionUtil.distancePlaneAndPoint(frustum.far, point);
        if (Math.abs(distance) < MathUtil.zeroTolerance) {
            return ContainmentType.Intersects;
        } else if (distance < 0) {
            return ContainmentType.Disjoint;
        }
        distance = CollisionUtil.distancePlaneAndPoint(frustum.left, point);
        if (Math.abs(distance) < MathUtil.zeroTolerance) {
            return ContainmentType.Intersects;
        } else if (distance < 0) {
            return ContainmentType.Disjoint;
        }
        distance = CollisionUtil.distancePlaneAndPoint(frustum.right, point);
        if (Math.abs(distance) < MathUtil.zeroTolerance) {
            return ContainmentType.Intersects;
        } else if (distance < 0) {
            return ContainmentType.Disjoint;
        }
        distance = CollisionUtil.distancePlaneAndPoint(frustum.top, point);
        if (Math.abs(distance) < MathUtil.zeroTolerance) {
            return ContainmentType.Intersects;
        } else if (distance < 0) {
            return ContainmentType.Disjoint;
        }
        distance = CollisionUtil.distancePlaneAndPoint(frustum.bottom, point);
        if (Math.abs(distance) < MathUtil.zeroTolerance) {
            return ContainmentType.Intersects;
        } else if (distance < 0) {
            return ContainmentType.Disjoint;
        }
        return ContainmentType.Contains;
    };
    /**
   * Get the containment type between a frustum and a box (AABB).
   * @param frustum - The frustum
   * @param box - The box
   * @returns The containment type
   */ CollisionUtil.frustumContainsBox = function frustumContainsBox(frustum, box) {
        var min = box.min, max = box.max;
        var p = CollisionUtil._tempVec30;
        var n = CollisionUtil._tempVec31;
        var result = ContainmentType.Contains;
        for(var i = 0; i < 6; ++i){
            var plane = frustum.getPlane(i);
            var normal = plane.normal;
            if (normal.x >= 0) {
                p.x = max.x;
                n.x = min.x;
            } else {
                p.x = min.x;
                n.x = max.x;
            }
            if (normal.y >= 0) {
                p.y = max.y;
                n.y = min.y;
            } else {
                p.y = min.y;
                n.y = max.y;
            }
            if (normal.z >= 0) {
                p.z = max.z;
                n.z = min.z;
            } else {
                p.z = min.z;
                n.z = max.z;
            }
            if (CollisionUtil.intersectsPlaneAndPoint(plane, p) === PlaneIntersectionType.Back) {
                return ContainmentType.Disjoint;
            }
            if (CollisionUtil.intersectsPlaneAndPoint(plane, n) === PlaneIntersectionType.Back) {
                result = ContainmentType.Intersects;
            }
        }
        return result;
    };
    /**
   * Get the containment type between a frustum and a sphere.
   * @param frustum - The frustum
   * @param sphere - The sphere
   * @returns The containment type
   */ CollisionUtil.frustumContainsSphere = function frustumContainsSphere(frustum, sphere) {
        var result = ContainmentType.Contains;
        for(var i = 0; i < 6; ++i){
            var plane = frustum.getPlane(i);
            var intersectionType = CollisionUtil.intersectsPlaneAndSphere(plane, sphere);
            if (intersectionType === PlaneIntersectionType.Back) {
                return ContainmentType.Disjoint;
            } else if (intersectionType === PlaneIntersectionType.Intersecting) {
                result = ContainmentType.Intersects;
                break;
            }
        }
        return result;
    };
    return CollisionUtil;
}();
CollisionUtil._tempVec30 = new Vector3();
CollisionUtil._tempVec31 = new Vector3();
CollisionUtil._tempVec32 = new Vector3();

/**
 * Represents a plane in three-dimensional space.
 */ var Plane = /*#__PURE__*/ function() {
    function Plane(normal, distance) {
        if (normal === void 0) normal = null;
        if (distance === void 0) distance = 0;
        /** The normal of the plane. */ this.normal = new Vector3();
        /** The distance of the plane along its normal to the origin. */ this.distance = 0;
        normal && this.normal.copyFrom(normal);
        this.distance = distance;
    }
    var _proto = Plane.prototype;
    /**
   * Normalize the normal vector of this plane.
   * @returns The plane after normalize
   */ _proto.normalize = function normalize() {
        Plane.normalize(this, this);
        return this;
    };
    /**
   * Creates a clone of this plane.
   * @returns A clone of this plane
   */ _proto.clone = function clone() {
        var out = new Plane();
        out.copyFrom(this);
        return out;
    };
    /**
   * Copy this plane from the specified plane.
   * @param source - The specified plane
   * @returns This plane
   */ _proto.copyFrom = function copyFrom(source) {
        this.normal.copyFrom(source.normal);
        this.distance = source.distance;
        return this;
    };
    /**
   * Normalize the normal vector of the specified plane.
   * @param p - The specified plane
   * @param out - A normalized version of the specified plane
   */ Plane.normalize = function normalize(p, out) {
        var normal = p.normal;
        var factor = 1.0 / normal.length();
        Vector3.scale(normal, factor, out.normal);
        out.distance = p.distance * factor;
    };
    /**
   * Calculate the plane that contains the three specified points.
   * @param point0 - The first point
   * @param point1 - The second point
   * @param point2 - The third point
   * @param out - The calculated plane
   */ Plane.fromPoints = function fromPoints(point0, point1, point2, out) {
        var x0 = point0.x;
        var y0 = point0.y;
        var z0 = point0.z;
        var x1 = point1.x - x0;
        var y1 = point1.y - y0;
        var z1 = point1.z - z0;
        var x2 = point2.x - x0;
        var y2 = point2.y - y0;
        var z2 = point2.z - z0;
        var yz = y1 * z2 - z1 * y2;
        var xz = z1 * x2 - x1 * z2;
        var xy = x1 * y2 - y1 * x2;
        var invPyth = 1.0 / Math.sqrt(yz * yz + xz * xz + xy * xy);
        var x = yz * invPyth;
        var y = xz * invPyth;
        var z = xy * invPyth;
        var normal = out.normal;
        normal.x = x;
        normal.y = y;
        normal.z = z;
        out.distance = -(x * x0 + y * y0 + z * z0);
    };
    return Plane;
}();

/**
 * A bounding frustum.
 */ var BoundingFrustum = /*#__PURE__*/ function() {
    function BoundingFrustum(matrix) {
        if (matrix === void 0) matrix = null;
        this.near = new Plane();
        this.far = new Plane();
        this.left = new Plane();
        this.right = new Plane();
        this.top = new Plane();
        this.bottom = new Plane();
        matrix && this.calculateFromMatrix(matrix);
    }
    var _proto = BoundingFrustum.prototype;
    /**
   * Get the plane by the given frustum face.
   * @param face - The frustum face
   * @returns The plane get
   */ _proto.getPlane = function getPlane(face) {
        switch(face){
            case FrustumFace.Near:
                return this.near;
            case FrustumFace.Far:
                return this.far;
            case FrustumFace.Left:
                return this.left;
            case FrustumFace.Right:
                return this.right;
            case FrustumFace.Bottom:
                return this.bottom;
            case FrustumFace.Top:
                return this.top;
            default:
                return null;
        }
    };
    /**
   * Update all planes from the given matrix.
   * @param matrix - The given view-projection matrix
   */ _proto.calculateFromMatrix = function calculateFromMatrix(matrix) {
        var me = matrix.elements;
        var m11 = me[0];
        var m12 = me[1];
        var m13 = me[2];
        var m14 = me[3];
        var m21 = me[4];
        var m22 = me[5];
        var m23 = me[6];
        var m24 = me[7];
        var m31 = me[8];
        var m32 = me[9];
        var m33 = me[10];
        var m34 = me[11];
        var m41 = me[12];
        var m42 = me[13];
        var m43 = me[14];
        var m44 = me[15];
        // near
        var nearNormal = this.near.normal;
        nearNormal.set(m14 + m13, m24 + m23, m34 + m33);
        this.near.distance = m44 + m43;
        this.near.normalize();
        // far
        var farNormal = this.far.normal;
        farNormal.set(m14 - m13, m24 - m23, m34 - m33);
        this.far.distance = m44 - m43;
        this.far.normalize();
        // left
        var leftNormal = this.left.normal;
        leftNormal.set(m14 + m11, m24 + m21, m34 + m31);
        this.left.distance = m44 + m41;
        this.left.normalize();
        // right
        var rightNormal = this.right.normal;
        rightNormal.set(m14 - m11, m24 - m21, m34 - m31);
        this.right.distance = m44 - m41;
        this.right.normalize();
        // bottom
        var bottomNormal = this.bottom.normal;
        bottomNormal.set(m14 + m12, m24 + m22, m34 + m32);
        this.bottom.distance = m44 + m42;
        this.bottom.normalize();
        // top
        var topNormal = this.top.normal;
        topNormal.set(m14 - m12, m24 - m22, m34 - m32);
        this.top.distance = m44 - m42;
        this.top.normalize();
    };
    /**
   * Get whether or not a specified bounding box intersects with this frustum (Contains or Intersects).
   * @param box - The box for testing
   * @returns True if bounding box intersects with this frustum, false otherwise
   */ _proto.intersectsBox = function intersectsBox(box) {
        return CollisionUtil.intersectsFrustumAndBox(this, box);
    };
    /**
   * Get whether or not a specified bounding sphere intersects with this frustum (Contains or Intersects).
   * @param sphere - The sphere for testing
   * @returns True if bounding sphere intersects with this frustum, false otherwise
   */ _proto.intersectsSphere = function intersectsSphere(sphere) {
        return CollisionUtil.frustumContainsSphere(this, sphere) !== ContainmentType.Disjoint;
    };
    /**
   * Creates a clone of this frustum.
   * @returns A clone of this frustum
   */ _proto.clone = function clone() {
        var out = new BoundingFrustum();
        out.copyFrom(this);
        return out;
    };
    /**
   * Copy this frustum from the specified frustum.
   * @param source - The specified frustum
   * @returns This frustum
   */ _proto.copyFrom = function copyFrom(source) {
        this.near.copyFrom(source.near);
        this.far.copyFrom(source.far);
        this.left.copyFrom(source.left);
        this.right.copyFrom(source.right);
        this.bottom.copyFrom(source.bottom);
        this.top.copyFrom(source.top);
        return this;
    };
    return BoundingFrustum;
}();

/**
 * Represents a 3x3 mathematical matrix.
 */ var Matrix3x3 = /*#__PURE__*/ function() {
    function Matrix3x3(m11, m12, m13, m21, m22, m23, m31, m32, m33) {
        if (m11 === void 0) m11 = 1;
        if (m12 === void 0) m12 = 0;
        if (m13 === void 0) m13 = 0;
        if (m21 === void 0) m21 = 0;
        if (m22 === void 0) m22 = 1;
        if (m23 === void 0) m23 = 0;
        if (m31 === void 0) m31 = 0;
        if (m32 === void 0) m32 = 0;
        if (m33 === void 0) m33 = 1;
        /**
   * An array containing the elements of the matrix (column matrix).
   * @remarks
   * elements[0] first column and first row value m11
   * elements[1] first column and second row value m12
   * elements[2] first column and third row value m13
   * elements[3] second column and first row value m21
   * and so on
   */ this.elements = new Float32Array(9);
        var e = this.elements;
        e[0] = m11;
        e[1] = m12;
        e[2] = m13;
        e[3] = m21;
        e[4] = m22;
        e[5] = m23;
        e[6] = m31;
        e[7] = m32;
        e[8] = m33;
    }
    var _proto = Matrix3x3.prototype;
    /**
   * Set the value of this matrix, and return this matrix.
   * @param m11
   * @param m12
   * @param m13
   * @param m21
   * @param m22
   * @param m23
   * @param m31
   * @param m32
   * @param m33
   * @returns This matrix
   */ _proto.set = function set(m11, m12, m13, m21, m22, m23, m31, m32, m33) {
        var e = this.elements;
        e[0] = m11;
        e[1] = m12;
        e[2] = m13;
        e[3] = m21;
        e[4] = m22;
        e[5] = m23;
        e[6] = m31;
        e[7] = m32;
        e[8] = m33;
        return this;
    };
    /**
   * Determines the sum of this matrix and the specified matrix.
   * @param right - The specified matrix
   * @returns This matrix that store the sum of the two matrices
   */ _proto.add = function add(right) {
        Matrix3x3.add(this, right, this);
        return this;
    };
    /**
   * Determines the difference between this matrix and the specified matrix.
   * @param right - The specified matrix
   * @returns This matrix that store the difference between the two matrices
   */ _proto.subtract = function subtract(right) {
        Matrix3x3.subtract(this, right, this);
        return this;
    };
    /**
   * Determines the product of this matrix and the specified matrix.
   * @param right - The specified matrix
   * @returns This matrix that store the product of the two matrices
   */ _proto.multiply = function multiply(right) {
        Matrix3x3.multiply(this, right, this);
        return this;
    };
    /**
   * Calculate a determinant of this matrix.
   * @returns The determinant of this matrix
   */ _proto.determinant = function determinant() {
        var e = this.elements;
        var a11 = e[0], a12 = e[1], a13 = e[2];
        var a21 = e[3], a22 = e[4], a23 = e[5];
        var a31 = e[6], a32 = e[7], a33 = e[8];
        var b12 = a33 * a22 - a23 * a32;
        var b22 = -a33 * a21 + a23 * a31;
        var b32 = a32 * a21 - a22 * a31;
        return a11 * b12 + a12 * b22 + a13 * b32;
    };
    /**
   * Identity this matrix.
   * @returns This matrix after identity
   */ _proto.identity = function identity() {
        var e = this.elements;
        e[0] = 1;
        e[1] = 0;
        e[2] = 0;
        e[3] = 0;
        e[4] = 1;
        e[5] = 0;
        e[6] = 0;
        e[7] = 0;
        e[8] = 1;
        return this;
    };
    /**
   * Invert the matrix.
   * @returns The matrix after invert
   */ _proto.invert = function invert() {
        Matrix3x3.invert(this, this);
        return this;
    };
    /**
   * This matrix rotates around an angle.
   * @param r - The rotation angle in radians
   * @returns This matrix after rotate
   */ _proto.rotate = function rotate(r) {
        Matrix3x3.rotate(this, r, this);
        return this;
    };
    /**
   * Scale this matrix by a given vector.
   * @param s - The given vector
   * @returns This matrix after scale
   */ _proto.scale = function scale(s) {
        Matrix3x3.scale(this, s, this);
        return this;
    };
    /**
   * Translate this matrix by a given vector.
   * @param translation - The given vector
   * @returns This matrix after translate
   */ _proto.translate = function translate(translation) {
        Matrix3x3.translate(this, translation, this);
        return this;
    };
    /**
   * Calculate the transpose of this matrix.
   * @returns This matrix after transpose
   */ _proto.transpose = function transpose() {
        Matrix3x3.transpose(this, this);
        return this;
    };
    /**
   * Creates a clone of this matrix.
   * @returns A clone of this matrix
   */ _proto.clone = function clone() {
        var e = this.elements;
        var ret = new Matrix3x3(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]);
        return ret;
    };
    /**
   * Copy this matrix from the specified matrix.
   * @param source - The specified matrix
   * @returns This matrix
   */ _proto.copyFrom = function copyFrom(source) {
        var e = this.elements;
        var se = source.elements;
        e[0] = se[0];
        e[1] = se[1];
        e[2] = se[2];
        e[3] = se[3];
        e[4] = se[4];
        e[5] = se[5];
        e[6] = se[6];
        e[7] = se[7];
        e[8] = se[8];
        return this;
    };
    /**
   * Copy the value of this matrix from an array.
   * @param array - The array
   * @param offset - The start offset of the array
   * @returns This matrix
   */ _proto.copyFromArray = function copyFromArray(array, offset) {
        if (offset === void 0) offset = 0;
        var srce = this.elements;
        for(var i = 0; i < 12; i++){
            srce[i] = array[i + offset];
        }
        return this;
    };
    /**
   * Copy the value of this matrix to an array.
   * @param out - The array
   * @param outOffset - The start offset of the array
   */ _proto.copyToArray = function copyToArray(out, outOffset) {
        if (outOffset === void 0) outOffset = 0;
        var e = this.elements;
        out[outOffset] = e[0];
        out[outOffset + 1] = e[1];
        out[outOffset + 2] = e[2];
        out[outOffset + 3] = e[3];
        out[outOffset + 4] = e[4];
        out[outOffset + 5] = e[5];
        out[outOffset + 6] = e[6];
        out[outOffset + 7] = e[7];
        out[outOffset + 8] = e[8];
    };
    /**
   * Copy the value of this 3x3 matrix from the specified 4x4 matrix.
   * upper-left principle
   * @param source - The specified 4x4 matrix
   * @returns This 3x3 matrix
   */ _proto.copyFromMatrix = function copyFromMatrix(source) {
        var ae = source.elements;
        var e = this.elements;
        e[0] = ae[0];
        e[1] = ae[1];
        e[2] = ae[2];
        e[3] = ae[4];
        e[4] = ae[5];
        e[5] = ae[6];
        e[6] = ae[8];
        e[7] = ae[9];
        e[8] = ae[10];
        return this;
    };
    /**
   * Determines the sum of two matrices.
   * @param left - The first matrix to add
   * @param right - The second matrix to add
   * @param out - The sum of two matrices
   */ Matrix3x3.add = function add(left, right, out) {
        var le = left.elements;
        var re = right.elements;
        var oe = out.elements;
        oe[0] = le[0] + re[0];
        oe[1] = le[1] + re[1];
        oe[2] = le[2] + re[2];
        oe[3] = le[3] + re[3];
        oe[4] = le[4] + re[4];
        oe[5] = le[5] + re[5];
        oe[6] = le[6] + re[6];
        oe[7] = le[7] + re[7];
        oe[8] = le[8] + re[8];
    };
    /**
   * Determines the difference between two matrices.
   * @param left - The first matrix to subtract
   * @param right - The second matrix to subtract
   * @param out - The difference between two matrices
   */ Matrix3x3.subtract = function subtract(left, right, out) {
        var le = left.elements;
        var re = right.elements;
        var oe = out.elements;
        oe[0] = le[0] - re[0];
        oe[1] = le[1] - re[1];
        oe[2] = le[2] - re[2];
        oe[3] = le[3] - re[3];
        oe[4] = le[4] - re[4];
        oe[5] = le[5] - re[5];
        oe[6] = le[6] - re[6];
        oe[7] = le[7] - re[7];
        oe[8] = le[8] - re[8];
    };
    /**
   * Determines the product of two matrices.
   * @param left - The first matrix to multiply
   * @param right - The second matrix to multiply
   * @param out - The product of two matrices
   */ Matrix3x3.multiply = function multiply(left, right, out) {
        var le = left.elements;
        var re = right.elements;
        var oe = out.elements;
        var l11 = le[0], l12 = le[1], l13 = le[2];
        var l21 = le[3], l22 = le[4], l23 = le[5];
        var l31 = le[6], l32 = le[7], l33 = le[8];
        var r11 = re[0], r12 = re[1], r13 = re[2];
        var r21 = re[3], r22 = re[4], r23 = re[5];
        var r31 = re[6], r32 = re[7], r33 = re[8];
        oe[0] = l11 * r11 + l21 * r12 + l31 * r13;
        oe[1] = l12 * r11 + l22 * r12 + l32 * r13;
        oe[2] = l13 * r11 + l23 * r12 + l33 * r13;
        oe[3] = l11 * r21 + l21 * r22 + l31 * r23;
        oe[4] = l12 * r21 + l22 * r22 + l32 * r23;
        oe[5] = l13 * r21 + l23 * r22 + l33 * r23;
        oe[6] = l11 * r31 + l21 * r32 + l31 * r33;
        oe[7] = l12 * r31 + l22 * r32 + l32 * r33;
        oe[8] = l13 * r31 + l23 * r32 + l33 * r33;
    };
    /**
   * Determines whether the specified matrices are equals.
   * @param left - The first matrix to compare
   * @param right - The second matrix to compare
   * @returns True if the specified matrices are equals, false otherwise
   */ Matrix3x3.equals = function equals(left, right) {
        var le = left.elements;
        var re = right.elements;
        return MathUtil.equals(le[0], re[0]) && MathUtil.equals(le[1], re[1]) && MathUtil.equals(le[2], re[2]) && MathUtil.equals(le[3], re[3]) && MathUtil.equals(le[4], re[4]) && MathUtil.equals(le[5], re[5]) && MathUtil.equals(le[6], re[6]) && MathUtil.equals(le[7], re[7]) && MathUtil.equals(le[8], re[8]);
    };
    /**
   * Performs a linear interpolation between two matrices.
   * @param start - The first matrix
   * @param end - The second matrix
   * @param t - The blend amount where 0 returns start and 1 end
   * @param out - The result of linear blending between two matrices
   */ Matrix3x3.lerp = function lerp(start, end, t, out) {
        var se = start.elements;
        var ee = end.elements;
        var oe = out.elements;
        var inv = 1.0 - t;
        oe[0] = se[0] * inv + ee[0] * t;
        oe[1] = se[1] * inv + ee[1] * t;
        oe[2] = se[2] * inv + ee[2] * t;
        oe[3] = se[3] * inv + ee[3] * t;
        oe[4] = se[4] * inv + ee[4] * t;
        oe[5] = se[5] * inv + ee[5] * t;
        oe[6] = se[6] * inv + ee[6] * t;
        oe[7] = se[7] * inv + ee[7] * t;
        oe[8] = se[8] * inv + ee[8] * t;
    };
    /**
   * Calculate a rotation matrix from a quaternion.
   * @param quaternion - The quaternion used to calculate the matrix
   * @param out - The calculated rotation matrix
   */ Matrix3x3.rotationQuaternion = function rotationQuaternion(quaternion, out) {
        var oe = out.elements;
        var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;
        var xx = x * x2;
        var yx = y * x2;
        var yy = y * y2;
        var zx = z * x2;
        var zy = z * y2;
        var zz = z * z2;
        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;
        oe[0] = 1 - yy - zz;
        oe[3] = yx - wz;
        oe[6] = zx + wy;
        oe[1] = yx + wz;
        oe[4] = 1 - xx - zz;
        oe[7] = zy - wx;
        oe[2] = zx - wy;
        oe[5] = zy + wx;
        oe[8] = 1 - xx - yy;
    };
    /**
   * Calculate a matrix from scale vector.
   * @param s - The scale vector
   * @param out - The calculated matrix
   */ Matrix3x3.scaling = function scaling(s, out) {
        var oe = out.elements;
        oe[0] = s._x;
        oe[1] = 0;
        oe[2] = 0;
        oe[3] = 0;
        oe[4] = s._y;
        oe[5] = 0;
        oe[6] = 0;
        oe[7] = 0;
        oe[8] = 1;
    };
    /**
   * Calculate a matrix from translation vector.
   * @param translation - The translation vector
   * @param out - The calculated matrix
   */ Matrix3x3.translation = function translation(translation, out) {
        var oe = out.elements;
        oe[0] = 1;
        oe[1] = 0;
        oe[2] = 0;
        oe[3] = 0;
        oe[4] = 1;
        oe[5] = 0;
        oe[6] = translation._x;
        oe[7] = translation._y;
        oe[8] = 1;
    };
    /**
   * Calculate the inverse of the specified matrix.
   * @param a - The matrix whose inverse is to be calculated
   * @param out - The inverse of the specified matrix
   */ Matrix3x3.invert = function invert(a, out) {
        var ae = a.elements;
        var oe = out.elements;
        var a11 = ae[0], a12 = ae[1], a13 = ae[2];
        var a21 = ae[3], a22 = ae[4], a23 = ae[5];
        var a31 = ae[6], a32 = ae[7], a33 = ae[8];
        var b12 = a33 * a22 - a23 * a32;
        var b22 = -a33 * a21 + a23 * a31;
        var b32 = a32 * a21 - a22 * a31;
        var det = a11 * b12 + a12 * b22 + a13 * b32;
        if (!det) {
            return;
        }
        det = 1.0 / det;
        oe[0] = b12 * det;
        oe[1] = (-a33 * a12 + a13 * a32) * det;
        oe[2] = (a23 * a12 - a13 * a22) * det;
        oe[3] = b22 * det;
        oe[4] = (a33 * a11 - a13 * a31) * det;
        oe[5] = (-a23 * a11 + a13 * a21) * det;
        oe[6] = b32 * det;
        oe[7] = (-a32 * a11 + a12 * a31) * det;
        oe[8] = (a22 * a11 - a12 * a21) * det;
    };
    /**
   * Calculate a 3x3 normal matrix from a 4x4 matrix.
   * @remarks The calculation process is the transpose matrix of the inverse matrix.
   * @param mat4 - The 4x4 matrix
   * @param out - THe 3x3 normal matrix
   */ Matrix3x3.normalMatrix = function normalMatrix(mat4, out) {
        var ae = mat4.elements;
        var oe = out.elements;
        var a11 = ae[0], a12 = ae[1], a13 = ae[2], a14 = ae[3];
        var a21 = ae[4], a22 = ae[5], a23 = ae[6], a24 = ae[7];
        var a31 = ae[8], a32 = ae[9], a33 = ae[10], a34 = ae[11];
        var a41 = ae[12], a42 = ae[13], a43 = ae[14], a44 = ae[15];
        var b00 = a11 * a22 - a12 * a21;
        var b01 = a11 * a23 - a13 * a21;
        var b02 = a11 * a24 - a14 * a21;
        var b03 = a12 * a23 - a13 * a22;
        var b04 = a12 * a24 - a14 * a22;
        var b05 = a13 * a24 - a14 * a23;
        var b06 = a31 * a42 - a32 * a41;
        var b07 = a31 * a43 - a33 * a41;
        var b08 = a31 * a44 - a34 * a41;
        var b09 = a32 * a43 - a33 * a42;
        var b10 = a32 * a44 - a34 * a42;
        var b11 = a33 * a44 - a34 * a43;
        var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        if (!det) {
            return null;
        }
        det = 1.0 / det;
        oe[0] = (a22 * b11 - a23 * b10 + a24 * b09) * det;
        oe[1] = (a23 * b08 - a21 * b11 - a24 * b07) * det;
        oe[2] = (a21 * b10 - a22 * b08 + a24 * b06) * det;
        oe[3] = (a13 * b10 - a12 * b11 - a14 * b09) * det;
        oe[4] = (a11 * b11 - a13 * b08 + a14 * b07) * det;
        oe[5] = (a12 * b08 - a11 * b10 - a14 * b06) * det;
        oe[6] = (a42 * b05 - a43 * b04 + a44 * b03) * det;
        oe[7] = (a43 * b02 - a41 * b05 - a44 * b01) * det;
        oe[8] = (a41 * b04 - a42 * b02 + a44 * b00) * det;
    };
    /**
   * The specified matrix rotates around an angle.
   * @param a - The specified matrix
   * @param r - The rotation angle in radians
   * @param out - The rotated matrix
   */ Matrix3x3.rotate = function rotate(a, r, out) {
        var ae = a.elements;
        var oe = out.elements;
        var s = Math.sin(r);
        var c = Math.cos(r);
        var a11 = ae[0], a12 = ae[1], a13 = ae[2];
        var a21 = ae[3], a22 = ae[4], a23 = ae[5];
        var a31 = ae[6], a32 = ae[7], a33 = ae[8];
        oe[0] = c * a11 + s * a21;
        oe[1] = c * a12 + s * a22;
        oe[2] = c * a13 + s * a23;
        oe[3] = c * a21 - s * a11;
        oe[4] = c * a22 - s * a12;
        oe[5] = c * a23 - s * a13;
        oe[6] = a31;
        oe[7] = a32;
        oe[8] = a33;
    };
    /**
   * Scale a matrix by a given vector.
   * @param m - The matrix
   * @param s - The given vector
   * @param out - The scaled matrix
   */ Matrix3x3.scale = function scale(m, s, out) {
        var x = s._x, y = s._y;
        var ae = m.elements;
        var oe = out.elements;
        oe[0] = x * ae[0];
        oe[1] = x * ae[1];
        oe[2] = x * ae[2];
        oe[3] = y * ae[3];
        oe[4] = y * ae[4];
        oe[5] = y * ae[5];
        oe[6] = ae[6];
        oe[7] = ae[7];
        oe[8] = ae[8];
    };
    /**
   * Translate a matrix by a given vector.
   * @param m - The matrix
   * @param translation - The given vector
   * @param out - The translated matrix
   */ Matrix3x3.translate = function translate(m, translation, out) {
        var x = translation._x, y = translation._y;
        var ae = m.elements;
        var oe = out.elements;
        var a11 = ae[0], a12 = ae[1], a13 = ae[2];
        var a21 = ae[3], a22 = ae[4], a23 = ae[5];
        var a31 = ae[6], a32 = ae[7], a33 = ae[8];
        oe[0] = a11;
        oe[1] = a12;
        oe[2] = a13;
        oe[3] = a21;
        oe[4] = a22;
        oe[5] = a23;
        oe[6] = x * a11 + y * a21 + a31;
        oe[7] = x * a12 + y * a22 + a32;
        oe[8] = x * a13 + y * a23 + a33;
    };
    /**
   * Calculate the transpose of the specified matrix.
   * @param a - The specified matrix
   * @param out - The transpose of the specified matrix
   */ Matrix3x3.transpose = function transpose(a, out) {
        var ae = a.elements;
        var oe = out.elements;
        if (out === a) {
            var a12 = ae[1];
            var a13 = ae[2];
            var a23 = ae[5];
            oe[1] = ae[3];
            oe[2] = ae[6];
            oe[3] = a12;
            oe[5] = ae[7];
            oe[6] = a13;
            oe[7] = a23;
        } else {
            oe[0] = ae[0];
            oe[1] = ae[3];
            oe[2] = ae[6];
            oe[3] = ae[1];
            oe[4] = ae[4];
            oe[5] = ae[7];
            oe[6] = ae[2];
            oe[7] = ae[5];
            oe[8] = ae[8];
        }
    };
    return Matrix3x3;
}();

/**
 * Represents a four dimensional mathematical quaternion.
 */ var Quaternion = /*#__PURE__*/ function() {
    function Quaternion(x, y, z, w) {
        if (x === void 0) x = 0;
        if (y === void 0) y = 0;
        if (z === void 0) z = 0;
        if (w === void 0) w = 1;
        /** @internal */ this._onValueChanged = null;
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
    }
    var _proto = Quaternion.prototype;
    /**
   * Set the value of this quaternion, and return this quaternion.
   * @param x - The x component of the quaternion
   * @param y - The y component of the quaternion
   * @param z - The z component of the quaternion
   * @param w - The w component of the quaternion
   * @returns This quaternion
   */ _proto.set = function set(x, y, z, w) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * Transforms this quaternion into its conjugated version.
   * @returns This quaternion
   */ _proto.conjugate = function conjugate() {
        this._x *= -1;
        this._y *= -1;
        this._z *= -1;
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * Get the rotation axis and rotation angle of the quaternion (unit: radians).
   * @param out - The axis as an output parameter
   * @returns The rotation angle (unit: radians)
   */ _proto.getAxisAngle = function getAxisAngle(out) {
        var _this = this, _x = _this._x, _y = _this._y, _z = _this._z;
        var length = _x * _x + _y * _y + _z * _z;
        if (length < MathUtil.zeroTolerance) {
            out._x = 1;
            out._y = 0;
            out._z = 0;
            return 0;
        } else {
            var inv = 1.0 / length;
            out._x = this._x * inv;
            out._y = this._y * inv;
            out._z = this._z * inv;
            return Math.acos(this._w) * 2.0;
        }
    };
    /**
   * Identity this quaternion.
   * @returns This quaternion after identity
   */ _proto.identity = function identity() {
        this._x = 0;
        this._y = 0;
        this._z = 0;
        this._w = 1;
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * Calculate the length of this quaternion.
   * @returns The length of this quaternion
   */ _proto.length = function length() {
        var _this = this, _x = _this._x, _y = _this._y, _z = _this._z, _w = _this._w;
        return Math.sqrt(_x * _x + _y * _y + _z * _z + _w * _w);
    };
    /**
   * Calculates the squared length of this quaternion.
   * @returns The squared length of this quaternion
   */ _proto.lengthSquared = function lengthSquared() {
        var _this = this, _x = _this._x, _y = _this._y, _z = _this._z, _w = _this._w;
        return _x * _x + _y * _y + _z * _z + _w * _w;
    };
    /**
   * Converts this quaternion into a unit quaternion.
   * @returns This quaternion
   */ _proto.normalize = function normalize() {
        Quaternion.normalize(this, this);
        return this;
    };
    /**
   * Get the euler of this quaternion.
   * @param out - The euler (in radians) as an output parameter
   * @returns Euler x->pitch y->yaw z->roll
   */ _proto.toEuler = function toEuler(out) {
        this._toYawPitchRoll(out);
        var t = out._x;
        out._x = out._y;
        out._y = t;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
        return out;
    };
    /**
   * Get the euler of this quaternion.
   * @param out - The euler (in radians) as an output parameter
   * @returns Euler x->yaw y->pitch z->roll
   */ _proto.toYawPitchRoll = function toYawPitchRoll(out) {
        this._toYawPitchRoll(out);
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
        return out;
    };
    /**
   * Calculate this quaternion rotate around X axis.
   * @param rad - The rotation angle in radians
   * @returns This quaternion
   */ _proto.rotateX = function rotateX(rad) {
        Quaternion.rotateX(this, rad, this);
        return this;
    };
    /**
   * Calculate this quaternion rotate around Y axis.
   * @param rad - The rotation angle in radians
   * @returns This quaternion
   */ _proto.rotateY = function rotateY(rad) {
        Quaternion.rotateY(this, rad, this);
        return this;
    };
    /**
   * Calculate this quaternion rotate around Z axis.
   * @param rad - The rotation angle in radians
   * @returns This quaternion
   */ _proto.rotateZ = function rotateZ(rad) {
        Quaternion.rotateZ(this, rad, this);
        return this;
    };
    /**
   * Calculate this quaternion rotates around an arbitrary axis.
   * @param axis - The axis
   * @param rad - The rotation angle in radians
   * @returns This quaternion
   */ _proto.rotationAxisAngle = function rotationAxisAngle(axis, rad) {
        Quaternion.rotationAxisAngle(axis, rad, this);
        return this;
    };
    /**
   * Determines the product of this quaternion and the specified quaternion.
   * @param quat - The specified quaternion
   * @returns The product of the two quaternions
   */ _proto.multiply = function multiply(quat) {
        Quaternion.multiply(this, quat, this);
        return this;
    };
    /**
   * Invert this quaternion.
   * @returns This quaternion after invert
   */ _proto.invert = function invert() {
        Quaternion.invert(this, this);
        return this;
    };
    /**
   * Determines the dot product of this quaternion and the specified quaternion.
   * @param quat - The specified quaternion
   * @returns The dot product of two quaternions
   */ _proto.dot = function dot(quat) {
        return Quaternion.dot(this, quat);
    };
    /**
   * Performs a linear blend between this quaternion and the specified quaternion.
   * @param quat - The specified quaternion
   * @param t - The blend amount where 0 returns this and 1 quat
   * @returns - The result of linear blending between two quaternions
   */ _proto.lerp = function lerp(quat, t) {
        Quaternion.lerp(this, quat, t, this);
        return this;
    };
    /**
   * Calculate this quaternion rotation around an arbitrary axis.
   * @param axis - The axis
   * @param rad - The rotation angle in radians
   * @returns This quaternion
   */ _proto.rotateAxisAngle = function rotateAxisAngle(axis, rad) {
        Quaternion._tempQuat1.rotationAxisAngle(axis, rad);
        this.multiply(Quaternion._tempQuat1);
        return this;
    };
    /**
   * Creates a clone of this quaternion.
   * @returns A clone of this quaternion
   */ _proto.clone = function clone() {
        return new Quaternion(this._x, this._y, this._z, this._w);
    };
    /**
   * Copy this quaternion from the specified quaternion.
   * @param source - The specified quaternion
   * @returns This quaternion
   */ _proto.copyFrom = function copyFrom(source) {
        this._x = source.x;
        this._y = source.y;
        this._z = source.z;
        this._w = source.w;
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * Copy this quaternion to the specified quaternion.
   * @param target - The specified quaternion
   * @returns This specified quaternion
   */ _proto.copyTo = function copyTo(target) {
        target.x = this._x;
        target.y = this._y;
        target.z = this._z;
        target.w = this._w;
        return target;
    };
    /**
   * Copy the value of this quaternion from an array.
   * @param array - The array
   * @param offset - The start offset of the array
   * @returns This quaternion
   */ _proto.copyFromArray = function copyFromArray(array, offset) {
        if (offset === void 0) offset = 0;
        this._x = array[offset];
        this._y = array[offset + 1];
        this._z = array[offset + 2];
        this._w = array[offset + 3];
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * Copy the value of this quaternion to an array.
   * @param out - The array
   * @param outOffset - The start offset of the array
   */ _proto.copyToArray = function copyToArray(out, outOffset) {
        if (outOffset === void 0) outOffset = 0;
        out[outOffset] = this._x;
        out[outOffset + 1] = this._y;
        out[outOffset + 2] = this._z;
        out[outOffset + 3] = this._w;
    };
    /**
   * Serialize this quaternion to a JSON representation.
   * @returns A JSON Object representation of this quaternion
   */ _proto.toJSON = function toJSON() {
        return {
            x: this._x,
            y: this._y,
            z: this._z,
            w: this._w
        };
    };
    _proto._toYawPitchRoll = function _toYawPitchRoll(out) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToEuler/
        var _this = this, x = _this._x, y = _this._y, z = _this._z, w = _this._w;
        var xx = x * x;
        var yy = y * y;
        var zz = z * z;
        var ww = w * w;
        var unit = xx + yy + zz + ww;
        var test = 2 * (x * w - y * z);
        if (test > (1 - MathUtil.zeroTolerance) * unit) {
            out._x = Math.atan2(2.0 * (w * y - x * z), xx + ww - yy - zz);
            out._y = Math.PI / 2;
            out._z = 0;
        } else if (test < -(1 - MathUtil.zeroTolerance) * unit) {
            out._x = Math.atan2(2.0 * (w * y - x * z), xx + ww - yy - zz);
            out._y = -Math.PI / 2;
            out._z = 0;
        } else {
            out._x = Math.atan2(2.0 * (z * x + y * w), zz + ww - yy - xx);
            out._y = Math.asin(test / unit);
            out._z = Math.atan2(2.0 * (x * y + z * w), yy + ww - zz - xx);
        }
    };
    /**
   * Determines the sum of two quaternions.
   * @param left - The first quaternion to add
   * @param right - The second quaternion to add
   * @param out - The sum of two quaternions
   */ Quaternion.add = function add(left, right, out) {
        out._x = left._x + right._x;
        out._y = left._y + right._y;
        out._z = left._z + right._z;
        out._w = left._w + right._w;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Determines the product of two quaternions.
   * @param left - The first quaternion to multiply
   * @param right - The second quaternion to multiply
   * @param out - The product of two quaternions
   */ Quaternion.multiply = function multiply(left, right, out) {
        var ax = left._x, ay = left._y, az = left._z, aw = left._w;
        var bx = right._x, by = right._y, bz = right._z, bw = right._w;
        out._x = ax * bw + aw * bx + ay * bz - az * by;
        out._y = ay * bw + aw * by + az * bx - ax * bz;
        out._z = az * bw + aw * bz + ax * by - ay * bx;
        out._w = aw * bw - ax * bx - ay * by - az * bz;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Calculate quaternion that contains conjugated version of the specified quaternion.
   * @param a - The specified quaternion
   * @param out - The conjugate version of the specified quaternion
   */ Quaternion.conjugate = function conjugate(a, out) {
        out._x = -a._x;
        out._y = -a._y;
        out._z = -a._z;
        out._w = a._w;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Determines the dot product of two quaternions.
   * @param left - The first quaternion to dot
   * @param right - The second quaternion to dot
   * @returns The dot product of two quaternions
   */ Quaternion.dot = function dot(left, right) {
        return left._x * right._x + left._y * right._y + left._z * right._z + left._w * right._w;
    };
    /**
   * Determines whether the specified quaternions are equals.
   * @param left - The first quaternion to compare
   * @param right - The second quaternion to compare
   * @returns True if the specified quaternions are equals, false otherwise
   */ Quaternion.equals = function equals(left, right) {
        return MathUtil.equals(left._x, right._x) && MathUtil.equals(left._y, right._y) && MathUtil.equals(left._z, right._z) && MathUtil.equals(left._w, right._w);
    };
    /**
   * Calculate a quaternion rotates around an arbitrary axis.
   * @param axis - The axis
   * @param rad - The rotation angle in radians
   * @param out - The quaternion after rotate
   */ Quaternion.rotationAxisAngle = function rotationAxisAngle(axis, rad, out) {
        var normalAxis = Quaternion._tempVector3;
        Vector3.normalize(axis, normalAxis);
        rad *= 0.5;
        var s = Math.sin(rad);
        out._x = normalAxis._x * s;
        out._y = normalAxis._y * s;
        out._z = normalAxis._z * s;
        out._w = Math.cos(rad);
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Calculate a quaternion rotates around x, y, z axis (pitch/yaw/roll).
   * @param x - The radian of rotation around X (pitch)
   * @param y - The radian of rotation around Y (yaw)
   * @param z - The radian of rotation around Z (roll)
   * @param out - The calculated quaternion
   */ Quaternion.rotationEuler = function rotationEuler(x, y, z, out) {
        Quaternion.rotationYawPitchRoll(y, x, z, out);
    };
    /**
   * Calculate a quaternion from the specified yaw, pitch and roll angles.
   * @param yaw - Yaw around the y axis in radians
   * @param pitch - Pitch around the x axis in radians
   * @param roll - Roll around the z axis in radians
   * @param out - The calculated quaternion
   */ Quaternion.rotationYawPitchRoll = function rotationYawPitchRoll(yaw, pitch, roll, out) {
        var halfRoll = roll * 0.5;
        var halfPitch = pitch * 0.5;
        var halfYaw = yaw * 0.5;
        var sinRoll = Math.sin(halfRoll);
        var cosRoll = Math.cos(halfRoll);
        var sinPitch = Math.sin(halfPitch);
        var cosPitch = Math.cos(halfPitch);
        var sinYaw = Math.sin(halfYaw);
        var cosYaw = Math.cos(halfYaw);
        var cosYawPitch = cosYaw * cosPitch;
        var sinYawPitch = sinYaw * sinPitch;
        out._x = cosYaw * sinPitch * cosRoll + sinYaw * cosPitch * sinRoll;
        out._y = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll;
        out._z = cosYawPitch * sinRoll - sinYawPitch * cosRoll;
        out._w = cosYawPitch * cosRoll + sinYawPitch * sinRoll;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Calculate a quaternion from the specified 3x3 matrix.
   * @param m - The specified 3x3 matrix
   * @param out - The calculated quaternion
   */ Quaternion.rotationMatrix3x3 = function rotationMatrix3x3(m, out) {
        var me = m.elements;
        var m11 = me[0], m12 = me[1], m13 = me[2];
        var m21 = me[3], m22 = me[4], m23 = me[5];
        var m31 = me[6], m32 = me[7], m33 = me[8];
        var scale = m11 + m22 + m33;
        var sqrt, half;
        if (scale > 0) {
            sqrt = Math.sqrt(scale + 1.0);
            out._w = sqrt * 0.5;
            sqrt = 0.5 / sqrt;
            out._x = (m23 - m32) * sqrt;
            out._y = (m31 - m13) * sqrt;
            out._z = (m12 - m21) * sqrt;
        } else if (m11 >= m22 && m11 >= m33) {
            sqrt = Math.sqrt(1.0 + m11 - m22 - m33);
            half = 0.5 / sqrt;
            out._x = 0.5 * sqrt;
            out._y = (m12 + m21) * half;
            out._z = (m13 + m31) * half;
            out._w = (m23 - m32) * half;
        } else if (m22 > m33) {
            sqrt = Math.sqrt(1.0 + m22 - m11 - m33);
            half = 0.5 / sqrt;
            out._x = (m21 + m12) * half;
            out._y = 0.5 * sqrt;
            out._z = (m32 + m23) * half;
            out._w = (m31 - m13) * half;
        } else {
            sqrt = Math.sqrt(1.0 + m33 - m11 - m22);
            half = 0.5 / sqrt;
            out._x = (m13 + m31) * half;
            out._y = (m23 + m32) * half;
            out._z = 0.5 * sqrt;
            out._w = (m12 - m21) * half;
        }
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Calculate the inverse of the specified quaternion.
   * @param a - The quaternion whose inverse is to be calculated
   * @param out - The inverse of the specified quaternion
   */ Quaternion.invert = function invert(a, out) {
        var x = a._x, y = a._y, z = a._z, w = a._w;
        var dot = x * x + y * y + z * z + w * w;
        if (dot > MathUtil.zeroTolerance) {
            var invDot = 1.0 / dot;
            out._x = -x * invDot;
            out._y = -y * invDot;
            out._z = -z * invDot;
            out._w = w * invDot;
            out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
        }
    };
    /**
   * Performs a linear blend between two quaternions.
   * @param start - The first quaternion
   * @param end - The second quaternion
   * @param t - The blend amount where 0 returns start and 1 end
   * @param out - The result of linear blending between two quaternions
   */ Quaternion.lerp = function lerp(start, end, t, out) {
        var inv = 1.0 - t;
        if (Quaternion.dot(start, end) >= 0) {
            out._x = start._x * inv + end._x * t;
            out._y = start._y * inv + end._y * t;
            out._z = start._z * inv + end._z * t;
            out._w = start._w * inv + end._w * t;
        } else {
            out._x = start._x * inv - end._x * t;
            out._y = start._y * inv - end._y * t;
            out._z = start._z * inv - end._z * t;
            out._w = start._w * inv - end._w * t;
        }
        out.normalize();
    };
    /**
   * Performs a spherical linear blend between two quaternions.
   * @param start - The first quaternion
   * @param end - The second quaternion
   * @param amount - The blend amount where 0 returns start and 1 end
   * @param out - The result of spherical linear blending between two quaternions
   */ Quaternion.slerp = function slerp(start, end, amount, out) {
        var opposite;
        var inverse;
        var dot = Quaternion.dot(start, end);
        if (Math.abs(dot) > 1.0 - MathUtil.zeroTolerance) {
            inverse = 1.0 - amount;
            opposite = amount * Math.sign(dot);
        } else {
            var acos = Math.acos(Math.abs(dot));
            var invSin = 1.0 / Math.sin(acos);
            inverse = Math.sin((1.0 - amount) * acos) * invSin;
            opposite = Math.sin(amount * acos) * invSin * Math.sign(dot);
        }
        out.x = inverse * start.x + opposite * end.x;
        out.y = inverse * start.y + opposite * end.y;
        out.z = inverse * start.z + opposite * end.z;
        out.w = inverse * start.w + opposite * end.w;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Scales the specified quaternion magnitude to unit length.
   * @param a - The specified quaternion
   * @param out - The normalized quaternion
   */ Quaternion.normalize = function normalize(a, out) {
        var _x = a._x, _y = a._y, _z = a._z, _w = a._w;
        var len = Math.sqrt(_x * _x + _y * _y + _z * _z + _w * _w);
        if (len > MathUtil.zeroTolerance) {
            len = 1 / len;
            out._x = _x * len;
            out._y = _y * len;
            out._z = _z * len;
            out._w = _w * len;
            out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
        }
    };
    /**
   * Calculate a quaternion rotate around X axis.
   * @param rad - The rotation angle in radians
   * @param out - The calculated quaternion
   */ Quaternion.rotationX = function rotationX(rad, out) {
        rad *= 0.5;
        var s = Math.sin(rad);
        var c = Math.cos(rad);
        out._x = s;
        out._y = 0;
        out._z = 0;
        out._w = c;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Calculate a quaternion rotate around Y axis.
   * @param rad - The rotation angle in radians
   * @param out - The calculated quaternion
   */ Quaternion.rotationY = function rotationY(rad, out) {
        rad *= 0.5;
        var s = Math.sin(rad);
        var c = Math.cos(rad);
        out._x = 0;
        out._y = s;
        out._z = 0;
        out._w = c;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Calculate a quaternion rotate around Z axis.
   * @param rad - The rotation angle in radians
   * @param out - The calculated quaternion
   */ Quaternion.rotationZ = function rotationZ(rad, out) {
        rad *= 0.5;
        var s = Math.sin(rad);
        var c = Math.cos(rad);
        out._x = 0;
        out._y = 0;
        out._z = s;
        out._w = c;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Calculate a quaternion that the specified quaternion rotate around X axis.
   * @param quaternion - The specified quaternion
   * @param rad - The rotation angle in radians
   * @param out - The calculated quaternion
   */ Quaternion.rotateX = function rotateX(quaternion, rad, out) {
        var _x = quaternion._x, _y = quaternion._y, _z = quaternion._z, _w = quaternion._w;
        rad *= 0.5;
        var bx = Math.sin(rad);
        var bw = Math.cos(rad);
        out._x = _x * bw + _w * bx;
        out._y = _y * bw + _z * bx;
        out._z = _z * bw - _y * bx;
        out._w = _w * bw - _x * bx;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Calculate a quaternion that the specified quaternion rotate around Y axis.
   * @param quaternion - The specified quaternion
   * @param rad - The rotation angle in radians
   * @param out - The calculated quaternion
   */ Quaternion.rotateY = function rotateY(quaternion, rad, out) {
        var _x = quaternion._x, _y = quaternion._y, _z = quaternion._z, _w = quaternion._w;
        rad *= 0.5;
        var by = Math.sin(rad);
        var bw = Math.cos(rad);
        out._x = _x * bw - _z * by;
        out._y = _y * bw + _w * by;
        out._z = _z * bw + _x * by;
        out._w = _w * bw - _y * by;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Calculate a quaternion that the specified quaternion rotate around Z axis.
   * @param quaternion - The specified quaternion
   * @param rad - The rotation angle in radians
   * @param out - The calculated quaternion
   */ Quaternion.rotateZ = function rotateZ(quaternion, rad, out) {
        var _x = quaternion._x, _y = quaternion._y, _z = quaternion._z, _w = quaternion._w;
        rad *= 0.5;
        var bz = Math.sin(rad);
        var bw = Math.cos(rad);
        out._x = _x * bw + _y * bz;
        out._y = _y * bw - _x * bz;
        out._z = _z * bw + _w * bz;
        out._w = _w * bw - _z * bz;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Scale a quaternion by a given number.
   * @param a - The quaternion
   * @param s - The given number
   * @param out - The scaled quaternion
   */ Quaternion.scale = function scale(a, s, out) {
        out._x = a._x * s;
        out._y = a._y * s;
        out._z = a._z * s;
        out._w = a._w * s;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    _create_class$3(Quaternion, [
        {
            key: "x",
            get: /**
   * The x component of the quaternion.
   */ function get() {
                return this._x;
            },
            set: function set(value) {
                this._x = value;
                this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
            }
        },
        {
            key: "y",
            get: /**
   * The y component of the quaternion.
   */ function get() {
                return this._y;
            },
            set: function set(value) {
                this._y = value;
                this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
            }
        },
        {
            key: "z",
            get: /**
   * The z component of the quaternion.
   */ function get() {
                return this._z;
            },
            set: function set(value) {
                this._z = value;
                this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
            }
        },
        {
            key: "normalized",
            get: /**
   * Indicting whether this instance is normalized.
   */ function get() {
                return Math.abs(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w - 1) < MathUtil.zeroTolerance;
            }
        },
        {
            key: "w",
            get: /**
   * The w component of the quaternion.
   */ function get() {
                return this._w;
            },
            set: function set(value) {
                this._w = value;
                this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
            }
        }
    ]);
    return Quaternion;
}();
/** @internal */ Quaternion._tempVector3 = new Vector3();
/** @internal */ Quaternion._tempQuat1 = new Quaternion();

/**
 * Represents a 4x4 mathematical matrix.
 */ var Matrix = /*#__PURE__*/ function() {
    function Matrix(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44) {
        if (m11 === void 0) m11 = 1;
        if (m12 === void 0) m12 = 0;
        if (m13 === void 0) m13 = 0;
        if (m14 === void 0) m14 = 0;
        if (m21 === void 0) m21 = 0;
        if (m22 === void 0) m22 = 1;
        if (m23 === void 0) m23 = 0;
        if (m24 === void 0) m24 = 0;
        if (m31 === void 0) m31 = 0;
        if (m32 === void 0) m32 = 0;
        if (m33 === void 0) m33 = 1;
        if (m34 === void 0) m34 = 0;
        if (m41 === void 0) m41 = 0;
        if (m42 === void 0) m42 = 0;
        if (m43 === void 0) m43 = 0;
        if (m44 === void 0) m44 = 1;
        /**
   * An array containing the elements of the matrix (column matrix).
   * @remarks
   * elements[0] first column and first row value m11
   * elements[1] first column and second row value m12
   * elements[2] first column and third row value m13
   * elements[3] first column and fourth row value m14
   * elements[4] second column and first row value m21
   * and so on
   */ this.elements = new Float32Array(16);
        var e = this.elements;
        e[0] = m11;
        e[1] = m12;
        e[2] = m13;
        e[3] = m14;
        e[4] = m21;
        e[5] = m22;
        e[6] = m23;
        e[7] = m24;
        e[8] = m31;
        e[9] = m32;
        e[10] = m33;
        e[11] = m34;
        e[12] = m41;
        e[13] = m42;
        e[14] = m43;
        e[15] = m44;
    }
    var _proto = Matrix.prototype;
    /**
   * Set the value of this matrix, and return this matrix.
   * @param m11 - column 1, row 1
   * @param m12 - column 1, row 2
   * @param m13 - column 1, row 3
   * @param m14 - column 1, row 4
   * @param m21 - column 2, row 1
   * @param m22 - column 2, row 2
   * @param m23 - column 2, row 3
   * @param m24 - column 2, row 4
   * @param m31 - column 3, row 1
   * @param m32 - column 3, row 2
   * @param m33 - column 3, row 3
   * @param m34 - column 3, row 4
   * @param m41 - column 4, row 1
   * @param m42 - column 4, row 2
   * @param m43 - column 4, row 3
   * @param m44 - column 4, row 4
   * @returns This matrix
   */ _proto.set = function set(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44) {
        var e = this.elements;
        e[0] = m11;
        e[1] = m12;
        e[2] = m13;
        e[3] = m14;
        e[4] = m21;
        e[5] = m22;
        e[6] = m23;
        e[7] = m24;
        e[8] = m31;
        e[9] = m32;
        e[10] = m33;
        e[11] = m34;
        e[12] = m41;
        e[13] = m42;
        e[14] = m43;
        e[15] = m44;
        return this;
    };
    /**
   * Determines the product of this matrix and the specified matrix.
   * @param right - The specified matrix
   * @returns This matrix that store the product of the two matrices
   */ _proto.multiply = function multiply(right) {
        Matrix.multiply(this, right, this);
        return this;
    };
    /**
   * Calculate a determinant of this matrix.
   * @returns The determinant of this matrix
   */ _proto.determinant = function determinant() {
        var e = this.elements;
        var a11 = e[0], a12 = e[1], a13 = e[2], a14 = e[3];
        var a21 = e[4], a22 = e[5], a23 = e[6], a24 = e[7];
        var a31 = e[8], a32 = e[9], a33 = e[10], a34 = e[11];
        var a41 = e[12], a42 = e[13], a43 = e[14], a44 = e[15];
        var b00 = a11 * a22 - a12 * a21;
        var b01 = a11 * a23 - a13 * a21;
        var b02 = a11 * a24 - a14 * a21;
        var b03 = a12 * a23 - a13 * a22;
        var b04 = a12 * a24 - a14 * a22;
        var b05 = a13 * a24 - a14 * a23;
        var b06 = a31 * a42 - a32 * a41;
        var b07 = a31 * a43 - a33 * a41;
        var b08 = a31 * a44 - a34 * a41;
        var b09 = a32 * a43 - a33 * a42;
        var b10 = a32 * a44 - a34 * a42;
        var b11 = a33 * a44 - a34 * a43;
        // Calculate the determinant
        return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    };
    /**
   * Decompose this matrix to translation, rotation and scale elements.
   * @param translation - Translation vector as an output parameter
   * @param rotation - Rotation quaternion as an output parameter
   * @param scale - Scale vector as an output parameter
   * @returns True if this matrix can be decomposed, false otherwise
   */ _proto.decompose = function decompose(translation, rotation, scale) {
        var rm = Matrix._tempMat30;
        var e = this.elements;
        var rme = rm.elements;
        var m11 = e[0];
        var m12 = e[1];
        var m13 = e[2];
        var m21 = e[4];
        var m22 = e[5];
        var m23 = e[6];
        var m31 = e[8];
        var m32 = e[9];
        var m33 = e[10];
        translation.set(e[12], e[13], e[14]);
        var sx = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
        var sy = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
        var sz = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
        if (this.determinant() < 0) sx = -sx;
        scale.set(sx, sy, sz);
        if (Math.abs(sx) < MathUtil.zeroTolerance || Math.abs(sy) < MathUtil.zeroTolerance || Math.abs(sz) < MathUtil.zeroTolerance) {
            rotation.identity();
            return false;
        } else {
            var invSX = 1 / sx;
            var invSY = 1 / sy;
            var invSZ = 1 / sz;
            rme[0] = m11 * invSX;
            rme[1] = m12 * invSX;
            rme[2] = m13 * invSX;
            rme[3] = m21 * invSY;
            rme[4] = m22 * invSY;
            rme[5] = m23 * invSY;
            rme[6] = m31 * invSZ;
            rme[7] = m32 * invSZ;
            rme[8] = m33 * invSZ;
            Quaternion.rotationMatrix3x3(rm, rotation);
            return true;
        }
    };
    /**
   * Get rotation from this matrix.
   * @param out - Rotation quaternion as an output parameter
   * @returns The out
   */ _proto.getRotation = function getRotation(out) {
        var e = this.elements;
        var trace = e[0] + e[5] + e[10];
        if (trace > MathUtil.zeroTolerance) {
            var s = Math.sqrt(trace + 1.0) * 2;
            out._w = 0.25 * s;
            out._x = (e[6] - e[9]) / s;
            out._y = (e[8] - e[2]) / s;
            out._z = (e[1] - e[4]) / s;
        } else if (e[0] > e[5] && e[0] > e[10]) {
            var s1 = Math.sqrt(1.0 + e[0] - e[5] - e[10]) * 2;
            out._w = (e[6] - e[9]) / s1;
            out._x = 0.25 * s1;
            out._y = (e[1] + e[4]) / s1;
            out._z = (e[8] + e[2]) / s1;
        } else if (e[5] > e[10]) {
            var s2 = Math.sqrt(1.0 + e[5] - e[0] - e[10]) * 2;
            out._w = (e[8] - e[2]) / s2;
            out._x = (e[1] + e[4]) / s2;
            out._y = 0.25 * s2;
            out._z = (e[6] + e[9]) / s2;
        } else {
            var s3 = Math.sqrt(1.0 + e[10] - e[0] - e[5]) * 2;
            out._w = (e[1] - e[4]) / s3;
            out._x = (e[8] + e[2]) / s3;
            out._y = (e[6] + e[9]) / s3;
            out._z = 0.25 * s3;
        }
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
        return out;
    };
    /**
   * Get scale from this matrix.
   * @param out - Scale vector as an output parameter
   * @returns The out
   */ _proto.getScaling = function getScaling(out) {
        //getScale()
        var e = this.elements;
        var m11 = e[0], m12 = e[1], m13 = e[2];
        var m21 = e[4], m22 = e[5], m23 = e[6];
        var m31 = e[8], m32 = e[9], m33 = e[10];
        out.set(Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13), Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23), Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33));
        return out;
    };
    /**
   * Get translation from this matrix.
   * @param out - Translation vector as an output parameter
   * @returns The out
   */ _proto.getTranslation = function getTranslation(out) {
        var e = this.elements;
        out.set(e[12], e[13], e[14]);
        return out;
    };
    /**
   * Identity this matrix.
   * @returns This matrix after identity
   */ _proto.identity = function identity() {
        var e = this.elements;
        e[0] = 1;
        e[1] = 0;
        e[2] = 0;
        e[3] = 0;
        e[4] = 0;
        e[5] = 1;
        e[6] = 0;
        e[7] = 0;
        e[8] = 0;
        e[9] = 0;
        e[10] = 1;
        e[11] = 0;
        e[12] = 0;
        e[13] = 0;
        e[14] = 0;
        e[15] = 1;
        return this;
    };
    /**
   * Invert the matrix.
   * @returns The matrix after invert
   */ _proto.invert = function invert() {
        Matrix.invert(this, this);
        return this;
    };
    /**
   * This matrix rotates around an arbitrary axis.
   * @param axis - The axis
   * @param r - The rotation angle in radians
   * @returns This matrix after rotate
   */ _proto.rotateAxisAngle = function rotateAxisAngle(axis, r) {
        Matrix.rotateAxisAngle(this, axis, r, this);
        return this;
    };
    /**
   * Scale this matrix by a given vector.
   * @param s - The given vector
   * @returns This matrix after scale
   */ _proto.scale = function scale(s) {
        Matrix.scale(this, s, this);
        return this;
    };
    /**
   * Translate this matrix by a given vector.
   * @param v - The given vector
   * @returns This matrix after translate
   */ _proto.translate = function translate(v) {
        Matrix.translate(this, v, this);
        return this;
    };
    /**
   * Calculate the transpose of this matrix.
   * @returns This matrix after transpose
   */ _proto.transpose = function transpose() {
        Matrix.transpose(this, this);
        return this;
    };
    /**
   * Creates a clone of this matrix.
   * @returns A clone of this matrix
   */ _proto.clone = function clone() {
        var e = this.elements;
        var ret = new Matrix(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]);
        return ret;
    };
    /**
   * Copy this matrix from the specified matrix.
   * @param source - The specified matrix
   * @returns This matrix
   */ _proto.copyFrom = function copyFrom(source) {
        var e = this.elements;
        var se = source.elements;
        e[0] = se[0];
        e[1] = se[1];
        e[2] = se[2];
        e[3] = se[3];
        e[4] = se[4];
        e[5] = se[5];
        e[6] = se[6];
        e[7] = se[7];
        e[8] = se[8];
        e[9] = se[9];
        e[10] = se[10];
        e[11] = se[11];
        e[12] = se[12];
        e[13] = se[13];
        e[14] = se[14];
        e[15] = se[15];
        return this;
    };
    /**
   * Copy the value of this matrix from an array.
   * @param array - The array
   * @param offset - The start offset of the array
   * @returns This matrix
   */ _proto.copyFromArray = function copyFromArray(array, offset) {
        if (offset === void 0) offset = 0;
        var srce = this.elements;
        for(var i = 0; i < 16; i++){
            srce[i] = array[i + offset];
        }
        return this;
    };
    /**
   * Copy the value of this matrix to an array.
   * @param out - The array
   * @param outOffset - The start offset of the array
   */ _proto.copyToArray = function copyToArray(out, outOffset) {
        if (outOffset === void 0) outOffset = 0;
        var e = this.elements;
        out[outOffset] = e[0];
        out[outOffset + 1] = e[1];
        out[outOffset + 2] = e[2];
        out[outOffset + 3] = e[3];
        out[outOffset + 4] = e[4];
        out[outOffset + 5] = e[5];
        out[outOffset + 6] = e[6];
        out[outOffset + 7] = e[7];
        out[outOffset + 8] = e[8];
        out[outOffset + 9] = e[9];
        out[outOffset + 10] = e[10];
        out[outOffset + 11] = e[11];
        out[outOffset + 12] = e[12];
        out[outOffset + 13] = e[13];
        out[outOffset + 14] = e[14];
        out[outOffset + 15] = e[15];
    };
    /**
   * Determines the product of two matrices.
   * @param left - The first matrix to multiply
   * @param right - The second matrix to multiply
   * @param out - The product of the two matrices
   */ Matrix.multiply = function multiply(left, right, out) {
        var le = left.elements;
        var re = right.elements;
        var oe = out.elements;
        // prettier-ignore
        var l11 = le[0], l12 = le[1], l13 = le[2], l14 = le[3], l21 = le[4], l22 = le[5], l23 = le[6], l24 = le[7], l31 = le[8], l32 = le[9], l33 = le[10], l34 = le[11], l41 = le[12], l42 = le[13], l43 = le[14], l44 = le[15];
        // prettier-ignore
        var r11 = re[0], r12 = re[1], r13 = re[2], r14 = re[3], r21 = re[4], r22 = re[5], r23 = re[6], r24 = re[7], r31 = re[8], r32 = re[9], r33 = re[10], r34 = re[11], r41 = re[12], r42 = re[13], r43 = re[14], r44 = re[15];
        oe[0] = l11 * r11 + l21 * r12 + l31 * r13 + l41 * r14;
        oe[1] = l12 * r11 + l22 * r12 + l32 * r13 + l42 * r14;
        oe[2] = l13 * r11 + l23 * r12 + l33 * r13 + l43 * r14;
        oe[3] = l14 * r11 + l24 * r12 + l34 * r13 + l44 * r14;
        oe[4] = l11 * r21 + l21 * r22 + l31 * r23 + l41 * r24;
        oe[5] = l12 * r21 + l22 * r22 + l32 * r23 + l42 * r24;
        oe[6] = l13 * r21 + l23 * r22 + l33 * r23 + l43 * r24;
        oe[7] = l14 * r21 + l24 * r22 + l34 * r23 + l44 * r24;
        oe[8] = l11 * r31 + l21 * r32 + l31 * r33 + l41 * r34;
        oe[9] = l12 * r31 + l22 * r32 + l32 * r33 + l42 * r34;
        oe[10] = l13 * r31 + l23 * r32 + l33 * r33 + l43 * r34;
        oe[11] = l14 * r31 + l24 * r32 + l34 * r33 + l44 * r34;
        oe[12] = l11 * r41 + l21 * r42 + l31 * r43 + l41 * r44;
        oe[13] = l12 * r41 + l22 * r42 + l32 * r43 + l42 * r44;
        oe[14] = l13 * r41 + l23 * r42 + l33 * r43 + l43 * r44;
        oe[15] = l14 * r41 + l24 * r42 + l34 * r43 + l44 * r44;
    };
    /**
   * Determines whether the specified matrices are equals.
   * @param left - The first matrix to compare
   * @param right - The second matrix to compare
   * @returns True if the specified matrices are equals, false otherwise
   */ Matrix.equals = function equals(left, right) {
        var le = left.elements;
        var re = right.elements;
        return MathUtil.equals(le[0], re[0]) && MathUtil.equals(le[1], re[1]) && MathUtil.equals(le[2], re[2]) && MathUtil.equals(le[3], re[3]) && MathUtil.equals(le[4], re[4]) && MathUtil.equals(le[5], re[5]) && MathUtil.equals(le[6], re[6]) && MathUtil.equals(le[7], re[7]) && MathUtil.equals(le[8], re[8]) && MathUtil.equals(le[9], re[9]) && MathUtil.equals(le[10], re[10]) && MathUtil.equals(le[11], re[11]) && MathUtil.equals(le[12], re[12]) && MathUtil.equals(le[13], re[13]) && MathUtil.equals(le[14], re[14]) && MathUtil.equals(le[15], re[15]);
    };
    /**
   * Performs a linear interpolation between two matrices.
   * @param start - The first matrix
   * @param end - The second matrix
   * @param t - The blend amount where 0 returns start and 1 end
   * @param out - The result of linear blending between two matrices
   */ Matrix.lerp = function lerp(start, end, t, out) {
        var se = start.elements;
        var ee = end.elements;
        var oe = out.elements;
        var inv = 1.0 - t;
        oe[0] = se[0] * inv + ee[0] * t;
        oe[1] = se[1] * inv + ee[1] * t;
        oe[2] = se[2] * inv + ee[2] * t;
        oe[3] = se[3] * inv + ee[3] * t;
        oe[4] = se[4] * inv + ee[4] * t;
        oe[5] = se[5] * inv + ee[5] * t;
        oe[6] = se[6] * inv + ee[6] * t;
        oe[7] = se[7] * inv + ee[7] * t;
        oe[8] = se[8] * inv + ee[8] * t;
        oe[9] = se[9] * inv + ee[9] * t;
        oe[10] = se[10] * inv + ee[10] * t;
        oe[11] = se[11] * inv + ee[11] * t;
        oe[12] = se[12] * inv + ee[12] * t;
        oe[13] = se[13] * inv + ee[13] * t;
        oe[14] = se[14] * inv + ee[14] * t;
        oe[15] = se[15] * inv + ee[15] * t;
    };
    /**
   * Determines the sum of two matrices.
   * @param left - The first matrix to add
   * @param right - The second matrix to add
   * @param out - The sum of two matrices
   */ Matrix.add = function add(left, right, out) {
        var le = left.elements;
        var re = right.elements;
        var oe = out.elements;
        oe[0] = le[0] + re[0];
        oe[1] = le[1] + re[1];
        oe[2] = le[2] + re[2];
        oe[3] = le[3] + re[3];
        oe[4] = le[4] + re[4];
        oe[5] = le[5] + re[5];
        oe[6] = le[6] + re[6];
        oe[7] = le[7] + re[7];
        oe[8] = le[8] + re[8];
        oe[9] = le[9] + re[9];
        oe[10] = le[10] + re[10];
        oe[11] = le[11] + re[11];
        oe[12] = le[12] + re[12];
        oe[13] = le[13] + re[13];
        oe[14] = le[14] + re[14];
        oe[15] = le[15] + re[15];
    };
    /**
   * Multiplies a matrix by a scalar.
   * @param source - The matrix to multiply
   * @param scalar - The scalar to multiply
   * @param out - The result of multiplying a matrix by a scalar
   */ Matrix.multiplyScalar = function multiplyScalar(source, scalar, out) {
        var se = source.elements;
        var oe = out.elements;
        oe[0] = se[0] * scalar;
        oe[1] = se[1] * scalar;
        oe[2] = se[2] * scalar;
        oe[3] = se[3] * scalar;
        oe[4] = se[4] * scalar;
        oe[5] = se[5] * scalar;
        oe[6] = se[6] * scalar;
        oe[7] = se[7] * scalar;
        oe[8] = se[8] * scalar;
        oe[9] = se[9] * scalar;
        oe[10] = se[10] * scalar;
        oe[11] = se[11] * scalar;
        oe[12] = se[12] * scalar;
        oe[13] = se[13] * scalar;
        oe[14] = se[14] * scalar;
        oe[15] = se[15] * scalar;
    };
    /**
   * Calculate a rotation matrix from a quaternion.
   * @param quaternion - The quaternion used to calculate the matrix
   * @param out - The calculated rotation matrix
   */ Matrix.rotationQuaternion = function rotationQuaternion(quaternion, out) {
        var oe = out.elements;
        var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;
        var xx = x * x2;
        var yx = y * x2;
        var yy = y * y2;
        var zx = z * x2;
        var zy = z * y2;
        var zz = z * z2;
        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;
        oe[0] = 1 - yy - zz;
        oe[1] = yx + wz;
        oe[2] = zx - wy;
        oe[3] = 0;
        oe[4] = yx - wz;
        oe[5] = 1 - xx - zz;
        oe[6] = zy + wx;
        oe[7] = 0;
        oe[8] = zx + wy;
        oe[9] = zy - wx;
        oe[10] = 1 - xx - yy;
        oe[11] = 0;
        oe[12] = 0;
        oe[13] = 0;
        oe[14] = 0;
        oe[15] = 1;
    };
    /**
   * Calculate a matrix rotates around an arbitrary axis.
   * @param axis - The axis
   * @param r - The rotation angle in radians
   * @param out - The matrix after rotate
   */ Matrix.rotationAxisAngle = function rotationAxisAngle(axis, r, out) {
        var oe = out.elements;
        var x = axis._x, y = axis._y, z = axis._z;
        var len = Math.sqrt(x * x + y * y + z * z);
        var s, c, t;
        if (Math.abs(len) < MathUtil.zeroTolerance) {
            return;
        }
        len = 1 / len;
        x *= len;
        y *= len;
        z *= len;
        s = Math.sin(r);
        c = Math.cos(r);
        t = 1 - c;
        // Perform rotation-specific matrix multiplication
        oe[0] = x * x * t + c;
        oe[1] = y * x * t + z * s;
        oe[2] = z * x * t - y * s;
        oe[3] = 0;
        oe[4] = x * y * t - z * s;
        oe[5] = y * y * t + c;
        oe[6] = z * y * t + x * s;
        oe[7] = 0;
        oe[8] = x * z * t + y * s;
        oe[9] = y * z * t - x * s;
        oe[10] = z * z * t + c;
        oe[11] = 0;
        oe[12] = 0;
        oe[13] = 0;
        oe[14] = 0;
        oe[15] = 1;
    };
    /**
   * Calculate a matrix from a quaternion and a translation.
   * @param quaternion - The quaternion used to calculate the matrix
   * @param translation - The translation used to calculate the matrix
   * @param out - The calculated matrix
   */ Matrix.rotationTranslation = function rotationTranslation(quaternion, translation, out) {
        Matrix.rotationQuaternion(quaternion, out);
        var oe = out.elements;
        oe[12] = translation._x;
        oe[13] = translation._y;
        oe[14] = translation._z;
    };
    /**
   * Calculate an affine matrix.
   * @param scale - The scale used to calculate matrix
   * @param rotation - The rotation used to calculate matrix
   * @param translation - The translation used to calculate matrix
   * @param out - The calculated matrix
   */ Matrix.affineTransformation = function affineTransformation(scale, rotation, translation, out) {
        var oe = out.elements;
        var x = rotation._x, y = rotation._y, z = rotation._z, w = rotation._w;
        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;
        var xx = x * x2;
        var xy = x * y2;
        var xz = x * z2;
        var yy = y * y2;
        var yz = y * z2;
        var zz = z * z2;
        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;
        var sx = scale._x;
        var sy = scale._y;
        var sz = scale._z;
        oe[0] = (1 - (yy + zz)) * sx;
        oe[1] = (xy + wz) * sx;
        oe[2] = (xz - wy) * sx;
        oe[3] = 0;
        oe[4] = (xy - wz) * sy;
        oe[5] = (1 - (xx + zz)) * sy;
        oe[6] = (yz + wx) * sy;
        oe[7] = 0;
        oe[8] = (xz + wy) * sz;
        oe[9] = (yz - wx) * sz;
        oe[10] = (1 - (xx + yy)) * sz;
        oe[11] = 0;
        oe[12] = translation._x;
        oe[13] = translation._y;
        oe[14] = translation._z;
        oe[15] = 1;
    };
    /**
   * Calculate a matrix from scale vector.
   * @param s - The scale vector
   * @param out - The calculated matrix
   */ Matrix.scaling = function scaling(s, out) {
        var oe = out.elements;
        oe[0] = s._x;
        oe[1] = 0;
        oe[2] = 0;
        oe[3] = 0;
        oe[4] = 0;
        oe[5] = s._y;
        oe[6] = 0;
        oe[7] = 0;
        oe[8] = 0;
        oe[9] = 0;
        oe[10] = s._z;
        oe[11] = 0;
        oe[12] = 0;
        oe[13] = 0;
        oe[14] = 0;
        oe[15] = 1;
    };
    /**
   * Calculate a matrix from translation vector.
   * @param translation - The translation vector
   * @param out - The calculated matrix
   */ Matrix.translation = function translation(translation, out) {
        var oe = out.elements;
        oe[0] = 1;
        oe[1] = 0;
        oe[2] = 0;
        oe[3] = 0;
        oe[4] = 0;
        oe[5] = 1;
        oe[6] = 0;
        oe[7] = 0;
        oe[8] = 0;
        oe[9] = 0;
        oe[10] = 1;
        oe[11] = 0;
        oe[12] = translation._x;
        oe[13] = translation._y;
        oe[14] = translation._z;
        oe[15] = 1;
    };
    /**
   * Calculate the inverse of the specified matrix.
   * @param a - The matrix whose inverse is to be calculated
   * @param out - The inverse of the specified matrix
   */ Matrix.invert = function invert(a, out) {
        var ae = a.elements;
        var oe = out.elements;
        var a11 = ae[0], a12 = ae[1], a13 = ae[2], a14 = ae[3];
        var a21 = ae[4], a22 = ae[5], a23 = ae[6], a24 = ae[7];
        var a31 = ae[8], a32 = ae[9], a33 = ae[10], a34 = ae[11];
        var a41 = ae[12], a42 = ae[13], a43 = ae[14], a44 = ae[15];
        var b00 = a11 * a22 - a12 * a21;
        var b01 = a11 * a23 - a13 * a21;
        var b02 = a11 * a24 - a14 * a21;
        var b03 = a12 * a23 - a13 * a22;
        var b04 = a12 * a24 - a14 * a22;
        var b05 = a13 * a24 - a14 * a23;
        var b06 = a31 * a42 - a32 * a41;
        var b07 = a31 * a43 - a33 * a41;
        var b08 = a31 * a44 - a34 * a41;
        var b09 = a32 * a43 - a33 * a42;
        var b10 = a32 * a44 - a34 * a42;
        var b11 = a33 * a44 - a34 * a43;
        var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        if (!det) {
            return null;
        }
        det = 1.0 / det;
        oe[0] = (a22 * b11 - a23 * b10 + a24 * b09) * det;
        oe[1] = (a13 * b10 - a12 * b11 - a14 * b09) * det;
        oe[2] = (a42 * b05 - a43 * b04 + a44 * b03) * det;
        oe[3] = (a33 * b04 - a32 * b05 - a34 * b03) * det;
        oe[4] = (a23 * b08 - a21 * b11 - a24 * b07) * det;
        oe[5] = (a11 * b11 - a13 * b08 + a14 * b07) * det;
        oe[6] = (a43 * b02 - a41 * b05 - a44 * b01) * det;
        oe[7] = (a31 * b05 - a33 * b02 + a34 * b01) * det;
        oe[8] = (a21 * b10 - a22 * b08 + a24 * b06) * det;
        oe[9] = (a12 * b08 - a11 * b10 - a14 * b06) * det;
        oe[10] = (a41 * b04 - a42 * b02 + a44 * b00) * det;
        oe[11] = (a32 * b02 - a31 * b04 - a34 * b00) * det;
        oe[12] = (a22 * b07 - a21 * b09 - a23 * b06) * det;
        oe[13] = (a11 * b09 - a12 * b07 + a13 * b06) * det;
        oe[14] = (a42 * b01 - a41 * b03 - a43 * b00) * det;
        oe[15] = (a31 * b03 - a32 * b01 + a33 * b00) * det;
    };
    /**
   * Calculate a right-handed look-at matrix.
   * @param eye - The position of the viewer's eye
   * @param target - The camera look-at target
   * @param up - The camera's up vector
   * @param out - The calculated look-at matrix
   */ Matrix.lookAt = function lookAt(eye, target, up, out) {
        var oe = out.elements;
        var xAxis = Matrix._tempVec30;
        var yAxis = Matrix._tempVec31;
        var zAxis = Matrix._tempVec32;
        Vector3.subtract(eye, target, zAxis);
        zAxis.normalize();
        Vector3.cross(up, zAxis, xAxis);
        xAxis.normalize();
        Vector3.cross(zAxis, xAxis, yAxis);
        oe[0] = xAxis._x;
        oe[1] = yAxis._x;
        oe[2] = zAxis._x;
        oe[3] = 0;
        oe[4] = xAxis._y;
        oe[5] = yAxis._y;
        oe[6] = zAxis._y;
        oe[7] = 0;
        oe[8] = xAxis._z;
        oe[9] = yAxis._z;
        oe[10] = zAxis._z;
        oe[11] = 0;
        oe[12] = -Vector3.dot(xAxis, eye);
        oe[13] = -Vector3.dot(yAxis, eye);
        oe[14] = -Vector3.dot(zAxis, eye);
        oe[15] = 1;
    };
    /**
   * Calculate an orthographic projection matrix.
   * @param left - The left edge of the viewing
   * @param right - The right edge of the viewing
   * @param bottom - The bottom edge of the viewing
   * @param top - The top edge of the viewing
   * @param near - The depth of the near plane
   * @param far - The depth of the far plane
   * @param out - The calculated orthographic projection matrix
   */ Matrix.ortho = function ortho(left, right, bottom, top, near, far, out) {
        var oe = out.elements;
        var lr = 1 / (left - right);
        var bt = 1 / (bottom - top);
        var nf = 1 / (near - far);
        oe[0] = -2 * lr;
        oe[1] = 0;
        oe[2] = 0;
        oe[3] = 0;
        oe[4] = 0;
        oe[5] = -2 * bt;
        oe[6] = 0;
        oe[7] = 0;
        oe[8] = 0;
        oe[9] = 0;
        oe[10] = 2 * nf;
        oe[11] = 0;
        oe[12] = (left + right) * lr;
        oe[13] = (top + bottom) * bt;
        oe[14] = (far + near) * nf;
        oe[15] = 1;
    };
    /**
   * Calculate a perspective projection matrix.
   * @param fovY - Field of view in the y direction, in radians
   * @param aspect - Aspect ratio, defined as view space width divided by height
   * @param near - The depth of the near plane
   * @param far - The depth of the far plane
   * @param out - The calculated perspective projection matrix
   */ Matrix.perspective = function perspective(fovY, aspect, near, far, out) {
        var oe = out.elements;
        var f = 1.0 / Math.tan(fovY / 2);
        var nf = 1 / (near - far);
        oe[0] = f / aspect;
        oe[1] = 0;
        oe[2] = 0;
        oe[3] = 0;
        oe[4] = 0;
        oe[5] = f;
        oe[6] = 0;
        oe[7] = 0;
        oe[8] = 0;
        oe[9] = 0;
        oe[10] = (far + near) * nf;
        oe[11] = -1;
        oe[12] = 0;
        oe[13] = 0;
        oe[14] = 2 * far * near * nf;
        oe[15] = 0;
    };
    /**
   * The specified matrix rotates around an arbitrary axis.
   * @param m - The specified matrix
   * @param axis - The axis
   * @param r - The rotation angle in radians
   * @param out - The rotated matrix
   */ Matrix.rotateAxisAngle = function rotateAxisAngle(m, axis, r, out) {
        var x = axis._x, y = axis._y, z = axis._z;
        var len = Math.sqrt(x * x + y * y + z * z);
        if (Math.abs(len) < MathUtil.zeroTolerance) {
            return;
        }
        var me = m.elements;
        var oe = out.elements;
        var s, c, t;
        len = 1 / len;
        x *= len;
        y *= len;
        z *= len;
        s = Math.sin(r);
        c = Math.cos(r);
        t = 1 - c;
        var a11 = me[0], a12 = me[1], a13 = me[2], a14 = me[3];
        var a21 = me[4], a22 = me[5], a23 = me[6], a24 = me[7];
        var a31 = me[8], a32 = me[9], a33 = me[10], a34 = me[11];
        // Construct the elements of the rotation matrix
        var b11 = x * x * t + c;
        var b12 = y * x * t + z * s;
        var b13 = z * x * t - y * s;
        var b21 = x * y * t - z * s;
        var b22 = y * y * t + c;
        var b23 = z * y * t + x * s;
        var b31 = x * z * t + y * s;
        var b32 = y * z * t - x * s;
        var b33 = z * z * t + c;
        // Perform rotation-specific matrix multiplication
        oe[0] = a11 * b11 + a21 * b12 + a31 * b13;
        oe[1] = a12 * b11 + a22 * b12 + a32 * b13;
        oe[2] = a13 * b11 + a23 * b12 + a33 * b13;
        oe[3] = a14 * b11 + a24 * b12 + a34 * b13;
        oe[4] = a11 * b21 + a21 * b22 + a31 * b23;
        oe[5] = a12 * b21 + a22 * b22 + a32 * b23;
        oe[6] = a13 * b21 + a23 * b22 + a33 * b23;
        oe[7] = a14 * b21 + a24 * b22 + a34 * b23;
        oe[8] = a11 * b31 + a21 * b32 + a31 * b33;
        oe[9] = a12 * b31 + a22 * b32 + a32 * b33;
        oe[10] = a13 * b31 + a23 * b32 + a33 * b33;
        oe[11] = a14 * b31 + a24 * b32 + a34 * b33;
        if (m !== out) {
            // If the source and destination differ, copy the unchanged last row
            oe[12] = me[12];
            oe[13] = me[13];
            oe[14] = me[14];
            oe[15] = me[15];
        }
    };
    /**
   * Scale a matrix by a given vector.
   * @param m - The matrix
   * @param s - The given vector
   * @param out - The scaled matrix
   */ Matrix.scale = function scale(m, s, out) {
        var me = m.elements;
        var oe = out.elements;
        var x = s._x, y = s._y, z = s._z;
        oe[0] = me[0] * x;
        oe[1] = me[1] * x;
        oe[2] = me[2] * x;
        oe[3] = me[3] * x;
        oe[4] = me[4] * y;
        oe[5] = me[5] * y;
        oe[6] = me[6] * y;
        oe[7] = me[7] * y;
        oe[8] = me[8] * z;
        oe[9] = me[9] * z;
        oe[10] = me[10] * z;
        oe[11] = me[11] * z;
        oe[12] = me[12];
        oe[13] = me[13];
        oe[14] = me[14];
        oe[15] = me[15];
    };
    /**
   * Translate a matrix by a given vector.
   * @param m - The matrix
   * @param v - The given vector
   * @param out - The translated matrix
   */ Matrix.translate = function translate(m, v, out) {
        var me = m.elements;
        var oe = out.elements;
        var x = v._x, y = v._y, z = v._z;
        if (m === out) {
            oe[12] = me[0] * x + me[4] * y + me[8] * z + me[12];
            oe[13] = me[1] * x + me[5] * y + me[9] * z + me[13];
            oe[14] = me[2] * x + me[6] * y + me[10] * z + me[14];
            oe[15] = me[3] * x + me[7] * y + me[11] * z + me[15];
        } else {
            var a11 = me[0], a12 = me[1], a13 = me[2], a14 = me[3];
            var a21 = me[4], a22 = me[5], a23 = me[6], a24 = me[7];
            var a31 = me[8], a32 = me[9], a33 = me[10], a34 = me[11];
            oe[0] = a11, oe[1] = a12, oe[2] = a13, oe[3] = a14;
            oe[4] = a21, oe[5] = a22, oe[6] = a23, oe[7] = a24;
            oe[8] = a31, oe[9] = a32, oe[10] = a33, oe[11] = a34;
            oe[12] = a11 * x + a21 * y + a31 * z + me[12];
            oe[13] = a12 * x + a22 * y + a32 * z + me[13];
            oe[14] = a13 * x + a23 * y + a33 * z + me[14];
            oe[15] = a14 * x + a24 * y + a34 * z + me[15];
        }
    };
    /**
   * Calculate the transpose of the specified matrix.
   * @param a - The specified matrix
   * @param out - The transpose of the specified matrix
   */ Matrix.transpose = function transpose(a, out) {
        var ae = a.elements;
        var oe = out.elements;
        if (out === a) {
            var a12 = ae[1];
            var a13 = ae[2];
            var a14 = ae[3];
            var a23 = ae[6];
            var a24 = ae[7];
            var a34 = ae[11];
            oe[1] = ae[4];
            oe[2] = ae[8];
            oe[3] = ae[12];
            oe[4] = a12;
            oe[6] = ae[9];
            oe[7] = ae[13];
            oe[8] = a13;
            oe[9] = a23;
            oe[11] = ae[14];
            oe[12] = a14;
            oe[13] = a24;
            oe[14] = a34;
        } else {
            oe[0] = ae[0];
            oe[1] = ae[4];
            oe[2] = ae[8];
            oe[3] = ae[12];
            oe[4] = ae[1];
            oe[5] = ae[5];
            oe[6] = ae[9];
            oe[7] = ae[13];
            oe[8] = ae[2];
            oe[9] = ae[6];
            oe[10] = ae[10];
            oe[11] = ae[14];
            oe[12] = ae[3];
            oe[13] = ae[7];
            oe[14] = ae[11];
            oe[15] = ae[15];
        }
    };
    return Matrix;
}();
Matrix._tempVec30 = new Vector3();
Matrix._tempVec31 = new Vector3();
Matrix._tempVec32 = new Vector3();
Matrix._tempMat30 = new Matrix3x3();
/** @internal Identity matrix. */ Matrix._identity = new Matrix(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);

/**
 * Represents a ray with an origin and a direction in 3D space.
 */ var Ray = /*#__PURE__*/ function() {
    function Ray(origin, direction) {
        if (origin === void 0) origin = null;
        if (direction === void 0) direction = null;
        /** The origin of the ray. */ this.origin = new Vector3();
        /** The normalized direction of the ray. */ this.direction = new Vector3();
        origin && this.origin.copyFrom(origin);
        direction && this.direction.copyFrom(direction);
    }
    var _proto = Ray.prototype;
    /**
   * Check if this ray intersects the specified plane.
   * @param plane - The specified plane
   * @returns The distance from this ray to the specified plane if intersecting, -1 otherwise
   */ _proto.intersectPlane = function intersectPlane(plane) {
        return CollisionUtil.intersectsRayAndPlane(this, plane);
    };
    /**
   * Check if this ray intersects the specified sphere.
   * @param sphere - The specified sphere
   * @returns The distance from this ray to the specified sphere if intersecting, -1 otherwise
   */ _proto.intersectSphere = function intersectSphere(sphere) {
        return CollisionUtil.intersectsRayAndSphere(this, sphere);
    };
    /**
   * Check if this ray intersects the specified box (AABB).
   * @param box - The specified box
   * @returns The distance from this ray to the specified box if intersecting, -1 otherwise
   */ _proto.intersectBox = function intersectBox(box) {
        return CollisionUtil.intersectsRayAndBox(this, box);
    };
    /**
   * The coordinates of the specified distance from the origin in the ray direction.
   * @param distance - The specified distance
   * @param out - The coordinates as an output parameter
   * @returns The out
   */ _proto.getPoint = function getPoint(distance, out) {
        Vector3.scale(this.direction, distance, out);
        return out.add(this.origin);
    };
    return Ray;
}();

/**
 * Describes a 2D-vector.
 */ var Vector2 = /*#__PURE__*/ function() {
    function Vector2(x, y) {
        if (x === void 0) x = 0;
        if (y === void 0) y = 0;
        /** @internal */ this._onValueChanged = null;
        this._x = x;
        this._y = y;
    }
    var _proto = Vector2.prototype;
    /**
   * Set the value of this vector.
   * @param x - The x component of the vector
   * @param y - The y component of the vector
   * @returns This vector
   */ _proto.set = function set(x, y) {
        this._x = x;
        this._y = y;
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * Determines the sum of this vector and the specified vector.
   * @param right - The specified vector
   * @returns This vector
   */ _proto.add = function add(right) {
        this._x += right._x;
        this._y += right._y;
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * Determines the difference of this vector and the specified vector.
   * @param right - The specified vector
   * @returns This vector
   */ _proto.subtract = function subtract(right) {
        this._x -= right._x;
        this._y -= right._y;
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * Determines the product of this vector and the specified vector.
   * @param right - The specified vector
   * @returns This vector
   */ _proto.multiply = function multiply(right) {
        this._x *= right._x;
        this._y *= right._y;
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * Determines the divisor of this vector and the specified vector.
   * @param right - The specified vector
   * @returns This vector
   */ _proto.divide = function divide(right) {
        this._x /= right._x;
        this._y /= right._y;
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * Calculate the length of this vector.
   * @returns The length of this vector
   */ _proto.length = function length() {
        var _this = this, _x = _this._x, _y = _this._y;
        return Math.sqrt(_x * _x + _y * _y);
    };
    /**
   * Calculate the squared length of this vector.
   * @returns The squared length of this vector
   */ _proto.lengthSquared = function lengthSquared() {
        var _this = this, _x = _this._x, _y = _this._y;
        return _x * _x + _y * _y;
    };
    /**
   * Reverses the direction of this vector.
   * @returns This vector
   */ _proto.negate = function negate() {
        this._x = -this._x;
        this._y = -this._y;
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * Converts this vector into a unit vector.
   * @returns This vector
   */ _proto.normalize = function normalize() {
        Vector2.normalize(this, this);
        return this;
    };
    /**
   * Scale this vector by the given value.
   * @param s - The amount by which to scale the vector
   * @returns This vector
   */ _proto.scale = function scale(s) {
        this._x *= s;
        this._y *= s;
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * Creates a clone of this vector.
   * @returns A clone of this vector
   */ _proto.clone = function clone() {
        return new Vector2(this._x, this._y);
    };
    /**
   * Copy from vector2 like object.
   * @param source - Vector2 like object
   * @returns This vector
   */ _proto.copyFrom = function copyFrom(source) {
        this._x = source.x;
        this._y = source.y;
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * Copy to vector2 like object.
   * @param target - Vector2 like object
   * @returns This Vector2 like object
   */ _proto.copyTo = function copyTo(target) {
        target.x = this._x;
        target.y = this._y;
        return target;
    };
    /**
   * Copy the value of this vector from an array.
   * @param array - The array
   * @param offset - The start offset of the array
   * @returns This vector
   */ _proto.copyFromArray = function copyFromArray(array, offset) {
        if (offset === void 0) offset = 0;
        this._x = array[offset];
        this._y = array[offset + 1];
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * Copy the value of this vector to an array.
   * @param out - The array
   * @param outOffset - The start offset of the array
   */ _proto.copyToArray = function copyToArray(out, outOffset) {
        if (outOffset === void 0) outOffset = 0;
        out[outOffset] = this._x;
        out[outOffset + 1] = this._y;
    };
    /**
   * Serialize this vector to a JSON representation.
   * @returns A JSON representation of this vector
   */ _proto.toJSON = function toJSON() {
        return {
            x: this._x,
            y: this._y
        };
    };
    /**
   * Determines the sum of two vectors.
   * @param left - The first vector to add
   * @param right - The second vector to add
   * @param out - The sum of two vectors
   */ Vector2.add = function add(left, right, out) {
        out._x = left._x + right._x;
        out._y = left._y + right._y;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Determines the difference between two vectors.
   * @param left - The first vector to subtract
   * @param right - The second vector to subtract
   * @param out - The difference between two vectors
   */ Vector2.subtract = function subtract(left, right, out) {
        out._x = left._x - right._x;
        out._y = left._y - right._y;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Determines the product of two vectors.
   * @param left - The first vector to multiply
   * @param right - The second vector to multiply
   * @param out - The product of two vectors
   */ Vector2.multiply = function multiply(left, right, out) {
        out._x = left._x * right._x;
        out._y = left._y * right._y;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Determines the divisor of two vectors.
   * @param left - The first vector to divide
   * @param right - The second vector to divide
   * @param out - The divisor of two vectors
   */ Vector2.divide = function divide(left, right, out) {
        out._x = left._x / right._x;
        out._y = left._y / right._y;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Determines the dot product of two vectors.
   * @param left - The first vector to dot
   * @param right - The second vector to dot
   * @returns The dot product of two vectors
   */ Vector2.dot = function dot(left, right) {
        return left._x * right._x + left._y * right._y;
    };
    /**
   * Determines the distance of two vectors.
   * @param left - The first vector
   * @param right - The second vector
   * @returns The distance of two vectors
   */ Vector2.distance = function distance(left, right) {
        var x = right._x - left._x;
        var y = right._y - left._y;
        return Math.sqrt(x * x + y * y);
    };
    /**
   * Determines the squared distance of two vectors.
   * @param left - The first vector
   * @param right - The second vector
   * @returns The squared distance of two vectors
   */ Vector2.distanceSquared = function distanceSquared(left, right) {
        var x = right._x - left._x;
        var y = right._y - left._y;
        return x * x + y * y;
    };
    /**
   * Determines whether the specified vectors are equals.
   * @param left - The first vector to compare
   * @param right - The second vector to compare
   * @returns True if the specified vectors are equals, false otherwise
   */ Vector2.equals = function equals(left, right) {
        return MathUtil.equals(left._x, right._x) && MathUtil.equals(left._y, right._y);
    };
    /**
   * Performs a linear interpolation between two vectors.
   * @param left - The first vector
   * @param right - The second vector
   * @param t - The blend amount where 0 returns left and 1 right
   * @param out - The result of linear blending between two vectors
   */ Vector2.lerp = function lerp(left, right, t, out) {
        var _x = left._x, _y = left._y;
        out._x = _x + (right._x - _x) * t;
        out._y = _y + (right._y - _y) * t;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Calculate a vector containing the largest components of the specified vectors.
   * @param left - The first vector
   * @param right - The second vector
   * @param out - The vector containing the largest components of the specified vectors
   */ Vector2.max = function max(left, right, out) {
        out._x = Math.max(left._x, right._x);
        out._y = Math.max(left._y, right._y);
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Calculate a vector containing the smallest components of the specified vectors.
   * @param left - The first vector
   * @param right - The second vector
   * @param out - The vector containing the smallest components of the specified vectors
   */ Vector2.min = function min(left, right, out) {
        out._x = Math.min(left._x, right._x);
        out._y = Math.min(left._y, right._y);
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Reverses the direction of a given vector.
   * @param left - The vector to negate
   * @param out - The vector facing in the opposite direction
   */ Vector2.negate = function negate(left, out) {
        out._x = -left._x;
        out._y = -left._y;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Converts the vector into a unit vector.
   * @param left - The vector to normalize
   * @param out - The normalized vector
   */ Vector2.normalize = function normalize(left, out) {
        var _x = left._x, _y = left._y;
        var len = Math.sqrt(_x * _x + _y * _y);
        if (len > MathUtil.zeroTolerance) {
            len = 1 / len;
            out._x = _x * len;
            out._y = _y * len;
            out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
        }
    };
    /**
   * Scale a vector by the given value.
   * @param left - The vector to scale
   * @param s - The amount by which to scale the vector
   * @param out - The scaled vector
   */ Vector2.scale = function scale(left, s, out) {
        out._x = left._x * s;
        out._y = left._y * s;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    _create_class$3(Vector2, [
        {
            key: "x",
            get: /**
   * The x component of the vector.
   */ function get() {
                return this._x;
            },
            set: function set(value) {
                this._x = value;
                this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
            }
        },
        {
            key: "y",
            get: /**
   * The y component of the vector.
   */ function get() {
                return this._y;
            },
            set: function set(value) {
                this._y = value;
                this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
            }
        }
    ]);
    return Vector2;
}();
/** @internal */ Vector2._zero = new Vector2(0.0, 0.0);
/** @internal */ Vector2._one = new Vector2(1.0, 1.0);

/**
 * Describes a 4D-vector.
 */ var Vector4 = /*#__PURE__*/ function() {
    function Vector4(x, y, z, w) {
        if (x === void 0) x = 0;
        if (y === void 0) y = 0;
        if (z === void 0) z = 0;
        if (w === void 0) w = 0;
        /** @internal */ this._onValueChanged = null;
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
    }
    var _proto = Vector4.prototype;
    /**
   * Set the value of this vector.
   * @param x - The x component of the vector
   * @param y - The y component of the vector
   * @param z - The z component of the vector
   * @param w - The w component of the vector
   * @returns This vector
   */ _proto.set = function set(x, y, z, w) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * Determines the sum of this vector and the specified vector.
   * @param right - The specified vector
   * @returns This vector
   */ _proto.add = function add(right) {
        this._x += right._x;
        this._y += right._y;
        this._z += right._z;
        this._w += right._w;
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * Determines the difference of this vector and the specified vector.
   * @param right - the specified vector
   * @returns This vector
   */ _proto.subtract = function subtract(right) {
        this._x -= right._x;
        this._y -= right._y;
        this._z -= right._z;
        this._w -= right._w;
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * Determines the product of this vector and the specified vector.
   * @param right - the specified vector
   * @returns This vector
   */ _proto.multiply = function multiply(right) {
        this._x *= right._x;
        this._y *= right._y;
        this._z *= right._z;
        this._w *= right._w;
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * Determines the divisor of this vector and the specified vector.
   * @param right - the specified vector
   * @returns This vector
   */ _proto.divide = function divide(right) {
        this._x /= right._x;
        this._y /= right._y;
        this._z /= right._z;
        this._w /= right._w;
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * Calculate the length of this vector.
   * @returns The length of this vector
   */ _proto.length = function length() {
        var _this = this, _x = _this._x, _y = _this._y, _z = _this._z, _w = _this._w;
        return Math.sqrt(_x * _x + _y * _y + _z * _z + _w * _w);
    };
    /**
   * Calculate the squared length of this vector.
   * @returns The squared length of this vector
   */ _proto.lengthSquared = function lengthSquared() {
        var _this = this, _x = _this._x, _y = _this._y, _z = _this._z, _w = _this._w;
        return _x * _x + _y * _y + _z * _z + _w * _w;
    };
    /**
   * Reverses the direction of this vector.
   * @returns This vector
   */ _proto.negate = function negate() {
        this._x = -this._x;
        this._y = -this._y;
        this._z = -this._z;
        this._w = -this._w;
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * Converts this vector into a unit vector.
   * @returns This vector
   */ _proto.normalize = function normalize() {
        Vector4.normalize(this, this);
        return this;
    };
    /**
   * Scale this vector by the given value.
   * @param s - The amount by which to scale the vector
   * @returns This vector
   */ _proto.scale = function scale(s) {
        this._x *= s;
        this._y *= s;
        this._z *= s;
        this._w *= s;
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * Creates a clone of this vector.
   * @returns A clone of this vector
   */ _proto.clone = function clone() {
        var ret = new Vector4(this._x, this._y, this._z, this._w);
        return ret;
    };
    /**
   * Copy from vector3 like object.
   * @param source - Vector3 like object.
   * @returns This vector
   */ _proto.copyFrom = function copyFrom(source) {
        this._x = source.x;
        this._y = source.y;
        this._z = source.z;
        this._w = source.w;
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * Copy to vector4 like object.
   * @param target - Vector4 like object
   * @returns This Vector4 like object
   */ _proto.copyTo = function copyTo(target) {
        target.x = this._x;
        target.y = this._y;
        target.z = this._z;
        target.w = this._w;
        return target;
    };
    /**
   * Copy the value of this vector by an array.
   * @param array - The array
   * @param offset - The start offset of the array
   * @returns This vector
   */ _proto.copyFromArray = function copyFromArray(array, offset) {
        if (offset === void 0) offset = 0;
        this._x = array[offset];
        this._y = array[offset + 1];
        this._z = array[offset + 2];
        this._w = array[offset + 3];
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * Copy the value of this vector to an array.
   * @param out - The array
   * @param outOffset - The start offset of the array
   */ _proto.copyToArray = function copyToArray(out, outOffset) {
        if (outOffset === void 0) outOffset = 0;
        out[outOffset] = this._x;
        out[outOffset + 1] = this._y;
        out[outOffset + 2] = this._z;
        out[outOffset + 3] = this._w;
    };
    /**
   * Serialize this vector to a JSON representation.
   * @returns A JSON representation of this vector
   */ _proto.toJSON = function toJSON() {
        return {
            x: this._x,
            y: this._y,
            z: this._z,
            w: this._w
        };
    };
    /**
   * Determines the sum of two vectors.
   * @param left - The first vector to add
   * @param right - The second vector to add
   * @param out - The sum of two vectors
   */ Vector4.add = function add(left, right, out) {
        out._x = left._x + right._x;
        out._y = left._y + right._y;
        out._z = left._z + right._z;
        out._w = left._w + right._w;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Determines the difference between two vectors.
   * @param left - The first vector to subtract
   * @param right - The second vector to subtract
   * @param out - The difference between two vectors
   */ Vector4.subtract = function subtract(left, right, out) {
        out._x = left._x - right._x;
        out._y = left._y - right._y;
        out._z = left._z - right._z;
        out._w = left._w - right._w;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Determines the product of two vectors.
   * @param left - The first vector to multiply
   * @param right - The second vector to multiply
   * @param out - The product of two vectors
   */ Vector4.multiply = function multiply(left, right, out) {
        out._x = left._x * right._x;
        out._y = left._y * right._y;
        out._z = left._z * right._z;
        out._w = left._w * right._w;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Determines the divisor of two vectors.
   * @param left - The first vector to divide
   * @param right - The second vector to divide
   * @param out - The divisor of two vectors
   */ Vector4.divide = function divide(left, right, out) {
        out._x = left._x / right._x;
        out._y = left._y / right._y;
        out._z = left._z / right._z;
        out._w = left._w / right._w;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Determines the dot product of two vectors.
   * @param left - The first vector to dot
   * @param right - The second vector to dot
   * @returns The dot product of two vectors
   */ Vector4.dot = function dot(left, right) {
        return left._x * right._x + left._y * right._y + left._z * right._z + left._w * right._w;
    };
    /**
   * Determines the distance of two vectors.
   * @param a - The first vector
   * @param b - The second vector
   * @returns The distance of two vectors
   */ Vector4.distance = function distance(a, b) {
        var x = b._x - a._x;
        var y = b._y - a._y;
        var z = b._z - a._z;
        var w = b._w - a._w;
        return Math.sqrt(x * x + y * y + z * z + w * w);
    };
    /**
   * Determines the squared distance of two vectors.
   * @param a - The first vector
   * @param b - The second vector
   * @returns The squared distance of two vectors
   */ Vector4.distanceSquared = function distanceSquared(a, b) {
        var x = b._x - a._x;
        var y = b._y - a._y;
        var z = b._z - a._z;
        var w = b._w - a._w;
        return x * x + y * y + z * z + w * w;
    };
    /**
   * Determines whether the specified vectors are equals.
   * @param left - The first vector to compare
   * @param right - The second vector to compare
   * @returns True if the specified vectors are equals, false otherwise
   */ Vector4.equals = function equals(left, right) {
        return MathUtil.equals(left._x, right._x) && MathUtil.equals(left._y, right._y) && MathUtil.equals(left._z, right._z) && MathUtil.equals(left._w, right._w);
    };
    /**
   * Performs a linear interpolation between two vectors.
   * @param start - The first vector
   * @param end - The second vector
   * @param t - The blend amount where 0 returns start and 1 end
   * @param out - The result of linear blending between two vectors
   */ Vector4.lerp = function lerp(start, end, t, out) {
        var _x = start._x, _y = start._y, _z = start._z, _w = start._w;
        out._x = _x + (end._x - _x) * t;
        out._y = _y + (end._y - _y) * t;
        out._z = _z + (end._z - _z) * t;
        out._w = _w + (end._w - _w) * t;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Calculate a vector containing the largest components of the specified vectors.
   * @param left - The first vector
   * @param right - The second vector
   * @param out - The vector containing the largest components of the specified vectors
   */ Vector4.max = function max(left, right, out) {
        out._x = Math.max(left._x, right._x);
        out._y = Math.max(left._y, right._y);
        out._z = Math.max(left._z, right._z);
        out._w = Math.max(left._w, right._w);
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Calculate a vector containing the smallest components of the specified vectors.
   * @param left - The first vector
   * @param right - The second vector
   * @param out - The vector containing the smallest components of the specified vectors
   */ Vector4.min = function min(left, right, out) {
        out._x = Math.min(left._x, right._x);
        out._y = Math.min(left._y, right._y);
        out._z = Math.min(left._z, right._z);
        out._w = Math.min(left._w, right._w);
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Reverses the direction of a given vector.
   * @param a - The vector to negate
   * @param out - The vector facing in the opposite direction
   */ Vector4.negate = function negate(a, out) {
        out._x = -a._x;
        out._y = -a._y;
        out._z = -a._z;
        out._w = -a._w;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Converts the vector into a unit vector.
   * @param a - The vector to normalize
   * @param out - The normalized vector
   */ Vector4.normalize = function normalize(a, out) {
        var _x = a._x, _y = a._y, _z = a._z, _w = a._w;
        var len = Math.sqrt(_x * _x + _y * _y + _z * _z + _w * _w);
        if (len > MathUtil.zeroTolerance) {
            len = 1 / len;
            out._x = _x * len;
            out._y = _y * len;
            out._z = _z * len;
            out._w = _w * len;
            out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
        }
    };
    /**
   * Scale a vector by the given value.
   * @param a - The vector to scale
   * @param s - The amount by which to scale the vector
   * @param out - The scaled vector
   */ Vector4.scale = function scale(a, s, out) {
        out._x = a._x * s;
        out._y = a._y * s;
        out._z = a._z * s;
        out._w = a._w * s;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Performs a transformation using the given 4x4 matrix.
   * @param v - The vector to transform
   * @param m - The transform matrix
   * @param out - The transformed vector3
   */ Vector4.transform = function transform(v, m, out) {
        var _x = v._x, _y = v._y, _z = v._z, _w = v._w;
        var e = m.elements;
        out._x = _x * e[0] + _y * e[4] + _z * e[8] + _w * e[12];
        out._y = _x * e[1] + _y * e[5] + _z * e[9] + _w * e[13];
        out._z = _x * e[2] + _y * e[6] + _z * e[10] + _w * e[14];
        out._w = _x * e[3] + _y * e[7] + _z * e[11] + _w * e[15];
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Performs a transformation using the given quaternion.
   * @param v - The vector to transform
   * @param q - The transform quaternion
   * @param out - The transformed vector
   */ Vector4.transformByQuat = function transformByQuat(v, q, out) {
        var x = v._x, y = v._y, z = v._z, w = v._w;
        var qx = q._x;
        var qy = q._y;
        var qz = q._z;
        var qw = q._w;
        // calculate quat * vec
        var ix = qw * x + qy * z - qz * y;
        var iy = qw * y + qz * x - qx * z;
        var iz = qw * z + qx * y - qy * x;
        var iw = -qx * x - qy * y - qz * z;
        // calculate result * inverse quat
        out._x = ix * qw - iw * qx - iy * qz + iz * qy;
        out._y = iy * qw - iw * qy - iz * qx + ix * qz;
        out._z = iz * qw - iw * qz - ix * qy + iy * qx;
        out._w = w;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    _create_class$3(Vector4, [
        {
            key: "x",
            get: /**
   * The x component of the vector.
   */ function get() {
                return this._x;
            },
            set: function set(value) {
                this._x = value;
                this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
            }
        },
        {
            key: "y",
            get: /**
   * The y component of the vector.
   */ function get() {
                return this._y;
            },
            set: function set(value) {
                this._y = value;
                this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
            }
        },
        {
            key: "z",
            get: /**
   * The z component of the vector.
   */ function get() {
                return this._z;
            },
            set: function set(value) {
                this._z = value;
                this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
            }
        },
        {
            key: "w",
            get: /**
   * The w component of the vector.
   */ function get() {
                return this._w;
            },
            set: function set(value) {
                this._w = value;
                this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
            }
        }
    ]);
    return Vector4;
}();
/** @internal */ Vector4._zero = new Vector4(0.0, 0.0, 0.0, 0.0);
/** @internal */ Vector4._one = new Vector4(1.0, 1.0, 1.0, 1.0);

/**
 * Describes a color in the from of RGBA (in order: R, G, B, A).
 */ var Color = /*#__PURE__*/ function() {
    function Color(r, g, b, a) {
        if (r === void 0) r = 1;
        if (g === void 0) g = 1;
        if (b === void 0) b = 1;
        if (a === void 0) a = 1;
        /** @internal */ this._onValueChanged = null;
        this._r = r;
        this._g = g;
        this._b = b;
        this._a = a;
    }
    var _proto = Color.prototype;
    /**
   * Set the value of this color.
   * @param r - The red component of the color
   * @param g - The green component of the color
   * @param b - The blue component of the color
   * @param a - The alpha component of the color
   * @returns This color.
   */ _proto.set = function set(r, g, b, a) {
        this._r = r;
        this._g = g;
        this._b = b;
        this._a = a;
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * Determines the sum of this color and the specified color.
   * @param color - The specified color
   * @returns The added color
   */ _proto.add = function add(color) {
        this._r += color._r;
        this._g += color._g;
        this._b += color._b;
        this._a += color._a;
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * Scale this color by the given value.
   * @param s - The amount by which to scale the color
   * @returns The scaled color
   */ _proto.scale = function scale(s) {
        this._r *= s;
        this._g *= s;
        this._b *= s;
        this._a *= s;
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * Creates a clone of this color.
   * @returns A clone of this color
   */ _proto.clone = function clone() {
        var ret = new Color(this._r, this._g, this._b, this._a);
        return ret;
    };
    /**
   * Copy from color like object.
   * @param source - Color like object.
   * @returns This vector
   */ _proto.copyFrom = function copyFrom(source) {
        this._r = source.r;
        this._g = source.g;
        this._b = source.b;
        this._a = source.a;
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * Copy to color like object.
   * @param target - Color like object.
   * @returns This Color like object
   */ _proto.copyTo = function copyTo(target) {
        target.r = this._r;
        target.g = this._g;
        target.b = this._b;
        target.a = this._a;
        return target;
    };
    /**
   * Copy from array like object.
   * @param source - Array like object
   * @param offset - The start offset
   * @returns This color
   */ _proto.copyFromArray = function copyFromArray(source, offset) {
        if (offset === void 0) offset = 0;
        this._r = source[offset];
        this._g = source[offset + 1];
        this._b = source[offset + 2];
        this._a = source[offset + 3];
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * Copy the value of this color to an array.
   * @param out - The color
   * @param outOffset - The start offset
   */ _proto.copyToArray = function copyToArray(out, outOffset) {
        if (outOffset === void 0) outOffset = 0;
        out[outOffset] = this._r;
        out[outOffset + 1] = this._g;
        out[outOffset + 2] = this._b;
        out[outOffset + 3] = this._a;
    };
    /**
   * Modify components (r, g, b) of this color from gamma space to linear space.
   * @param out - The color in linear space
   * @returns The color in linear space
   */ _proto.toLinear = function toLinear(out) {
        out._r = Color.sRGBToLinearSpace(this._r);
        out._g = Color.sRGBToLinearSpace(this._g);
        out._b = Color.sRGBToLinearSpace(this._b);
        out._a = this._a;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
        return out;
    };
    /**
   * Modify components (r, g, b) of this color from linear space to sRGB space.
   * @param out - The color in sRGB space
   * @returns The color in sRGB space
   */ _proto.toSRGB = function toSRGB(out) {
        out._r = Color.linearToSRGBSpace(this._r);
        out._g = Color.linearToSRGBSpace(this._g);
        out._b = Color.linearToSRGBSpace(this._b);
        out._a = this._a;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
        return out;
    };
    /**
   * Gets the brightness.
   * @returns The Hue-Saturation-Brightness (HSB) saturation for this
   */ _proto.getBrightness = function getBrightness() {
        var r = this.r;
        var g = this.g;
        var b = this.b;
        var max = r;
        var min = r;
        if (g > max) max = g;
        if (b > max) max = b;
        if (g < min) min = g;
        if (b < min) min = b;
        return (max + min) / 2;
    };
    /**
   * Serialize this color to a JSON representation.
   * @return A JSON representation of this color
   */ _proto.toJSON = function toJSON() {
        return {
            r: this._r,
            g: this._g,
            b: this._b,
            a: this._a
        };
    };
    /** @deprecated Please use `toSRGB` instead. */ _proto.toGamma = function toGamma(out) {
        return this.toSRGB(out);
    };
    /**
   * Modify a value from the sRGB space to the linear space.
   * @param value - The value in sRGB space
   * @returns The value in linear space
   */ Color.sRGBToLinearSpace = function sRGBToLinearSpace(value) {
        // https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_framebuffer_sRGB.txt
        // https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_texture_sRGB_decode.txt
        if (value <= 0.0) return 0.0;
        else if (value <= 0.04045) return value / 12.92;
        else if (value < 1.0) return Math.pow((value + 0.055) / 1.055, 2.4);
        else return Math.pow(value, 2.4);
    };
    /**
   * Modify a value from the linear space to the sRGB space.
   * @param value - The value in linear space
   * @returns The value in sRGB space
   */ Color.linearToSRGBSpace = function linearToSRGBSpace(value) {
        // https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_framebuffer_sRGB.txt
        // https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_texture_sRGB_decode.txt
        if (value <= 0.0) return 0.0;
        else if (value < 0.0031308) return 12.92 * value;
        else if (value < 1.0) return 1.055 * Math.pow(value, 0.41666) - 0.055;
        else return Math.pow(value, 0.41666);
    };
    /**
   * Determines whether the specified colors are equals.
   * @param left - The first color to compare
   * @param right - The second color to compare
   * @returns True if the specified colors are equals, false otherwise
   */ Color.equals = function equals(left, right) {
        return MathUtil.equals(left._r, right._r) && MathUtil.equals(left._g, right._g) && MathUtil.equals(left._b, right._b) && MathUtil.equals(left._a, right._a);
    };
    /**
   * Determines the sum of two colors.
   * @param left - The first color to add
   * @param right - The second color to add
   * @param out - The sum of two colors
   * @returns The added color
   */ Color.add = function add(left, right, out) {
        out._r = left._r + right._r;
        out._g = left._g + right._g;
        out._b = left._b + right._b;
        out._a = left._a + right._a;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
        return out;
    };
    /**
   * Determines the difference between two colors.
   * @param left - The first color to subtract
   * @param right - The second color to subtract
   * @param out - The difference between two colors
   */ Color.subtract = function subtract(left, right, out) {
        out._r = left._r - right._r;
        out._g = left._g - right._g;
        out._b = left._b - right._b;
        out._a = left._a - right._a;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
    };
    /**
   * Scale a color by the given value.
   * @param left - The color to scale
   * @param s - The amount by which to scale the color
   * @param out - The scaled color
   * @returns The scaled color
   */ Color.scale = function scale(left, s, out) {
        out._r = left._r * s;
        out._g = left._g * s;
        out._b = left._b * s;
        out._a = left._a * s;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
        return out;
    };
    /**
   * Performs a linear interpolation between two color.
   * @param start - The first color
   * @param end - The second color
   * @param t - The blend amount where 0 returns start and 1 end
   * @param out - The result of linear blending between two color
   */ Color.lerp = function lerp(start, end, t, out) {
        var _r = start._r, _g = start._g, _b = start._b, _a = start._a;
        out._r = _r + (end._r - _r) * t;
        out._g = _g + (end._g - _g) * t;
        out._b = _b + (end._b - _b) * t;
        out._a = _a + (end._a - _a) * t;
        out._onValueChanged == null ? void 0 : out._onValueChanged.call(out);
        return out;
    };
    /** @deprecated Please use `sRGBToLinearSpace` instead. */ Color.gammaToLinearSpace = function gammaToLinearSpace(value) {
        return Color.sRGBToLinearSpace(value);
    };
    /** @deprecated Please use `linearToSRGBSpace` instead. */ Color.linearToGammaSpace = function linearToGammaSpace(value) {
        return Color.linearToSRGBSpace(value);
    };
    _create_class$3(Color, [
        {
            key: "r",
            get: /**
   * The red component of the color, 0~1.
   */ function get() {
                return this._r;
            },
            set: function set(value) {
                this._r = value;
                this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
            }
        },
        {
            key: "g",
            get: /**
   * The green component of the color, 0~1.
   */ function get() {
                return this._g;
            },
            set: function set(value) {
                this._g = value;
                this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
            }
        },
        {
            key: "b",
            get: /**
   * The blue component of the color, 0~1.
   */ function get() {
                return this._b;
            },
            set: function set(value) {
                this._b = value;
                this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
            }
        },
        {
            key: "a",
            get: /**
   * The alpha component of the color, 0~1.
   */ function get() {
                return this._a;
            },
            set: function set(value) {
                this._a = value;
                this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
            }
        }
    ]);
    return Color;
}();

// A 2d rectangle defined by x and y position, width and height.
var Rect = /*#__PURE__*/ function() {
    function Rect(x, y, width, height) {
        if (x === void 0) x = 0;
        if (y === void 0) y = 0;
        if (width === void 0) width = 0;
        if (height === void 0) height = 0;
        /** @internal */ this._onValueChanged = null;
        this._x = x;
        this._y = y;
        this._width = width;
        this._height = height;
    }
    var _proto = Rect.prototype;
    /**
   * Set the value of this rectangle.
   * @param x - The x coordinate of the rectangle
   * @param y - The y coordinate of the rectangle
   * @param width - The width of the rectangle, measured from the x position
   * @param height - The height of the rectangle, measured from the y position
   * @returns This rectangle
   */ _proto.set = function set(x, y, width, height) {
        this._x = x;
        this._y = y;
        this._width = width;
        this._height = height;
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    /**
   * Creates a clone of this rect.
   * @returns A clone of this rect
   */ _proto.clone = function clone() {
        return new Rect(this.x, this.y, this.width, this.height);
    };
    /**
   * Copy this rect from the specified rect.
   * @param source - The specified rect
   * @returns This rect
   */ _proto.copyFrom = function copyFrom(source) {
        this._x = source.x;
        this._y = source.y;
        this._width = source.width;
        this._height = source.height;
        this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
        return this;
    };
    _create_class$3(Rect, [
        {
            key: "x",
            get: /**
   *  The x coordinate of the rectangle.
   */ function get() {
                return this._x;
            },
            set: function set(value) {
                this._x = value;
                this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
            }
        },
        {
            key: "y",
            get: /**
   *  The y coordinate of the rectangle.
   */ function get() {
                return this._y;
            },
            set: function set(value) {
                this._y = value;
                this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
            }
        },
        {
            key: "width",
            get: /**
   * The width of the rectangle, measured from the x position.
   */ function get() {
                return this._width;
            },
            set: function set(value) {
                this._width = value;
                this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
            }
        },
        {
            key: "height",
            get: /**
   * The height of the rectangle, measured from the y position.
   */ function get() {
                return this._height;
            },
            set: function set(value) {
                this._height = value;
                this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
            }
        }
    ]);
    return Rect;
}();

/**
 * Use SH3 to represent irradiance environment maps efficiently, allowing for interactive rendering of diffuse objects under distant illumination.
 * @remarks
 * https://graphics.stanford.edu/papers/envmap/envmap.pdf
 * http://www.ppsloan.org/publications/StupidSH36.pdf
 * https://google.github.io/filament/Filament.md.html#annex/sphericalharmonics
 */ var SphericalHarmonics3 = /*#__PURE__*/ function() {
    function SphericalHarmonics3() {
        /** The coefficients of SphericalHarmonics3. */ this.coefficients = new Float32Array(27);
    }
    var _proto = SphericalHarmonics3.prototype;
    /**
   * Add light to SphericalHarmonics3.
   * @param direction - Light direction
   * @param color - Light color
   * @param deltaSolidAngle - The delta solid angle of the light
   */ _proto.addLight = function addLight(direction, color, deltaSolidAngle) {
        /**
     * Implements `EvalSHBasis` from [Projection from Cube maps] in http://www.ppsloan.org/publications/StupidSH36.pdf.
     *
     * Basis constants
     * 0: Math.sqrt(1/(4 * Math.PI))
     *
     * 1: -Math.sqrt(3 / (4 * Math.PI))
     * 2: Math.sqrt(3 / (4 * Math.PI))
     * 3: -Math.sqrt(3 / (4 * Math.PI))
     *
     * 4: Math.sqrt(15 / (4 * Math.PI))
     * 5: -Math.sqrt(15 / (4 * Math.PI))
     * 6: Math.sqrt(5 / (16 * Math.PI))
     * 7: -Math.sqrt(15 / (4 * Math.PI)）
     * 8: Math.sqrt(15 / (16 * Math.PI))
     */ color.scale(deltaSolidAngle);
        var coe = this.coefficients;
        var x = direction._x, y = direction._y, z = direction._z;
        var r = color.r, g = color.g, b = color.b;
        var bv0 = 0.282095; // basis0 = 0.886227
        var bv1 = -0.488603 * y; // basis1 = -0.488603
        var bv2 = 0.488603 * z; // basis2 = 0.488603
        var bv3 = -0.488603 * x; // basis3 = -0.488603
        var bv4 = 1.092548 * (x * y); // basis4 = 1.092548
        var bv5 = -1.092548 * (y * z); // basis5 = -1.092548
        var bv6 = 0.315392 * (3 * z * z - 1); // basis6 = 0.315392
        var bv7 = -1.092548 * (x * z); // basis7 = -1.092548
        var bv8 = 0.546274 * (x * x - y * y); // basis8 = 0.546274
        coe[0] += r * bv0, coe[1] += g * bv0, coe[2] += b * bv0;
        coe[3] += r * bv1, coe[4] += g * bv1, coe[5] += b * bv1;
        coe[6] += r * bv2, coe[7] += g * bv2, coe[8] += b * bv2;
        coe[9] += r * bv3, coe[10] += g * bv3, coe[11] += b * bv3;
        coe[12] += r * bv4, coe[13] += g * bv4, coe[14] += b * bv4;
        coe[15] += r * bv5, coe[16] += g * bv5, coe[17] += b * bv5;
        coe[18] += r * bv6, coe[19] += g * bv6, coe[20] += b * bv6;
        coe[21] += r * bv7, coe[22] += g * bv7, coe[23] += b * bv7;
        coe[24] += r * bv8, coe[25] += g * bv8, coe[26] += b * bv8;
    };
    /**
   * Evaluates the color for the specified direction.
   * @param direction - Specified direction
   * @param out - Out color
   */ _proto.evaluate = function evaluate(direction, out) {
        /**
     * Equations based on data from: http://ppsloan.org/publications/StupidSH36.pdf
     *
     *
     * Basis constants
     * 0: Math.sqrt(1/(4 * Math.PI))
     *
     * 1: -Math.sqrt(3 / (4 * Math.PI))
     * 2: Math.sqrt(3 / (4 * Math.PI))
     * 3: -Math.sqrt(3 / (4 * Math.PI))
     *
     * 4: Math.sqrt(15 / (4 * Math.PI)）
     * 5: -Math.sqrt(15 / (4 * Math.PI))
     * 6: Math.sqrt(5 / (16 * Math.PI)）
     * 7: -Math.sqrt(15 / (4 * Math.PI)）
     * 8: Math.sqrt(15 / (16 * Math.PI)）
     *
     *
     * Convolution kernel
     * 0: Math.PI
     * 1: (2 * Math.PI) / 3
     * 2: Math.PI / 4
     */ var coe = this.coefficients;
        var x = direction._x, y = direction._y, z = direction._z;
        var bv0 = 0.886227; // kernel0 * basis0 = 0.886227
        var bv1 = -1.023327 * y; // kernel1 * basis1 = -1.023327
        var bv2 = 1.023327 * z; // kernel1 * basis2 = 1.023327
        var bv3 = -1.023327 * x; // kernel1 * basis3 = -1.023327
        var bv4 = 0.858086 * y * x; // kernel2 * basis4 = 0.858086
        var bv5 = -0.858086 * y * z; // kernel2 * basis5 = -0.858086
        var bv6 = 0.247708 * (3 * z * z - 1); // kernel2 * basis6 = 0.247708
        var bv7 = -0.858086 * z * x; // kernel2 * basis7 = -0.858086
        var bv8 = 0.429042 * (x * x - y * y); // kernel2 * basis8 = 0.429042
        // l0
        var r = coe[0] * bv0;
        var g = coe[1] * bv0;
        var b = coe[2] * bv0;
        // l1
        r += coe[3] * bv1 + coe[6] * bv2 + coe[9] * bv3;
        g += coe[4] * bv1 + coe[7] * bv2 + coe[10] * bv3;
        b += coe[5] * bv1 + coe[8] * bv2 + coe[11] * bv3;
        // l2
        r += coe[12] * bv4 + coe[15] * bv5 + coe[18] * bv6 + coe[21] * bv7 + coe[24] * bv8;
        g += coe[13] * bv4 + coe[16] * bv5 + coe[19] * bv6 + coe[22] * bv7 + coe[25] * bv8;
        b += coe[14] * bv4 + coe[17] * bv5 + coe[20] * bv6 + coe[23] * bv7 + coe[26] * bv8;
        out.set(r, g, b, 1.0);
        return out;
    };
    /**
   * Scale the coefficients.
   * @param s - The amount by which to scale the SphericalHarmonics3
   */ _proto.scale = function scale(s) {
        var src = this.coefficients;
        src[0] *= s, src[1] *= s, src[2] *= s;
        src[3] *= s, src[4] *= s, src[5] *= s;
        src[6] *= s, src[7] *= s, src[8] *= s;
        src[9] *= s, src[10] *= s, src[11] *= s;
        src[12] *= s, src[13] *= s, src[14] *= s;
        src[15] *= s, src[16] *= s, src[17] *= s;
        src[18] *= s, src[19] *= s, src[20] *= s;
        src[21] *= s, src[22] *= s, src[23] *= s;
        src[24] *= s, src[25] *= s, src[26] *= s;
    };
    /**
   * Creates a clone of this SphericalHarmonics3.
   * @returns A clone of this SphericalHarmonics3
   */ _proto.clone = function clone() {
        var sh = new SphericalHarmonics3();
        sh.copyFrom(this);
        return sh;
    };
    /**
   * Copy this SphericalHarmonics3 from the specified SphericalHarmonics3.
   * @param source - The specified SphericalHarmonics3
   * @returns This SphericalHarmonics3
   */ _proto.copyFrom = function copyFrom(source) {
        source.copyToArray(this.coefficients);
        return this;
    };
    /**
   * Copy the value of this spherical harmonics from an array.
   * @param array - The array
   * @param offset - The start offset of the array
   */ _proto.copyFromArray = function copyFromArray(array, offset) {
        if (offset === void 0) offset = 0;
        var s = this.coefficients;
        s[0] = array[offset], s[1] = array[1 + offset], s[2] = array[2 + offset];
        s[3] = array[3 + offset], s[4] = array[4 + offset], s[5] = array[5 + offset];
        s[6] = array[6 + offset], s[7] = array[7 + offset], s[8] = array[8 + offset];
        s[9] = array[9 + offset], s[10] = array[10 + offset], s[11] = array[11 + offset];
        s[12] = array[12 + offset], s[13] = array[13 + offset], s[14] = array[14 + offset];
        s[15] = array[15 + offset], s[16] = array[16 + offset], s[17] = array[17 + offset];
        s[18] = array[18 + offset], s[19] = array[19 + offset], s[20] = array[20 + offset];
        s[21] = array[21 + offset], s[22] = array[22 + offset], s[23] = array[23 + offset];
        s[24] = array[24 + offset], s[25] = array[25 + offset], s[26] = array[26 + offset];
    };
    /**
   * Copy the value of this spherical harmonics to an array.
   * @param out - The array
   * @param outOffset - The start offset of the array
   */ _proto.copyToArray = function copyToArray(out, outOffset) {
        if (outOffset === void 0) outOffset = 0;
        var s = this.coefficients;
        out[0 + outOffset] = s[0], out[1 + outOffset] = s[1], out[2 + outOffset] = s[2];
        out[3 + outOffset] = s[3], out[4 + outOffset] = s[4], out[5 + outOffset] = s[5];
        out[6 + outOffset] = s[6], out[7 + outOffset] = s[7], out[8 + outOffset] = s[8];
        out[9 + outOffset] = s[9], out[10 + outOffset] = s[10], out[11 + outOffset] = s[11];
        out[12 + outOffset] = s[12], out[13 + outOffset] = s[13], out[14 + outOffset] = s[14];
        out[15 + outOffset] = s[15], out[16 + outOffset] = s[16], out[17 + outOffset] = s[17];
        out[18 + outOffset] = s[18], out[19 + outOffset] = s[19], out[20 + outOffset] = s[20];
        out[21 + outOffset] = s[21], out[22 + outOffset] = s[22], out[23 + outOffset] = s[23];
        out[24 + outOffset] = s[24], out[25 + outOffset] = s[25], out[26 + outOffset] = s[26];
    };
    return SphericalHarmonics3;
}();

/**
 * Random number generator based on the xorshift128+ algorithm.
 * https://vigna.di.unimi.it/ftp/papers/xorshiftplus.pdf
 */ var Rand = /*#__PURE__*/ function() {
    function Rand(seed0, seed1) {
        this.reset(seed0, seed1);
    }
    var _proto = Rand.prototype;
    /**
   * Generate a integer 32bit random number.
   * @returns - A random number
   */ _proto.randomInt32 = function randomInt32() {
        var x = this._state0;
        var y = this._state1;
        this._state0 = y;
        x ^= x << 23;
        x ^= x >>> 17;
        x ^= y ^ y >>> 26;
        this._state1 = x;
        return this._state0 + this._state1 >>> 0;
    };
    /**
   * Generate a number between 0 and 1.
   * @returns - A random number
   */ _proto.random = function random() {
        return this.randomInt32() / 0xffffffff; // 2^32 - 1
    };
    /**
   * Reset the generator by new seeds.
   * @param seed0 - Random seed0
   * @param seed1 - Random seed1
   */ _proto.reset = function reset(seed0, seed1) {
        this._state0 = seed0 >>> 0;
        this._state1 = seed1 >>> 0;
    };
    return Rand;
}();

/**
 * The platform (including operating system and hardware) is running on.
 */ var Platform = /*#__PURE__*/ function(Platform) {
    /** Android platform. */ Platform[Platform["Android"] = 0] = "Android";
    /** IPhone platform. */ Platform[Platform["IPhone"] = 1] = "IPhone";
    /** IPad platform. */ Platform[Platform["IPad"] = 2] = "IPad";
    /** Mac platform. */ Platform[Platform["Mac"] = 3] = "Mac";
    /** Unknown platform. */ Platform[Platform["Unknown"] = 4] = "Unknown";
    return Platform;
}({});

function _defineProperties$2(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;

        if ("value" in descriptor) descriptor.writable = true;

        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class$2(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$2(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$2(Constructor, staticProps);

    return Constructor;
}

function _set_prototype_of$2(o, p) {
    _set_prototype_of$2 = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;

        return o;
    };

    return _set_prototype_of$2(o, p);
}

function _inherits$2(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });

    if (superClass) _set_prototype_of$2(subClass, superClass);
}

/**
 * @internal
 */ var CharRenderInfo = /*#__PURE__*/ function() {
    function CharRenderInfo() {
        /** x:Top y:Left z:Bottom w:Right */ this.localPositions = new Vector4();
    }
    var _proto = CharRenderInfo.prototype;
    _proto.dispose = function dispose() {
        this.texture = null;
        this.localPositions = null;
        this.uvs = null;
    };
    return CharRenderInfo;
}();
CharRenderInfo.triangles = [
    0,
    2,
    1,
    2,
    0,
    3
];

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate$1(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __generator$1(thisArg, body) {
  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
  function verb(n) { return function (v) { return step([n, v]); }; }
  function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
              case 0: case 1: t = op; break;
              case 4: _.label++; return { value: op[1], done: false };
              case 5: _.label++; y = op[1]; op = [0]; continue;
              case 7: op = _.ops.pop(); _.trys.pop(); continue;
              default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                  if (t[2]) _.ops.pop();
                  _.trys.pop(); continue;
          }
          op = body.call(thisArg, _);
      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
  }
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function _instanceof$3(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else return left instanceof right;
}

/**
 * Clone mode.
 */ var CloneMode = /*#__PURE__*/ function(CloneMode) {
    /** Ignore clone. */ CloneMode[CloneMode["Ignore"] = 0] = "Ignore";
    /** Assignment clone. */ CloneMode[CloneMode["Assignment"] = 1] = "Assignment";
    /** Shallow clone. */ CloneMode[CloneMode["Shallow"] = 2] = "Shallow";
    /** Deep clone. */ CloneMode[CloneMode["Deep"] = 3] = "Deep";
    return CloneMode;
}({});

/**
 * Property decorator, ignore the property when cloning.
 */ function ignoreClone(target, propertyKey) {
    CloneManager.registerCloneMode(target, propertyKey, CloneMode.Ignore);
}
/**
 * Property decorator, assign value to the property when cloning.
 *
 * @remarks
 * If it's a primitive type, the value will be copied.
 * If it's a class type, the reference will be copied.
 */ function assignmentClone(target, propertyKey) {
    CloneManager.registerCloneMode(target, propertyKey, CloneMode.Assignment);
}
/**
 * Property decorator, shallow clone the property when cloning.
 * After cloning, it will keep its own reference independent, and use the method of assignment to clone all its internal properties.
 * if the internal property is a primitive type, the value will be copied, if the internal property is a reference type, its reference address will be copied.。
 *
 * @remarks
 * Applicable to Object, Array, TypedArray and Class types.
 */ function shallowClone(target, propertyKey) {
    CloneManager.registerCloneMode(target, propertyKey, CloneMode.Shallow);
}
/**
 * Property decorator, deep clone the property when cloning.
 * After cloning, it will maintain its own reference independence, and all its internal deep properties will remain completely independent.
 *
 * @remarks
 * Applicable to Object, Array, TypedArray and Class types.
 * If Class is encountered during the deep cloning process, the custom cloning function of the object will be called first.
 * Custom cloning requires the object to implement the IClone interface.
 */ function deepClone(target, propertyKey) {
    CloneManager.registerCloneMode(target, propertyKey, CloneMode.Deep);
}
/**
 * @internal
 * Clone manager.
 */ var CloneManager = /*#__PURE__*/ function() {
    function CloneManager() {}
    /**
   * Register clone mode.
   * @param target - Clone target
   * @param propertyKey - Clone property name
   * @param mode - Clone mode
   */ CloneManager.registerCloneMode = function registerCloneMode(target, propertyKey, mode) {
        var targetMap = CloneManager._subCloneModeMap.get(target.constructor);
        if (!targetMap) {
            targetMap = Object.create(null);
            CloneManager._subCloneModeMap.set(target.constructor, targetMap);
        }
        targetMap[propertyKey] = mode;
    };
    /**
   * Get the clone mode according to the prototype chain.
   */ CloneManager.getCloneMode = function getCloneMode(type) {
        var cloneModes = CloneManager._cloneModeMap.get(type);
        if (!cloneModes) {
            cloneModes = Object.create(null);
            CloneManager._cloneModeMap.set(type, cloneModes);
            var objectType = CloneManager._objectType;
            var cloneModeMap = CloneManager._subCloneModeMap;
            while(type !== objectType){
                var subCloneModes = cloneModeMap.get(type);
                if (subCloneModes) {
                    Object.assign(cloneModes, subCloneModes);
                }
                type = Object.getPrototypeOf(type);
            }
        }
        return cloneModes;
    };
    CloneManager.cloneProperty = function cloneProperty(source, target, k, cloneMode, srcRoot, targetRoot, deepInstanceMap) {
        if (cloneMode === CloneMode.Ignore) {
            return;
        }
        var sourceProperty = source[k];
        if (_instanceof$3(sourceProperty, Object)) {
            if (cloneMode === undefined || cloneMode === CloneMode.Assignment) {
                target[k] = sourceProperty;
                return;
            }
            var type = sourceProperty.constructor;
            switch(type){
                case Uint8Array:
                case Uint16Array:
                case Uint32Array:
                case Int8Array:
                case Int16Array:
                case Int32Array:
                case Float32Array:
                case Float64Array:
                    var targetPropertyT = target[k];
                    if (targetPropertyT == null || targetPropertyT.length !== sourceProperty.length) {
                        target[k] = sourceProperty.slice();
                    } else {
                        targetPropertyT.set(sourceProperty);
                    }
                    break;
                case Array:
                    var targetPropertyA = target[k];
                    var length = sourceProperty.length;
                    if (targetPropertyA == null) {
                        target[k] = targetPropertyA = new Array(length);
                    } else {
                        targetPropertyA.length = length;
                    }
                    for(var i = 0; i < length; i++){
                        CloneManager.cloneProperty(sourceProperty, targetPropertyA, i, cloneMode, srcRoot, targetRoot, deepInstanceMap);
                    }
                    break;
                default:
                    var targetProperty = target[k];
                    // If the target property is undefined, create new instance and keep reference sharing like the source
                    if (!targetProperty) {
                        targetProperty = deepInstanceMap.get(sourceProperty);
                        if (!targetProperty) {
                            targetProperty = new sourceProperty.constructor();
                            deepInstanceMap.set(sourceProperty, targetProperty);
                        }
                        target[k] = targetProperty;
                    }
                    if (sourceProperty.copyFrom) {
                        // Custom clone
                        targetProperty.copyFrom(sourceProperty);
                    } else {
                        // Universal clone
                        var cloneModes = CloneManager.getCloneMode(sourceProperty.constructor);
                        for(var _$k in sourceProperty){
                            CloneManager.cloneProperty(sourceProperty, targetProperty, _$k, cloneModes[_$k], srcRoot, targetRoot, deepInstanceMap);
                        }
                        // Custom incremental clone
                        if (sourceProperty._cloneTo) {
                            sourceProperty._cloneTo(targetProperty, srcRoot, targetRoot);
                        }
                    }
                    break;
            }
        } else {
            // null, undefined, primitive type, function
            target[k] = sourceProperty;
        }
    };
    CloneManager.deepCloneObject = function deepCloneObject(source, target, deepInstanceMap) {
        for(var k in source){
            CloneManager.cloneProperty(source, target, k, CloneMode.Deep, null, null, deepInstanceMap);
        }
    };
    return CloneManager;
}();
/** @internal */ CloneManager._subCloneModeMap = new Map();
/** @internal */ CloneManager._cloneModeMap = new Map();
CloneManager._objectType = Object.getPrototypeOf(Object);

/**
 * EngineObject.
 */ var EngineObject = /*#__PURE__*/ function() {
    function EngineObject(engine) {
        /** Engine unique id. */ this.instanceId = ++EngineObject._instanceIdCounter;
        this._destroyed = false;
        this._engine = engine;
    }
    var _proto = EngineObject.prototype;
    /**
   * Destroy self.
   */ _proto.destroy = function destroy() {
        if (this._destroyed) return;
        this._onDestroy();
        this._destroyed = true;
    };
    _proto._onDestroy = function _onDestroy() {
        var resourceManager = this._engine.resourceManager;
        resourceManager._deleteAsset(this);
        resourceManager._deleteContentRestorer(this);
    };
    _create_class$2(EngineObject, [
        {
            key: "engine",
            get: /**
   * Get the engine which the object belongs.
   */ function get() {
                return this._engine;
            }
        },
        {
            key: "destroyed",
            get: /**
   * Whether it has been destroyed.
   */ function get() {
                return this._destroyed;
            }
        }
    ]);
    return EngineObject;
}();
EngineObject._instanceIdCounter = 0;
__decorate$1([
    ignoreClone
], EngineObject.prototype, "instanceId", void 0);
__decorate$1([
    ignoreClone
], EngineObject.prototype, "_engine", void 0);

/**
 * The base class of assets, with reference counting capability.
 */ var ReferResource = /*#__PURE__*/ function(EngineObject) {
    _inherits$2(ReferResource, EngineObject);
    function ReferResource(engine) {
        var _this;
        _this = EngineObject.call(this, engine) || this, /** Whether to ignore the garbage collection check, if it is true, it will not be affected by ResourceManager.gc(). */ _this.isGCIgnored = false, _this._refCount = 0, _this._superResources = null;
        engine.resourceManager._addReferResource(_this);
        return _this;
    }
    var _proto = ReferResource.prototype;
    _proto.destroy = function destroy(force, isGC) {
        if (force === void 0) force = false;
        if (!force) {
            if (this._refCount !== 0) {
                return false;
            }
            var superResources = this._superResources;
            if (superResources == null ? void 0 : superResources.length) {
                if (isGC) {
                    for(var i = 0, n = superResources.length; i < n; i++){
                        if (superResources[i].refCount > 0) {
                            return false;
                        }
                    }
                } else {
                    return false;
                }
            }
        }
        EngineObject.prototype.destroy.call(this);
        return true;
    };
    /**
   * @internal
   */ _proto._associationSuperResource = function _associationSuperResource(superResource) {
        (this._superResources || (this._superResources = [])).push(superResource);
    };
    /**
   * @internal
   */ _proto._disassociationSuperResource = function _disassociationSuperResource(superResource) {
        var superResources = this._superResources;
        var index = superResources.indexOf(superResource);
        superResources.splice(index, 1);
    };
    /**
   * @internal
   */ _proto._getReferCount = function _getReferCount() {
        return this._refCount;
    };
    /**
   * @internal
   */ _proto._addReferCount = function _addReferCount(value) {
        this._refCount += value;
    };
    /**
   * @internal
   */ _proto._addToResourceManager = function _addToResourceManager(path) {
        this._engine.resourceManager._addAsset(path, this);
    };
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        EngineObject.prototype._onDestroy.call(this);
        this._engine.resourceManager._deleteReferResource(this);
        var refCount = this._getReferCount();
        if (refCount > 0) {
            this._addReferCount(-refCount);
        }
    };
    _create_class$2(ReferResource, [
        {
            key: "refCount",
            get: /**
   * Counted by valid references.
   */ function get() {
                return this._refCount;
            }
        }
    ]);
    return ReferResource;
}(EngineObject);

/**
 * ContentRestorer is a base class for all content restore info classes.
 */ var ContentRestorer = function ContentRestorer(resource) {
    this.resource = resource;
};

/**
 * @deprecated Please use `TextureFormat` instead.
 *
 * Render buffer depth format enumeration.
 */ var RenderBufferDepthFormat = /*#__PURE__*/ function(RenderBufferDepthFormat) {
    /** Render to depth buffer,engine will automatically select the supported precision. */ RenderBufferDepthFormat[RenderBufferDepthFormat["Depth"] = 27] = "Depth";
    /** Render to stencil buffer. */ RenderBufferDepthFormat[RenderBufferDepthFormat["Stencil"] = 28] = "Stencil";
    /** Render to depth stencil buffer, engine will automatically select the supported precision. */ RenderBufferDepthFormat[RenderBufferDepthFormat["DepthStencil"] = 29] = "DepthStencil";
    /** Force 16-bit depth buffer. */ RenderBufferDepthFormat[RenderBufferDepthFormat["Depth16"] = 30] = "Depth16";
    /** Force 24-bit depth buffer. */ RenderBufferDepthFormat[RenderBufferDepthFormat["Depth24"] = 31] = "Depth24";
    /** Force 32-bit depth buffer. */ RenderBufferDepthFormat[RenderBufferDepthFormat["Depth32"] = 32] = "Depth32";
    /** Force 16-bit depth + 8-bit stencil buffer. */ RenderBufferDepthFormat[RenderBufferDepthFormat["Depth24Stencil8"] = 33] = "Depth24Stencil8";
    /** Force 32-bit depth + 8-bit stencil buffer. */ RenderBufferDepthFormat[RenderBufferDepthFormat["Depth32Stencil8"] = 34] = "Depth32Stencil8";
    return RenderBufferDepthFormat;
}({});

/**
 * Define the face of the cube texture.
 */ var TextureCubeFace = /*#__PURE__*/ function(TextureCubeFace) {
    /** Positive X face for a cube-mapped texture. */ TextureCubeFace[TextureCubeFace["PositiveX"] = 0] = "PositiveX";
    /** Negative X face for a cube-mapped texture. */ TextureCubeFace[TextureCubeFace["NegativeX"] = 1] = "NegativeX";
    /** Positive Y face for a cube-mapped texture. */ TextureCubeFace[TextureCubeFace["PositiveY"] = 2] = "PositiveY";
    /** Negative Y face for a cube-mapped texture. */ TextureCubeFace[TextureCubeFace["NegativeY"] = 3] = "NegativeY";
    /** Positive Z face for a cube-mapped texture. */ TextureCubeFace[TextureCubeFace["PositiveZ"] = 4] = "PositiveZ";
    /** Negative Z face for a cube-mapped texture. */ TextureCubeFace[TextureCubeFace["NegativeZ"] = 5] = "NegativeZ";
    return TextureCubeFace;
}({});

/**
 * Define the compare mode of depth texture.
 */ var TextureDepthCompareFunction = /*#__PURE__*/ function(TextureDepthCompareFunction) {
    /** never pass. */ TextureDepthCompareFunction[TextureDepthCompareFunction["Never"] = 0] = "Never";
    /** pass if the compare value is less than the sample value. */ TextureDepthCompareFunction[TextureDepthCompareFunction["Less"] = 1] = "Less";
    /** pass if the compare value equals the sample value. */ TextureDepthCompareFunction[TextureDepthCompareFunction["Equal"] = 2] = "Equal";
    /** pass if the compare value is less than or equal to the sample value. */ TextureDepthCompareFunction[TextureDepthCompareFunction["LessEqual"] = 3] = "LessEqual";
    /** pass if the compare value is greater than the sample value. */ TextureDepthCompareFunction[TextureDepthCompareFunction["Greater"] = 4] = "Greater";
    /** pass if the compare value is not equal to the sample value. */ TextureDepthCompareFunction[TextureDepthCompareFunction["NotEqual"] = 5] = "NotEqual";
    /** pass if the compare value is greater than or equal to the sample value. */ TextureDepthCompareFunction[TextureDepthCompareFunction["GreaterEqual"] = 6] = "GreaterEqual";
    /** always pass. */ TextureDepthCompareFunction[TextureDepthCompareFunction["Always"] = 7] = "Always";
    return TextureDepthCompareFunction;
}({});

/**
 * The filter mode of the texture.
 */ var TextureFilterMode = /*#__PURE__*/ function(TextureFilterMode) {
    /** Point filtering. */ TextureFilterMode[TextureFilterMode["Point"] = 0] = "Point";
    /** Bilinear filtering. */ TextureFilterMode[TextureFilterMode["Bilinear"] = 1] = "Bilinear";
    /** Trilinear filtering. */ TextureFilterMode[TextureFilterMode["Trilinear"] = 2] = "Trilinear";
    return TextureFilterMode;
}({});

/**
 * Texture format enumeration.
 */ var TextureFormat = /*#__PURE__*/ function(TextureFormat) {
    /** RGB format, 8 bits per channel. */ TextureFormat[TextureFormat["R8G8B8"] = 0] = "R8G8B8";
    /** RGBA format, 8 bits per channel. */ TextureFormat[TextureFormat["R8G8B8A8"] = 1] = "R8G8B8A8";
    /** RGBA format, 4 bits per channel. */ TextureFormat[TextureFormat["R4G4B4A4"] = 2] = "R4G4B4A4";
    /** RGBA format, 5 bits in R channel, 5 bits in G channel, 5 bits in B channel, 1 bit in A channel. */ TextureFormat[TextureFormat["R5G5B5A1"] = 3] = "R5G5B5A1";
    /** RGB format, 5 bits in R channel, 6 bits in G channel, 5 bits in B channel. */ TextureFormat[TextureFormat["R5G6B5"] = 4] = "R5G6B5";
    /** RGBA format, 16 bits per channel. */ TextureFormat[TextureFormat["R16G16B16A16"] = 7] = "R16G16B16A16";
    /** RGBA format, 32 bits per channel. */ TextureFormat[TextureFormat["R32G32B32A32"] = 8] = "R32G32B32A32";
    /** RGBA unsigned integer format, 32 bits per channel. */ TextureFormat[TextureFormat["R32G32B32A32_UInt"] = 9] = "R32G32B32A32_UInt";
    /** RGB unsigned float format, 11 bits in R channel, 11 bits in G channel, 10 bits in B channel. */ TextureFormat[TextureFormat["R11G11B10_UFloat"] = 35] = "R11G11B10_UFloat";
    /** R float format, 8 bits. */ TextureFormat[TextureFormat["R8"] = 36] = "R8";
    /** RG float format, 8 bits per channel. */ TextureFormat[TextureFormat["R8G8"] = 37] = "R8G8";
    /** RGB compressed format, 4 bits per pixel. */ TextureFormat[TextureFormat["BC1"] = 10] = "BC1";
    /** RGBA compressed format, 8 bits per pixel. */ TextureFormat[TextureFormat["BC3"] = 11] = "BC3";
    /** RGB(A) compressed format, 128 bits per 4x4 pixel block. */ TextureFormat[TextureFormat["BC7"] = 12] = "BC7";
    /** RGB compressed format, 4 bits per pixel. */ TextureFormat[TextureFormat["ETC1_RGB"] = 13] = "ETC1_RGB";
    /** RGB compressed format, 4 bits per pixel. */ TextureFormat[TextureFormat["ETC2_RGB"] = 14] = "ETC2_RGB";
    /** RGBA compressed format, 5 bits per pixel, 4 bit in RGB, 1 bit in A. */ TextureFormat[TextureFormat["ETC2_RGBA5"] = 15] = "ETC2_RGBA5";
    /** RGB compressed format, 8 bits per pixel. */ TextureFormat[TextureFormat["ETC2_RGBA8"] = 16] = "ETC2_RGBA8";
    /** RGB compressed format, 2 bits per pixel. */ TextureFormat[TextureFormat["PVRTC_RGB2"] = 17] = "PVRTC_RGB2";
    /** RGBA compressed format, 2 bits per pixel. */ TextureFormat[TextureFormat["PVRTC_RGBA2"] = 18] = "PVRTC_RGBA2";
    /** RGB compressed format, 4 bits per pixel. */ TextureFormat[TextureFormat["PVRTC_RGB4"] = 19] = "PVRTC_RGB4";
    /** RGBA compressed format, 4 bits per pixel. */ TextureFormat[TextureFormat["PVRTC_RGBA4"] = 20] = "PVRTC_RGBA4";
    /** RGB(A) compressed format, 128 bits per 4x4 pixel block. */ TextureFormat[TextureFormat["ASTC_4x4"] = 21] = "ASTC_4x4";
    /** RGB(A) compressed format, 128 bits per 5x5 pixel block. */ TextureFormat[TextureFormat["ASTC_5x5"] = 22] = "ASTC_5x5";
    /** RGB(A) compressed format, 128 bits per 6x6 pixel block. */ TextureFormat[TextureFormat["ASTC_6x6"] = 23] = "ASTC_6x6";
    /** RGB(A) compressed format, 128 bits per 8x8 pixel block. */ TextureFormat[TextureFormat["ASTC_8x8"] = 24] = "ASTC_8x8";
    /** RGB(A) compressed format, 128 bits per 10x10 pixel block. */ TextureFormat[TextureFormat["ASTC_10x10"] = 25] = "ASTC_10x10";
    /** RGB(A) compressed format, 128 bits per 12x12 pixel block. */ TextureFormat[TextureFormat["ASTC_12x12"] = 26] = "ASTC_12x12";
    /** Automatic depth format, engine will automatically select the supported precision. */ TextureFormat[TextureFormat["Depth"] = 27] = "Depth";
    /** Render to stencil buffer. */ TextureFormat[TextureFormat["Stencil"] = 28] = "Stencil";
    /** Automatic depth stencil format, engine will automatically select the supported precision. */ TextureFormat[TextureFormat["DepthStencil"] = 29] = "DepthStencil";
    /** 16-bit depth format. */ TextureFormat[TextureFormat["Depth16"] = 30] = "Depth16";
    /** 24-bit depth format. */ TextureFormat[TextureFormat["Depth24"] = 31] = "Depth24";
    /** 32-bit depth format. */ TextureFormat[TextureFormat["Depth32"] = 32] = "Depth32";
    /** 16-bit depth + 8-bit stencil format. */ TextureFormat[TextureFormat["Depth24Stencil8"] = 33] = "Depth24Stencil8";
    /** 32-bit depth + 8-bit stencil format. */ TextureFormat[TextureFormat["Depth32Stencil8"] = 34] = "Depth32Stencil8";
    /** @deprecated Use 'TextureFormat.R8' instead. */ TextureFormat[TextureFormat["Alpha8"] = 5] = "Alpha8";
    /** @deprecated Use 'TextureFormat.R8G8' instead. */ TextureFormat[TextureFormat["LuminanceAlpha"] = 6] = "LuminanceAlpha";
    /** @deprecated Use `TextureFormat.BC1` instead. */ TextureFormat[TextureFormat["DXT1"] = 10] = "DXT1";
    /** @deprecated Use `TextureFormat.BC3` instead. */ TextureFormat[TextureFormat["DXT5"] = 11] = "DXT5";
    return TextureFormat;
}({});

/**
 * Texture usage.
 */ var TextureUsage = /*#__PURE__*/ function(TextureUsage) {
    /** The content of the texture is intended to be specified once.  */ TextureUsage[TextureUsage["Static"] = 0] = "Static";
    /** The content of the texture is intended to be updated frequently, with better performance. */ TextureUsage[TextureUsage["Dynamic"] = 1] = "Dynamic";
    return TextureUsage;
}({});

/**
 * Wrapping mode of the texture.
 */ var TextureWrapMode$1 = /*#__PURE__*/ function(TextureWrapMode) {
    /** Clamping mode. use the color of edge pixels beyond the texture boundary. */ TextureWrapMode[TextureWrapMode["Clamp"] = 0] = "Clamp";
    /** Repeating mode. tiling will be repeated if it exceeds the texture boundary. */ TextureWrapMode[TextureWrapMode["Repeat"] = 1] = "Repeat";
    /** Mirror repeat mode. tiling will be mirrored and repeated if it exceeds the texture boundary. */ TextureWrapMode[TextureWrapMode["Mirror"] = 2] = "Mirror";
    return TextureWrapMode;
}({});

var GraphicsResource = /*#__PURE__*/ function(ReferResource) {
    _inherits$2(GraphicsResource, ReferResource);
    function GraphicsResource(engine) {
        var _this;
        _this = ReferResource.call(this, engine) || this, /** @internal */ _this._isContentLost = false;
        engine.resourceManager._addGraphicResource(_this);
        return _this;
    }
    var _proto = GraphicsResource.prototype;
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        ReferResource.prototype._onDestroy.call(this);
        this.engine.resourceManager._deleteGraphicResource(this);
    };
    _create_class$2(GraphicsResource, [
        {
            key: "isContentLost",
            get: /**
   * Whether the content of the resource is lost.
   */ function get() {
                return this._isContentLost;
            }
        }
    ]);
    return GraphicsResource;
}(ReferResource);

/**
 * @class
 * @private
 */ /* tslint:disable */ var noop = function(message) {
    for(var _len = arguments.length, optionalParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        optionalParams[_key - 1] = arguments[_key];
    }
};
var debug = console.log.bind(console);
var info = console.info.bind(console);
var warn = console.warn.bind(console);
var error = console.error.bind(console);
var Logger = {
    debug: noop,
    info: noop,
    warn: noop,
    error: noop,
    isEnabled: false,
    /** Turn on log */ enable: function enable() {
        this.debug = debug;
        this.info = info;
        this.warn = warn;
        this.error = error;
        this.isEnabled = true;
    },
    /** Turn off log */ disable: function disable() {
        this.debug = noop;
        this.info = noop;
        this.warn = noop;
        this.error = noop;
        this.isEnabled = false;
    }
};

/**
 * Data type enumeration
 */ var DataType = /*#__PURE__*/ function(DataType) {
    /** Float */ DataType[DataType["FLOAT"] = 5126] = "FLOAT";
    /** Floating-point two-dimensional vector */ DataType[DataType["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
    /** Floating-point three-dimensional vector */ DataType[DataType["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
    /** Floating-point four-dimensional vector */ DataType[DataType["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
    /** Integer */ DataType[DataType["INT"] = 5124] = "INT";
    /** Integer two-dimensional vector */ DataType[DataType["INT_VEC2"] = 35667] = "INT_VEC2";
    /** Integer three-dimensional vector */ DataType[DataType["INT_VEC3"] = 35668] = "INT_VEC3";
    /** Integer four-dimensional vector */ DataType[DataType["INT_VEC4"] = 35669] = "INT_VEC4";
    /** Boolean */ DataType[DataType["BOOL"] = 35670] = "BOOL";
    /** Boolean two-dimensional vector */ DataType[DataType["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
    /** Boolean three-dimensional vector */ DataType[DataType["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
    /** Boolean four-dimensional vector */ DataType[DataType["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
    /** Second-order matrix */ DataType[DataType["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
    /** Third-order matrix */ DataType[DataType["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
    /** Fourth-order matrix */ DataType[DataType["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
    /** Float array */ DataType[DataType["FLOAT_ARRAY"] = 35677] = "FLOAT_ARRAY";
    /** Floating-point two-dimensional vector array */ DataType[DataType["FLOAT_VEC2_ARRAY"] = 100000] = "FLOAT_VEC2_ARRAY";
    /** Floating-point three-dimensional vector array */ DataType[DataType["FLOAT_VEC3_ARRAY"] = 100001] = "FLOAT_VEC3_ARRAY";
    /** Floating-point four-dimensional vector array */ DataType[DataType["FLOAT_VEC4_ARRAY"] = 100002] = "FLOAT_VEC4_ARRAY";
    /** Integer array */ DataType[DataType["INT_ARRAY"] = 100003] = "INT_ARRAY";
    /** Integer two-dimensional vector array */ DataType[DataType["INT_VEC2_ARRAY"] = 100004] = "INT_VEC2_ARRAY";
    /** Integer three-dimensional vector array */ DataType[DataType["INT_VEC3_ARRAY"] = 100005] = "INT_VEC3_ARRAY";
    /** Integer four-dimensional vector array */ DataType[DataType["INT_VEC4_ARRAY"] = 100006] = "INT_VEC4_ARRAY";
    /** Second-order matrix array */ DataType[DataType["FLOAT_MAT2_ARRAY"] = 100007] = "FLOAT_MAT2_ARRAY";
    /** Third-order matrix array */ DataType[DataType["FLOAT_MAT3_ARRAY"] = 100008] = "FLOAT_MAT3_ARRAY";
    /** Fourth-order matrix array */ DataType[DataType["FLOAT_MAT4_ARRAY"] = 100009] = "FLOAT_MAT4_ARRAY";
    /** 2D texture sampler array */ DataType[DataType["SAMPLER_2D_ARRAY"] = 100010] = "SAMPLER_2D_ARRAY";
    /** Cube map texture sampler array */ DataType[DataType["SAMPLER_CUBE_ARRAY"] = 100011] = "SAMPLER_CUBE_ARRAY";
    /** 2D sampler */ DataType[DataType["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
    /** Cube map Texture sampler */ DataType[DataType["SAMPLER_CUBE"] = 35680] = "SAMPLER_CUBE";
    /** Byte */ DataType[DataType["BYTE"] = 5120] = "BYTE";
    /** Unsigned byte */ DataType[DataType["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
    /** Short */ DataType[DataType["SHORT"] = 5122] = "SHORT";
    /** Unsigned short */ DataType[DataType["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
    /** Unsigned int */ DataType[DataType["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT"; // gl.UNSIGNED_INT
    return DataType;
}({});
/**
 * GL Capabilities
 * Some capabilities can be smoothed out by extension, and some capabilities must use WebGL 2.0.
 * */ var GLCapabilityType = /*#__PURE__*/ function(GLCapabilityType) {
    GLCapabilityType["shaderVertexID"] = "shaderVertexID";
    GLCapabilityType["standardDerivatives"] = "OES_standard_derivatives";
    GLCapabilityType["shaderTextureLod"] = "EXT_shader_texture_lod";
    GLCapabilityType["elementIndexUint"] = "OES_element_index_uint";
    GLCapabilityType["depthTexture"] = "WEBGL_depth_texture";
    GLCapabilityType["drawBuffers"] = "WEBGL_draw_buffers";
    GLCapabilityType["vertexArrayObject"] = "OES_vertex_array_object";
    GLCapabilityType["instancedArrays"] = "ANGLE_instanced_arrays";
    GLCapabilityType["multipleSample"] = "multipleSampleOnlySupportedInWebGL2";
    GLCapabilityType["textureFloat"] = "OES_texture_float";
    GLCapabilityType["textureFloatLinear"] = "OES_texture_float_linear";
    GLCapabilityType["textureHalfFloat"] = "OES_texture_half_float";
    GLCapabilityType["textureHalfFloatLinear"] = "OES_texture_half_float_linear";
    GLCapabilityType["WEBGL_colorBufferFloat"] = "WEBGL_color_buffer_float";
    GLCapabilityType["colorBufferFloat"] = "EXT_color_buffer_float";
    GLCapabilityType["colorBufferHalfFloat"] = "EXT_color_buffer_half_float";
    GLCapabilityType["textureFilterAnisotropic"] = "EXT_texture_filter_anisotropic";
    GLCapabilityType["blendMinMax"] = "EXT_blend_minmax";
    GLCapabilityType["fragDepth"] = "EXT_frag_depth";
    GLCapabilityType["astc"] = "WEBGL_compressed_texture_astc";
    GLCapabilityType["astc_webkit"] = "WEBKIT_WEBGL_compressed_texture_astc";
    GLCapabilityType["etc"] = "WEBGL_compressed_texture_etc";
    GLCapabilityType["etc_webkit"] = "WEBKIT_WEBGL_compressed_texture_etc";
    GLCapabilityType["etc1"] = "WEBGL_compressed_texture_etc1";
    GLCapabilityType["etc1_webkit"] = "WEBKIT_WEBGL_compressed_texture_etc1";
    GLCapabilityType["pvrtc"] = "WEBGL_compressed_texture_pvrtc";
    GLCapabilityType["pvrtc_webkit"] = "WEBKIT_WEBGL_compressed_texture_pvrtc";
    GLCapabilityType["s3tc"] = "WEBGL_compressed_texture_s3tc";
    GLCapabilityType["s3tc_webkit"] = "WEBKIT_WEBGL_compressed_texture_s3tc";
    GLCapabilityType["s3tc_srgb"] = "WEBGL_compressed_texture_s3tc_srgb";
    GLCapabilityType["bptc"] = "EXT_texture_compression_bptc";
    GLCapabilityType["WEBGL_lose_context"] = "WEBGL_lose_context";
    GLCapabilityType["sRGB"] = "EXT_sRGB";
    return GLCapabilityType;
}({});

var AssetPromise = /*#__PURE__*/ function() {
    function AssetPromise(executor) {
        var _this = this;
        this._state = "pending";
        this._onTaskCompleteCallbacks = [];
        this._onTaskDetailCallbacks = [];
        this._promise = new Promise(function(resolve, reject) {
            _this._reject = reject;
            var onResolve = function(value) {
                if (_this._state === "pending") {
                    resolve(value);
                    _this._state = "fulfilled";
                    _this._onTaskCompleteCallbacks = undefined;
                    _this._onTaskDetailCallbacks = undefined;
                }
            };
            var onReject = function(reason) {
                if (_this._state === "pending") {
                    reject(reason);
                    _this._state = "rejected";
                    _this._onTaskCompleteCallbacks = undefined;
                    _this._onTaskDetailCallbacks = undefined;
                }
            };
            var onCancel = function(callback) {
                if (_this._state === "pending") {
                    _this._onCancelHandler = callback;
                }
            };
            var setTaskCompleteProgress = function(loaded, total) {
                if (_this._state === "pending") {
                    var progress = _this._taskCompleteProgress || (_this._taskCompleteProgress = {
                        loaded: loaded,
                        total: total
                    });
                    progress.loaded = loaded;
                    progress.total = total;
                    _this._onTaskCompleteCallbacks.forEach(function(callback) {
                        return callback(loaded, total);
                    });
                }
            };
            var setTaskDetailProgress = function(url, loaded, total) {
                if (_this._state === "pending") {
                    var _this__taskDetailProgress, _url;
                    _this._taskDetailProgress || (_this._taskDetailProgress = {});
                    var progress = (_this__taskDetailProgress = _this._taskDetailProgress)[_url = url] || (_this__taskDetailProgress[_url] = {
                        loaded: loaded,
                        total: total
                    });
                    progress.loaded = loaded;
                    progress.total = total;
                    _this._onTaskDetailCallbacks.forEach(function(callback) {
                        return callback(url, loaded, total);
                    });
                }
            };
            executor(onResolve, onReject, setTaskCompleteProgress, setTaskDetailProgress, onCancel);
        });
    }
    var _proto = AssetPromise.prototype;
    /**
   * Progress callback.
   * @param onTaskComplete - This callback function provides information about the overall progress of the task. For example, in batch processing tasks, you can use the loaded and total parameters to calculate the percentage of task completion or display a progress bar
   * @param onTaskDetail - This callback function provides detailed progress information about the task. For instance, in file downloading scenarios, you can use the loaded and total parameters to calculate the download progress percentage and utilize the url parameter to provide additional details such as download speed and estimated remaining time
   * @returns AssetPromise
   */ _proto.onProgress = function onProgress(onTaskComplete, onTaskDetail) {
        var completeProgress = this._taskCompleteProgress;
        var detailProgress = this._taskDetailProgress;
        if (completeProgress) {
            onTaskComplete(completeProgress.loaded, completeProgress.total);
        }
        if (detailProgress) {
            for(var url in detailProgress){
                var _detailProgress_url = detailProgress[url], loaded = _detailProgress_url.loaded, total = _detailProgress_url.total;
                onTaskDetail(url, loaded, total);
            }
        }
        if (this._state === "pending") {
            onTaskComplete && this._onTaskCompleteCallbacks.push(onTaskComplete);
            onTaskDetail && this._onTaskDetailCallbacks.push(onTaskDetail);
        }
        return this;
    };
    _proto.then = function then(onfulfilled, onrejected) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            _this._promise.then(onfulfilled, onrejected).then(resolve).catch(reject);
        });
    };
    /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onRejected - The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */ _proto.catch = function _catch(onRejected) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            _this._promise.catch(onRejected).then(resolve).catch(reject);
        });
    };
    /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */ _proto.finally = function _finally(onFinally) {
        return this._promise.finally(onFinally);
    };
    /**
   * Cancel promise request.
   * @returns Asset promise
   */ _proto.cancel = function cancel() {
        if (this._state !== "pending") {
            return;
        }
        this._state = "canceled";
        this._reject("canceled");
        this._onCancelHandler && this._onCancelHandler();
        return this;
    };
    AssetPromise.resolve = function resolve(value) {
        if (value === undefined) {
            return new AssetPromise(function(resolve) {
                return resolve();
            });
        } else if (_instanceof$3(value, AssetPromise) || _instanceof$3(value, Promise)) {
            return new AssetPromise(function(resolve, reject) {
                value.then(function(resolved) {
                    return resolve(resolved);
                }, reject);
            });
        } else {
            return new AssetPromise(function(resolve) {
                return resolve(value);
            });
        }
    };
    AssetPromise.all = function all(values) {
        return new AssetPromise(function(resolve, reject, setTaskCompleteProgress) {
            var onComplete = function onComplete(index, resultValue) {
                completed++;
                results[index] = resultValue;
                setTaskCompleteProgress(completed, count);
                if (completed === count) {
                    resolve(results);
                }
            };
            var onProgress = function onProgress(promise, index) {
                if (_instanceof$3(promise, AssetPromise) || _instanceof$3(promise, Promise)) {
                    promise.then(function(value) {
                        onComplete(index, value);
                    }, reject);
                } else {
                    Promise.resolve().then(function() {
                        onComplete(index, promise);
                    });
                }
            };
            var count = Array.from(values).length;
            var results = new Array(count);
            var completed = 0;
            if (count === 0) {
                return resolve(results);
            }
            for(var i = 0; i < count; i++){
                onProgress(values[i], i);
            }
        });
    };
    _create_class$2(AssetPromise, [
        {
            key: Symbol.toStringTag,
            get: /** compatible with Promise */ function get() {
                return "AssetPromise";
            }
        }
    ]);
    return AssetPromise;
}();

/**
 * Access operating system, platform and hardware information.
 */ var SystemInfo = /*#__PURE__*/ function() {
    function SystemInfo() {}
    /**
   * @internal
   */ SystemInfo._initialize = function _initialize() {
        {
            if (typeof navigator == "undefined") {
                SystemInfo._isBrowser = false;
                return;
            }
            var userAgent = navigator.userAgent;
            if (/iPhone/i.test(userAgent)) {
                SystemInfo.platform = Platform.IPhone;
            } else if (/iPad/i.test(userAgent)) {
                SystemInfo.platform = Platform.IPad;
            } else if (/Android/i.test(userAgent)) {
                SystemInfo.platform = Platform.Android;
            } else if (/Macintosh/i.test(userAgent)) {
                SystemInfo.platform = Platform.Mac;
            }
            var v;
            switch(SystemInfo.platform){
                case Platform.IPhone:
                    v = userAgent.match(/OS (\d+)_?(\d+)?_?(\d+)?/);
                    this.operatingSystem = v ? "iPhone OS " + v[1] + "." + (v[2] || 0) + "." + (v[3] || 0) : "iPhone OS";
                    break;
                case Platform.IPad:
                    v = userAgent.match(/OS (\d+)_?(\d+)?_?(\d+)?/);
                    this.operatingSystem = v ? "iPad OS " + v[1] + "." + (v[2] || 0) + "." + (v[3] || 0) : "iPad OS";
                    break;
                case Platform.Android:
                    v = userAgent.match(/Android (\d+).?(\d+)?.?(\d+)?/);
                    this.operatingSystem = v ? "Android " + v[1] + "." + (v[2] || 0) + "." + (v[3] || 0) : "Android";
                    break;
                case Platform.Mac:
                    v = userAgent.match(/Mac OS X (\d+)_?(\d+)?_?(\d+)?/);
                    this.operatingSystem = v ? "Mac OS X " + v[1] + "." + (v[2] || 0) + "." + (v[3] || 0) : "Mac OS X";
                    break;
            }
        }
    };
    /**
   * @internal
   */ SystemInfo._detectSIMDSupported = function _detectSIMDSupported() {
        if (this._simdSupported === null) {
            this._simdSupported = WebAssembly.validate(new Uint8Array([
                0,
                97,
                115,
                109,
                1,
                0,
                0,
                0,
                1,
                4,
                1,
                96,
                0,
                0,
                3,
                3,
                2,
                0,
                0,
                5,
                3,
                1,
                0,
                1,
                12,
                1,
                0,
                10,
                22,
                2,
                12,
                0,
                65,
                0,
                65,
                0,
                65,
                0,
                252,
                10,
                0,
                0,
                11,
                7,
                0,
                65,
                0,
                253,
                15,
                26,
                11
            ]));
        }
        return this._simdSupported;
    };
    SystemInfo._checkWebpSupported = function _checkWebpSupported() {
        var _this = this;
        if (!this._webpSupported) {
            this._webpSupported = new AssetPromise(function(resolve) {
                if (_this._isBrowser) {
                    var img = new Image();
                    img.onload = function() {
                        var result = img.width > 0 && img.height > 0;
                        resolve(result);
                    };
                    img.onerror = function() {
                        resolve(false);
                    };
                    img.src = "data:image/webp;base64,UklGRhACAABXRUJQVlA4WAoAAAAwAAAAAAAAAAAASUNDUMgBAAAAAAHIAAAAAAQwAABtbnRyUkdCIFhZWiAH4AABAAEAAAAAAABhY3NwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAA9tYAAQAAAADTLQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlkZXNjAAAA8AAAACRyWFlaAAABFAAAABRnWFlaAAABKAAAABRiWFlaAAABPAAAABR3dHB0AAABUAAAABRyVFJDAAABZAAAAChnVFJDAAABZAAAAChiVFJDAAABZAAAAChjcHJ0AAABjAAAADxtbHVjAAAAAAAAAAEAAAAMZW5VUwAAAAgAAAAcAHMAUgBHAEJYWVogAAAAAAAAb6IAADj1AAADkFhZWiAAAAAAAABimQAAt4UAABjaWFlaIAAAAAAAACSgAAAPhAAAts9YWVogAAAAAAAA9tYAAQAAAADTLXBhcmEAAAAAAAQAAAACZmYAAPKnAAANWQAAE9AAAApbAAAAAAAAAABtbHVjAAAAAAAAAAEAAAAMZW5VUwAAACAAAAAcAEcAbwBvAGcAbABlACAASQBuAGMALgAgADIAMAAxADZBTFBIAgAAAAAAVlA4IBgAAAAwAQCdASoBAAEAAUAmJaQAA3AA/v02aAA=";
                } else {
                    resolve(false);
                }
            });
        }
        return this._webpSupported;
    };
    /**
   * Checks whether the system supports the given texture format.
   * @param format - The texture format
   * @returns Whether support the texture format
   */ SystemInfo.supportsTextureFormat = function supportsTextureFormat(engine, format) {
        var rhi = engine._hardwareRenderer;
        rhi.canIUse(GLCapabilityType.depthTexture);
        switch(format){
            case TextureFormat.R16G16B16A16:
                if (!rhi.canIUse(GLCapabilityType.textureHalfFloat)) {
                    return false;
                }
                break;
            case TextureFormat.R32G32B32A32:
                if (!rhi.canIUse(GLCapabilityType.textureFloat)) {
                    return false;
                }
                break;
            case TextureFormat.Depth16:
            case TextureFormat.Depth24Stencil8:
            case TextureFormat.Depth:
            case TextureFormat.DepthStencil:
                if (!rhi.canIUse(GLCapabilityType.depthTexture)) {
                    return false;
                }
                break;
            case TextureFormat.R11G11B10_UFloat:
            case TextureFormat.R32G32B32A32_UInt:
            case TextureFormat.Depth24:
            case TextureFormat.Depth32:
            case TextureFormat.Depth32Stencil8:
            case TextureFormat.R8:
            case TextureFormat.R8G8:
                return rhi.isWebGL2;
        }
        return true;
    };
    _create_class$2(SystemInfo, null, [
        {
            key: "devicePixelRatio",
            get: /**
   * The pixel ratio of the device.
   */ function get() {
                return window.devicePixelRatio;
            }
        }
    ]);
    return SystemInfo;
}();
/** The platform is running on. */ SystemInfo.platform = Platform.Unknown;
/** The operating system is running on. */ SystemInfo.operatingSystem = "";
/** @internal */ SystemInfo._isBrowser = true;
/** Whether the system support SIMD. */ SystemInfo._simdSupported = null;
SystemInfo._webpSupported = null;
SystemInfo._initialize();

/**
 * The base class of texture, contains some common functions of texture-related classes.
 */ var Texture = /*#__PURE__*/ function(GraphicsResource) {
    _inherits$2(Texture, GraphicsResource);
    function Texture(engine, width, height, format, mipmap, isSRGBColorSpace) {
        var _this;
        if (!SystemInfo.supportsTextureFormat(engine, format)) {
            throw new Error("Texture format is not supported:" + TextureFormat[format]);
        }
        _this = GraphicsResource.call(this, engine) || this, /** @internal */ _this._isDepthTexture = false, _this._anisoLevel = 1, _this._useDepthCompareMode = false;
        _this._width = width;
        _this._height = height;
        _this._format = format;
        _this._mipmap = mipmap;
        _this._isSRGBColorSpace = isSRGBColorSpace;
        _this._mipmapCount = _this._getMipmapCount();
        return _this;
    }
    var _proto = Texture.prototype;
    /**
   * Generate multi-level textures based on the 0th level data.
   */ _proto.generateMipmaps = function generateMipmaps() {
        if (!this._mipmap) return;
        this._platformTexture.generateMipmaps();
    };
    /**
   * @internal
   */ _proto._setUseDepthCompareMode = function _setUseDepthCompareMode(value) {
        if (this._useDepthCompareMode !== value) {
            this._platformTexture.setUseDepthCompareMode(value);
            this._useDepthCompareMode = value;
        }
    };
    /**
   * @internal
   */ _proto._rebuild = function _rebuild() {
        var platformTexture = this._platformTexture;
        platformTexture.wrapModeU = this._wrapModeU;
        platformTexture.wrapModeV = this._wrapModeV;
        platformTexture.filterMode = this._filterMode;
        platformTexture.anisoLevel = this._anisoLevel;
        if (this._engine._hardwareRenderer._isWebGL2) {
            platformTexture.depthCompareFunction = this._depthCompareFunction;
            platformTexture.setUseDepthCompareMode(this._useDepthCompareMode);
        }
    };
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        GraphicsResource.prototype._onDestroy.call(this);
        this._platformTexture.destroy();
        this._platformTexture = null;
    };
    /**
   * Get the maximum mip level of the corresponding size:rounding down.
   * @remarks http://download.nvidia.com/developer/Papers/2005/NP2_Mipmapping/NP2_Mipmap_Creation.pdf
   */ _proto._getMaxMiplevel = function _getMaxMiplevel(size) {
        return Math.floor(Math.log2(size));
    };
    _proto._getMipmapCount = function _getMipmapCount() {
        return this._mipmap ? Math.floor(Math.log2(Math.max(this._width, this._height))) + 1 : 1;
    };
    _proto._isIntFormat = function _isIntFormat() {
        if (TextureFormat.R32G32B32A32_UInt === this._format) {
            return true;
        }
        return false;
    };
    _create_class$2(Texture, [
        {
            key: "isSRGBColorSpace",
            get: /**
   * Whether the texture data is in sRGB color space, otherwise is linear color space.
   */ function get() {
                return this._isSRGBColorSpace;
            }
        },
        {
            key: "format",
            get: /**
   * Texture format.
   */ function get() {
                return this._format;
            }
        },
        {
            key: "width",
            get: /**
   * The width of the texture.
   */ function get() {
                return this._width;
            }
        },
        {
            key: "height",
            get: /**
   * The height of the texture.
   */ function get() {
                return this._height;
            }
        },
        {
            key: "usage",
            get: /**
   * The usage of the texture.
   */ function get() {
                return this._usage;
            }
        },
        {
            key: "wrapModeU",
            get: /**
   * Wrapping mode for texture coordinate S.
   */ function get() {
                return this._wrapModeU;
            },
            set: function set(value) {
                if (value === this._wrapModeU) return;
                this._wrapModeU = value;
                this._platformTexture.wrapModeU = value;
            }
        },
        {
            key: "wrapModeV",
            get: /**
   * Wrapping mode for texture coordinate T.
   */ function get() {
                return this._wrapModeV;
            },
            set: function set(value) {
                if (value === this._wrapModeV) return;
                this._wrapModeV = value;
                this._platformTexture.wrapModeV = value;
            }
        },
        {
            key: "mipmapCount",
            get: /**
   * Texture mipmapping count.
   */ function get() {
                return this._mipmapCount;
            }
        },
        {
            key: "filterMode",
            get: /**
   * Filter mode for texture.
   */ function get() {
                return this._filterMode;
            },
            set: function set(value) {
                if (value === this._filterMode) return;
                if (value !== TextureFilterMode.Point && this._isIntFormat()) {
                    value = TextureFilterMode.Point;
                    Logger.warn("Int or UInt format texture only support TextureFilterMode.Point");
                    return;
                }
                this._filterMode = value;
                this._platformTexture.filterMode = value;
            }
        },
        {
            key: "anisoLevel",
            get: /**
   * Anisotropic level for texture.
   */ function get() {
                return this._anisoLevel;
            },
            set: function set(value) {
                var max = this._engine._hardwareRenderer.capability.maxAnisoLevel;
                if (value > max) {
                    Logger.warn("anisoLevel:" + value + ", exceeds the limit and is automatically downgraded to:" + max);
                    value = max;
                }
                if (value < 1) {
                    Logger.warn("anisoLevel:" + value + ", must be greater than 0, and is automatically downgraded to 1");
                    value = 1;
                }
                if (value === this._anisoLevel) return;
                this._anisoLevel = value;
                this._platformTexture.anisoLevel = value;
            }
        },
        {
            key: "depthCompareFunction",
            get: /**
   * Filter mode when texture as depth Texture.
   * @remarks Only depth-related formats take effect.
   */ function get() {
                return this._depthCompareFunction;
            },
            set: function set(value) {
                if (!this._engine._hardwareRenderer._isWebGL2) {
                    console.warn("depthCompareFunction only support WebGL2");
                    return;
                }
                if (value !== this._depthCompareFunction) {
                    this._depthCompareFunction = value;
                    this._platformTexture.depthCompareFunction = value;
                }
            }
        }
    ]);
    return Texture;
}(GraphicsResource);

/**
 * The render target used for off-screen rendering.
 */ var RenderTarget = /*#__PURE__*/ function(GraphicsResource) {
    _inherits$2(RenderTarget, GraphicsResource);
    function RenderTarget(engine, width, height, renderTexture, depth, antiAliasing) {
        if (depth === void 0) depth = TextureFormat.Depth;
        if (antiAliasing === void 0) antiAliasing = 1;
        var _this;
        _this = GraphicsResource.call(this, engine) || this, /** @internal */ _this._depthFormat = null, _this._autoGenerateMipmaps = true, _this._depthTexture = null;
        _this._width = width;
        _this._height = height;
        _this._antiAliasing = antiAliasing;
        _this._depth = depth;
        if (renderTexture) {
            var colorTextures = _instanceof$3(renderTexture, Array) ? renderTexture.slice() : [
                renderTexture
            ];
            for(var i = 0, n = colorTextures.length; i < n; i++){
                var colorTexture = colorTextures[i];
                if (colorTexture._isDepthTexture) {
                    throw "Render texture can't use depth format.";
                }
                colorTexture._addReferCount(1);
            }
            _this._colorTextures = colorTextures;
        } else {
            _this._colorTextures = [];
        }
        if (_instanceof$3(depth, Texture)) {
            if (!depth._isDepthTexture) {
                throw "Depth texture must use depth format.";
            }
            _this._depthTexture = depth;
            _this._depthTexture._addReferCount(1);
            _this._depthFormat = depth.format;
        } else if (typeof depth === "number") {
            _this._depthFormat = depth;
        }
        _this._platformRenderTarget = engine._hardwareRenderer.createPlatformRenderTarget(_this);
        return _this;
    }
    var _proto = RenderTarget.prototype;
    /**
   * Get the render color texture by index.
   * @param index - Render color texture index
   */ _proto.getColorTexture = function getColorTexture(index) {
        if (index === void 0) index = 0;
        var _this__colorTextures_index;
        return (_this__colorTextures_index = this._colorTextures[index]) != null ? _this__colorTextures_index : null;
    };
    /**
   * Generate the mipmap of each attachment texture of the renderTarget according to the configuration.
   */ _proto.generateMipmaps = function generateMipmaps() {
        if (this._autoGenerateMipmaps) {
            var colorTextures = this._colorTextures;
            for(var i = 0, n = colorTextures.length; i < n; i++){
                var colorTexture = colorTextures[i];
                colorTexture.generateMipmaps();
            }
            this._depthTexture && this._depthTexture.generateMipmaps();
        }
    };
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        var _this__depthTexture;
        GraphicsResource.prototype._onDestroy.call(this);
        this._platformRenderTarget.destroy();
        var _this = this, colorTextures = _this._colorTextures;
        for(var i = 0, n = colorTextures.length; i < n; i++){
            colorTextures[i]._addReferCount(-1);
        }
        colorTextures.length = 0;
        (_this__depthTexture = this._depthTexture) == null ? void 0 : _this__depthTexture._addReferCount(-1);
        this._depthTexture = null;
        this._depth = null;
    };
    /**
   * @internal
   */ _proto._blitRenderTarget = function _blitRenderTarget() {
        this._platformRenderTarget.blitRenderTarget();
    };
    /**
   * @internal
   */ _proto._rebuild = function _rebuild() {
        this._platformRenderTarget = this._engine._hardwareRenderer.createPlatformRenderTarget(this);
    };
    _create_class$2(RenderTarget, [
        {
            key: "autoGenerateMipmaps",
            get: /**
   * Whether to automatically generate multi-level textures.
   */ function get() {
                return this._autoGenerateMipmaps;
            },
            set: function set(value) {
                this._autoGenerateMipmaps = value;
            }
        },
        {
            key: "width",
            get: /**
   * Render target width.
   */ function get() {
                return this._width;
            }
        },
        {
            key: "height",
            get: /**
   * Render target height.
   */ function get() {
                return this._height;
            }
        },
        {
            key: "colorTextureCount",
            get: /**
   * Render color texture count.
   */ function get() {
                return this._colorTextures.length;
            }
        },
        {
            key: "depthTexture",
            get: /**
   * Depth texture.
   */ function get() {
                return this._depthTexture;
            }
        },
        {
            key: "antiAliasing",
            get: /**
   * Anti-aliasing level.
   * @remarks If the anti-aliasing level set is greater than the maximum level supported by the hardware, the maximum level of the hardware will be used.
   */ function get() {
                return this._antiAliasing;
            }
        }
    ]);
    return RenderTarget;
}(GraphicsResource);

/**
 * Two-dimensional texture.
 */ var Texture2D = /*#__PURE__*/ function(Texture) {
    _inherits$2(Texture2D, Texture);
    function Texture2D(engine, width, height, format, mipmap, isSRGBColorSpace, usage) {
        if (format === void 0) format = TextureFormat.R8G8B8A8;
        if (mipmap === void 0) mipmap = true;
        if (isSRGBColorSpace === void 0) isSRGBColorSpace = true;
        if (usage === void 0) usage = TextureUsage.Static;
        var _this;
        _this = Texture.call(this, engine, width, height, format, mipmap, isSRGBColorSpace) || this;
        _this._usage = usage;
        _this._isDepthTexture = format >= TextureFormat.Depth && format <= TextureFormat.Depth32Stencil8;
        _this._platformTexture = engine._hardwareRenderer.createPlatformTexture2D(_this);
        _this.filterMode = _this._isIntFormat() ? TextureFilterMode.Point : TextureFilterMode.Bilinear;
        _this.wrapModeU = _this.wrapModeV = TextureWrapMode$1.Repeat;
        return _this;
    }
    var _proto = Texture2D.prototype;
    /**
   * Setting pixels data through color buffer data, designated area and texture mipmapping level,it's also applicable to compressed formats.
   * @remarks If it is the WebGL1.0 platform and the texture format is compressed, the first upload must be filled with textures.
   * @param colorBuffer - Color buffer data
   * @param mipLevel - Texture mipmapping level
   * @param x - X coordinate of area start
   * @param y - Y coordinate of area start
   * @param width - Data width. if it's empty, width is the width corresponding to mipLevel minus x , width corresponding to mipLevel is Math.max(1, this.width >> mipLevel)
   * @param height - Data height. if it's empty, height is the height corresponding to mipLevel minus y , height corresponding to mipLevel is Math.max(1, this.height >> mipLevel)
   */ _proto.setPixelBuffer = function setPixelBuffer(colorBuffer, mipLevel, x, y, width, height) {
        if (mipLevel === void 0) mipLevel = 0;
        if (x === void 0) x = 0;
        if (y === void 0) y = 0;
        this._platformTexture.setPixelBuffer(colorBuffer, mipLevel, x, y, width, height);
        this._isContentLost = false;
    };
    /**
   * Setting pixels data through TexImageSource, designated area and texture mipmapping level.
   * @param imageSource - The source of texture
   * @param mipLevel - Texture mipmapping level
   * @param flipY - Whether to flip the Y axis
   * @param premultiplyAlpha - Whether to premultiply the transparent channel
   * @param x - X coordinate of area start
   * @param y - Y coordinate of area start
   */ _proto.setImageSource = function setImageSource(imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
        if (mipLevel === void 0) mipLevel = 0;
        if (flipY === void 0) flipY = false;
        if (premultiplyAlpha === void 0) premultiplyAlpha = false;
        if (x === void 0) x = 0;
        if (y === void 0) y = 0;
        this._platformTexture.setImageSource(imageSource, mipLevel, flipY, premultiplyAlpha, x, y);
        this._isContentLost = false;
    };
    _proto.getPixelBuffer = function getPixelBuffer(xOrMipLevelOrOut, yOrMipLevel, width, height, mipLevelOrOut, out) {
        var argsLength = arguments.length;
        if (argsLength === 1) {
            this._platformTexture.getPixelBuffer(0, 0, this._width, this._height, 0, xOrMipLevelOrOut);
        } else if (argsLength === 2) {
            this._platformTexture.getPixelBuffer(0, 0, this._width >> xOrMipLevelOrOut, this._height >> xOrMipLevelOrOut, xOrMipLevelOrOut, yOrMipLevel);
        } else if (argsLength === 5) {
            this._platformTexture.getPixelBuffer(xOrMipLevelOrOut, yOrMipLevel, width, height, 0, mipLevelOrOut);
        } else if (argsLength === 6) {
            this._platformTexture.getPixelBuffer(xOrMipLevelOrOut, yOrMipLevel, width, height, mipLevelOrOut, out);
        }
    };
    /**
   * @internal
   */ _proto._rebuild = function _rebuild() {
        this._platformTexture = this._engine._hardwareRenderer.createPlatformTexture2D(this);
        Texture.prototype._rebuild.call(this);
    };
    return Texture2D;
}(Texture);

/**
 * Two-dimensional texture array.
 */ var Texture2DArray = /*#__PURE__*/ function(Texture) {
    _inherits$2(Texture2DArray, Texture);
    function Texture2DArray(engine, width, height, length, format, mipmap, isSRGBColorSpace) {
        if (format === void 0) format = TextureFormat.R8G8B8A8;
        if (mipmap === void 0) mipmap = true;
        if (isSRGBColorSpace === void 0) isSRGBColorSpace = true;
        var _this;
        if (!engine._hardwareRenderer.isWebGL2) {
            throw new Error("Texture2D Array is not supported in WebGL1.0");
        }
        _this = Texture.call(this, engine, width, height, format, mipmap, isSRGBColorSpace) || this;
        _this._length = length;
        _this._platformTexture = engine._hardwareRenderer.createPlatformTexture2DArray(_this);
        _this.filterMode = TextureFilterMode.Bilinear;
        _this.wrapModeU = _this.wrapModeV = TextureWrapMode$1.Repeat;
        return _this;
    }
    var _proto = Texture2DArray.prototype;
    /**
   * Setting pixels data through color buffer data, designated area and texture mipmapping level,it's also applicable to compressed formats.
   * @remarks If it is the WebGL1.0 platform and the texture format is compressed, the first upload must be filled with textures.
   * @param offsetIndex - The texture array element offset index
   * @param colorBuffer - Color buffer data
   * @param mipLevel - Texture mipmapping level
   * @param x - X coordinate of area start
   * @param y - Y coordinate of area start
   * @param width - Data width. if it's empty, width is the width corresponding to mipLevel minus x , width corresponding to mipLevel is Math.max(1, this.width >> mipLevel)
   * @param height - Data height. if it's empty, height is the height corresponding to mipLevel minus y , height corresponding to mipLevel is Math.max(1, this.height >> mipLevel)
   * @param length - Data length. if it's empty, length is the length of Texture2DArray.length
   */ _proto.setPixelBuffer = function setPixelBuffer(offsetIndex, colorBuffer, mipLevel, x, y, width, height, length) {
        if (mipLevel === void 0) mipLevel = 0;
        if (x === void 0) x = 0;
        if (y === void 0) y = 0;
        this._platformTexture.setPixelBuffer(offsetIndex, colorBuffer, mipLevel, x, y, width, height, length);
        this._isContentLost = false;
    };
    /**
   * Setting pixels data through TexImageSource, designated area and texture mipmapping level.
   * @param elementIndex - The texture array element index
   * @param imageSource - The source of texture
   * @param mipLevel - Texture mipmapping level
   * @param flipY - Whether to flip the Y axis
   * @param premultiplyAlpha - Whether to premultiply the transparent channel
   * @param x - X coordinate of area start
   * @param y - Y coordinate of area start
   */ _proto.setImageSource = function setImageSource(elementIndex, imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
        if (mipLevel === void 0) mipLevel = 0;
        if (flipY === void 0) flipY = false;
        if (premultiplyAlpha === void 0) premultiplyAlpha = false;
        if (x === void 0) x = 0;
        if (y === void 0) y = 0;
        this._platformTexture.setImageSource(elementIndex, imageSource, mipLevel, flipY, premultiplyAlpha, x, y);
        this._isContentLost = false;
    };
    _proto.getPixelBuffer = function getPixelBuffer(elementIndex, xOrMipLevelOrOut, yOrMipLevel, width, height, mipLevelOrOut, out) {
        var argsLength = arguments.length;
        if (argsLength === 1) {
            this._platformTexture.getPixelBuffer(elementIndex, 0, 0, this._width, this._height, 0, xOrMipLevelOrOut);
        } else if (argsLength === 2) {
            this._platformTexture.getPixelBuffer(elementIndex, 0, 0, this._width >> xOrMipLevelOrOut, this._height >> xOrMipLevelOrOut, xOrMipLevelOrOut, yOrMipLevel);
        } else if (argsLength === 5) {
            this._platformTexture.getPixelBuffer(elementIndex, xOrMipLevelOrOut, yOrMipLevel, width, height, 0, mipLevelOrOut);
        } else if (argsLength === 6) {
            this._platformTexture.getPixelBuffer(elementIndex, xOrMipLevelOrOut, yOrMipLevel, width, height, mipLevelOrOut, out);
        }
    };
    /**
   * @internal
   */ _proto._rebuild = function _rebuild() {
        this._platformTexture = this._engine._hardwareRenderer.createPlatformTexture2DArray(this);
        Texture.prototype._rebuild.call(this);
    };
    _create_class$2(Texture2DArray, [
        {
            key: "length",
            get: /**
   * The length of the texture.
   */ function get() {
                return this._length;
            }
        }
    ]);
    return Texture2DArray;
}(Texture);

/**
 * Cube texture.
 */ var TextureCube = /*#__PURE__*/ function(Texture) {
    _inherits$2(TextureCube, Texture);
    function TextureCube(engine, size, format, mipmap, isSRGBColorSpace) {
        if (format === void 0) format = TextureFormat.R8G8B8A8;
        if (mipmap === void 0) mipmap = true;
        if (isSRGBColorSpace === void 0) isSRGBColorSpace = true;
        var _this;
        _this = Texture.call(this, engine, size, size, format, mipmap, isSRGBColorSpace) || this;
        _this._platformTexture = engine._hardwareRenderer.createPlatformTextureCube(_this);
        _this.filterMode = TextureFilterMode.Bilinear;
        _this.wrapModeU = _this.wrapModeV = TextureWrapMode$1.Clamp;
        return _this;
    }
    var _proto = TextureCube.prototype;
    /**
   * Setting pixels data through cube face,color buffer data, designated area and texture mipmapping level,it's also applicable to compressed formats.
   * @remarks When compressed texture is in WebGL1, the texture must be filled first before writing the sub-region
   * @param face - Cube face
   * @param colorBuffer - Color buffer data
   * @param mipLevel - Texture mipmapping level
   * @param x - X coordinate of area start
   * @param y -  Y coordinate of area start
   * @param width - Data width.if it's empty, width is the width corresponding to mipLevel minus x , width corresponding to mipLevel is Math.max(1, this.width >> mipLevel)
   * @param height - Data height.if it's empty, height is the height corresponding to mipLevel minus y , height corresponding to mipLevel is Math.max(1, this.height >> mipLevel)
   */ _proto.setPixelBuffer = function setPixelBuffer(face, colorBuffer, mipLevel, x, y, width, height) {
        if (mipLevel === void 0) mipLevel = 0;
        if (x === void 0) x = 0;
        if (y === void 0) y = 0;
        this._platformTexture.setPixelBuffer(face, colorBuffer, mipLevel, x, y, width, height);
        this._isContentLost = false;
    };
    /**
   * Setting pixels data through cube face, TexImageSource, designated area and texture mipmapping level.
   * @param face - Cube face
   * @param imageSource - The source of texture
   * @param mipLevel - Texture mipmapping level
   * @param flipY - Whether to flip the Y axis
   * @param premultiplyAlpha - Whether to premultiply the transparent channel
   * @param x - X coordinate of area start
   * @param y - Y coordinate of area start
   */ _proto.setImageSource = function setImageSource(face, imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
        if (mipLevel === void 0) mipLevel = 0;
        if (flipY === void 0) flipY = false;
        if (premultiplyAlpha === void 0) premultiplyAlpha = false;
        if (x === void 0) x = 0;
        if (y === void 0) y = 0;
        this._platformTexture.setImageSource(face, imageSource, mipLevel, flipY, premultiplyAlpha, x, y);
        this._isContentLost = false;
    };
    _proto.getPixelBuffer = function getPixelBuffer(face, xOrMipLevelOrOut, yOrMipLevel, width, height, mipLevelOrOut, out) {
        var argsLength = arguments.length;
        if (argsLength === 2) {
            this._platformTexture.getPixelBuffer(face, 0, 0, this._width, this._height, 0, xOrMipLevelOrOut);
        } else if (argsLength === 3) {
            this._platformTexture.getPixelBuffer(face, 0, 0, this._width >> xOrMipLevelOrOut, this._height >> xOrMipLevelOrOut, xOrMipLevelOrOut, yOrMipLevel);
        } else if (argsLength === 6) {
            this._platformTexture.getPixelBuffer(face, xOrMipLevelOrOut, yOrMipLevel, width, height, 0, mipLevelOrOut);
        } else if (argsLength === 7) {
            this._platformTexture.getPixelBuffer(face, xOrMipLevelOrOut, yOrMipLevel, width, height, mipLevelOrOut, out);
        }
    };
    /**
   * @internal
   */ _proto._rebuild = function _rebuild() {
        this._platformTexture = this._engine._hardwareRenderer.createPlatformTextureCube(this);
        Texture.prototype._rebuild.call(this);
    };
    return TextureCube;
}(Texture);

/**
 * @internal
 */ var TextureUtils = /*#__PURE__*/ function() {
    function TextureUtils() {}
    /**
   * Check if the texture config supports auto mipmap generation with real correction for mipmap and isSRGBColorSpace.
   */ TextureUtils.supportGenerateMipmapsWithCorrection = function supportGenerateMipmapsWithCorrection(width, height, format, mipmap, isSRGBColorSpace, isWebGL2) {
        if (!mipmap) {
            return false;
        }
        if (isSRGBColorSpace && !TextureUtils.supportSRGB(format)) {
            isSRGBColorSpace = false;
        }
        if (!TextureUtils.supportMipmaps(width, height, isWebGL2)) {
            mipmap = false;
        }
        return TextureUtils.supportGenerateMipmaps(format, mipmap, isSRGBColorSpace, isWebGL2);
    };
    TextureUtils.supportSRGB = function supportSRGB(format) {
        switch(format){
            case TextureFormat.R8G8B8:
            case TextureFormat.R8G8B8A8:
            case TextureFormat.BC1:
            case TextureFormat.BC3:
            case TextureFormat.BC7:
            case TextureFormat.ETC2_RGB:
            case TextureFormat.ETC2_RGBA8:
            case TextureFormat.ASTC_4x4:
                return true;
            default:
                return false;
        }
    };
    TextureUtils.supportMipmaps = function supportMipmaps(width, height, isWebGL2) {
        return isWebGL2 || MathUtil.isPowerOf2(width) && MathUtil.isPowerOf2(height);
    };
    TextureUtils.supportGenerateMipmaps = function supportGenerateMipmaps(format, mipmap, isSRGBColorSpace, isWebGL2) {
        // Auto generating mipmaps for sRGB textures is only supported in [WebGL2 + RGBA]
        if (mipmap && isSRGBColorSpace && !(isWebGL2 && format === TextureFormat.R8G8B8A8)) {
            return false;
        }
        return true;
    };
    return TextureUtils;
}();

/**
 * @internal
 */ var FontAtlas = /*#__PURE__*/ function(ReferResource) {
    _inherits$2(FontAtlas, ReferResource);
    function FontAtlas(engine) {
        var _this;
        _this = ReferResource.call(this, engine) || this, _this._charInfoMap = {}, _this._space = 1, _this._curX = 1, _this._curY = 1, _this._nextY = 1;
        return _this;
    }
    var _proto = FontAtlas.prototype;
    _proto.uploadCharTexture = function uploadCharTexture(charInfo) {
        var width = charInfo.w, height = charInfo.h, data = charInfo.data;
        var _this = this, space = _this._space, texture = _this.texture;
        var textureSize = texture.width;
        var offsetWidth = width + space;
        var offsetHeight = height + space;
        if (1 + offsetWidth >= textureSize || 1 + offsetHeight >= textureSize) {
            throw Error("The char fontSize is too large.");
        }
        var endX = this._curX + offsetWidth;
        if (endX >= textureSize) {
            this._curX = space;
            this._curY = this._nextY + space;
        }
        var endY = this._curY + offsetHeight;
        if (endY > this._nextY) {
            this._nextY = endY;
        }
        if (endY >= textureSize) {
            return false;
        }
        if (width > 0 && height > 0 && data) {
            charInfo.bufferOffset = new Vector2(this._curX, this._curY);
            texture.setPixelBuffer(data, 0, this._curX, this._curY, width, height);
            texture.generateMipmaps();
        }
        var textureSizeReciprocal = 1.0 / textureSize;
        var x = this._curX;
        var y = this._curY;
        var w = width;
        var h = height;
        var u0 = x * textureSizeReciprocal;
        var u1 = (x + w) * textureSizeReciprocal;
        var v0 = y * textureSizeReciprocal;
        var v1 = (y + h) * textureSizeReciprocal;
        charInfo.x = x;
        charInfo.y = y;
        var uvs = charInfo.uvs;
        uvs[0].set(u0, v0);
        uvs[1].set(u1, v0);
        uvs[2].set(u1, v1);
        uvs[3].set(u0, v1);
        this._curX += offsetWidth + space;
        return true;
    };
    _proto.addCharInfo = function addCharInfo(char, charInfo) {
        this._charInfoMap[char.charCodeAt(0)] = charInfo;
    };
    _proto.getCharInfo = function getCharInfo(char) {
        return this._charInfoMap[char.charCodeAt(0)];
    };
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        ReferResource.prototype._onDestroy.call(this);
        this.texture.destroy();
        this.texture = null;
        this._charInfoMap = {};
    };
    return FontAtlas;
}(ReferResource);

/**
 * The style of the font.
 */ var FontStyle = /*#__PURE__*/ function(FontStyle) {
    /** Set font without style */ FontStyle[FontStyle["None"] = 0] = "None";
    /** Set font bold */ FontStyle[FontStyle["Bold"] = 1] = "Bold";
    /** Set font italic */ FontStyle[FontStyle["Italic"] = 2] = "Italic";
    return FontStyle;
}({});

/**
 * The way to handle the situation where wrapped text is too tall to fit in the height.
 */ var OverflowMode = /*#__PURE__*/ function(OverflowMode) {
    /** Overflow when the text is too tall */ OverflowMode[OverflowMode["Overflow"] = 0] = "Overflow";
    /** Truncate with height when the text is too tall */ OverflowMode[OverflowMode["Truncate"] = 1] = "Truncate";
    return OverflowMode;
}({});

/**
 * @internal
 * TextUtils includes some helper function for text.
 */ var TextUtils = /*#__PURE__*/ function() {
    function TextUtils() {}
    /**
   * The instance function to get an object includes 2d context and canvas.
   * @returns the TextContext object
   */ TextUtils.textContext = function textContext() {
        var textContext = TextUtils._textContext;
        if (!textContext) {
            var canvas;
            try {
                canvas = new OffscreenCanvas(0, 0);
            } catch (e) {
                canvas = document.createElement("canvas");
            }
            var context = canvas.getContext("2d", {
                willReadFrequently: true
            });
            textContext = {
                canvas: canvas,
                context: context
            };
            TextUtils._textContext = textContext;
        }
        return textContext;
    };
    /**
   * Measure the font.
   * @param fontString - the string of the font
   * @returns the font size info
   */ TextUtils.measureFont = function measureFont(fontString) {
        var fontSizeInfoCache = TextUtils._fontSizeInfoCache;
        var info = fontSizeInfoCache[fontString];
        if (info) {
            return info;
        }
        info = TextUtils._measureFontOrChar(fontString, TextUtils._measureString, false);
        fontSizeInfoCache[fontString] = info;
        return info;
    };
    /**
   * Get native font string.
   * @param fontName - The font name
   * @param fontSize - The font size
   * @param style - The font style
   * @returns The native font string
   */ TextUtils.getNativeFontString = function getNativeFontString(fontName, fontSize, style) {
        var str = style & FontStyle.Bold ? "bold " : "";
        style & FontStyle.Italic && (str += "italic ");
        // Check if font already contains strings
        if (!/([\"\'])[^\'\"]+\1/.test(fontName) && TextUtils._genericFontFamilies.indexOf(fontName) == -1) {
            fontName = '"' + fontName + '"';
        }
        str += fontSize + "px " + fontName;
        return str;
    };
    TextUtils.measureChar = function measureChar(char, fontString) {
        return TextUtils._measureFontOrChar(fontString, char, true);
    };
    TextUtils.measureTextWithWrap = function measureTextWithWrap(renderer, rendererWidth, rendererHeight, lineSpacing) {
        var subFont = renderer._getSubFont();
        var fontString = subFont.nativeFontString;
        var fontSizeInfo = TextUtils.measureFont(fontString);
        var subTexts = renderer.text.split(/(?:\r\n|\r|\n)/);
        var lines = new Array();
        var lineWidths = new Array();
        var lineMaxSizes = new Array();
        var lineHeight = fontSizeInfo.size + lineSpacing;
        var textWidth = 0;
        subFont.nativeFontString = fontString;
        for(var i = 0, n = subTexts.length; i < n; i++){
            var subText = subTexts[i];
            // If subText is empty, push an empty line directly
            if (subText.length === 0) {
                this._pushLine(lines, lineWidths, lineMaxSizes, "", 0, 0, 0);
                continue;
            }
            var word = "";
            var wordWidth = 0;
            var wordMaxAscent = 0;
            var wordMaxDescent = 0;
            var line = "";
            var lineWidth = 0;
            var lineMaxAscent = 0;
            var lineMaxDescent = 0;
            var notFirstLine = false;
            for(var j = 0, m = subText.length; j < m; ++j){
                var char = subText[j];
                var charInfo = TextUtils._getCharInfo(char, fontString, subFont);
                var charCode = char.charCodeAt(0);
                var isSpace = charCode === 32;
                if (isSpace && notFirstLine && line.length === 0 && word.length === 0) {
                    continue;
                }
                // The char code scope of Chinese is [\u4e00-\u9fff]
                var unableFromWord = isSpace || charCode >= 0x4e00 && charCode <= 0x9fff;
                var w = charInfo.w, offsetY = charInfo.offsetY;
                var halfH = charInfo.h * 0.5;
                var ascent = halfH + offsetY;
                var descent = halfH - offsetY;
                if (unableFromWord) {
                    // If it is a word before, need to handle the previous word and line
                    if (word.length > 0) {
                        if (lineWidth + wordWidth > rendererWidth) {
                            // Push if before line is not empty
                            if (lineWidth > 0) {
                                this._pushLine(lines, lineWidths, lineMaxSizes, line, lineWidth, lineMaxAscent, lineMaxDescent);
                            }
                            textWidth = Math.max(textWidth, lineWidth);
                            notFirstLine = true;
                            line = word;
                            lineWidth = wordWidth;
                            lineMaxAscent = wordMaxAscent;
                            lineMaxDescent = wordMaxDescent;
                        } else {
                            line += word;
                            lineWidth += wordWidth;
                            lineMaxAscent = Math.max(lineMaxAscent, wordMaxAscent);
                            lineMaxDescent = Math.max(lineMaxDescent, wordMaxDescent);
                        }
                        word = "";
                        wordWidth = wordMaxAscent = wordMaxDescent = 0;
                    }
                    // Handle char
                    // At least one char in a line
                    if (lineWidth + w > rendererWidth && lineWidth > 0) {
                        this._pushLine(lines, lineWidths, lineMaxSizes, line, lineWidth, lineMaxAscent, lineMaxDescent);
                        textWidth = Math.max(textWidth, lineWidth);
                        notFirstLine = true;
                        if (isSpace) {
                            line = "";
                            lineWidth = lineMaxAscent = lineMaxDescent = 0;
                        } else {
                            line = char;
                            lineWidth = charInfo.xAdvance;
                            lineMaxAscent = ascent;
                            lineMaxDescent = descent;
                        }
                    } else {
                        line += char;
                        lineWidth += charInfo.xAdvance;
                        lineMaxAscent = Math.max(lineMaxAscent, ascent);
                        lineMaxDescent = Math.max(lineMaxDescent, descent);
                    }
                } else {
                    if (wordWidth + charInfo.w > rendererWidth) {
                        if (lineWidth > 0) {
                            this._pushLine(lines, lineWidths, lineMaxSizes, line, lineWidth, lineMaxAscent, lineMaxDescent);
                            textWidth = Math.max(textWidth, lineWidth);
                            line = "";
                            lineWidth = lineMaxAscent = lineMaxDescent = 0;
                        }
                        // Push if before word is not empty
                        if (wordWidth > 0) {
                            this._pushLine(lines, lineWidths, lineMaxSizes, word, wordWidth, wordMaxAscent, wordMaxDescent);
                        }
                        textWidth = Math.max(textWidth, wordWidth);
                        notFirstLine = true;
                        word = char;
                        wordWidth = charInfo.xAdvance;
                        wordMaxAscent = ascent;
                        wordMaxDescent = descent;
                    } else {
                        word += char;
                        wordWidth += charInfo.xAdvance;
                        wordMaxAscent = Math.max(wordMaxAscent, ascent);
                        wordMaxDescent = Math.max(wordMaxDescent, descent);
                    }
                }
            }
            if (wordWidth > 0) {
                // If the total width from line and word exceed wrap width
                if (lineWidth + wordWidth > rendererWidth) {
                    // Push chars to a single line
                    if (lineWidth > 0) {
                        this._pushLine(lines, lineWidths, lineMaxSizes, line, lineWidth, lineMaxAscent, lineMaxDescent);
                    }
                    textWidth = Math.max(textWidth, lineWidth);
                    lineWidth = 0;
                    // Push word to a single line
                    if (wordWidth > 0) {
                        this._pushLine(lines, lineWidths, lineMaxSizes, word, wordWidth, wordMaxAscent, wordMaxDescent);
                    }
                    textWidth = Math.max(textWidth, wordWidth);
                } else {
                    // Merge to chars
                    line += word;
                    lineWidth += wordWidth;
                    lineMaxAscent = Math.max(lineMaxAscent, wordMaxAscent);
                    lineMaxDescent = Math.max(lineMaxDescent, wordMaxDescent);
                }
            }
            if (lineWidth > 0) {
                this._pushLine(lines, lineWidths, lineMaxSizes, line, lineWidth, lineMaxAscent, lineMaxDescent);
                textWidth = Math.max(textWidth, lineWidth);
            }
        }
        var height = rendererHeight;
        if (renderer.overflowMode === OverflowMode.Overflow) {
            height = lineHeight * lines.length;
        }
        return {
            width: textWidth,
            height: height,
            lines: lines,
            lineWidths: lineWidths,
            lineHeight: lineHeight,
            lineMaxSizes: lineMaxSizes
        };
    };
    TextUtils.measureTextWithoutWrap = function measureTextWithoutWrap(renderer, rendererHeight, lineSpacing) {
        var subFont = renderer._getSubFont();
        var fontString = subFont.nativeFontString;
        var fontSizeInfo = TextUtils.measureFont(fontString);
        var subTexts = renderer.text.split(/(?:\r\n|\r|\n)/);
        var textCount = subTexts.length;
        var lines = new Array();
        var lineWidths = new Array();
        var lineMaxSizes = new Array();
        var lineHeight = fontSizeInfo.size + lineSpacing;
        var width = 0;
        subFont.nativeFontString = fontString;
        for(var i = 0; i < textCount; ++i){
            var line = subTexts[i];
            var curWidth = 0;
            var maxAscent = 0;
            var maxDescent = 0;
            for(var j = 0, m = line.length; j < m; ++j){
                var charInfo = TextUtils._getCharInfo(line[j], fontString, subFont);
                curWidth += charInfo.xAdvance;
                var offsetY = charInfo.offsetY;
                var halfH = charInfo.h * 0.5;
                var ascent = halfH + offsetY;
                var descent = halfH - offsetY;
                maxAscent < ascent && (maxAscent = ascent);
                maxDescent < descent && (maxDescent = descent);
            }
            if (curWidth > 0) {
                this._pushLine(lines, lineWidths, lineMaxSizes, line, curWidth, maxAscent, maxDescent);
                width = Math.max(width, curWidth);
            }
        }
        var height = rendererHeight;
        if (renderer.overflowMode === OverflowMode.Overflow) {
            height = lineHeight * lines.length;
        }
        return {
            width: width,
            height: height,
            lines: lines,
            lineWidths: lineWidths,
            lineHeight: lineHeight,
            lineMaxSizes: lineMaxSizes
        };
    };
    /**
   * Get native font hash.
   * @param fontName - The font name
   * @param fontSize - The font size
   * @param style - The font style
   * @returns The native font hash
   */ TextUtils.getNativeFontHash = function getNativeFontHash(fontName, fontSize, style) {
        var str = style & FontStyle.Bold ? "bold" : "";
        style & FontStyle.Italic && (str += "italic");
        // Check if font already contains strings
        if (!/([\"\'])[^\'\"]+\1/.test(fontName) && TextUtils._genericFontFamilies.indexOf(fontName) == -1) {
            fontName = "" + fontName;
        }
        str += fontSize + "px" + fontName;
        return str;
    };
    /**
   * @internal
   */ TextUtils._measureFontOrChar = function _measureFontOrChar(fontString, measureString, isChar) {
        var _TextUtils_textContext = TextUtils.textContext(), canvas = _TextUtils_textContext.canvas, context = _TextUtils_textContext.context;
        context.font = fontString;
        // Safari gets data confusion through getImageData when the canvas width is not an integer.
        // The measure text width of some special invisible characters may be 0, so make sure the width is at least 1.
        // @todo: Text layout may vary from standard and not support emoji.
        var _context_measureText = context.measureText(measureString), actualBoundingBoxLeft = _context_measureText.actualBoundingBoxLeft, actualBoundingBoxRight = _context_measureText.actualBoundingBoxRight, actualWidth = _context_measureText.width;
        // In some case (ex: " "), actualBoundingBoxRight and actualBoundingBoxLeft will be 0, so use width.
        // TODO: With testing, actualBoundingBoxLeft + actualBoundingBoxRight is the actual rendering width
        // but the space rules between characters are unclear. Using actualBoundingBoxRight + Math.abs(actualBoundingBoxLeft) is the closest to the native effect.
        var width = Math.max(1, Math.round(Math.max(actualBoundingBoxRight + Math.abs(actualBoundingBoxLeft), actualWidth)));
        // Make sure enough width.
        var baseline = Math.ceil(context.measureText(TextUtils._measureBaseline).width);
        var height = baseline * TextUtils._heightMultiplier;
        baseline = TextUtils._baselineMultiplier * baseline | 0;
        var _extendHeight = TextUtils._extendHeight;
        height += _extendHeight;
        baseline += _extendHeight * 0.5;
        canvas.width = width;
        canvas.height = height;
        context.font = fontString;
        context.fillStyle = "#000";
        context.clearRect(0, 0, width, height);
        context.textBaseline = "middle";
        context.fillStyle = "#fff";
        if (actualBoundingBoxLeft > 0) {
            context.fillText(measureString, actualBoundingBoxLeft, baseline);
        } else {
            context.fillText(measureString, 0, baseline);
        }
        var colorData = context.getImageData(0, 0, width, height).data;
        var len = colorData.length;
        var top = -1;
        var bottom = -1;
        var y;
        var ascent = 0;
        var descent = 0;
        var size = 0;
        var integerW = canvas.width;
        var integerWReciprocal = 1.0 / integerW;
        for(var i = 0; i < len; i += 4){
            if (colorData[i + 3] !== 0) {
                var idx = i * 0.25;
                y = ~~(idx * integerWReciprocal);
                if (top === -1) {
                    top = y;
                }
                if (y > bottom) {
                    bottom = y;
                }
            } else {
                colorData[i] = colorData[i + 1] = colorData[i + 2] = 255;
            }
        }
        if (top !== -1 && bottom !== -1) {
            ascent = baseline - top;
            // Baseline belong to descent
            descent = bottom - baseline + 1;
            size = ascent + descent;
        }
        if (isChar) {
            var data = null;
            if (size > 0) {
                var lineIntegerW = integerW * 4;
                // gl.texSubImage2D uploading data of type Uint8ClampedArray is not supported in some devices(eg: IphoneX IOS 13.6.1).
                data = new Uint8Array(colorData.buffer, top * lineIntegerW, size * lineIntegerW);
            }
            return {
                char: measureString,
                x: 0,
                y: 0,
                w: width,
                h: size,
                offsetX: actualBoundingBoxLeft > 0 ? actualBoundingBoxLeft : 0,
                offsetY: (ascent - descent) * 0.5,
                xAdvance: Math.round(actualWidth),
                uvs: [
                    new Vector2(),
                    new Vector2(),
                    new Vector2(),
                    new Vector2()
                ],
                ascent: ascent,
                descent: descent,
                index: 0,
                data: data
            };
        } else {
            return {
                ascent: ascent,
                descent: descent,
                size: size
            };
        }
    };
    /**
   * @internal
   */ TextUtils._getCharInfo = function _getCharInfo(char, fontString, font) {
        var charInfo = font._getCharInfo(char);
        if (!charInfo) {
            charInfo = TextUtils.measureChar(char, fontString);
            font._uploadCharTexture(charInfo);
            font._addCharInfo(char, charInfo);
        }
        return charInfo;
    };
    TextUtils._pushLine = function _pushLine(lines, lineWidths, lineMaxSizes, line, lineWidth, ascent, descent) {
        lines.push(line);
        lineWidths.push(lineWidth);
        lineMaxSizes.push({
            ascent: ascent,
            descent: descent,
            size: ascent + descent
        });
    };
    return TextUtils;
}();
/** @internal */ TextUtils._genericFontFamilies = [
    "serif",
    "sans-serif",
    "monospace",
    "cursive",
    "fantasy",
    "system-ui",
    "math",
    "emoji",
    "fangsong"
];
// _extendHeight used to extend the height of canvas, because in miniprogram performance is different from h5.
/** @internal */ TextUtils._extendHeight = 0;
/** These characters are all tall to help calculate the height required for text. */ TextUtils._measureString = "|ÉqÅ";
TextUtils._measureBaseline = "M";
TextUtils._heightMultiplier = 2;
TextUtils._baselineMultiplier = 1.4;
TextUtils._fontSizeInfoCache = {};
TextUtils._textContext = null;

/**
 * @internal
 */ var SubFont = /*#__PURE__*/ function() {
    function SubFont(engine) {
        this._fontAtlases = [];
        this._lastIndex = -1;
        this._engine = engine;
    }
    var _proto = SubFont.prototype;
    _proto.destroy = function destroy() {
        var fontAtlases = this._fontAtlases;
        for(var i = 0, n = fontAtlases.length; i < n; ++i){
            fontAtlases[i].destroy(true);
        }
        fontAtlases.length = 0;
    };
    /**
   * @internal
   */ _proto._uploadCharTexture = function _uploadCharTexture(charInfo) {
        var fontAtlases = this._fontAtlases;
        var lastIndex = this._lastIndex;
        if (lastIndex === -1) {
            this._createFontAtlas();
            lastIndex++;
        }
        var fontAtlas = fontAtlases[lastIndex];
        if (!fontAtlas.uploadCharTexture(charInfo)) {
            fontAtlas = this._createFontAtlas();
            fontAtlas.uploadCharTexture(charInfo);
            lastIndex++;
        }
        this._lastIndex = lastIndex;
        charInfo.data = null;
    };
    /**
   * @internal
   */ _proto._addCharInfo = function _addCharInfo(char, charInfo) {
        var lastIndex = this._lastIndex;
        charInfo.index = lastIndex;
        this._fontAtlases[lastIndex].addCharInfo(char, charInfo);
    };
    /**
   * @internal
   */ _proto._getCharInfo = function _getCharInfo(char) {
        var fontAtlases = this._fontAtlases;
        for(var i = 0, n = fontAtlases.length; i < n; ++i){
            var fontAtlas = fontAtlases[i];
            var charInfo = fontAtlas.getCharInfo(char);
            if (charInfo) {
                return charInfo;
            }
        }
        return null;
    };
    /**
   * @internal
   */ _proto._getTextureByIndex = function _getTextureByIndex(index) {
        var fontAtlas = this._fontAtlases[index];
        if (fontAtlas) {
            return fontAtlas.texture;
        }
        return null;
    };
    /**
   * @internal
   */ _proto._getLastIndex = function _getLastIndex() {
        return this._lastIndex;
    };
    _proto._createFontAtlas = function _createFontAtlas() {
        var _this = this, engine = _this._engine;
        var fontAtlas = new FontAtlas(engine);
        var texture = new Texture2D(engine, 256, 256, TextureFormat.R8G8B8A8, false);
        texture.filterMode = TextureFilterMode.Bilinear;
        fontAtlas.texture = texture;
        fontAtlas.isGCIgnored = texture.isGCIgnored = true;
        this._fontAtlases.push(fontAtlas);
        var nativeFontString = this.nativeFontString;
        engine.resourceManager.addContentRestorer(new (/*#__PURE__*/ function(ContentRestorer) {
            _inherits$2(_class, ContentRestorer);
            function _class() {
                return ContentRestorer.call(this, fontAtlas) || this;
            }
            var _proto = _class.prototype;
            _proto.restoreContent = function restoreContent() {
                var resource = this.resource;
                var charInfoMap = resource._charInfoMap;
                var texture = resource.texture;
                for(var k in charInfoMap){
                    var charInfo = charInfoMap[k];
                    var data = TextUtils.measureChar(charInfo.char, nativeFontString).data;
                    if (charInfo.w > 0 && charInfo.h > 0 && data) {
                        var bufferOffset = charInfo.bufferOffset;
                        texture.setPixelBuffer(data, 0, bufferOffset.x, bufferOffset.y, charInfo.w, charInfo.h);
                    }
                }
                texture.generateMipmaps();
            };
            return _class;
        }(ContentRestorer))());
        return fontAtlas;
    };
    return SubFont;
}();

/**
 * Font.
 */ var Font = /*#__PURE__*/ function(ReferResource) {
    _inherits$2(Font, ReferResource);
    function Font(engine, name) {
        if (name === void 0) name = "";
        var _this;
        _this = ReferResource.call(this, engine) || this, _this._name = "", _this._subFontMap = {};
        _this._name = name;
        return _this;
    }
    var _proto = Font.prototype;
    /**
   * @internal
   */ _proto._getSubFont = function _getSubFont(fontSize, fontStyle) {
        var key = fontSize + "-" + fontStyle;
        var subFontMap = this._subFontMap;
        var subFont = subFontMap[key];
        if (subFont) {
            return subFont;
        }
        subFont = new SubFont(this.engine);
        subFontMap[key] = subFont;
        return subFont;
    };
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        ReferResource.prototype._onDestroy.call(this);
        var subFontMap = this._subFontMap;
        for(var k in subFontMap){
            subFontMap[k].destroy();
        }
        this._subFontMap = null;
        delete this.engine._fontMap[this._name];
    };
    /**
   * Create a system font.
   * @param engine - Engine to which the font belongs
   * @param name - The name of font want to create
   * @returns The font object has been create
   */ Font.createFromOS = function createFromOS(engine, name) {
        if (name) {
            var fontMap = engine._fontMap;
            var font = fontMap[name];
            if (font) {
                return font;
            }
            font = new Font(engine, name);
            fontMap[name] = font;
            return font;
        }
        return null;
    };
    _create_class$2(Font, [
        {
            key: "name",
            get: /**
   * The name of the font object.
   */ function get() {
                return this._name;
            }
        }
    ]);
    return Font;
}(ReferResource);

/**
 *  Static interface implement decorator.
 *  https://stackoverflow.com/questions/13955157/how-to-define-static-property-in-typescript-interface
 */ function StaticInterfaceImplement() {
    return function(constructor) {
    };
}

var SimpleSpriteAssembler = /*#__PURE__*/ function() {
    function SimpleSpriteAssembler() {}
    SimpleSpriteAssembler.resetData = function resetData(renderer) {
        var manager = renderer._getChunkManager();
        var lastSubChunk = renderer._subChunk;
        lastSubChunk && manager.freeSubChunk(lastSubChunk);
        var subChunk = manager.allocateSubChunk(4);
        subChunk.indices = SimpleSpriteAssembler._rectangleTriangles;
        renderer._subChunk = subChunk;
    };
    SimpleSpriteAssembler.updatePositions = function updatePositions(renderer, worldMatrix, width, height, pivot, flipX, flipY) {
        var sprite = renderer.sprite;
        var pivotX = pivot.x, pivotY = pivot.y;
        // Position to World
        var modelMatrix = SimpleSpriteAssembler._matrix;
        var wE = modelMatrix.elements;
        // Renderer's worldMatrix
        var pWE = worldMatrix.elements;
        var sx = flipX ? -width : width;
        var sy = flipY ? -height : height;
        wE[0] = pWE[0] * sx, wE[1] = pWE[1] * sx, wE[2] = pWE[2] * sx;
        wE[4] = pWE[4] * sy, wE[5] = pWE[5] * sy, wE[6] = pWE[6] * sy;
        wE[8] = pWE[8], wE[9] = pWE[9], wE[10] = pWE[10];
        wE[12] = pWE[12] - pivotX * wE[0] - pivotY * wE[4];
        wE[13] = pWE[13] - pivotX * wE[1] - pivotY * wE[5];
        wE[14] = pWE[14] - pivotX * wE[2] - pivotY * wE[6];
        // ---------------
        //  2 - 3
        //  |   |
        //  0 - 1
        // ---------------
        // Update positions
        var spritePositions = sprite._getPositions();
        var subChunk = renderer._subChunk;
        var vertices = subChunk.chunk.vertices;
        for(var i = 0, o = subChunk.vertexArea.start; i < 4; ++i, o += 9){
            var _spritePositions_i = spritePositions[i], x = _spritePositions_i.x, y = _spritePositions_i.y;
            vertices[o] = wE[0] * x + wE[4] * y + wE[12];
            vertices[o + 1] = wE[1] * x + wE[5] * y + wE[13];
            vertices[o + 2] = wE[2] * x + wE[6] * y + wE[14];
        }
        // @ts-ignore
        BoundingBox.transform(sprite._getBounds(), modelMatrix, renderer._bounds);
    };
    SimpleSpriteAssembler.updateUVs = function updateUVs(renderer) {
        var spriteUVs = renderer.sprite._getUVs();
        var _spriteUVs_ = spriteUVs[0], left = _spriteUVs_.x, bottom = _spriteUVs_.y;
        var _spriteUVs_1 = spriteUVs[3], right = _spriteUVs_1.x, top = _spriteUVs_1.y;
        var subChunk = renderer._subChunk;
        var vertices = subChunk.chunk.vertices;
        var offset = subChunk.vertexArea.start + 3;
        vertices[offset] = left;
        vertices[offset + 1] = bottom;
        vertices[offset + 9] = right;
        vertices[offset + 10] = bottom;
        vertices[offset + 18] = left;
        vertices[offset + 19] = top;
        vertices[offset + 27] = right;
        vertices[offset + 28] = top;
    };
    SimpleSpriteAssembler.updateColor = function updateColor(renderer, alpha) {
        var subChunk = renderer._subChunk;
        var _renderer_color = renderer.color, r = _renderer_color.r, g = _renderer_color.g, b = _renderer_color.b, a = _renderer_color.a;
        var finalAlpha = a * alpha;
        var vertices = subChunk.chunk.vertices;
        for(var i = 0, o = subChunk.vertexArea.start + 5; i < 4; ++i, o += 9){
            vertices[o] = r;
            vertices[o + 1] = g;
            vertices[o + 2] = b;
            vertices[o + 3] = finalAlpha;
        }
    };
    return SimpleSpriteAssembler;
}();
SimpleSpriteAssembler._rectangleTriangles = [
    0,
    1,
    2,
    2,
    1,
    3
];
SimpleSpriteAssembler._matrix = new Matrix();
SimpleSpriteAssembler = __decorate$1([
    StaticInterfaceImplement()
], SimpleSpriteAssembler);

var SlicedSpriteAssembler = /*#__PURE__*/ function() {
    function SlicedSpriteAssembler() {}
    SlicedSpriteAssembler.resetData = function resetData(renderer) {
        var manager = renderer._getChunkManager();
        var lastSubChunk = renderer._subChunk;
        lastSubChunk && manager.freeSubChunk(lastSubChunk);
        var subChunk = manager.allocateSubChunk(16);
        subChunk.indices = SlicedSpriteAssembler._rectangleTriangles;
        renderer._subChunk = subChunk;
    };
    SlicedSpriteAssembler.updatePositions = function updatePositions(renderer, worldMatrix, width, height, pivot, flipX, flipY, referenceResolutionPerUnit) {
        if (referenceResolutionPerUnit === void 0) referenceResolutionPerUnit = 1;
        var sprite = renderer.sprite;
        var border = sprite.border;
        // Update local positions.
        var spritePositions = sprite._getPositions();
        var _spritePositions_ = spritePositions[0], left = _spritePositions_.x, bottom = _spritePositions_.y;
        var _spritePositions_1 = spritePositions[3], right = _spritePositions_1.x, top = _spritePositions_1.y;
        var expectWidth = sprite.width * referenceResolutionPerUnit;
        var expectHeight = sprite.height * referenceResolutionPerUnit;
        var fixedLeft = expectWidth * border.x;
        var fixedBottom = expectHeight * border.y;
        var fixedRight = expectWidth * border.z;
        var fixedTop = expectHeight * border.w;
        // ------------------------
        //     [3]
        //      |
        //     [2]
        //      |
        //     [1]
        //      |
        // row [0] - [1] - [2] - [3]
        //    column
        // ------------------------
        // Calculate row and column.
        var row = SlicedSpriteAssembler._row, column = SlicedSpriteAssembler._column;
        if (fixedLeft + fixedRight > width) {
            var widthScale = width / (fixedLeft + fixedRight);
            row[0] = expectWidth * left * widthScale, row[1] = row[2] = fixedLeft * widthScale;
            row[3] = width - expectWidth * (1 - right) * widthScale;
        } else {
            row[0] = expectWidth * left, row[1] = fixedLeft, row[2] = width - fixedRight;
            row[3] = width - expectWidth * (1 - right);
        }
        if (fixedTop + fixedBottom > height) {
            var heightScale = height / (fixedTop + fixedBottom);
            column[0] = expectHeight * bottom * heightScale, column[1] = column[2] = fixedBottom * heightScale;
            column[3] = height - expectHeight * (1 - top) * heightScale;
        } else {
            column[0] = expectHeight * bottom, column[1] = fixedBottom, column[2] = height - fixedTop;
            column[3] = height - expectHeight * (1 - top);
        }
        // Update renderer's worldMatrix.
        var pivotX = pivot.x, pivotY = pivot.y;
        var localTransX = width * pivotX;
        var localTransY = height * pivotY;
        // Position to World
        var modelMatrix = SlicedSpriteAssembler._matrix;
        var wE = modelMatrix.elements;
        // Renderer's worldMatrix.
        var pWE = worldMatrix.elements;
        var sx = flipX ? -1 : 1;
        var sy = flipY ? -1 : 1;
        wE[0] = pWE[0] * sx, wE[1] = pWE[1] * sx, wE[2] = pWE[2] * sx;
        wE[4] = pWE[4] * sy, wE[5] = pWE[5] * sy, wE[6] = pWE[6] * sy;
        wE[8] = pWE[8], wE[9] = pWE[9], wE[10] = pWE[10];
        wE[12] = pWE[12] - localTransX * wE[0] - localTransY * wE[4];
        wE[13] = pWE[13] - localTransX * wE[1] - localTransY * wE[5];
        wE[14] = pWE[14] - localTransX * wE[2] - localTransY * wE[6];
        // ------------------------
        //  3 - 7 - 11 - 15
        //  |   |   |    |
        //  2 - 6 - 10 - 14
        //  |   |   |    |
        //  1 - 5 - 9  - 13
        //  |   |   |    |
        //  0 - 4 - 8  - 12
        // ------------------------
        // Assemble position and uv.
        var subChunk = renderer._subChunk;
        var vertices = subChunk.chunk.vertices;
        for(var i = 0, o = subChunk.vertexArea.start; i < 4; i++){
            var rowValue = row[i];
            for(var j = 0; j < 4; j++, o += 9){
                var columnValue = column[j];
                vertices[o] = wE[0] * rowValue + wE[4] * columnValue + wE[12];
                vertices[o + 1] = wE[1] * rowValue + wE[5] * columnValue + wE[13];
                vertices[o + 2] = wE[2] * rowValue + wE[6] * columnValue + wE[14];
            }
        }
        // @ts-ignore
        var bounds = renderer._bounds;
        bounds.min.set(row[0], column[0], 0);
        bounds.max.set(row[3], column[3], 0);
        bounds.transform(modelMatrix);
    };
    SlicedSpriteAssembler.updateUVs = function updateUVs(renderer) {
        var subChunk = renderer._subChunk;
        var vertices = subChunk.chunk.vertices;
        var spriteUVs = renderer.sprite._getUVs();
        for(var i = 0, o = subChunk.vertexArea.start + 3; i < 4; i++){
            var rowU = spriteUVs[i].x;
            for(var j = 0; j < 4; j++, o += 9){
                vertices[o] = rowU;
                vertices[o + 1] = spriteUVs[j].y;
            }
        }
    };
    SlicedSpriteAssembler.updateColor = function updateColor(renderer, alpha) {
        var subChunk = renderer._subChunk;
        var _renderer_color = renderer.color, r = _renderer_color.r, g = _renderer_color.g, b = _renderer_color.b, a = _renderer_color.a;
        var finalAlpha = a * alpha;
        var vertices = subChunk.chunk.vertices;
        for(var i = 0, o = subChunk.vertexArea.start + 5; i < 16; ++i, o += 9){
            vertices[o] = r;
            vertices[o + 1] = g;
            vertices[o + 2] = b;
            vertices[o + 3] = finalAlpha;
        }
    };
    return SlicedSpriteAssembler;
}();
SlicedSpriteAssembler._rectangleTriangles = [
    0,
    1,
    4,
    1,
    5,
    4,
    1,
    2,
    5,
    2,
    6,
    5,
    2,
    3,
    6,
    3,
    7,
    6,
    4,
    5,
    8,
    5,
    9,
    8,
    5,
    6,
    9,
    6,
    10,
    9,
    6,
    7,
    10,
    7,
    11,
    10,
    8,
    9,
    12,
    9,
    13,
    12,
    9,
    10,
    13,
    10,
    14,
    13,
    10,
    11,
    14,
    11,
    15,
    14
];
SlicedSpriteAssembler._matrix = new Matrix();
SlicedSpriteAssembler._row = new Array(4);
SlicedSpriteAssembler._column = new Array(4);
SlicedSpriteAssembler = __decorate$1([
    StaticInterfaceImplement()
], SlicedSpriteAssembler);

/**
 * EventDispatcher, which can be inherited as a base class.
 */ var EventDispatcher = /*#__PURE__*/ function() {
    function EventDispatcher() {
        this._events = Object.create(null);
        this._eventCount = 0;
    }
    var _proto = EventDispatcher.prototype;
    /**
   * Determine whether there is event listening.
   * @param event - Event name
   * @returns Returns whether there is a corresponding event
   */ _proto.hasEvent = function hasEvent(event) {
        return this._events[event] != null;
    };
    /**
   * Returns the names of all registered events.
   * @returns All event names
   */ _proto.eventNames = function eventNames() {
        if (this._eventCount === 0) return [];
        return Object.keys(this._events);
    };
    /**
   * Returns the number of listeners with the specified event name.
   * @param event - Event name
   * @returns The count of listeners
   */ _proto.listenerCount = function listenerCount(event) {
        var listeners = this._events[event];
        if (!listeners) return 0;
        if (Array.isArray(listeners)) return listeners.length;
        return 1;
    };
    /**
   * Dispatch the event with the specified event name.
   * @param event - Event name
   * @param data - Data
   * @returns - Whether the dispatching is successful
   */ _proto.dispatch = function dispatch(event, data) {
        if (!this._events[event]) {
            return false;
        }
        var listeners = this._events[event];
        if (Array.isArray(listeners)) {
            var count = listeners.length;
            // cloning list to avoid structure breaking
            var pool = EventDispatcher._dispatchingListenersPool;
            var dispatchingListeners = pool.length > 0 ? pool.pop() : [];
            dispatchingListeners.length = count;
            for(var i = 0; i < count; i++){
                dispatchingListeners[i] = listeners[i];
            }
            for(var i1 = 0; i1 < count; i1++){
                var listener = dispatchingListeners[i1];
                if (!listener.destroyed) {
                    if (listener.once) this.off(event, listener.fn);
                    listener.fn(data);
                }
            }
            // remove hooked function to avoid gc problem
            dispatchingListeners.length = 0;
            pool.push(dispatchingListeners);
        } else {
            if (listeners.once) this.off(event, listeners.fn);
            listeners.fn(data);
        }
        return true;
    };
    /**
   * Add a listener/
   * @param event - Event name
   * @param fn - Function
   * @returns This
   */ _proto.on = function on(event, fn) {
        return this._addEventListener(event, fn);
    };
    /**
   * Add a one-time listener.
   * @param event - Event name
   * @param fn - Function
   * @returns This
   */ _proto.once = function once(event, fn) {
        return this._addEventListener(event, fn, true);
    };
    /**
   * Remove the event listener(s) of the specified event name.
   * @param event - Event name
   * @param fn - Function, If is undefined, delete all corresponding event listeners.
   */ _proto.off = function off(event, fn) {
        if (!this._events[event]) return this;
        if (!fn) {
            this._clearEvent(event);
            return this;
        }
        var listeners = this._events[event];
        var isArray = Array.isArray(listeners);
        if (!isArray && listeners.fn === fn) {
            this._clearEvent(event);
        } else if (isArray) {
            for(var i = listeners.length - 1; i >= 0; i--){
                if (listeners[i].fn === fn) {
                    // mark as destroyed
                    listeners[i].destroyed = true;
                    listeners.splice(i, 1);
                }
            }
            if (listeners.length === 0) {
                this._clearEvent(event);
            } else if (listeners.length === 1) {
                this._events[event] = listeners[0];
            }
        }
        return this;
    };
    /**
   * @deprecated Use `off` instead.
   * Remove the event listener(s) of the specified event name.
   * @param event - Event name
   * @param fn - Function, If is undefined, delete all corresponding event listeners.
   */ _proto.removeEventListener = function removeEventListener(event, fn) {
        return this.off(event, fn);
    };
    /**
   * Remove all event listeners.
   * @param event - Event name, delete all events if not passed
   */ _proto.removeAllEventListeners = function removeAllEventListeners(event) {
        if (event) {
            if (this._events[event]) this._clearEvent(event);
        } else {
            this._events = Object.create(null);
            this._eventCount = 0;
        }
    };
    _proto._addEventListener = function _addEventListener(event, fn, once) {
        var listener = {
            fn: fn,
            once: once
        };
        var events = this._events;
        var element = events[event];
        if (!element) {
            events[event] = listener;
            this._eventCount++;
        } else if (Array.isArray(element)) {
            element.push(listener);
        } else {
            events[event] = [
                element,
                listener
            ];
        }
        return this;
    };
    _proto._clearEvent = function _clearEvent(event) {
        if (--this._eventCount === 0) {
            this._events = Object.create(null);
        } else {
            delete this._events[event];
        }
    };
    return EventDispatcher;
}();
EventDispatcher._dispatchingListenersPool = [];

/**
 * Shader property.
 */ var ShaderProperty = /*#__PURE__*/ function() {
    function ShaderProperty(name) {
        this.name = name;
        this._uniqueId = ShaderProperty._propertyNameCounter++;
    }
    /**
   * Get shader property by name.
   * @param name - Name of the shader property
   * @returns Shader property
   */ ShaderProperty.getByName = function getByName(name) {
        var propertyNameMap = ShaderProperty._propertyNameMap;
        if (propertyNameMap[name] != null) {
            return propertyNameMap[name];
        } else {
            var property = new ShaderProperty(name);
            propertyNameMap[name] = property;
            ShaderProperty._propertyIdMap[property._uniqueId] = property;
            return property;
        }
    };
    /**
   * @internal
   */ ShaderProperty._getShaderPropertyGroup = function _getShaderPropertyGroup(propertyName) {
        var shaderProperty = ShaderProperty._propertyNameMap[propertyName];
        return shaderProperty == null ? void 0 : shaderProperty._group;
    };
    _create_class$2(ShaderProperty, [
        {
            key: "type",
            get: /**
   * Shader property type.
   */ function get() {
                return this._type;
            }
        }
    ]);
    return ShaderProperty;
}();
/** @internal */ ShaderProperty._propertyIdMap = Object.create(null);
ShaderProperty._propertyNameCounter = 0;
ShaderProperty._propertyNameMap = Object.create(null);

/**
 * Provide time related information.
 */ var Time = /*#__PURE__*/ function() {
    function Time() {
        this._frameCount = 0;
        this._deltaTime = 0;
        this._actualDeltaTime = 0;
        this._elapsedTime = 0;
        this._actualElapsedTime = 0;
        this._elapsedTimeValue = new Vector4();
        this._deltaTimeValue = new Vector4();
        /** Maximum delta time allowed per frame in seconds. */ this.maximumDeltaTime = 0.333333;
        /** The scale of time. */ this.timeScale = 1.0;
        this._lastSystemTime = performance.now() / 1000;
    }
    var _proto = Time.prototype;
    /**
   * @internal
   */ _proto._reset = function _reset() {
        this._lastSystemTime = performance.now() / 1000;
    };
    /**
   * @internal
   */ _proto._update = function _update() {
        var currentSystemTime = performance.now() / 1000;
        var actualDeltaTime = currentSystemTime - this._lastSystemTime;
        this._actualDeltaTime = actualDeltaTime;
        this._actualElapsedTime += actualDeltaTime;
        var deltaTime = Math.min(actualDeltaTime, this.maximumDeltaTime) * this.timeScale;
        this._deltaTime = deltaTime;
        this._elapsedTime += deltaTime;
        this._frameCount++;
        this._lastSystemTime = currentSystemTime;
    };
    /**
   * @internal
   */ _proto._updateSceneShaderData = function _updateSceneShaderData(shaderData) {
        var _this = this, elapsedTimeValue = _this._elapsedTimeValue, deltaTimeValue = _this._deltaTimeValue;
        var time = this._elapsedTime;
        elapsedTimeValue.set(time, Math.sin(time), Math.cos(time), 0);
        shaderData.setVector4(Time._elapsedTimeProperty, elapsedTimeValue);
        deltaTimeValue.set(this._deltaTime, 0, 0, 0);
        shaderData.setVector4(Time._deltaTimeProperty, deltaTimeValue);
    };
    _create_class$2(Time, [
        {
            key: "frameCount",
            get: /*
   * The total number of frames since the start of the engine.
   */ function get() {
                return this._frameCount;
            }
        },
        {
            key: "deltaTime",
            get: /**
   * The delta time in seconds from the last frame to the current frame.
   *
   * @remarks When the frame rate is low or stutter occurs, `deltaTime` will not exceed the value of `maximumDeltaTime` * `timeScale`.
   */ function get() {
                return this._deltaTime;
            }
        },
        {
            key: "elapsedTime",
            get: /**
   * The amount of elapsed time in seconds since the start of the engine.
   */ function get() {
                return this._elapsedTime;
            }
        },
        {
            key: "actualDeltaTime",
            get: /**
   * The actual delta time in seconds from the last frame to the current frame.
   *
   * @remarks The actual delta time is not affected by `maximumDeltaTime` and `timeScale`.
   */ function get() {
                return this._actualDeltaTime;
            }
        },
        {
            key: "actualElapsedTime",
            get: /**
   * The amount of actual elapsed time in seconds since the start of the engine.
   */ function get() {
                return this._actualElapsedTime;
            }
        }
    ]);
    return Time;
}();
Time._elapsedTimeProperty = ShaderProperty.getByName("scene_ElapsedTime");
Time._deltaTimeProperty = ShaderProperty.getByName("scene_DeltaTime");

var Utils = /*#__PURE__*/ function() {
    function Utils() {}
    /**
   * Fast remove an element from array.
   * @param array - Array
   * @param item - Element
   */ Utils.removeFromArray = function removeFromArray(array, item) {
        var index = array.indexOf(item);
        if (index < 0) {
            return false;
        }
        var last = array.length - 1;
        if (index !== last) {
            var end = array[last];
            array[index] = end;
        }
        array.length--;
        return true;
    };
    /**
   * Decodes a given Uint8Array into a string.
   */ Utils.decodeText = function decodeText(array) {
        if (typeof TextDecoder !== "undefined") {
            return new TextDecoder().decode(array);
        }
        // TextDecoder polyfill
        var s = "";
        for(var i = 0, il = array.length; i < il; i++){
            s += String.fromCharCode(array[i]);
        }
        return decodeURIComponent(encodeURIComponent(s));
    };
    /**
   * Judge whether the url is absolute url.
   * @param url - The url to be judged.
   * @returns Whether the url is absolute url.
   */ Utils.isAbsoluteUrl = function isAbsoluteUrl(url) {
        return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    };
    /**
   * Judge whether the url is base64 url.
   * @param url - The url to be judged.
   * @returns Whether the url is base64 url.
   */ Utils.isBase64Url = function isBase64Url(url) {
        return /^data:.*,.*$/i.test(url);
    };
    /**
   * Get the values of an object.
   */ Utils.objectValues = function objectValues(obj) {
        return Object.keys(obj).map(function(key) {
            return obj[key];
        });
    };
    /**
   * Convert a relative URL to an absolute URL based on a given base URL.
   * @param baseUrl - The base url.
   * @param relativeUrl - The relative url.
   * @returns The resolved url.
   */ Utils.resolveAbsoluteUrl = function resolveAbsoluteUrl(baseUrl, relativeUrl) {
        if (Utils.isAbsoluteUrl(relativeUrl)) {
            return relativeUrl;
        }
        if (Utils.isBase64Url(relativeUrl)) {
            return relativeUrl;
        }
        if (!/^https?:/.test(baseUrl)) {
            var fileSchema = "file://";
            baseUrl = fileSchema + baseUrl;
            return new URL(relativeUrl, baseUrl).href.substring(fileSchema.length);
        }
        return relativeUrl ? new URL(relativeUrl, baseUrl).href : baseUrl;
    };
    /**
   * @internal
   */ Utils._floatMatrixMultiply = function _floatMatrixMultiply(left, re, rOffset, oe, offset) {
        var le = left.elements;
        // prettier-ignore
        var l11 = le[0], l12 = le[1], l13 = le[2], l14 = le[3], l21 = le[4], l22 = le[5], l23 = le[6], l24 = le[7], l31 = le[8], l32 = le[9], l33 = le[10], l34 = le[11], l41 = le[12], l42 = le[13], l43 = le[14], l44 = le[15];
        // prettier-ignore
        var r11 = re[rOffset], r12 = re[rOffset + 1], r13 = re[rOffset + 2], r14 = re[rOffset + 3], r21 = re[rOffset + 4], r22 = re[rOffset + 5], r23 = re[rOffset + 6], r24 = re[rOffset + 7], r31 = re[rOffset + 8], r32 = re[rOffset + 9], r33 = re[rOffset + 10], r34 = re[rOffset + 11], r41 = re[rOffset + 12], r42 = re[rOffset + 13], r43 = re[rOffset + 14], r44 = re[rOffset + 15];
        oe[offset] = l11 * r11 + l21 * r12 + l31 * r13 + l41 * r14;
        oe[offset + 1] = l12 * r11 + l22 * r12 + l32 * r13 + l42 * r14;
        oe[offset + 2] = l13 * r11 + l23 * r12 + l33 * r13 + l43 * r14;
        oe[offset + 3] = l14 * r11 + l24 * r12 + l34 * r13 + l44 * r14;
        oe[offset + 4] = l11 * r21 + l21 * r22 + l31 * r23 + l41 * r24;
        oe[offset + 5] = l12 * r21 + l22 * r22 + l32 * r23 + l42 * r24;
        oe[offset + 6] = l13 * r21 + l23 * r22 + l33 * r23 + l43 * r24;
        oe[offset + 7] = l14 * r21 + l24 * r22 + l34 * r23 + l44 * r24;
        oe[offset + 8] = l11 * r31 + l21 * r32 + l31 * r33 + l41 * r34;
        oe[offset + 9] = l12 * r31 + l22 * r32 + l32 * r33 + l42 * r34;
        oe[offset + 10] = l13 * r31 + l23 * r32 + l33 * r33 + l43 * r34;
        oe[offset + 11] = l14 * r31 + l24 * r32 + l34 * r33 + l44 * r34;
        oe[offset + 12] = l11 * r41 + l21 * r42 + l31 * r43 + l41 * r44;
        oe[offset + 13] = l12 * r41 + l22 * r42 + l32 * r43 + l42 * r44;
        oe[offset + 14] = l13 * r41 + l23 * r42 + l33 * r43 + l43 * r44;
        oe[offset + 15] = l14 * r41 + l24 * r42 + l34 * r43 + l44 * r44;
    };
    /**
   * @internal
   * Simplify lodash get: https://github.com/lodash/lodash/blob/master/get.js.
   * @param target - The object to query.
   * @param path - The path of the property to get.
   * @returns Returns the resolved value.
   */ Utils._reflectGet = function _reflectGet(target, path) {
        var pathArr = this._stringToPath(path);
        var object = target;
        var index = 0;
        var length = pathArr.length;
        while(object != null && index < length){
            object = object[pathArr[index++]];
        }
        return index && index == length ? object : undefined;
    };
    /**
   * @internal
   * @remarks
   * Modified based on v8.
   * https://github.com/v8/v8/blob/7.2-lkgr/src/js/array.js
   */ Utils._quickSort = function _quickSort(a, from, to, compareFunc) {
        while(true){
            // Insertion sort is faster for short arrays.
            if (to - from <= 10) {
                this._insertionSort(a, from, to, compareFunc);
                return;
            }
            var third_index = from + to >> 1;
            // Find a pivot as the median of first, last and middle element.
            var v0 = a[from];
            var v1 = a[to - 1];
            var v2 = a[third_index];
            var c01 = compareFunc(v0, v1);
            if (c01 > 0) {
                // v1 < v0, so swap them.
                var tmp = v0;
                v0 = v1;
                v1 = tmp;
            } // v0 <= v1.
            var c02 = compareFunc(v0, v2);
            if (c02 >= 0) {
                // v2 <= v0 <= v1.
                var tmp1 = v0;
                v0 = v2;
                v2 = v1;
                v1 = tmp1;
            } else {
                // v0 <= v1 && v0 < v2
                var c12 = compareFunc(v1, v2);
                if (c12 > 0) {
                    // v0 <= v2 < v1
                    var tmp2 = v1;
                    v1 = v2;
                    v2 = tmp2;
                }
            }
            // v0 <= v1 <= v2
            a[from] = v0;
            a[to - 1] = v2;
            var pivot = v1;
            var low_end = from + 1; // Upper bound of elements lower than pivot.
            var high_start = to - 1; // Lower bound of elements greater than pivot.
            a[third_index] = a[low_end];
            a[low_end] = pivot;
            // From low_end to i are elements equal to pivot.
            // From i to high_start are elements that haven't been compared yet.
            partition: for(var i = low_end + 1; i < high_start; i++){
                var element = a[i];
                var order = compareFunc(element, pivot);
                if (order < 0) {
                    a[i] = a[low_end];
                    a[low_end] = element;
                    low_end++;
                } else if (order > 0) {
                    do {
                        high_start--;
                        if (high_start == i) break partition;
                        var top_elem = a[high_start];
                        order = compareFunc(top_elem, pivot);
                    }while (order > 0);
                    a[i] = a[high_start];
                    a[high_start] = element;
                    if (order < 0) {
                        element = a[i];
                        a[i] = a[low_end];
                        a[low_end] = element;
                        low_end++;
                    }
                }
            }
            if (to - high_start < low_end - from) {
                this._quickSort(a, high_start, to, compareFunc);
                to = low_end;
            } else {
                this._quickSort(a, from, low_end, compareFunc);
                from = high_start;
            }
        }
    };
    Utils._stringToPath = function _stringToPath(string) {
        var result = [];
        if (string.charCodeAt(0) === charCodeOfDot$1) {
            result.push("");
        }
        string.replace(rePropName$1, function(match, expression, quote, subString) {
            var key = match;
            if (quote) {
                key = subString.replace(reEscapeChar$1, "$1");
            } else if (expression) {
                key = expression.trim();
            }
            result.push(key);
        });
        return result;
    };
    Utils._insertionSort = function _insertionSort(a, from, to, compareFunc) {
        for(var i = from + 1; i < to; i++){
            var j = void 0;
            var element = a[i];
            for(j = i - 1; j >= from; j--){
                var tmp = a[j];
                var order = compareFunc(tmp, element);
                if (order > 0) {
                    a[j + 1] = tmp;
                } else {
                    break;
                }
            }
            a[j + 1] = element;
        }
    };
    return Utils;
}();
var charCodeOfDot$1 = ".".charCodeAt(0);
var reEscapeChar$1 = /\\(\\)?/g;
var rePropName$1 = RegExp(// Match anything that isn't a dot or bracket.
"[^.[\\]]+" + "|" + // Or match property names within brackets.
"\\[(?:" + // Match a non-string expression.
"([^\"'][^[]*)" + "|" + // Or match strings (supports escaping characters).
"([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2" + ")\\]" + "|" + // Or match "" as the space between consecutive dots or empty brackets.
"(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))", "g");

/**
 * High-performance unordered array, delete uses exchange method to improve performance, internal capacity only increases.
 */ var DisorderedArray = /*#__PURE__*/ function() {
    function DisorderedArray(count) {
        if (count === void 0) count = 0;
        /** The length of the array. */ this.length = 0;
        this._loopCounter = 0 // Ignore nested loops, use counter to solve the problem
        ;
        this._blankCount = 0;
        this._elements = new Array(count);
    }
    var _proto = DisorderedArray.prototype;
    /**
   * Add an element to disordered array.
   * @param element - The element to be added
   */ _proto.add = function add(element) {
        if (this.length === this._elements.length) {
            this._elements.push(element);
        } else {
            this._elements[this.length] = element;
        }
        this.length++;
    };
    /**
   * Delete the specified element.
   * @param element - The element to be deleted
   */ _proto.delete = function _delete(element) {
        // @todo: It can be optimized for custom binary search and other algorithms, currently this._elements>=this.length wastes performance.
        var index = this._elements.indexOf(element);
        this.deleteByIndex(index);
    };
    /**
   * Set the element at the specified index.
   * @param index - The index of the element to be set
   * @param element - The element to be set
   */ _proto.set = function set(index, element) {
        if (index >= this.length) {
            throw "Index is out of range.";
        }
        this._elements[index] = element;
    };
    /**
   * Get the element at the specified index.
   * @param index - The index of the element to be get
   * @returns The element at the specified index
   */ _proto.get = function get(index) {
        if (index >= this.length) {
            throw "Index is out of range.";
        }
        return this._elements[index];
    };
    /**
   * Delete the element at the specified index.
   * @param index - The index of the element to be deleted
   * @returns The replaced item is used to reset its index
   */ _proto.deleteByIndex = function deleteByIndex(index) {
        var elements = this._elements;
        var end;
        if (this._loopCounter > 0) {
            this._elements[index] = null;
            this._blankCount++;
        } else {
            var endIndex = this.length - 1;
            if (index !== endIndex) {
                end = elements[endIndex];
                elements[index] = end;
            }
            elements[endIndex] = null;
            this.length--;
        }
        return end;
    };
    /**
   * Loop through all elements.
   * @param callbackFn - The callback function
   * @param swapFn - The swap function can process the element after the callback function, it will be called after end looping(`isLopping` = true)
   */ _proto.forEach = function forEach(callbackFn, swapFn) {
        this._startLoop();
        var elements = this._elements;
        for(var i = 0, n = this.length; i < n; i++){
            var element = elements[i];
            element && callbackFn(element, i);
        }
        this._endLoop(swapFn);
    };
    /**
   * Loop through all elements and clean up the blank elements.
   * @param callbackFn - The callback function
   * @param swapFn - The swap function can process the element after the callback function,  it will be called after end looping(`isLopping` = true)
   */ _proto.forEachAndClean = function forEachAndClean(callbackFn, swapFn) {
        this._startLoop();
        var preEnd = this.length;
        var elements = this._elements;
        for(var i = 0, n = preEnd; i < n; i++){
            var element = elements[i];
            element && callbackFn(element, i);
        }
        this._endLoopAndClean(preEnd, elements, swapFn);
    };
    /**
   * Sort the array.
   * @param compareFn - The comparison function
   */ _proto.sort = function sort(compareFn) {
        Utils._quickSort(this._elements, 0, this.length, compareFn);
    };
    /**
   * Garbage collection, clean up all cached elements.
   */ _proto.garbageCollection = function garbageCollection() {
        this._elements.length = this.length;
    };
    _proto._startLoop = function _startLoop() {
        ++this._loopCounter;
    };
    _proto._endLoop = function _endLoop(swapFn) {
        if (--this._loopCounter !== 0) {
            return;
        }
        if (this._blankCount) {
            var from = 0;
            var to = this.length - 1;
            var elements = this._elements;
            partition: do {
                while(elements[from])if (++from >= to) {
                    break partition;
                }
                while(!elements[to])if (from >= --to) {
                    break partition;
                }
                var swapElement = elements[to];
                swapFn == null ? void 0 : swapFn(swapElement, from);
                elements[from++] = swapElement;
                elements[to--] = null;
            }while (from < to);
            this.length -= this._blankCount;
            this._blankCount = 0;
        }
    };
    _proto._endLoopAndClean = function _endLoopAndClean(preEnd, elements, swapFn) {
        if (--this._loopCounter !== 0) {
            return;
        }
        var index = 0;
        for(var i = preEnd, n = this.length; i < n; i++){
            var element = elements[i];
            if (!element) continue;
            elements[index] = element;
            swapFn == null ? void 0 : swapFn(element, index);
            index++;
        }
        this.length = index;
        this._blankCount = 0;
    };
    _create_class$2(DisorderedArray, [
        {
            key: "isLopping",
            get: /**
   * Get whether the array is in the loop.
   */ function get() {
                return this._loopCounter > 0;
            }
        }
    ]);
    return DisorderedArray;
}();

/**
 * Sprite's tiling mode enumeration.
 * Only works in `SpriteDrawMode.tiled` mode.
 */ var SpriteTileMode = /*#__PURE__*/ function(SpriteTileMode) {
    /** SpriteRenderer will tile continuously. */ SpriteTileMode[SpriteTileMode["Continuous"] = 0] = "Continuous";
    /** When the fractional part of the tiling multiple is greater than or equal to `SpriteRenderer.tileStretchValue`,
   * a tile will be added，and the number of tiles can only be an integer. */ SpriteTileMode[SpriteTileMode["Adaptive"] = 1] = "Adaptive";
    return SpriteTileMode;
}({});

var TiledSpriteAssembler = /*#__PURE__*/ function() {
    function TiledSpriteAssembler() {}
    TiledSpriteAssembler.resetData = function resetData(renderer, vertexCount) {
        if (vertexCount) {
            var manager = renderer._getChunkManager();
            var lastSubChunk = renderer._subChunk;
            var sizeChanged = lastSubChunk && lastSubChunk.vertexArea.size !== vertexCount * 9;
            sizeChanged && manager.freeSubChunk(lastSubChunk);
            if (!lastSubChunk || sizeChanged) {
                var newSubChunk = manager.allocateSubChunk(vertexCount);
                newSubChunk.indices = [];
                renderer._subChunk = newSubChunk;
            }
        }
    };
    TiledSpriteAssembler.updatePositions = function updatePositions(renderer, worldMatrix, width, height, pivot, flipX, flipY, referenceResolutionPerUnit) {
        if (referenceResolutionPerUnit === void 0) referenceResolutionPerUnit = 1;
        // Calculate row and column
        var rPos = TiledSpriteAssembler._posRow, cPos = TiledSpriteAssembler._posColumn, rUV = TiledSpriteAssembler._uvRow, cUV = TiledSpriteAssembler._uvColumn;
        TiledSpriteAssembler.resetData(renderer, TiledSpriteAssembler._calculateDividing(renderer, width, height, rPos, cPos, rUV, cUV, referenceResolutionPerUnit));
        // Update renderer's worldMatrix
        var pivotX = pivot.x, pivotY = pivot.y;
        var localTransX = width * pivotX;
        var localTransY = height * pivotY;
        // Position to World
        var modelMatrix = TiledSpriteAssembler._matrix;
        var wE = modelMatrix.elements;
        // Renderer's worldMatrix
        var pWE = worldMatrix.elements;
        var sx = flipX ? -1 : 1;
        var sy = flipY ? -1 : 1;
        var wE0, wE1, wE2;
        var wE4, wE5, wE6;
        wE0 = wE[0] = pWE[0] * sx, wE1 = wE[1] = pWE[1] * sx, wE2 = wE[2] = pWE[2] * sx;
        wE4 = wE[4] = pWE[4] * sy, wE5 = wE[5] = pWE[5] * sy, wE6 = wE[6] = pWE[6] * sy;
        wE[8] = pWE[8], wE[9] = pWE[9], wE[10] = pWE[10];
        var wE12 = wE[12] = pWE[12] - localTransX * wE0 - localTransY * wE4;
        var wE13 = wE[13] = pWE[13] - localTransX * wE1 - localTransY * wE5;
        var wE14 = wE[14] = pWE[14] - localTransX * wE2 - localTransY * wE6;
        // Assemble position and uv
        var rowLength = rPos.length - 1;
        var columnLength = cPos.length - 1;
        var subChunk = renderer._subChunk;
        var vertices = subChunk.chunk.vertices;
        var indices = subChunk.indices;
        var count = 0;
        var trianglesOffset = 0;
        for(var j = 0, o = subChunk.vertexArea.start; j < columnLength; j++){
            var doubleJ = j << 1;
            if (Number.isNaN(cUV.get(doubleJ)) || Number.isNaN(cUV.get(doubleJ + 1))) {
                continue;
            }
            for(var i = 0; i < rowLength; i++){
                var doubleI = i << 1;
                if (Number.isNaN(rUV.get(doubleI)) || Number.isNaN(rUV.get(doubleI + 1))) {
                    continue;
                }
                indices[trianglesOffset++] = count;
                indices[trianglesOffset++] = count + 1;
                indices[trianglesOffset++] = count + 2;
                indices[trianglesOffset++] = count + 2;
                indices[trianglesOffset++] = count + 1;
                indices[trianglesOffset++] = count + 3;
                count += 4;
                var l = rPos.get(i);
                var b = cPos.get(j);
                var r = rPos.get(i + 1);
                var t = cPos.get(j + 1);
                // left and bottom
                vertices[o] = wE0 * l + wE4 * b + wE12;
                vertices[o + 1] = wE1 * l + wE5 * b + wE13;
                vertices[o + 2] = wE2 * l + wE6 * b + wE14;
                // right and bottom
                vertices[o + 9] = wE0 * r + wE4 * b + wE12;
                vertices[o + 10] = wE1 * r + wE5 * b + wE13;
                vertices[o + 11] = wE2 * r + wE6 * b + wE14;
                // left and top
                vertices[o + 18] = wE0 * l + wE4 * t + wE12;
                vertices[o + 19] = wE1 * l + wE5 * t + wE13;
                vertices[o + 20] = wE2 * l + wE6 * t + wE14;
                // right and top
                vertices[o + 27] = wE0 * r + wE4 * t + wE12;
                vertices[o + 28] = wE1 * r + wE5 * t + wE13;
                vertices[o + 29] = wE2 * r + wE6 * t + wE14;
                o += 36;
            }
        }
        // @ts-ignore
        var bounds = renderer._bounds;
        bounds.min.set(rPos.get(0), cPos.get(0), 0);
        bounds.max.set(rPos.get(rowLength), cPos.get(columnLength), 0);
        bounds.transform(modelMatrix);
    };
    TiledSpriteAssembler.updateUVs = function updateUVs(renderer) {
        var posRow = TiledSpriteAssembler._posRow, posColumn = TiledSpriteAssembler._posColumn, uvRow = TiledSpriteAssembler._uvRow, uvColumn = TiledSpriteAssembler._uvColumn;
        var rowLength = posRow.length - 1;
        var columnLength = posColumn.length - 1;
        var subChunk = renderer._subChunk;
        var vertices = subChunk.chunk.vertices;
        for(var j = 0, o = subChunk.vertexArea.start + 3; j < columnLength; j++){
            var doubleJ = 2 * j;
            for(var i = 0; i < rowLength; i++){
                var uvL = uvRow.get(2 * i);
                var uvB = uvColumn.get(doubleJ);
                var uvR = uvRow.get(2 * i + 1);
                var uvT = uvColumn.get(doubleJ + 1);
                if (Number.isNaN(uvL) || Number.isNaN(uvB) || Number.isNaN(uvR) || Number.isNaN(uvT)) {
                    continue;
                }
                // left and bottom
                vertices[o] = uvL;
                vertices[o + 1] = uvB;
                // right and bottom
                vertices[o + 9] = uvR;
                vertices[o + 10] = uvB;
                // left and top
                vertices[o + 18] = uvL;
                vertices[o + 19] = uvT;
                // right and top
                vertices[o + 27] = uvR;
                vertices[o + 28] = uvT;
                o += 36;
            }
        }
    };
    TiledSpriteAssembler.updateColor = function updateColor(renderer, alpha) {
        var subChunk = renderer._subChunk;
        var _renderer_color = renderer.color, r = _renderer_color.r, g = _renderer_color.g, b = _renderer_color.b, a = _renderer_color.a;
        var finalAlpha = a * alpha;
        var vertices = subChunk.chunk.vertices;
        var vertexArea = subChunk.vertexArea;
        for(var i = 0, o = vertexArea.start + 5, n = vertexArea.size / 9; i < n; ++i, o += 9){
            vertices[o] = r;
            vertices[o + 1] = g;
            vertices[o + 2] = b;
            vertices[o + 3] = finalAlpha;
        }
    };
    TiledSpriteAssembler._calculateDividing = function _calculateDividing(renderer, width, height, rPos, cPos, rUV, cUV, referenceResolutionPerUnit) {
        var sprite = renderer.sprite, threshold = renderer.tiledAdaptiveThreshold;
        var border = sprite.border;
        var spritePositions = sprite._getPositions();
        var _spritePositions_ = spritePositions[0], left = _spritePositions_.x, bottom = _spritePositions_.y;
        var _spritePositions_1 = spritePositions[3], right = _spritePositions_1.x, top = _spritePositions_1.y;
        var _sprite__getUVs = sprite._getUVs(), spriteUV0 = _sprite__getUVs[0], spriteUV1 = _sprite__getUVs[1], spriteUV2 = _sprite__getUVs[2], spriteUV3 = _sprite__getUVs[3];
        var expectWidth = sprite.width * referenceResolutionPerUnit;
        var expectHeight = sprite.height * referenceResolutionPerUnit;
        var fixedL = expectWidth * border.x;
        var fixedR = expectWidth * border.z;
        var fixedLR = fixedL + fixedR;
        var fixedCW = expectWidth - fixedLR;
        var fixedT = expectHeight * border.w;
        var fixedB = expectHeight * border.y;
        var fixedTB = fixedT + fixedB;
        var fixedCH = expectHeight - fixedTB;
        var isAdaptive = renderer.tileMode === SpriteTileMode.Adaptive;
        var rType, rBlocksCount, rTiledCount;
        var cType, cBlocksCount, cTiledCount;
        if (fixedLR >= width) {
            rBlocksCount = 2;
            rType = 0;
        } else {
            if (fixedCW > MathUtil.zeroTolerance) {
                rTiledCount = (width - fixedLR) / fixedCW;
                if (isAdaptive) {
                    rTiledCount = rTiledCount % 1 >= threshold ? Math.ceil(rTiledCount) : Math.floor(rTiledCount);
                    rBlocksCount = 2 + rTiledCount;
                } else {
                    rBlocksCount = 2 + Math.ceil(rTiledCount);
                }
                rType = 2;
            } else {
                rBlocksCount = 2;
                rType = 1;
            }
        }
        if (fixedTB >= height) {
            cBlocksCount = 2;
            cType = 0;
        } else {
            if (fixedCH > MathUtil.zeroTolerance) {
                cTiledCount = (height - fixedTB) / fixedCH;
                if (isAdaptive) {
                    cTiledCount = cTiledCount % 1 >= threshold ? Math.ceil(cTiledCount) : Math.floor(cTiledCount);
                    cBlocksCount = 2 + cTiledCount;
                } else {
                    cBlocksCount = 2 + Math.ceil(cTiledCount);
                }
                cType = 2;
            } else {
                cBlocksCount = 2;
                cType = 1;
            }
        }
        rPos.length = cPos.length = rUV.length = cUV.length = 0;
        var vertexCount = rBlocksCount * cBlocksCount * 4;
        var maxVertexCount = renderer._getChunkManager().maxVertexCount;
        if (vertexCount > maxVertexCount) {
            rPos.add(width * left), rPos.add(width * right);
            cPos.add(height * bottom), cPos.add(height * top);
            rUV.add(spriteUV0.x), rUV.add(spriteUV3.x);
            cUV.add(spriteUV0.y), cUV.add(spriteUV3.y);
            Logger.warn("The number of vertices exceeds the upper limit(" + maxVertexCount + ").");
            return 4;
        }
        switch(rType){
            case 0:
                var scale = width / fixedLR;
                rPos.add(expectWidth * left * scale), rPos.add(fixedL * scale);
                rPos.add(width - expectWidth * (1 - right) * scale);
                rUV.add(spriteUV0.x), rUV.add(spriteUV1.x), rUV.add(spriteUV2.x), rUV.add(spriteUV3.x);
                break;
            case 1:
                rPos.add(expectWidth * left), rPos.add(fixedL), rPos.add(width - fixedR);
                rPos.add(width - expectWidth * (1 - right));
                rUV.add(spriteUV0.x), rUV.add(spriteUV1.x), rUV.add(NaN), rUV.add(NaN);
                rUV.add(spriteUV2.x), rUV.add(spriteUV3.x);
                break;
            case 2:
                var uv1 = spriteUV1.x;
                var uv2 = spriteUV2.x;
                var repeatWidth = (width - fixedLR) / rTiledCount;
                rPos.add(expectWidth * left), rPos.add(fixedL);
                rUV.add(spriteUV0.x), rUV.add(uv1), rUV.add(uv1);
                for(var i = 1, l = rBlocksCount - 2; i < l; i++){
                    rPos.add(fixedL + i * repeatWidth), rUV.add(uv2), rUV.add(uv1);
                }
                rPos.add(width - fixedR), rPos.add(width - expectWidth * (1 - right));
                isAdaptive ? rUV.add(uv2) : rUV.add((rTiledCount - (Math.ceil(rTiledCount) - 1)) * (uv2 - uv1) + uv1);
                rUV.add(uv2), rUV.add(spriteUV3.x);
                break;
        }
        switch(cType){
            case 0:
                var scale1 = height / fixedTB;
                cPos.add(expectHeight * bottom * scale1), cPos.add(fixedB * scale1);
                cPos.add(height - expectHeight * (1 - top) * scale1);
                cUV.add(spriteUV0.y), cUV.add(spriteUV1.y), cUV.add(spriteUV2.y), cUV.add(spriteUV3.y);
                break;
            case 1:
                cPos.add(expectHeight * bottom), cPos.add(fixedB), cPos.add(height - fixedT);
                cPos.add(height - expectHeight * (1 - top));
                cUV.add(spriteUV0.y), cUV.add(spriteUV1.y), cUV.add(NaN), cUV.add(NaN);
                cUV.add(spriteUV2.y), cUV.add(spriteUV3.y);
                break;
            case 2:
                var uv11 = spriteUV1.y;
                var uv21 = spriteUV2.y;
                var repeatHeight = (height - fixedTB) / cTiledCount;
                cPos.add(expectHeight * bottom), cPos.add(fixedB);
                cUV.add(spriteUV0.y), cUV.add(uv11), cUV.add(uv11);
                for(var i1 = 1, l1 = cBlocksCount - 2; i1 < l1; i1++){
                    cPos.add(fixedB + i1 * repeatHeight), cUV.add(uv21), cUV.add(uv11);
                }
                cPos.add(height - fixedT), cPos.add(height - expectHeight * (1 - top));
                isAdaptive ? cUV.add(uv21) : cUV.add((cTiledCount - (Math.ceil(cTiledCount) - 1)) * (uv21 - uv11) + uv11);
                cUV.add(uv21), cUV.add(spriteUV3.y);
                break;
        }
        return vertexCount;
    };
    return TiledSpriteAssembler;
}();
TiledSpriteAssembler._matrix = new Matrix();
TiledSpriteAssembler._posRow = new DisorderedArray();
TiledSpriteAssembler._posColumn = new DisorderedArray();
TiledSpriteAssembler._uvRow = new DisorderedArray();
TiledSpriteAssembler._uvColumn = new DisorderedArray();
TiledSpriteAssembler = __decorate$1([
    StaticInterfaceImplement()
], TiledSpriteAssembler);

/**
 * Sprite Atlas.
 */ var SpriteAtlas = /*#__PURE__*/ function(ReferResource) {
    _inherits$2(SpriteAtlas, ReferResource);
    function SpriteAtlas(engine) {
        var _this;
        _this = ReferResource.call(this, engine) || this, _this._sprites = new Array(), _this._spriteNamesToIndex = {};
        return _this;
    }
    var _proto = SpriteAtlas.prototype;
    /**
   * Get the last sprite named 'name' from the atlas.
   * @param name - The name of the sprite you want to find
   * @returns The sprite you want to find
   */ _proto.getSprite = function getSprite(name) {
        var sprite = this._sprites[this._spriteNamesToIndex[name]];
        if (!sprite) {
            console.warn("There is no sprite named " + name + " in the atlas.");
        }
        return sprite;
    };
    /**
   * Get all the sprite named 'name' from the atlas.
   * @param name - The name of the sprites you want to find
   * @param outSprites - This array holds the sprites found
   * @returns The sprites you want to find
   */ _proto.getSprites = function getSprites(name, outSprites) {
        outSprites.length = 0;
        var i = this._spriteNamesToIndex[name];
        if (i !== undefined) {
            var _sprites = this._sprites;
            for(; i >= 0; i--){
                var sprite = _sprites[i];
                sprite.name === name && outSprites.push(sprite);
            }
        } else {
            console.warn("The name of the sprite you want to find is not exit in SpriteAtlas.");
        }
        return outSprites;
    };
    /**
   * @internal
   */ _proto._addSprite = function _addSprite(sprite) {
        this._spriteNamesToIndex[sprite.name] = this._sprites.push(sprite) - 1;
        sprite._atlas = this;
        sprite.isGCIgnored = true;
    };
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        ReferResource.prototype._onDestroy.call(this);
        var _this = this, sprites = _this._sprites;
        for(var i = 0, n = sprites.length; i < n; i++){
            sprites[i].destroy();
        }
        sprites.length = 0;
        this._sprites = null;
        this._spriteNamesToIndex = null;
    };
    _create_class$2(SpriteAtlas, [
        {
            key: "sprites",
            get: /**
   * All the sprites in the atlas.
   */ function get() {
                return this._sprites;
            }
        }
    ]);
    return SpriteAtlas;
}(ReferResource);

/**
 * Sprite's drawing mode enumeration.
 */ var SpriteDrawMode = /*#__PURE__*/ function(SpriteDrawMode) {
    /** Overall scaling when modifying size. */ SpriteDrawMode[SpriteDrawMode["Simple"] = 0] = "Simple";
    /** When modifying the size of the renderer, it scales to fill the range according to the sprite border settings. */ SpriteDrawMode[SpriteDrawMode["Sliced"] = 1] = "Sliced";
    /** When modifying the size of the renderer, it will tile to fill the range according to the sprite border settings. */ SpriteDrawMode[SpriteDrawMode["Tiled"] = 2] = "Tiled";
    return SpriteDrawMode;
}({});

/**
 * Sprite mask interaction.
 */ var SpriteMaskInteraction = /*#__PURE__*/ function(SpriteMaskInteraction) {
    /** The sprite will not interact with the masking system. */ SpriteMaskInteraction[SpriteMaskInteraction["None"] = 0] = "None";
    /** The sprite will be visible only in areas where a mask is present. */ SpriteMaskInteraction[SpriteMaskInteraction["VisibleInsideMask"] = 1] = "VisibleInsideMask";
    /** The sprite will be visible only in areas where no mask is present. */ SpriteMaskInteraction[SpriteMaskInteraction["VisibleOutsideMask"] = 2] = "VisibleOutsideMask";
    return SpriteMaskInteraction;
}({});

/**
 * Sprite Property Dirty Flag.
 */ var SpriteModifyFlags = /*#__PURE__*/ function(SpriteModifyFlags) {
    /** The texture of sprite changes. */ SpriteModifyFlags[SpriteModifyFlags["texture"] = 1] = "texture";
    /** The size of sprite changes. */ SpriteModifyFlags[SpriteModifyFlags["size"] = 2] = "size";
    /** The rotation of sprite changes. */ SpriteModifyFlags[SpriteModifyFlags["atlasRotate"] = 4] = "atlasRotate";
    /** The atlasRegion of sprite changes. */ SpriteModifyFlags[SpriteModifyFlags["atlasRegion"] = 8] = "atlasRegion";
    /** The atlasRegionOffset of sprite changes. */ SpriteModifyFlags[SpriteModifyFlags["atlasRegionOffset"] = 16] = "atlasRegionOffset";
    /** The region of sprite changes. */ SpriteModifyFlags[SpriteModifyFlags["region"] = 32] = "region";
    /** The pivot of sprite changes. */ SpriteModifyFlags[SpriteModifyFlags["pivot"] = 64] = "pivot";
    /** The border of sprite changes. */ SpriteModifyFlags[SpriteModifyFlags["border"] = 128] = "border";
    /** The sprite destroyed. */ SpriteModifyFlags[SpriteModifyFlags["destroy"] = 256] = "destroy";
    return SpriteModifyFlags;
}({});

/**
 * The horizontal alignment of the text.
 */ var TextHorizontalAlignment = /*#__PURE__*/ function(TextHorizontalAlignment) {
    /** Align left horizontally */ TextHorizontalAlignment[TextHorizontalAlignment["Left"] = 0] = "Left";
    /** Align center horizontally */ TextHorizontalAlignment[TextHorizontalAlignment["Center"] = 1] = "Center";
    /** Align right horizontally */ TextHorizontalAlignment[TextHorizontalAlignment["Right"] = 2] = "Right";
    return TextHorizontalAlignment;
}({});
/**
 * The vertical alignment of the text.
 */ var TextVerticalAlignment = /*#__PURE__*/ function(TextVerticalAlignment) {
    /** Align top vertically */ TextVerticalAlignment[TextVerticalAlignment["Top"] = 0] = "Top";
    /** Align center vertically */ TextVerticalAlignment[TextVerticalAlignment["Center"] = 1] = "Center";
    /** Align bottom vertically */ TextVerticalAlignment[TextVerticalAlignment["Bottom"] = 2] = "Bottom";
    return TextVerticalAlignment;
}({});

/**
 * @internal
 */ var UpdateFlagManager = /*#__PURE__*/ function() {
    function UpdateFlagManager() {
        /** @internal */ this._updateFlags = [];
        this._listeners = [];
    }
    var _proto = UpdateFlagManager.prototype;
    /**
   * Create a UpdateFlag.
   * @returns - The UpdateFlag.
   */ _proto.createFlag = function createFlag(type) {
        var flag = new type();
        this.addFlag(flag);
        return flag;
    };
    /**
   * Add a UpdateFlag.
   * @param flag - The UpdateFlag.
   */ _proto.addFlag = function addFlag(flag) {
        this._updateFlags.push(flag);
        flag._flagManagers.push(this);
    };
    /**
   * Remove a UpdateFlag.
   * @param flag - The UpdateFlag.
   */ _proto.removeFlag = function removeFlag(flag) {
        var success = Utils.removeFromArray(this._updateFlags, flag);
        if (success) {
            Utils.removeFromArray(flag._flagManagers, this);
        }
    };
    /**
   * Add a listener.
   * @param listener - The listener
   */ _proto.addListener = function addListener(listener) {
        this._listeners.push(listener);
    };
    /**
   * Remove a listener.
   * @param listener - The listener
   */ _proto.removeListener = function removeListener(listener) {
        Utils.removeFromArray(this._listeners, listener);
    };
    /**
   * Dispatch a event.
   * @param type - Event type, usually in the form of enumeration
   * @param param - Event param
   */ _proto.dispatch = function dispatch(type, param) {
        var updateFlags = this._updateFlags;
        for(var i = updateFlags.length - 1; i >= 0; i--){
            updateFlags[i].dispatch(type, param);
        }
        var listeners = this._listeners;
        for(var i1 = listeners.length - 1; i1 >= 0; i1--){
            listeners[i1](type, param);
        }
    };
    return UpdateFlagManager;
}();

/**
 * 2D sprite.
 */ var Sprite = /*#__PURE__*/ function(ReferResource) {
    _inherits$2(Sprite, ReferResource);
    function Sprite(engine, texture, region, pivot, border, name) {
        if (texture === void 0) texture = null;
        if (region === void 0) region = null;
        if (pivot === void 0) pivot = null;
        if (border === void 0) border = null;
        if (name === void 0) name = null;
        var _this;
        _this = ReferResource.call(this, engine) || this, _this._automaticWidth = 0, _this._automaticHeight = 0, _this._customWidth = undefined, _this._customHeight = undefined, _this._positions = [
            new Vector2(),
            new Vector2(),
            new Vector2(),
            new Vector2()
        ], _this._uvs = [
            new Vector2(),
            new Vector2(),
            new Vector2(),
            new Vector2()
        ], _this._bounds = new BoundingBox(), _this._texture = null, _this._atlasRotated = false, _this._atlasRegion = new Rect(0, 0, 1, 1), _this._atlasRegionOffset = new Vector4(0, 0, 0, 0), _this._region = new Rect(0, 0, 1, 1), _this._pivot = new Vector2(0.5, 0.5), _this._border = new Vector4(0, 0, 0, 0), _this._dirtyUpdateFlag = 7, /** @internal */ _this._updateFlagManager = new UpdateFlagManager();
        _this._texture = texture;
        _this._onRegionChange = _this._onRegionChange.bind(_this);
        _this._onPivotChange = _this._onPivotChange.bind(_this);
        _this._onBorderChange = _this._onBorderChange.bind(_this);
        // @ts-ignore
        _this._region._onValueChanged = _this._onRegionChange;
        // @ts-ignore
        _this._pivot._onValueChanged = _this._onPivotChange;
        // @ts-ignore
        _this._border._onValueChanged = _this._onBorderChange;
        region && _this._region.copyFrom(region);
        pivot && _this._pivot.copyFrom(pivot);
        border && _this._border.copyFrom(border);
        _this.name = name;
        return _this;
    }
    var _proto = Sprite.prototype;
    /**
   * Clone.
   * @returns Cloned sprite
   */ _proto.clone = function clone() {
        var cloneSprite = new Sprite(this._engine, this._texture, this._region, this._pivot, this._border, this.name);
        cloneSprite._atlasRotated = this._atlasRotated;
        cloneSprite._atlasRegion.copyFrom(this._atlasRegion);
        cloneSprite._atlasRegionOffset.copyFrom(this._atlasRegionOffset);
        return cloneSprite;
    };
    /**
   * @internal
   */ _proto._getPositions = function _getPositions() {
        this._dirtyUpdateFlag & 1 && this._updatePositions();
        return this._positions;
    };
    /**
   * @internal
   */ _proto._getUVs = function _getUVs() {
        this._dirtyUpdateFlag & 2 && this._updateUVs();
        return this._uvs;
    };
    /**
   * @internal
   */ _proto._getBounds = function _getBounds() {
        this._dirtyUpdateFlag & 1 && this._updatePositions();
        return this._bounds;
    };
    /**
   * @internal
   */ _proto._addReferCount = function _addReferCount(value) {
        var _this__atlas;
        ReferResource.prototype._addReferCount.call(this, value);
        (_this__atlas = this._atlas) == null ? void 0 : _this__atlas._addReferCount(value);
    };
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        this._dispatchSpriteChange(SpriteModifyFlags.destroy);
        ReferResource.prototype._onDestroy.call(this);
        this._positions.length = 0;
        this._positions = null;
        this._uvs.length = 0;
        this._uvs = null;
        this._atlasRegion = null;
        this._atlasRegionOffset = null;
        this._region = null;
        this._pivot = null;
        this._border = null;
        this._bounds = null;
        this._atlas = null;
        this._texture = null;
    };
    _proto._calDefaultSize = function _calDefaultSize() {
        if (this._texture) {
            var _this = this, _texture = _this._texture, _atlasRegion = _this._atlasRegion, _atlasRegionOffset = _this._atlasRegionOffset, _region = _this._region;
            var pixelsPerUnitReciprocal = 1.0 / Engine._pixelsPerUnit;
            this._automaticWidth = _texture.width * _atlasRegion.width / (1 - _atlasRegionOffset.x - _atlasRegionOffset.z) * _region.width * pixelsPerUnitReciprocal;
            this._automaticHeight = _texture.height * _atlasRegion.height / (1 - _atlasRegionOffset.y - _atlasRegionOffset.w) * _region.height * pixelsPerUnitReciprocal;
        } else {
            this._automaticWidth = this._automaticHeight = 0;
        }
        this._dirtyUpdateFlag &= -5;
    };
    _proto._updatePositions = function _updatePositions() {
        var blank = this._atlasRegionOffset;
        var _this__region = this._region, regionX = _this__region.x, regionY = _this__region.y, regionW = _this__region.width, regionH = _this__region.height;
        var regionRight = 1 - regionX - regionW;
        var regionBottom = 1 - regionY - regionH;
        var left = Math.max(blank.x - regionX, 0) / regionW;
        var bottom = Math.max(blank.w - regionY, 0) / regionH;
        var right = 1 - Math.max(blank.z - regionRight, 0) / regionW;
        var top = 1 - Math.max(blank.y - regionBottom, 0) / regionH;
        // Update positions.
        // ---------------
        //  2 - 3
        //  |   |
        //  0 - 1
        // ---------------
        var positions = this._positions;
        positions[0].set(left, bottom);
        positions[1].set(right, bottom);
        positions[2].set(left, top);
        positions[3].set(right, top);
        var bounds = this._bounds;
        bounds.min.set(left, bottom, 0);
        bounds.max.set(right, top, 0);
        this._dirtyUpdateFlag &= -2;
    };
    _proto._updateUVs = function _updateUVs() {
        var _this = this, uv = _this._uvs, atlasRegionOffset = _this._atlasRegionOffset;
        var _this__region = this._region, regionX = _this__region.x, regionY = _this__region.y, regionW = _this__region.width, regionH = _this__region.height;
        var regionRight = 1 - regionX - regionW;
        var regionBottom = 1 - regionY - regionH;
        var _this__atlasRegion = this._atlasRegion, atlasRegionX = _this__atlasRegion.x, atlasRegionY = _this__atlasRegion.y, atlasRegionW = _this__atlasRegion.width, atlasRegionH = _this__atlasRegion.height;
        var offsetLeft = atlasRegionOffset.x, offsetTop = atlasRegionOffset.y, offsetRight = atlasRegionOffset.z, offsetBottom = atlasRegionOffset.w;
        var realWidth = atlasRegionW / (1 - offsetLeft - offsetRight);
        var realHeight = atlasRegionH / (1 - offsetTop - offsetBottom);
        // Coordinates of the four boundaries.
        var left = Math.max(regionX - offsetLeft, 0) * realWidth + atlasRegionX;
        var top = Math.max(regionBottom - offsetTop, 0) * realHeight + atlasRegionY;
        var right = atlasRegionW + atlasRegionX - Math.max(regionRight - offsetRight, 0) * realWidth;
        var bottom = atlasRegionH + atlasRegionY - Math.max(regionY - offsetBottom, 0) * realHeight;
        var _this__border = this._border, borderLeft = _this__border.x, borderBottom = _this__border.y, borderRight = _this__border.z, borderTop = _this__border.w;
        // Left-Bottom
        uv[0].set(left, bottom);
        // Border ( Left-Bottom )
        uv[1].set((regionX - offsetLeft + borderLeft * regionW) * realWidth + atlasRegionX, atlasRegionH + atlasRegionY - (regionY - offsetBottom + borderBottom * regionH) * realHeight);
        // Border ( Right-Top )
        uv[2].set(atlasRegionW + atlasRegionX - (regionRight - offsetRight + borderRight * regionW) * realWidth, (regionBottom - offsetTop + borderTop * regionH) * realHeight + atlasRegionY);
        // Right-Top
        uv[3].set(right, top);
        this._dirtyUpdateFlag &= -3;
    };
    _proto._dispatchSpriteChange = function _dispatchSpriteChange(type) {
        switch(type){
            case SpriteModifyFlags.texture:
                this._dirtyUpdateFlag |= 4;
                break;
            case SpriteModifyFlags.atlasRegionOffset:
            case SpriteModifyFlags.region:
                this._dirtyUpdateFlag |= 7;
                break;
            case SpriteModifyFlags.atlasRegion:
                this._dirtyUpdateFlag |= 4 | 2;
                break;
            case SpriteModifyFlags.border:
                this._dirtyUpdateFlag |= 2;
                break;
        }
        this._updateFlagManager.dispatch(type);
    };
    _proto._onRegionChange = function _onRegionChange() {
        var _this = this, region = _this._region;
        // @ts-ignore
        region._onValueChanged = null;
        var x = MathUtil.clamp(region.x, 0, 1);
        var y = MathUtil.clamp(region.y, 0, 1);
        region.set(x, y, MathUtil.clamp(region.width, 0, 1 - x), MathUtil.clamp(region.height, 0, 1 - y));
        this._dispatchSpriteChange(SpriteModifyFlags.region);
        if (this._customWidth === undefined || this._customHeight === undefined) {
            this._dispatchSpriteChange(SpriteModifyFlags.size);
        }
        // @ts-ignore
        region._onValueChanged = this._onRegionChange;
    };
    _proto._onPivotChange = function _onPivotChange() {
        this._dispatchSpriteChange(SpriteModifyFlags.pivot);
    };
    _proto._onBorderChange = function _onBorderChange() {
        var _this = this, border = _this._border;
        // @ts-ignore
        border._onValueChanged = null;
        var x = MathUtil.clamp(border.x, 0, 1);
        var y = MathUtil.clamp(border.y, 0, 1);
        border.set(x, y, MathUtil.clamp(border.z, 0, 1 - x), MathUtil.clamp(border.w, 0, 1 - y));
        this._dispatchSpriteChange(SpriteModifyFlags.border);
        // @ts-ignore
        border._onValueChanged = this._onBorderChange;
    };
    _create_class$2(Sprite, [
        {
            key: "texture",
            get: /**
   * The reference to the used texture.
   */ function get() {
                return this._texture;
            },
            set: function set(value) {
                if (this._texture !== value) {
                    this._texture = value;
                    this._dispatchSpriteChange(SpriteModifyFlags.texture);
                    if (this._customWidth === undefined || this._customHeight === undefined) {
                        this._dispatchSpriteChange(SpriteModifyFlags.size);
                    }
                }
            }
        },
        {
            key: "width",
            get: /**
   * The width of the sprite (in world coordinates).
   *
   * @remarks
   * If width is set, return the set value,
   * otherwise return the width calculated according to `Texture.width`, `Sprite.region`, `Sprite.atlasRegion` and `Sprite.atlasRegionOffset`.
   */ function get() {
                if (this._customWidth !== undefined) {
                    return this._customWidth;
                } else {
                    this._dirtyUpdateFlag & 4 && this._calDefaultSize();
                    return this._automaticWidth;
                }
            },
            set: function set(value) {
                if (this._customWidth !== value) {
                    this._customWidth = value;
                    this._dispatchSpriteChange(SpriteModifyFlags.size);
                }
            }
        },
        {
            key: "height",
            get: /**
   * The height of the sprite (in world coordinates).
   *
   * @remarks
   * If height is set, return the set value,
   * otherwise return the height calculated according to `Texture.height`, `Sprite.region`, `Sprite.atlasRegion` and `Sprite.atlasRegionOffset`.
   */ function get() {
                if (this._customHeight !== undefined) {
                    return this._customHeight;
                } else {
                    this._dirtyUpdateFlag & 4 && this._calDefaultSize();
                    return this._automaticHeight;
                }
            },
            set: function set(value) {
                if (this._customHeight !== value) {
                    this._customHeight = value;
                    this._dispatchSpriteChange(SpriteModifyFlags.size);
                }
            }
        },
        {
            key: "atlasRotated",
            get: /**
   * Is it rotated 90 degrees clockwise when packing.
   */ function get() {
                return this._atlasRotated;
            },
            set: function set(value) {
                if (this._atlasRotated != value) {
                    this._atlasRotated = value;
                }
            }
        },
        {
            key: "atlasRegion",
            get: /**
   * The rectangle region of the original texture on its atlas texture, specified in normalized.
   */ function get() {
                return this._atlasRegion;
            },
            set: function set(value) {
                var x = MathUtil.clamp(value.x, 0, 1);
                var y = MathUtil.clamp(value.y, 0, 1);
                this._atlasRegion.set(x, y, MathUtil.clamp(value.width, 0, 1 - x), MathUtil.clamp(value.height, 0, 1 - y));
                this._dispatchSpriteChange(SpriteModifyFlags.atlasRegion);
                if (this._customWidth === undefined || this._customHeight === undefined) {
                    this._dispatchSpriteChange(SpriteModifyFlags.size);
                }
            }
        },
        {
            key: "atlasRegionOffset",
            get: /**
   * The rectangle region offset of the original texture on its atlas texture, specified in normalized.
   */ function get() {
                return this._atlasRegionOffset;
            },
            set: function set(value) {
                var x = MathUtil.clamp(value.x, 0, 1);
                var y = MathUtil.clamp(value.y, 0, 1);
                this._atlasRegionOffset.set(x, y, MathUtil.clamp(value.z, 0, 1 - x), MathUtil.clamp(value.w, 0, 1 - y));
                this._dispatchSpriteChange(SpriteModifyFlags.atlasRegionOffset);
                if (this._customWidth === undefined || this._customHeight === undefined) {
                    this._dispatchSpriteChange(SpriteModifyFlags.size);
                }
            }
        },
        {
            key: "region",
            get: /**
   * The rectangle region of the sprite, specified in normalized.
   */ function get() {
                return this._region;
            },
            set: function set(value) {
                this._region !== value && this._region.copyFrom(value);
            }
        },
        {
            key: "pivot",
            get: /**
   * Location of the sprite's center point in the rectangle region, specified in normalized.
   * The origin is at the bottom left and the default value is (0.5, 0.5).
   */ function get() {
                return this._pivot;
            },
            set: function set(value) {
                this._pivot !== value && this._pivot.copyFrom(value);
            }
        },
        {
            key: "border",
            get: /**
   * Get the border of the sprite.
   *  x      y       z     w
   *  |      |       |     |
   * Left, bottom, right, top.
   * @remarks only use in sliced mode.
   */ function get() {
                return this._border;
            },
            set: function set(value) {
                this._border !== value && this._border.copyFrom(value);
            }
        }
    ]);
    return Sprite;
}(ReferResource);
__decorate$1([
    ignoreClone
], Sprite.prototype, "_onRegionChange", null);
__decorate$1([
    ignoreClone
], Sprite.prototype, "_onPivotChange", null);
__decorate$1([
    ignoreClone
], Sprite.prototype, "_onBorderChange", null);

/**
 * The Background mode enumeration.
 */ var BackgroundMode = /*#__PURE__*/ function(BackgroundMode) {
    /* Solid color. */ BackgroundMode[BackgroundMode["SolidColor"] = 0] = "SolidColor";
    /* Sky. */ BackgroundMode[BackgroundMode["Sky"] = 1] = "Sky";
    /** Texture */ BackgroundMode[BackgroundMode["Texture"] = 2] = "Texture";
    return BackgroundMode;
}({});

/**
 * Filling mode of background texture.
 */ var BackgroundTextureFillMode = /*#__PURE__*/ function(BackgroundTextureFillMode) {
    /* Maintain the aspect ratio and scale the texture to fit the width of the canvas. */ BackgroundTextureFillMode[BackgroundTextureFillMode["AspectFitWidth"] = 0] = "AspectFitWidth";
    /* Maintain the aspect ratio and scale the texture to fit the height of the canvas. */ BackgroundTextureFillMode[BackgroundTextureFillMode["AspectFitHeight"] = 1] = "AspectFitHeight";
    /* Scale the texture fully fills the canvas. */ BackgroundTextureFillMode[BackgroundTextureFillMode["Fill"] = 2] = "Fill";
    return BackgroundTextureFillMode;
}({});

/**
 * Blend factor.
 * @remarks defines which function is used for blending pixel arithmetic
 */ var BlendFactor = /*#__PURE__*/ function(BlendFactor) {
    /** (0, 0, 0, 0)*/ BlendFactor[BlendFactor["Zero"] = 0] = "Zero";
    /** (1, 1, 1, 1)*/ BlendFactor[BlendFactor["One"] = 1] = "One";
    /** (Rs, Gs, Bs, As) */ BlendFactor[BlendFactor["SourceColor"] = 2] = "SourceColor";
    /** (1 - Rs, 1 - Gs, 1 - Bs, 1 - As)*/ BlendFactor[BlendFactor["OneMinusSourceColor"] = 3] = "OneMinusSourceColor";
    /** (Rd, Gd, Bd, Ad)*/ BlendFactor[BlendFactor["DestinationColor"] = 4] = "DestinationColor";
    /** (1 - Rd, 1 - Gd, 1 - Bd, 1 - Ad)*/ BlendFactor[BlendFactor["OneMinusDestinationColor"] = 5] = "OneMinusDestinationColor";
    /** (As, As, As, As)*/ BlendFactor[BlendFactor["SourceAlpha"] = 6] = "SourceAlpha";
    /** (1 - As, 1 - As, 1 - As, 1 - As)*/ BlendFactor[BlendFactor["OneMinusSourceAlpha"] = 7] = "OneMinusSourceAlpha";
    /** (Ad, Ad, Ad, Ad)*/ BlendFactor[BlendFactor["DestinationAlpha"] = 8] = "DestinationAlpha";
    /** (1 - Ad, 1 - Ad, 1 - Ad, 1 - Ad)*/ BlendFactor[BlendFactor["OneMinusDestinationAlpha"] = 9] = "OneMinusDestinationAlpha";
    /** (min(As, 1 - Ad), min(As, 1 - Ad), min(As, 1 - Ad), 10)*/ BlendFactor[BlendFactor["SourceAlphaSaturate"] = 10] = "SourceAlphaSaturate";
    /** (Rc, Gc, Bc, Ac)*/ BlendFactor[BlendFactor["BlendColor"] = 11] = "BlendColor";
    /** (1 - Rc, 1 - Gc, 1 - Bc, 1 - Ac)*/ BlendFactor[BlendFactor["OneMinusBlendColor"] = 12] = "OneMinusBlendColor";
    return BlendFactor;
}({});

/**
 * Blend operation function.
 * @remarks defines how a new pixel is combined with a pixel.
 */ var BlendOperation = /*#__PURE__*/ function(BlendOperation) {
    /** src + dst. */ BlendOperation[BlendOperation["Add"] = 0] = "Add";
    /** src - dst. */ BlendOperation[BlendOperation["Subtract"] = 1] = "Subtract";
    /** dst - src. */ BlendOperation[BlendOperation["ReverseSubtract"] = 2] = "ReverseSubtract";
    /** Minimum of source and destination. */ BlendOperation[BlendOperation["Min"] = 3] = "Min";
    /** Maximum of source and destination. */ BlendOperation[BlendOperation["Max"] = 4] = "Max";
    return BlendOperation;
}({});

/**
 * Set which color channels can be rendered to frame buffer.
 * @remarks enumeration can be combined using bit operations.
 */ var ColorWriteMask = /*#__PURE__*/ function(ColorWriteMask) {
    /** Do not write to any channel. */ ColorWriteMask[ColorWriteMask["None"] = 0] = "None";
    /** Write to the red channel. */ ColorWriteMask[ColorWriteMask["Red"] = 1] = "Red";
    /** Write to the green channel. */ ColorWriteMask[ColorWriteMask["Green"] = 2] = "Green";
    /** Write to the blue channel. */ ColorWriteMask[ColorWriteMask["Blue"] = 4] = "Blue";
    /** Write to the alpha channel. */ ColorWriteMask[ColorWriteMask["Alpha"] = 8] = "Alpha";
    /** Write to all channel. */ ColorWriteMask[ColorWriteMask["All"] = 15] = "All";
    return ColorWriteMask;
}({});

/**
 * Depth/Stencil comparison function.
 * @remarks Specifies a function that compares incoming pixel depth/stencil to the current depth/stencil buffer value.
 */ var CompareFunction = /*#__PURE__*/ function(CompareFunction) {
    /** never pass. */ CompareFunction[CompareFunction["Never"] = 0] = "Never";
    /** pass if the incoming value is less than the depth/stencil buffer value. */ CompareFunction[CompareFunction["Less"] = 1] = "Less";
    /** pass if the incoming value equals the depth/stencil buffer value. */ CompareFunction[CompareFunction["Equal"] = 2] = "Equal";
    /** pass if the incoming value is less than or equal to the depth/stencil buffer value. */ CompareFunction[CompareFunction["LessEqual"] = 3] = "LessEqual";
    /** pass if the incoming value is greater than the depth/stencil buffer value. */ CompareFunction[CompareFunction["Greater"] = 4] = "Greater";
    /** pass if the incoming value is not equal to the depth/stencil buffer value. */ CompareFunction[CompareFunction["NotEqual"] = 5] = "NotEqual";
    /** pass if the incoming value is greater than or equal to the depth/stencil buffer value. */ CompareFunction[CompareFunction["GreaterEqual"] = 6] = "GreaterEqual";
    /** always pass. */ CompareFunction[CompareFunction["Always"] = 7] = "Always";
    return CompareFunction;
}({});

/**
 * Culling mode.
 * @remarks specifies whether or not front- and/or back-facing polygons can be culled.
 */ var CullMode = /*#__PURE__*/ function(CullMode) {
    /** Disable culling. */ CullMode[CullMode["Off"] = 0] = "Off";
    /** cut the front-face of the polygons. */ CullMode[CullMode["Front"] = 1] = "Front";
    /** cut the back-face of the polygons. */ CullMode[CullMode["Back"] = 2] = "Back";
    return CullMode;
}({});

var RenderStateElementKey = /*#__PURE__*/ function(RenderStateElementKey) {
    /** Blend state enabled for target 0 key. */ RenderStateElementKey[RenderStateElementKey["BlendStateEnabled0"] = 0] = "BlendStateEnabled0";
    /** Blend state color blend operation for target 0 key. */ RenderStateElementKey[RenderStateElementKey["BlendStateColorBlendOperation0"] = 1] = "BlendStateColorBlendOperation0";
    /** Blend state alpha blend operation for target 0 key. */ RenderStateElementKey[RenderStateElementKey["BlendStateAlphaBlendOperation0"] = 2] = "BlendStateAlphaBlendOperation0";
    /** Blend state source color blend factor for target 0 key. */ RenderStateElementKey[RenderStateElementKey["BlendStateSourceColorBlendFactor0"] = 3] = "BlendStateSourceColorBlendFactor0";
    /** Blend state source alpha blend factor for target 0 key. */ RenderStateElementKey[RenderStateElementKey["BlendStateSourceAlphaBlendFactor0"] = 4] = "BlendStateSourceAlphaBlendFactor0";
    /** Blend state destination color blend factor for target 0 key. */ RenderStateElementKey[RenderStateElementKey["BlendStateDestinationColorBlendFactor0"] = 5] = "BlendStateDestinationColorBlendFactor0";
    /** Blend state destination alpha blend factor for target 0 key. */ RenderStateElementKey[RenderStateElementKey["BlendStateDestinationAlphaBlendFactor0"] = 6] = "BlendStateDestinationAlphaBlendFactor0";
    /** Blend state color write mask for target 0 key. */ RenderStateElementKey[RenderStateElementKey["BlendStateColorWriteMask0"] = 7] = "BlendStateColorWriteMask0";
    /** Blend state blend color key. */ RenderStateElementKey[RenderStateElementKey["BlendStateBlendColor"] = 8] = "BlendStateBlendColor";
    /** Blend state alpha to coverage key. */ RenderStateElementKey[RenderStateElementKey["BlendStateAlphaToCoverage"] = 9] = "BlendStateAlphaToCoverage";
    /** Depth state enabled key. */ RenderStateElementKey[RenderStateElementKey["DepthStateEnabled"] = 10] = "DepthStateEnabled";
    /** Depth state write enabled key. */ RenderStateElementKey[RenderStateElementKey["DepthStateWriteEnabled"] = 11] = "DepthStateWriteEnabled";
    /** Depth state compare function key. */ RenderStateElementKey[RenderStateElementKey["DepthStateCompareFunction"] = 12] = "DepthStateCompareFunction";
    /** Stencil state enabled key. */ RenderStateElementKey[RenderStateElementKey["StencilStateEnabled"] = 13] = "StencilStateEnabled";
    /** Stencil state reference value key. */ RenderStateElementKey[RenderStateElementKey["StencilStateReferenceValue"] = 14] = "StencilStateReferenceValue";
    /** Stencil state read mask key. */ RenderStateElementKey[RenderStateElementKey["StencilStateMask"] = 15] = "StencilStateMask";
    /** Stencil state write mask key. */ RenderStateElementKey[RenderStateElementKey["StencilStateWriteMask"] = 16] = "StencilStateWriteMask";
    /** Stencil state compare function front key. */ RenderStateElementKey[RenderStateElementKey["StencilStateCompareFunctionFront"] = 17] = "StencilStateCompareFunctionFront";
    /** Stencil state compare function back key. */ RenderStateElementKey[RenderStateElementKey["StencilStateCompareFunctionBack"] = 18] = "StencilStateCompareFunctionBack";
    /** Stencil state pass operation front key. */ RenderStateElementKey[RenderStateElementKey["StencilStatePassOperationFront"] = 19] = "StencilStatePassOperationFront";
    /** Stencil state pass operation back key. */ RenderStateElementKey[RenderStateElementKey["StencilStatePassOperationBack"] = 20] = "StencilStatePassOperationBack";
    /** Stencil state fail operation front key. */ RenderStateElementKey[RenderStateElementKey["StencilStateFailOperationFront"] = 21] = "StencilStateFailOperationFront";
    /** Stencil state fail operation back key. */ RenderStateElementKey[RenderStateElementKey["StencilStateFailOperationBack"] = 22] = "StencilStateFailOperationBack";
    /** Stencil state z fail operation front key. */ RenderStateElementKey[RenderStateElementKey["StencilStateZFailOperationFront"] = 23] = "StencilStateZFailOperationFront";
    /** Stencil state z fail operation back key. */ RenderStateElementKey[RenderStateElementKey["StencilStateZFailOperationBack"] = 24] = "StencilStateZFailOperationBack";
    /** Raster state fill mode key. */ RenderStateElementKey[RenderStateElementKey["RasterStateCullMode"] = 25] = "RasterStateCullMode";
    /** Raster state cull mode key. */ RenderStateElementKey[RenderStateElementKey["RasterStateDepthBias"] = 26] = "RasterStateDepthBias";
    /** Raster state depth bias key. */ RenderStateElementKey[RenderStateElementKey["RasterStateSlopeScaledDepthBias"] = 27] = "RasterStateSlopeScaledDepthBias";
    /** Render queue type key. */ RenderStateElementKey[RenderStateElementKey["RenderQueueType"] = 28] = "RenderQueueType";
    return RenderStateElementKey;
}({});

/**
 * Render queue type.
 */ var RenderQueueType = /*#__PURE__*/ function(RenderQueueType) {
    /** Opaque queue. */ RenderQueueType[RenderQueueType["Opaque"] = 0] = "Opaque";
    /** Opaque queue, alpha cutoff. */ RenderQueueType[RenderQueueType["AlphaTest"] = 1] = "AlphaTest";
    /** Transparent queue, rendering from back to front to ensure correct rendering of transparent objects. */ RenderQueueType[RenderQueueType["Transparent"] = 2] = "Transparent";
    return RenderQueueType;
}({});

/**
 * Shader data grouping.
 */ var ShaderDataGroup = /*#__PURE__*/ function(ShaderDataGroup) {
    /** Scene group. */ ShaderDataGroup[ShaderDataGroup["Scene"] = 0] = "Scene";
    /** Camera group. */ ShaderDataGroup[ShaderDataGroup["Camera"] = 1] = "Camera";
    /** Renderer group. */ ShaderDataGroup[ShaderDataGroup["Renderer"] = 2] = "Renderer";
    /** Material group. */ ShaderDataGroup[ShaderDataGroup["Material"] = 3] = "Material";
    /** Render element group. */ ShaderDataGroup[ShaderDataGroup["RenderElement"] = 4] = "RenderElement";
    return ShaderDataGroup;
}({});

/**
 * Shader Property type.
 */ var ShaderPropertyType = /*#__PURE__*/ function(ShaderPropertyType) {
    /** Float type. */ ShaderPropertyType[ShaderPropertyType["Float"] = 0] = "Float";
    /** Int type. */ ShaderPropertyType[ShaderPropertyType["Int"] = 1] = "Int";
    /** Vector2 type. */ ShaderPropertyType[ShaderPropertyType["Vector2"] = 2] = "Vector2";
    /** Vector3 type. */ ShaderPropertyType[ShaderPropertyType["Vector3"] = 3] = "Vector3";
    /** Vector4 type. */ ShaderPropertyType[ShaderPropertyType["Vector4"] = 4] = "Vector4";
    /** Matrix type. */ ShaderPropertyType[ShaderPropertyType["Matrix"] = 5] = "Matrix";
    /** Color type. */ ShaderPropertyType[ShaderPropertyType["Color"] = 6] = "Color";
    /** Texture type. */ ShaderPropertyType[ShaderPropertyType["Texture"] = 7] = "Texture";
    /** Float array type. */ ShaderPropertyType[ShaderPropertyType["FloatArray"] = 8] = "FloatArray";
    /** Int array type. */ ShaderPropertyType[ShaderPropertyType["IntArray"] = 9] = "IntArray";
    /** Texture array type. */ ShaderPropertyType[ShaderPropertyType["TextureArray"] = 10] = "TextureArray";
    return ShaderPropertyType;
}({});

/**
 * Stencil operation mode.
 * @remarks sets the front and/or back-facing stencil test actions.
 */ var StencilOperation = /*#__PURE__*/ function(StencilOperation) {
    /** Keeps the current value. */ StencilOperation[StencilOperation["Keep"] = 0] = "Keep";
    /** Sets the stencil buffer value to 0. */ StencilOperation[StencilOperation["Zero"] = 1] = "Zero";
    /** Sets the stencil buffer value to the reference value. */ StencilOperation[StencilOperation["Replace"] = 2] = "Replace";
    /** Increments the current stencil buffer value. Clamps to the maximum representable unsigned value. */ StencilOperation[StencilOperation["IncrementSaturate"] = 3] = "IncrementSaturate";
    /** Decrements the current stencil buffer value. Clamps to 0. */ StencilOperation[StencilOperation["DecrementSaturate"] = 4] = "DecrementSaturate";
    /** Inverts the current stencil buffer value bitwise. */ StencilOperation[StencilOperation["Invert"] = 5] = "Invert";
    /** Increments the current stencil buffer value. Wraps stencil buffer value to zero when incrementing the maximum representable unsigned value. */ StencilOperation[StencilOperation["IncrementWrap"] = 6] = "IncrementWrap";
    /** Decrements the current stencil buffer value. Wraps stencil buffer value to the maximum representable unsigned value when decrementing a stencil buffer value of 0. */ StencilOperation[StencilOperation["DecrementWrap"] = 7] = "DecrementWrap";
    return StencilOperation;
}({});

var ShaderPlatformTarget = /*#__PURE__*/ function(ShaderPlatformTarget) {
    ShaderPlatformTarget[ShaderPlatformTarget["GLES100"] = 0] = "GLES100";
    ShaderPlatformTarget[ShaderPlatformTarget["GLES300"] = 1] = "GLES300";
    return ShaderPlatformTarget;
}({});

function _array_like_to_array$1(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
}

function _unsupported_iterable_to_array$1(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array$1(o, minLen);

    var n = Object.prototype.toString.call(o).slice(8, -1);

    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$1(o, minLen);
}

function _create_for_of_iterator_helper_loose$1(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (it) return (it = it.call(o)).next.bind(it);
    // Fallback for engines without symbol support
    if (Array.isArray(o) || (it = _unsupported_iterable_to_array$1(o)) || allowArrayLike) {
        if (it) o = it;

        var i = 0;

        return function() {
            if (i >= o.length) return { done: true };

            return { done: false, value: o[i++] };
        };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/**
 * Shader macro。
 */ var ShaderMacro = /*#__PURE__*/ function() {
    function ShaderMacro(name, value, maskIndex, maskValue) {
        this.name = name;
        this._maskIndex = maskIndex;
        this._maskValue = maskValue;
        this.value = value;
        var macroNameIDMap = ShaderMacro._macroNameIdMap;
        var nameID = macroNameIDMap[name];
        if (macroNameIDMap[name] === undefined) {
            macroNameIDMap[name] = nameID = ShaderMacro._macroNameCounter++;
        }
        this._nameId = nameID;
    }
    ShaderMacro.getByName = function getByName(name, value) {
        var key = value ? name + " " + value : name;
        var macro = ShaderMacro._macroMap[key];
        if (!macro) {
            var maskMap = ShaderMacro._macroMaskMap;
            var counter = ShaderMacro._macroCounter;
            var index = Math.floor(counter / 32);
            var bit = counter % 32;
            macro = new ShaderMacro(name, value, index, 1 << bit);
            ShaderMacro._macroMap[key] = macro;
            if (index == maskMap.length) {
                maskMap.length++;
                maskMap[index] = new Array(32);
            }
            maskMap[index][bit] = macro;
            ShaderMacro._macroCounter++;
        }
        return macro;
    };
    /**
   * @internal
   */ ShaderMacro._getMacrosElements = function _getMacrosElements(macros, out) {
        var maskMap = ShaderMacro._macroMaskMap;
        var mask = macros._mask;
        out.length = 0;
        for(var i = 0, n = macros._length; i < n; i++){
            var subMaskMap = maskMap[i];
            var subMask = mask[i];
            var m = subMask < 0 ? 32 : Math.floor(Math.log2(subMask)) + 1; // if is negative must contain 1 << 31.
            for(var j = 0; j < m; j++){
                if (subMask & 1 << j) {
                    out.push(subMaskMap[j]);
                }
            }
        }
    };
    return ShaderMacro;
}();
/** @internal */ ShaderMacro._macroMaskMap = [];
/** @internal */ ShaderMacro._macroNameIdMap = Object.create(null);
ShaderMacro._macroNameCounter = 0;
ShaderMacro._macroCounter = 0;
ShaderMacro._macroMap = Object.create(null);

/**
 * Shader macro collection.
 * @internal
 */ var ShaderMacroCollection = /*#__PURE__*/ function() {
    function ShaderMacroCollection() {
        /** @internal */ this._mask = [];
        /** @internal */ this._length = 0;
    }
    var _proto = ShaderMacroCollection.prototype;
    /**
   * Enable one macro in this macro collection.
   * @param macro - ShaderMacro
   */ _proto.enable = function enable(macro) {
        var index = macro._maskIndex;
        var size = index + 1;
        var mask = this._mask;
        var maskStart = this._length; // must from this._length because this._length maybe less than mask.length and have dirty data should clear.
        if (maskStart < size) {
            mask.length < size && (mask.length = size); // mask.length maybe small than size,maybe not.
            for(; maskStart < index; maskStart++){
                mask[maskStart] = 0;
            }
            mask[index] = macro._maskValue;
            this._length = size;
        } else {
            mask[index] |= macro._maskValue;
        }
    };
    /**
   * Disable one macro in this macro collection.
   * @param macro - ShaderMacro
   */ _proto.disable = function disable(macro) {
        var index = macro._maskIndex;
        var mask = this._mask;
        var endIndex = this._length - 1;
        if (index > endIndex) {
            return;
        }
        var newValue = mask[index] & ~macro._maskValue;
        if (index == endIndex && newValue === 0) {
            this._length--;
        } else {
            mask[index] = newValue;
        }
    };
    /**
   * Union of this and other macro collection.
   * @param macroCollection - macro collection
   */ _proto.unionCollection = function unionCollection(macroCollection) {
        var addMask = macroCollection._mask;
        var addSize = macroCollection._length;
        var mask = this._mask;
        var maskSize = this._length;
        if (maskSize < addSize) {
            mask.length < addSize && (mask.length = addSize);
            var i = 0;
            for(; i < maskSize; i++){
                mask[i] |= addMask[i];
            }
            for(; i < addSize; i++){
                mask[i] = addMask[i];
            }
            this._length = addSize;
        } else {
            for(var i1 = 0; i1 < addSize; i1++){
                mask[i1] |= addMask[i1];
            }
        }
    };
    /**
   * Complementarity of this and other macro collection.
   * @param macroCollection - macro collection
   */ _proto.complementaryCollection = function complementaryCollection(macroCollection) {
        var removeMask = macroCollection._mask;
        var mask = this._mask;
        var endIndex = this._length - 1;
        var i = Math.min(macroCollection._length - 1, endIndex);
        for(; i >= 0; i--){
            var newValue = mask[i] & ~removeMask[i];
            if (i == endIndex && newValue === 0) {
                endIndex--;
                this._length--;
            } else {
                mask[i] = newValue;
            }
        }
    };
    /**
   * Intersection of this and other macro collection.
   * @param macroCollection - macro collection
   */ _proto.intersectionCollection = function intersectionCollection(macroCollection) {
        var unionMask = macroCollection._mask;
        var mask = this._mask;
        for(var i = this._length - 1; i >= 0; i--){
            var value = mask[i] & unionMask[i];
            if (value == 0 && i == this._length - 1) {
                this._length--;
            } else {
                mask[i] = value;
            }
        }
    };
    /**
   * Whether macro is enabled in this macro collection.
   * @param macro - ShaderMacro
   */ _proto.isEnable = function isEnable(macro) {
        var index = macro._maskIndex;
        if (index >= this._length) {
            return false;
        }
        return (this._mask[index] & macro._maskValue) !== 0;
    };
    /**
   * Clear this macro collection.
   */ _proto.clear = function clear() {
        this._length = 0;
    };
    /**
   * Union of two macro collection.
   * @param left - input macro collection
   * @param right - input macro collection
   * @param out - union output macro collection
   */ ShaderMacroCollection.unionCollection = function unionCollection(left, right, out) {
        var outMask = out._mask;
        var minSize, maxSize;
        var minMask, maxMask;
        if (left._length < right._length) {
            minSize = left._length;
            maxSize = right._length;
            minMask = left._mask;
            maxMask = right._mask;
        } else {
            minSize = right._length;
            maxSize = left._length;
            minMask = right._mask;
            maxMask = left._mask;
        }
        var i = 0;
        outMask.length < maxSize && (outMask.length = maxSize);
        for(; i < minSize; i++){
            outMask[i] = minMask[i] | maxMask[i];
        }
        for(; i < maxSize; i++){
            outMask[i] = maxMask[i];
        }
        out._length = maxSize;
    };
    return ShaderMacroCollection;
}();

function _extends$2() {
    _extends$2 = Object.assign || function assign(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }

        return target;
    };

    return _extends$2.apply(this, arguments);
}

/**
 * Pipeline stage.
 */ var PipelineStage = /*#__PURE__*/ function(PipelineStage) {
    /** DepthOnly stage. */ PipelineStage["DepthOnly"] = "DepthOnly";
    /** Shadow caster stage. */ PipelineStage["ShadowCaster"] = "ShadowCaster";
    /** Forward shading stage. */ PipelineStage["Forward"] = "Forward";
    return PipelineStage;
}({});

var camera_declare = "#define GLSLIFY 1\nuniform vec3 camera_Position;\nuniform vec3 camera_Forward; \nuniform vec4 camera_ProjectionParams;"; // eslint-disable-line

var common = "#define GLSLIFY 1\n#define PI 3.14159265359\n#define RECIPROCAL_PI 0.31830988618\n#define EPSILON 1e-6\n#define LOG2 1.442695\n#define HALF_MIN 6.103515625e-5  // 2^-14, the same value for 10, 11 and 16-bit: https://www.khronos.org/opengl/wiki/Small_Float_Formats\n#define HALF_EPS 4.8828125e-4    // 2^-11, machine epsilon: 1 + EPS = 1 (half of the ULP for 1.0f)\n\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n\nfloat pow2(float x ) {\n    return x * x;\n}\n\nvec4 RGBMToLinear(vec4 value, float maxRange ) {\n    return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\n\nvec4 gammaToLinear(vec4 value){\n    return vec4( pow(value.rgb, vec3(2.2)), value.a);\n}\n\nvec4 linearToGamma(vec4 value){\n\tvalue = max(value, 0.0);\n    return vec4( pow(value.rgb, vec3(1.0 / 2.2)), value.a);\n}\n\n// https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_framebuffer_sRGB.txt\n// https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_texture_sRGB_decode.txt\nfloat sRGBToLinear(float value){\n    float linearRGBLo  = value / 12.92;\n    float linearRGBHi  = pow((value + 0.055) / 1.055, 2.4);\n    float linearRGB    = (value <= 0.04045) ? linearRGBLo : linearRGBHi;\n    return linearRGB;\n}\n\nvec4 sRGBToLinear(vec4 value){\n   return vec4(sRGBToLinear(value.r), sRGBToLinear(value.g), sRGBToLinear(value.b), value.a);\n}\n\nfloat linearToSRGB(float value){\n\tvalue = max(value, 0.0);\n    return (value <= 0.0031308) ? (value * 12.9232102) : 1.055 * pow(value, 1.0 / 2.4) - 0.055;\n}\n\nvec4 linearToSRGB(vec4 value){\n    return vec4(linearToSRGB(value.r), linearToSRGB(value.g), linearToSRGB(value.b), value.a);\n}\n\n// Compatible with devices that do not even support EXT_sRGB in WebGL1.0.\nvec4 texture2DSRGB(sampler2D tex, vec2 uv) {\n\tvec4 color = texture2D(tex, uv);\n\t#ifdef ENGINE_NO_SRGB\n\t\tcolor = sRGBToLinear(color);\n\t#endif\n\treturn color;\n}\n\n#ifdef HAS_TEX_LOD\n\tvec4 texture2DLodSRGB(sampler2D tex, vec2 uv, float lod) {\n\t\tvec4 color = texture2DLodEXT(tex, uv, lod);\n\t\t#ifdef ENGINE_NO_SRGB\n\t\t\tcolor = sRGBToLinear(color);\n\t\t#endif\n\t\treturn color;\n\t}\n#endif\n\nvec4 outputSRGBCorrection(vec4 linearIn){\n    #ifdef ENGINE_OUTPUT_SRGB_CORRECT\n    \treturn linearToSRGB(linearIn);\n    #else \n    \treturn linearIn;\n    #endif\n}\n\nuniform vec4 camera_DepthBufferParams;\n\nfloat remapDepthBufferLinear01(float z){\n\treturn 1.0/ (camera_DepthBufferParams.x * z + camera_DepthBufferParams.y);\n}\n\n#ifdef GRAPHICS_API_WEBGL2\n\t#define INVERSE_MAT(mat) inverse(mat)\n#else\n\tmat2 inverseMat(mat2 m) {\n\t\treturn mat2(m[1][1],-m[0][1],\n\t\t\t\t-m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n\t}\n\tmat3 inverseMat(mat3 m) {\n\t\tfloat a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n\t\tfloat a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n\t\tfloat a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n\t\tfloat b01 = a22 * a11 - a12 * a21;\n\t\tfloat b11 = -a22 * a10 + a12 * a20;\n\t\tfloat b21 = a21 * a10 - a11 * a20;\n\n\t\tfloat det = a00 * b01 + a01 * b11 + a02 * b21;\n\n\t\treturn mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n\t\t\t\t\tb11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n\t\t\t\t\tb21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n\t}\n\tmat4 inverseMat(mat4 m) {\n\t\tfloat a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n\t\t\ta10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n\t\t\ta20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n\t\t\ta30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n\t\t\tb00 = a00 * a11 - a01 * a10,\n\t\t\tb01 = a00 * a12 - a02 * a10,\n\t\t\tb02 = a00 * a13 - a03 * a10,\n\t\t\tb03 = a01 * a12 - a02 * a11,\n\t\t\tb04 = a01 * a13 - a03 * a11,\n\t\t\tb05 = a02 * a13 - a03 * a12,\n\t\t\tb06 = a20 * a31 - a21 * a30,\n\t\t\tb07 = a20 * a32 - a22 * a30,\n\t\t\tb08 = a20 * a33 - a23 * a30,\n\t\t\tb09 = a21 * a32 - a22 * a31,\n\t\t\tb10 = a21 * a33 - a23 * a31,\n\t\t\tb11 = a22 * a33 - a23 * a32,\n\n\t\t\tdet = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n\t\treturn mat4(\n\t\t\ta11 * b11 - a12 * b10 + a13 * b09,\n\t\t\ta02 * b10 - a01 * b11 - a03 * b09,\n\t\t\ta31 * b05 - a32 * b04 + a33 * b03,\n\t\t\ta22 * b04 - a21 * b05 - a23 * b03,\n\t\t\ta12 * b08 - a10 * b11 - a13 * b07,\n\t\t\ta00 * b11 - a02 * b08 + a03 * b07,\n\t\t\ta32 * b02 - a30 * b05 - a33 * b01,\n\t\t\ta20 * b05 - a22 * b02 + a23 * b01,\n\t\t\ta10 * b10 - a11 * b08 + a13 * b06,\n\t\t\ta01 * b08 - a00 * b10 - a03 * b06,\n\t\t\ta30 * b04 - a31 * b02 + a33 * b00,\n\t\t\ta21 * b02 - a20 * b04 - a23 * b00,\n\t\t\ta11 * b07 - a10 * b09 - a12 * b06,\n\t\t\ta00 * b09 - a01 * b07 + a02 * b06,\n\t\t\ta31 * b01 - a30 * b03 - a32 * b00,\n\t\t\ta20 * b03 - a21 * b01 + a22 * b00) / det;\n\t}\n\n\t#define INVERSE_MAT(mat) inverseMat(mat)\n#endif\n\nvec3 safeNormalize(vec3 inVec) {\n    float dp3 = max(float(HALF_MIN), dot(inVec, inVec));\n    return inVec * inversesqrt(dp3);\n}\n"; // eslint-disable-line

var common_vert = "#define GLSLIFY 1\nattribute vec3 POSITION;\n\n#ifdef RENDERER_HAS_UV\n    attribute vec2 TEXCOORD_0;\n#endif\n\n#ifdef RENDERER_HAS_UV1\n    attribute vec2 TEXCOORD_1;\n#endif\n\n#ifdef RENDERER_HAS_SKIN\n    attribute vec4 JOINTS_0;\n    attribute vec4 WEIGHTS_0;\n\n    #ifdef RENDERER_USE_JOINT_TEXTURE\n        uniform sampler2D renderer_JointSampler;\n        uniform float renderer_JointCount;\n\n        mat4 getJointMatrix(sampler2D smp, float index)\n        {\n            float base = index / renderer_JointCount;\n            float hf = 0.5 / renderer_JointCount;\n            float v = base + hf;\n\n            vec4 m0 = texture2D(smp, vec2(0.125, v ));\n            vec4 m1 = texture2D(smp, vec2(0.375, v ));\n            vec4 m2 = texture2D(smp, vec2(0.625, v ));\n            vec4 m3 = texture2D(smp, vec2(0.875, v ));\n\n            return mat4(m0, m1, m2, m3);\n\n        }\n\n    #else\n        uniform mat4 renderer_JointMatrix[ RENDERER_JOINTS_NUM ];\n    #endif\n#endif\n\n#ifdef RENDERER_ENABLE_VERTEXCOLOR\n    attribute vec4 COLOR_0;\n#endif\n\n#include <transform_declare>\n#include <camera_declare>\n\nuniform vec4 material_TilingOffset;\n\n#ifndef MATERIAL_OMIT_NORMAL\n    #ifdef RENDERER_HAS_NORMAL\n        attribute vec3 NORMAL;\n    #endif\n\n    #ifdef RENDERER_HAS_TANGENT\n        attribute vec4 TANGENT;\n    #endif\n#endif"; // eslint-disable-line

var transform_declare = "#define GLSLIFY 1\nuniform mat4 renderer_LocalMat;\nuniform mat4 renderer_ModelMat;\nuniform mat4 camera_ViewMat;\nuniform mat4 camera_ProjMat;\nuniform mat4 renderer_MVMat;\nuniform mat4 renderer_MVPMat;\nuniform mat4 renderer_NormalMat;"; // eslint-disable-line

var color_share = "#define GLSLIFY 1\n#ifdef RENDERER_ENABLE_VERTEXCOLOR\n\nvarying vec4 v_color;\n\n#endif\n"; // eslint-disable-line

var FogFragmentDeclaration = "#define GLSLIFY 1\n#if SCENE_FOG_MODE != 0\n    varying vec3 v_positionVS;\n\n    uniform vec4 scene_FogColor;\n    uniform vec4 scene_FogParams;// (-1/(end-start), end/(end-start), density/ln(2),density/sprt(ln(2)));\n\n    float ComputeFogIntensity(float fogDepth){\n        #if SCENE_FOG_MODE == 1\n            // (end-z) / (end-start) = z * (-1/(end-start)) + (end/(end-start))\n            return clamp(fogDepth * scene_FogParams.x + scene_FogParams.y, 0.0, 1.0);\n        #elif SCENE_FOG_MODE == 2\n            // exp(-z * density) = exp2((-z * density)/ln(2)) = exp2(-z * density/ln(2))\n            return  clamp(exp2(-fogDepth * scene_FogParams.z), 0.0, 1.0);\n        #elif SCENE_FOG_MODE == 3\n            // exp(-(z * density)^2) = exp2(-(z * density)^2/ln(2)) = exp2(-(z * density/sprt(ln(2)))^2)\n            float factor = fogDepth * scene_FogParams.w;\n            return  clamp(exp2(-factor * factor), 0.0, 1.0);\n        #endif\n    }\n#endif\n"; // eslint-disable-line

var FogVertexDeclaration = "#define GLSLIFY 1\n#if SCENE_FOG_MODE != 0\n    varying vec3 v_positionVS;\n#endif\n"; // eslint-disable-line

var normal_share = "#define GLSLIFY 1\n#ifndef MATERIAL_OMIT_NORMAL\n    #ifdef RENDERER_HAS_NORMAL\n        varying vec3 v_normal;\n        #if defined(RENDERER_HAS_TANGENT) && ( defined(MATERIAL_HAS_NORMALTEXTURE) || defined(MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE) || defined(MATERIAL_ENABLE_ANISOTROPY) )\n            varying mat3 v_TBN;\n        #endif\n    #endif\n#endif"; // eslint-disable-line

var uv_share = "#define GLSLIFY 1\nvarying vec2 v_uv;\n\n#ifdef RENDERER_HAS_UV1\n    varying vec2 v_uv1;\n#endif"; // eslint-disable-line

var worldpos_share = "#define GLSLIFY 1\n#ifdef MATERIAL_NEED_WORLD_POS\n    varying vec3 v_pos;\n#endif\n"; // eslint-disable-line

var begin_normal_vert = "#define GLSLIFY 1\n#ifndef MATERIAL_OMIT_NORMAL\n    #ifdef RENDERER_HAS_NORMAL\n        vec3 normal = vec3( NORMAL );\n    #endif\n\n    #ifdef RENDERER_HAS_TANGENT\n        vec4 tangent = vec4( TANGENT );\n    #endif\n#endif"; // eslint-disable-line

var begin_position_vert = "#define GLSLIFY 1\n    vec4 position = vec4( POSITION , 1.0 );\n"; // eslint-disable-line

var blendShape_input = "#define GLSLIFY 1\n#ifdef RENDERER_HAS_BLENDSHAPE\n\t#ifdef RENDERER_BLENDSHAPE_USE_TEXTURE\n\t\tuniform mediump sampler2DArray renderer_BlendShapeTexture;\n\t\tuniform ivec3 renderer_BlendShapeTextureInfo;\n\t\tuniform float renderer_BlendShapeWeights[RENDERER_BLENDSHAPE_COUNT];\n\t#else\n\t\tattribute vec3 POSITION_BS0;\n\t\tattribute vec3 POSITION_BS1;\n\t\t#if defined( RENDERER_BLENDSHAPE_HAS_NORMAL ) && defined( RENDERER_BLENDSHAPE_HAS_TANGENT )\n\t\t\tattribute vec3 NORMAL_BS0;\n\t\t\tattribute vec3 NORMAL_BS1;\n\t\t\tattribute vec3 TANGENT_BS0;\n\t\t\tattribute vec3 TANGENT_BS1;\n\t\t\tuniform float renderer_BlendShapeWeights[2];\n\t\t#else\n\t\t\t#if defined( RENDERER_BLENDSHAPE_HAS_NORMAL ) || defined( RENDERER_BLENDSHAPE_HAS_TANGENT )\n\t\t\t\tattribute vec3 POSITION_BS2;\n\t\t\t\tattribute vec3 POSITION_BS3;\n\t\t\t\t#ifdef RENDERER_BLENDSHAPE_HAS_NORMAL\n\t\t\t\t\tattribute vec3 NORMAL_BS0;\n\t\t\t\t\tattribute vec3 NORMAL_BS1;\n\t\t\t\t\tattribute vec3 NORMAL_BS2;\n\t\t\t\t\tattribute vec3 NORMAL_BS3;\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef RENDERER_BLENDSHAPE_HAS_TANGENT\n\t\t\t\t\tattribute vec3 TANGENT_BS0;\n\t\t\t\t\tattribute vec3 TANGENT_BS1;\n\t\t\t\t\tattribute vec3 TANGENT_BS2;\n\t\t\t\t\tattribute vec3 TANGENT_BS3;\n\t\t\t\t#endif\n\n\t\t\t\tuniform float renderer_BlendShapeWeights[4];\n\t\t\t#else\n\t\t\t\tattribute vec3 POSITION_BS2;\n\t\t\t\tattribute vec3 POSITION_BS3;\n\t\t\t\tattribute vec3 POSITION_BS4;\n\t\t\t\tattribute vec3 POSITION_BS5;\n\t\t\t\tattribute vec3 POSITION_BS6;\n\t\t\t\tattribute vec3 POSITION_BS7;\n\t\t\t\tuniform float renderer_BlendShapeWeights[8];\n\t\t\t#endif\n\t\t#endif\n\t#endif\n\n\t#ifdef RENDERER_BLENDSHAPE_USE_TEXTURE\n\t\tvec3 getBlendShapeVertexElement(int blendShapeIndex, int vertexElementIndex)\n\t\t{\t\t\t\n\t\t\tint y = vertexElementIndex / renderer_BlendShapeTextureInfo.y;\n\t\t\tint x = vertexElementIndex - y * renderer_BlendShapeTextureInfo.y;\n\t\t\tivec3 uv = ivec3(x, y , blendShapeIndex);\n\t\t\treturn texelFetch(renderer_BlendShapeTexture, uv, 0).xyz;\n\t\t}\n\t#endif\n#endif\n"; // eslint-disable-line

var blendShape_vert = "#define GLSLIFY 1\n#ifdef RENDERER_HAS_BLENDSHAPE\n\t#ifdef RENDERER_BLENDSHAPE_USE_TEXTURE\t\n\t\tint vertexOffset = gl_VertexID * renderer_BlendShapeTextureInfo.x;\n\t\tfor(int i = 0; i < RENDERER_BLENDSHAPE_COUNT; i++){\n\t\t\tint vertexElementOffset = vertexOffset;\n\t\t\tfloat weight = renderer_BlendShapeWeights[i];\n\t\t\t// Warnning: Multiplying by 0 creates weird precision issues, causing rendering anomalies in Ace2 Android13\n\t\t\tif(weight != 0.0){\n\t\t\t\tposition.xyz += getBlendShapeVertexElement(i, vertexElementOffset) * weight;\n\t\n\t\t\t\t#ifndef MATERIAL_OMIT_NORMAL\n\t\t\t\t\t#if defined( RENDERER_HAS_NORMAL ) && defined( RENDERER_BLENDSHAPE_HAS_NORMAL )\n\t\t\t\t\t\tvertexElementOffset += 1;\n\t\t\t\t\t\tnormal += getBlendShapeVertexElement(i, vertexElementOffset) * weight;\n\t\t\t\t\t#endif\n\t\n\t\t\t\t\t#if defined( RENDERER_HAS_TANGENT ) && defined(RENDERER_BLENDSHAPE_HAS_TANGENT) && ( defined(MATERIAL_HAS_NORMALTEXTURE) || defined(MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE) )\n\t\t\t\t\t\tvertexElementOffset += 1;\n\t\t\t\t\t\ttangent.xyz += getBlendShapeVertexElement(i, vertexElementOffset) * weight;\n\t\t\t\t\t#endif\n\t\t\t\t#endif\n\t\t\t}\n\t\t\t\n\t\t}\n\t#else\n\t\tposition.xyz += POSITION_BS0 * renderer_BlendShapeWeights[0];\n\t\tposition.xyz += POSITION_BS1 * renderer_BlendShapeWeights[1];\n\n\t\t#if defined( RENDERER_BLENDSHAPE_HAS_NORMAL ) && defined( RENDERER_BLENDSHAPE_HAS_TANGENT )\n\t\t\t#ifndef MATERIAL_OMIT_NORMAL\n\t\t\t\t#ifdef RENDERER_HAS_NORMAL\n\t\t\t\t\tnormal += NORMAL_BS0 * renderer_BlendShapeWeights[0];\n\t\t\t\t\tnormal += NORMAL_BS1 * renderer_BlendShapeWeights[1];\n\t\t\t\t#endif\n\t\t\t\t#if defined( RENDERER_HAS_TANGENT ) && ( defined(MATERIAL_HAS_NORMALTEXTURE) || defined(MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE) )\n\t\t\t\t\ttangent.xyz += TANGENT_BS0 * renderer_BlendShapeWeights[0];\n\t\t\t\t\ttangent.xyz += TANGENT_BS1 * renderer_BlendShapeWeights[1];\n\t\t\t\t#endif\t\t\t\t\n\t\t\t#endif\n\t\t#else\n\t\t\t#if defined( RENDERER_BLENDSHAPE_HAS_NORMAL ) || defined( RENDERER_BLENDSHAPE_HAS_TANGENT )\n\t\t\t\t#ifndef MATERIAL_OMIT_NORMAL\n\t\t\t\t\tposition.xyz += POSITION_BS2 * renderer_BlendShapeWeights[2];\n\t\t\t\t\tposition.xyz += POSITION_BS3 * renderer_BlendShapeWeights[3];\n\n\t\t\t\t\t#if defined( RENDERER_BLENDSHAPE_HAS_NORMAL ) && defined( RENDERER_HAS_NORMAL )\n\t\t\t\t\t\tnormal += NORMAL_BS0 * renderer_BlendShapeWeights[0];\n\t\t\t\t\t\tnormal += NORMAL_BS1 * renderer_BlendShapeWeights[1];\n\t\t\t\t\t\tnormal += NORMAL_BS2 * renderer_BlendShapeWeights[2];\n\t\t\t\t\t\tnormal += NORMAL_BS3 * renderer_BlendShapeWeights[3];\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if defined(RENDERER_BLENDSHAPE_HAS_TANGENT) && defined( RENDERER_HAS_TANGENT ) && ( defined(MATERIAL_HAS_NORMALTEXTURE) || defined(MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE) )\n\t\t\t\t\t\ttangent.xyz += TANGENT_BS0 * renderer_BlendShapeWeights[0];\n\t\t\t\t\t\ttangent.xyz += TANGENT_BS1 * renderer_BlendShapeWeights[1];\n\t\t\t\t\t\ttangent.xyz += TANGENT_BS2 * renderer_BlendShapeWeights[2];\n\t\t\t\t\t\ttangent.xyz += TANGENT_BS3 * renderer_BlendShapeWeights[3];\n\t\t\t\t\t#endif\n\t\t\t\t#endif\n\t\t\t#else\n\t\t\t\tposition.xyz += POSITION_BS2 * renderer_BlendShapeWeights[2];\n\t\t\t\tposition.xyz += POSITION_BS3 * renderer_BlendShapeWeights[3];\n\t\t\t\tposition.xyz += POSITION_BS4 * renderer_BlendShapeWeights[4];\n\t\t\t\tposition.xyz += POSITION_BS5 * renderer_BlendShapeWeights[5];\n\t\t\t\tposition.xyz += POSITION_BS6 * renderer_BlendShapeWeights[6];\n\t\t\t\tposition.xyz += POSITION_BS7 * renderer_BlendShapeWeights[7];\n\t\t\t#endif\n\t\t#endif\n\t#endif\n#endif\n\n"; // eslint-disable-line

var color_vert = "#define GLSLIFY 1\n    #ifdef RENDERER_ENABLE_VERTEXCOLOR\n\n    v_color = COLOR_0;\n\n    #endif\n"; // eslint-disable-line

var FogVertex = "#define GLSLIFY 1\n#if SCENE_FOG_MODE != 0\n    vec4 positionVS = renderer_MVMat * position;\n    v_positionVS = positionVS.xyz / positionVS.w;\n#endif\n"; // eslint-disable-line

var normal_vert = "#define GLSLIFY 1\n#ifndef MATERIAL_OMIT_NORMAL\n    #ifdef RENDERER_HAS_NORMAL\n        v_normal = normalize( mat3(renderer_NormalMat) * normal );\n\n        #if defined(RENDERER_HAS_TANGENT) && ( defined(MATERIAL_HAS_NORMALTEXTURE) || defined(MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE) || defined(MATERIAL_ENABLE_ANISOTROPY) )\n            vec3 tangentW = normalize( mat3(renderer_NormalMat) * tangent.xyz );\n            vec3 bitangentW = cross( v_normal, tangentW ) * tangent.w;\n\n            v_TBN = mat3( tangentW, bitangentW, v_normal );\n        #endif\n    #endif\n#endif"; // eslint-disable-line

var position_vert = "#define GLSLIFY 1\n    gl_Position = renderer_MVPMat * position;"; // eslint-disable-line

var skinning_vert = "#define GLSLIFY 1\n#ifdef RENDERER_HAS_SKIN\n\n        #ifdef RENDERER_USE_JOINT_TEXTURE\n            mat4 skinMatrix =\n                WEIGHTS_0.x * getJointMatrix(renderer_JointSampler, JOINTS_0.x ) +\n                WEIGHTS_0.y * getJointMatrix(renderer_JointSampler, JOINTS_0.y ) +\n                WEIGHTS_0.z * getJointMatrix(renderer_JointSampler, JOINTS_0.z ) +\n                WEIGHTS_0.w * getJointMatrix(renderer_JointSampler, JOINTS_0.w );\n\n        #else\n            mat4 skinMatrix =\n                WEIGHTS_0.x * renderer_JointMatrix[ int( JOINTS_0.x ) ] +\n                WEIGHTS_0.y * renderer_JointMatrix[ int( JOINTS_0.y ) ] +\n                WEIGHTS_0.z * renderer_JointMatrix[ int( JOINTS_0.z ) ] +\n                WEIGHTS_0.w * renderer_JointMatrix[ int( JOINTS_0.w ) ];\n        #endif\n\n        position = skinMatrix * position;\n\n        #if defined(RENDERER_HAS_NORMAL) && !defined(MATERIAL_OMIT_NORMAL)\n            mat3 skinNormalMatrix = INVERSE_MAT(mat3(skinMatrix));\n            normal = normal * skinNormalMatrix;\n            #if defined(RENDERER_HAS_TANGENT) && ( defined(MATERIAL_HAS_NORMALTEXTURE) || defined(MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE) )\n                tangent.xyz = tangent.xyz * skinNormalMatrix;\n            #endif\n\n        #endif\n\n#endif\n"; // eslint-disable-line

var uv_vert = "#define GLSLIFY 1\n#ifdef RENDERER_HAS_UV\n    v_uv = TEXCOORD_0;\n#else\n    // may need this calculate normal\n    v_uv = vec2( 0., 0. );\n#endif\n\n#ifdef RENDERER_HAS_UV1\n    v_uv1 = TEXCOORD_1;\n#endif\n\n#ifdef MATERIAL_NEED_TILING_OFFSET\n    v_uv = v_uv * material_TilingOffset.xy + material_TilingOffset.zw;\n#endif"; // eslint-disable-line

var worldpos_vert = "#define GLSLIFY 1\n#ifdef MATERIAL_NEED_WORLD_POS\n    vec4 temp_pos = renderer_ModelMat * position;\n    v_pos = temp_pos.xyz / temp_pos.w;\n#endif\n"; // eslint-disable-line

var FogFragment = "#define GLSLIFY 1\n#if SCENE_FOG_MODE != 0\n    float fogIntensity = ComputeFogIntensity(length(v_positionVS));\n    gl_FragColor.rgb = mix(scene_FogColor.rgb, gl_FragColor.rgb, fogIntensity);\n#endif\n"; // eslint-disable-line

var light_frag_define = "#define GLSLIFY 1\n// Directional light\n#ifdef SCENE_DIRECT_LIGHT_COUNT\n\n    struct DirectLight {\n        vec3 color;\n        vec3 direction;\n    };\n\n    uniform ivec2 scene_DirectLightCullingMask[SCENE_DIRECT_LIGHT_COUNT];\n    uniform vec3 scene_DirectLightColor[SCENE_DIRECT_LIGHT_COUNT];\n    uniform vec3 scene_DirectLightDirection[SCENE_DIRECT_LIGHT_COUNT];\n\n#endif\n\n// Point light\n#ifdef SCENE_POINT_LIGHT_COUNT\n\n    struct PointLight {\n        vec3 color;\n        vec3 position;\n        float distance;\n    };\n\n    uniform ivec2 scene_PointLightCullingMask[ SCENE_POINT_LIGHT_COUNT ];\n    uniform vec3 scene_PointLightColor[ SCENE_POINT_LIGHT_COUNT ];\n    uniform vec3 scene_PointLightPosition[ SCENE_POINT_LIGHT_COUNT ];\n    uniform float scene_PointLightDistance[ SCENE_POINT_LIGHT_COUNT ];\n\n#endif\n\n// Spot light\n#ifdef SCENE_SPOT_LIGHT_COUNT\n\n    struct SpotLight {\n        vec3 color;\n        vec3 position;\n        vec3 direction;\n        float distance;\n        float angleCos;\n        float penumbraCos;\n    };\n\n    uniform ivec2 scene_SpotLightCullingMask[ SCENE_SPOT_LIGHT_COUNT ];\n    uniform vec3 scene_SpotLightColor[ SCENE_SPOT_LIGHT_COUNT ];\n    uniform vec3 scene_SpotLightPosition[ SCENE_SPOT_LIGHT_COUNT ];\n    uniform vec3 scene_SpotLightDirection[ SCENE_SPOT_LIGHT_COUNT ];\n    uniform float scene_SpotLightDistance[ SCENE_SPOT_LIGHT_COUNT ];\n    uniform float scene_SpotLightAngleCos[ SCENE_SPOT_LIGHT_COUNT ];\n    uniform float scene_SpotLightPenumbraCos[ SCENE_SPOT_LIGHT_COUNT ];\n\n#endif\n\n// Ambient light\nstruct EnvMapLight {\n    vec3 diffuse;\n    float mipMapLevel;\n    float diffuseIntensity;\n    float specularIntensity;\n};\n\nuniform EnvMapLight scene_EnvMapLight;\nuniform ivec4 renderer_Layer;\n\n#ifdef SCENE_USE_SH\n    uniform vec3 scene_EnvSH[9];\n#endif\n\n#ifdef SCENE_USE_SPECULAR_ENV\n    uniform samplerCube scene_EnvSpecularSampler;\n#endif\n\n#ifndef GRAPHICS_API_WEBGL2\nbool isBitSet(float value, float mask, float bitIndex)\n{\n    return mod(floor(value / pow(2.0, bitIndex)), 2.0) == 1.0 && mod(floor(mask / pow(2.0, bitIndex)), 2.0) == 1.0;\n}\n#endif\n\nbool isRendererCulledByLight(ivec2 rendererLayer, ivec2 lightCullingMask)\n{\n    #ifdef GRAPHICS_API_WEBGL2\n    return !((rendererLayer.x & lightCullingMask.x) != 0 || (rendererLayer.y & lightCullingMask.y) != 0);\n    #else\n    for (int i = 0; i < 16; i++) {\n        if (isBitSet( float(rendererLayer.x), float(lightCullingMask.x), float(i)) || isBitSet( float(rendererLayer.y), float(lightCullingMask.y), float(i))) {\n            return false;\n        }\n    }\n    return true;\n    #endif\n}\n"; // eslint-disable-line

var mobile_material_frag = "#define GLSLIFY 1\nuniform vec4 material_EmissiveColor;\nuniform vec4 material_BaseColor;\nuniform vec4 material_SpecularColor;\nuniform float material_Shininess;\nuniform float material_NormalIntensity;\nuniform float material_AlphaCutoff;\n\n#ifdef MATERIAL_HAS_EMISSIVETEXTURE\n    uniform sampler2D material_EmissiveTexture;\n#endif\n\n#ifdef MATERIAL_HAS_BASETEXTURE\n    uniform sampler2D material_BaseTexture;\n#endif\n\n#ifdef MATERIAL_HAS_SPECULAR_TEXTURE\n    uniform sampler2D material_SpecularTexture;\n#endif\n\n#ifdef MATERIAL_HAS_NORMALTEXTURE\n    uniform sampler2D material_NormalTexture;\n#endif\n"; // eslint-disable-line

var begin_mobile_frag = "#define GLSLIFY 1\n    vec4 ambient = vec4(0.0);\n    vec4 emission = material_EmissiveColor;\n    vec4 diffuse = material_BaseColor;\n    vec4 specular = material_SpecularColor;\n\n    \n\n    #ifdef MATERIAL_HAS_EMISSIVETEXTURE\n        emission *= texture2DSRGB(material_EmissiveTexture, v_uv);\n    #endif\n\n    #ifdef MATERIAL_HAS_BASETEXTURE\n        diffuse *= texture2DSRGB(material_BaseTexture, v_uv);\n    #endif\n\n     #ifdef RENDERER_ENABLE_VERTEXCOLOR\n        diffuse *= v_color;\n    #endif\n\n    #ifdef MATERIAL_HAS_SPECULAR_TEXTURE\n        specular *= texture2DSRGB(material_SpecularTexture, v_uv);\n    #endif\n\n    ambient = vec4(scene_EnvMapLight.diffuse * scene_EnvMapLight.diffuseIntensity, 1.0) * diffuse;"; // eslint-disable-line

var begin_viewdir_frag = "#define GLSLIFY 1\n#ifdef CAMERA_ORTHOGRAPHIC\n    vec3 V = -camera_Forward;\n#else\n    #ifdef MATERIAL_NEED_WORLD_POS\n        vec3 V =  normalize( camera_Position - v_pos );\n    #endif\n#endif"; // eslint-disable-line

var mobile_blinnphong_frag = "#define GLSLIFY 1\n    #ifdef MATERIAL_HAS_NORMALTEXTURE\n        mat3 tbn = getTBN(gl_FrontFacing);\n        vec3 N = getNormalByNormalTexture(tbn, material_NormalTexture, material_NormalIntensity, v_uv, gl_FrontFacing);\n    #else\n        vec3 N = getNormal(gl_FrontFacing);\n    #endif\n\n    vec3 lightDiffuse = vec3( 0.0, 0.0, 0.0 );\n    vec3 lightSpecular = vec3( 0.0, 0.0, 0.0 );\n    float shadowAttenuation = 1.0;\n\n    #ifdef SCENE_DIRECT_LIGHT_COUNT\n        shadowAttenuation = 1.0;\n        #ifdef SCENE_IS_CALCULATE_SHADOWS\n            shadowAttenuation *= sampleShadowMap();\n        #endif\n\n    DirectLight directionalLight;\n    for( int i = 0; i < SCENE_DIRECT_LIGHT_COUNT; i++ ) {\n        if(!isRendererCulledByLight(renderer_Layer.xy, scene_DirectLightCullingMask[i])){\n            directionalLight.color = scene_DirectLightColor[i];\n            #ifdef SCENE_IS_CALCULATE_SHADOWS\n                if (i == 0) { // Sun light index is always 0\n                    directionalLight.color *= shadowAttenuation;\n                }\n            #endif\n            directionalLight.direction = scene_DirectLightDirection[i];\n    \n            float d = max(dot(N, -directionalLight.direction), 0.0);\n            lightDiffuse += directionalLight.color * d;\n    \n            vec3 halfDir = normalize( V - directionalLight.direction );\n            float s = pow( clamp( dot( N, halfDir ), 0.0, 1.0 ), material_Shininess );\n            lightSpecular += directionalLight.color * s;\n        }\n    }\n\n    #endif\n\n    #ifdef SCENE_POINT_LIGHT_COUNT\n    PointLight pointLight;\n    for( int i = 0; i < SCENE_POINT_LIGHT_COUNT; i++ ) {\n        if(!isRendererCulledByLight(renderer_Layer.xy, scene_PointLightCullingMask[i])){\n            pointLight.color = scene_PointLightColor[i];\n            pointLight.position = scene_PointLightPosition[i];\n            pointLight.distance = scene_PointLightDistance[i];\n\n            vec3 direction = v_pos - pointLight.position;\n            float dist = length( direction );\n            direction /= dist;\n            float decay = clamp(1.0 - pow(dist / pointLight.distance, 4.0), 0.0, 1.0);\n\n            float d =  max( dot( N, -direction ), 0.0 ) * decay;\n            lightDiffuse += pointLight.color * d;\n\n            vec3 halfDir = normalize( V - direction );\n            float s = pow( clamp( dot( N, halfDir ), 0.0, 1.0 ), material_Shininess )  * decay;\n            lightSpecular += pointLight.color * s;\n        }\n    }\n\n    #endif\n\n    #ifdef SCENE_SPOT_LIGHT_COUNT\n    SpotLight spotLight;\n    for( int i = 0; i < SCENE_SPOT_LIGHT_COUNT; i++) {\n        if(!isRendererCulledByLight(renderer_Layer.xy, scene_SpotLightCullingMask[i])){\n            spotLight.color = scene_SpotLightColor[i];\n            spotLight.position = scene_SpotLightPosition[i];\n            spotLight.direction = scene_SpotLightDirection[i];\n            spotLight.distance = scene_SpotLightDistance[i];\n            spotLight.angleCos = scene_SpotLightAngleCos[i];\n            spotLight.penumbraCos = scene_SpotLightPenumbraCos[i];\n\n            vec3 direction = spotLight.position - v_pos;\n            float lightDistance = length( direction );\n            direction /= lightDistance;\n            float angleCos = dot( direction, -spotLight.direction );\n            float decay = clamp(1.0 - pow(lightDistance/spotLight.distance, 4.0), 0.0, 1.0);\n            float spotEffect = smoothstep( spotLight.penumbraCos, spotLight.angleCos, angleCos );\n            float decayTotal = decay * spotEffect;\n            float d = max( dot( N, direction ), 0.0 )  * decayTotal;\n            lightDiffuse += spotLight.color * d;\n\n            vec3 halfDir = normalize( V + direction );\n            float s = pow( clamp( dot( N, halfDir ), 0.0, 1.0 ), material_Shininess ) * decayTotal;\n            lightSpecular += spotLight.color * s;\n        }\n    }\n\n    #endif\n\n    diffuse *= vec4( lightDiffuse, 1.0 );\n    specular *= vec4( lightSpecular, 1.0 );\n\n    #ifdef MATERIAL_IS_ALPHA_CUTOFF\n        if( diffuse.a < material_AlphaCutoff ) {\n            discard;\n        }\n    #endif\n"; // eslint-disable-line

var noise_cellular = "#define GLSLIFY 1\n#include <noise_cellular_2D>\n#include <noise_cellular_3D>\n#include <noise_cellular_2x2>\n#include <noise_cellular_2x2x2>\n"; // eslint-disable-line

var noise_cellular_2D = "#define GLSLIFY 1\n// Cellular noise (\"Worley noise\") in 2D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n// https://github.com/stegu/webgl-noise\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Standard 3x3 search window for good F1 and F2 values\nvec2 cellular( vec2 P ) {\n\n\tvec2 Pi = mod289( floor( P ) );\n \tvec2 Pf = fract( P );\n\tvec3 oi = vec3( -1.0, 0.0, 1.0);\n\tvec3 of = vec3( -0.5, 0.5, 1.5);\n\tvec3 px = permute( Pi.x + oi );\n\tvec3 p = permute( px.x + Pi.y + oi ); // p11, p12, p13\n\tvec3 ox = fract( p * K ) - Ko;\n\tvec3 oy = mod7( floor( p * K ) ) * K - Ko;\n\tvec3 dx = Pf.x + 0.5 + jitter * ox;\n\tvec3 dy = Pf.y - of + jitter * oy;\n\tvec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared\n\tp = permute( px.y + Pi.y + oi ); // p21, p22, p23\n\tox = fract( p * K ) - Ko;\n\toy = mod7( floor( p * K ) ) * K - Ko;\n\tdx = Pf.x - 0.5 + jitter * ox;\n\tdy = Pf.y - of + jitter * oy;\n\tvec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared\n\tp = permute( px.z + Pi.y + oi ); // p31, p32, p33\n\tox = fract( p * K ) - Ko;\n\toy = mod7( floor( p * K ) ) * K - Ko;\n\tdx = Pf.x - 1.5 + jitter * ox;\n\tdy = Pf.y - of + jitter * oy;\n\tvec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared\n\t// Sort out the two smallest distances (F1, F2)\n\tvec3 d1a = min( d1, d2 );\n\td2 = max( d1, d2 ); // Swap to keep candidates for F2\n\td2 = min( d2, d3 ); // neither F1 nor F2 are now in d3\n\td1 = min( d1a, d2 ); // F1 is now in d1\n\td2 = max( d1a, d2 ); // Swap to keep candidates for F2\n\td1.xy = ( d1.x < d1.y ) ? d1.xy : d1.yx; // Swap if smaller\n\td1.xz = ( d1.x < d1.z ) ? d1.xz : d1.zx; // F1 is in d1.x\n\td1.yz = min( d1.yz, d2.yz ); // F2 is now not in d2.yz\n\td1.y = min( d1.y, d1.z ); // nor in  d1.z\n\td1.y = min( d1.y, d2.x ); // F2 is in d1.y, we're done.\n\treturn sqrt( d1.xy );\n\n}\n"; // eslint-disable-line

var noise_cellular_2x2 = "#define GLSLIFY 1\n// Cellular noise (\"Worley noise\") in 2D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n// https://github.com/stegu/webgl-noise\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Speeded up by using 2x2 search window instead of 3x3,\n// at the expense of some strong pattern artifacts.\n// F2 is often wrong and has sharp discontinuities.\n// If you need a smooth F2, use the slower 3x3 version.\n// F1 is sometimes wrong, too, but OK for most purposes.\nvec2 cellular2x2( vec2 P ) {\n\n\tvec2 Pi = mod289( floor( P ) );\n \tvec2 Pf = fract( P );\n\tvec4 Pfx = Pf.x + vec4( -0.5, -1.5, -0.5, -1.5 );\n\tvec4 Pfy = Pf.y + vec4( -0.5, -0.5, -1.5, -1.5 );\n\tvec4 p = permute( Pi.x + vec4( 0.0, 1.0, 0.0, 1.0 ) );\n\tp = permute( p + Pi.y + vec4( 0.0, 0.0, 1.0, 1.0 ) );\n\tvec4 ox = mod7( p ) * K + Kd2;\n\tvec4 oy = mod7( floor( p * K ) ) * K + Kd2;\n\tvec4 dx = Pfx + jitter1 * ox;\n\tvec4 dy = Pfy + jitter1 * oy;\n\tvec4 d = dx * dx + dy * dy; // d11, d12, d21 and d22, squared\n\n\t// Do it right and find both F1 and F2\n\td.xy = ( d.x < d.y ) ? d.xy : d.yx; // Swap if smaller\n\td.xz = ( d.x < d.z ) ? d.xz : d.zx;\n\td.xw = ( d.x < d.w ) ? d.xw : d.wx;\n\td.y = min( d.y, d.z );\n\td.y = min( d.y, d.w );\n\treturn sqrt( d.xy );\n\n}\n"; // eslint-disable-line

var noise_cellular_2x2x2 = "#define GLSLIFY 1\n// Cellular noise (\"Worley noise\") in 3D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n// https://github.com/stegu/webgl-noise\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Speeded up by using 2x2x2 search window instead of 3x3x3,\n// at the expense of some pattern artifacts.\n// F2 is often wrong and has sharp discontinuities.\n// If you need a good F2, use the slower 3x3x3 version.\nvec2 cellular2x2x2(vec3 P) {\n\n\tvec3 Pi = mod289( floor( P ) );\n \tvec3 Pf = fract( P );\n\tvec4 Pfx = Pf.x + vec4( 0.0, -1.0, 0.0, -1.0 );\n\tvec4 Pfy = Pf.y + vec4( 0.0, 0.0, -1.0, -1.0 );\n\tvec4 p = permute( Pi.x + vec4( 0.0, 1.0, 0.0, 1.0 ) );\n\tp = permute( p + Pi.y + vec4( 0.0, 0.0, 1.0, 1.0 ) );\n\tvec4 p1 = permute( p + Pi.z ); // z+0\n\tvec4 p2 = permute( p + Pi.z + vec4( 1.0 ) ); // z+1\n\tvec4 ox1 = fract( p1 * K ) - Ko;\n\tvec4 oy1 = mod7( floor( p1 * K ) ) * K - Ko;\n\tvec4 oz1 = floor( p1 * K2 ) * Kz - Kzo; // p1 < 289 guaranteed\n\tvec4 ox2 = fract( p2 * K ) - Ko;\n\tvec4 oy2 = mod7( floor( p2 * K ) ) * K - Ko;\n\tvec4 oz2 = floor( p2 * K2 ) * Kz - Kzo;\n\tvec4 dx1 = Pfx + jitter1 * ox1;\n\tvec4 dy1 = Pfy + jitter1 * oy1;\n\tvec4 dz1 = Pf.z + jitter1 * oz1;\n\tvec4 dx2 = Pfx + jitter1 * ox2;\n\tvec4 dy2 = Pfy + jitter1 * oy2;\n\tvec4 dz2 = Pf.z - 1.0 + jitter1 * oz2;\n\tvec4 d1 = dx1 * dx1 + dy1 * dy1 + dz1 * dz1; // z+0\n\tvec4 d2 = dx2 * dx2 + dy2 * dy2 + dz2 * dz2; // z+1\n\n\t// Do it right and sort out both F1 and F2\n\tvec4 d = min( d1, d2 ); // F1 is now in d\n\td2 = max( d1, d2 ); // Make sure we keep all candidates for F2\n\td.xy = ( d.x < d.y ) ? d.xy : d.yx; // Swap smallest to d.x\n\td.xz = ( d.x < d.z ) ? d.xz : d.zx;\n\td.xw = ( d.x < d.w ) ? d.xw : d.wx; // F1 is now in d.x\n\td.yzw = min( d.yzw, d2.yzw ); // F2 now not in d2.yzw\n\td.y = min( d.y, d.z ); // nor in d.z\n\td.y = min( d.y, d.w ); // nor in d.w\n\td.y = min( d.y, d2.x ); // F2 is now in d.y\n\treturn sqrt( d.xy ); // F1 and F2\n\n}\n"; // eslint-disable-line

var noise_cellular_3D = "#define GLSLIFY 1\n// Cellular noise (\"Worley noise\") in 3D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n// https://github.com/stegu/webgl-noise\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// 3x3x3 search region for good F2 everywhere, but a lot\n// slower than the 2x2x2 version.\n// The code below is a bit scary even to its author,\n// but it has at least half decent performance on a\n// modern GPU. In any case, it beats any software\n// implementation of Worley noise hands down.\n\nvec2 cellular( vec3 P ) {\n\n\tvec3 Pi = mod289( floor( P ) );\n \tvec3 Pf = fract( P ) - 0.5;\n\n\tvec3 Pfx = Pf.x + vec3( 1.0, 0.0, -1.0 );\n\tvec3 Pfy = Pf.y + vec3( 1.0, 0.0, -1.0 );\n\tvec3 Pfz = Pf.z + vec3( 1.0, 0.0, -1.0 );\n\n\tvec3 p = permute( Pi.x + vec3( -1.0, 0.0, 1.0 ) );\n\tvec3 p1 = permute( p + Pi.y - 1.0 );\n\tvec3 p2 = permute( p + Pi.y );\n\tvec3 p3 = permute( p + Pi.y + 1.0 );\n\n\tvec3 p11 = permute( p1 + Pi.z - 1.0 );\n\tvec3 p12 = permute( p1 + Pi.z );\n\tvec3 p13 = permute( p1 + Pi.z + 1.0 );\n\n\tvec3 p21 = permute( p2 + Pi.z - 1.0 );\n\tvec3 p22 = permute( p2 + Pi.z );\n\tvec3 p23 = permute( p2 + Pi.z + 1.0 );\n\n\tvec3 p31 = permute( p3 + Pi.z - 1.0 );\n\tvec3 p32 = permute( p3 + Pi.z );\n\tvec3 p33 = permute( p3 + Pi.z + 1.0 );\n\n\tvec3 ox11 = fract( p11 * K ) - Ko;\n\tvec3 oy11 = mod7( floor( p11 * K ) ) * K - Ko;\n\tvec3 oz11 = floor( p11 * K2 ) * Kz - Kzo; // p11 < 289 guaranteed\n\n\tvec3 ox12 = fract( p12 * K ) - Ko;\n\tvec3 oy12 = mod7( floor( p12 * K ) ) * K - Ko;\n\tvec3 oz12 = floor( p12 * K2 ) * Kz - Kzo;\n\n\tvec3 ox13 = fract( p13 * K ) - Ko;\n\tvec3 oy13 = mod7( floor( p13 * K ) ) * K - Ko;\n\tvec3 oz13 = floor( p13 * K2 ) * Kz - Kzo;\n\n\tvec3 ox21 = fract( p21 * K ) - Ko;\n\tvec3 oy21 = mod7( floor( p21 * K ) ) * K - Ko;\n\tvec3 oz21 = floor( p21 * K2 ) * Kz - Kzo;\n\n\tvec3 ox22 = fract( p22 * K ) - Ko;\n\tvec3 oy22 = mod7( floor( p22 * K ) ) * K - Ko;\n\tvec3 oz22 = floor( p22 * K2 ) * Kz - Kzo;\n\n\tvec3 ox23 = fract( p23 * K ) - Ko;\n\tvec3 oy23 = mod7( floor( p23 * K ) ) * K - Ko;\n\tvec3 oz23 = floor( p23 * K2 ) * Kz - Kzo;\n\n\tvec3 ox31 = fract( p31 * K ) - Ko;\n\tvec3 oy31 = mod7( floor( p31 * K ) ) * K - Ko;\n\tvec3 oz31 = floor( p31 * K2 ) * Kz - Kzo;\n\n\tvec3 ox32 = fract( p32 * K ) - Ko;\n\tvec3 oy32 = mod7( floor( p32 * K ) ) * K - Ko;\n\tvec3 oz32 = floor( p32 * K2 ) * Kz - Kzo;\n\n\tvec3 ox33 = fract( p33 * K ) - Ko;\n\tvec3 oy33 = mod7( floor( p33 * K ) ) * K - Ko;\n\tvec3 oz33 = floor( p33 * K2 ) * Kz - Kzo;\n\n\tvec3 dx11 = Pfx + jitter * ox11;\n\tvec3 dy11 = Pfy.x + jitter * oy11;\n\tvec3 dz11 = Pfz.x + jitter * oz11;\n\n\tvec3 dx12 = Pfx + jitter * ox12;\n\tvec3 dy12 = Pfy.x + jitter * oy12;\n\tvec3 dz12 = Pfz.y + jitter * oz12;\n\n\tvec3 dx13 = Pfx + jitter * ox13;\n\tvec3 dy13 = Pfy.x + jitter * oy13;\n\tvec3 dz13 = Pfz.z + jitter * oz13;\n\n\tvec3 dx21 = Pfx + jitter * ox21;\n\tvec3 dy21 = Pfy.y + jitter * oy21;\n\tvec3 dz21 = Pfz.x + jitter * oz21;\n\n\tvec3 dx22 = Pfx + jitter * ox22;\n\tvec3 dy22 = Pfy.y + jitter * oy22;\n\tvec3 dz22 = Pfz.y + jitter * oz22;\n\n\tvec3 dx23 = Pfx + jitter * ox23;\n\tvec3 dy23 = Pfy.y + jitter * oy23;\n\tvec3 dz23 = Pfz.z + jitter * oz23;\n\n\tvec3 dx31 = Pfx + jitter * ox31;\n\tvec3 dy31 = Pfy.z + jitter * oy31;\n\tvec3 dz31 = Pfz.x + jitter * oz31;\n\n\tvec3 dx32 = Pfx + jitter * ox32;\n\tvec3 dy32 = Pfy.z + jitter * oy32;\n\tvec3 dz32 = Pfz.y + jitter * oz32;\n\n\tvec3 dx33 = Pfx + jitter * ox33;\n\tvec3 dy33 = Pfy.z + jitter * oy33;\n\tvec3 dz33 = Pfz.z + jitter * oz33;\n\n\tvec3 d11 = dx11 * dx11 + dy11 * dy11 + dz11 * dz11;\n\tvec3 d12 = dx12 * dx12 + dy12 * dy12 + dz12 * dz12;\n\tvec3 d13 = dx13 * dx13 + dy13 * dy13 + dz13 * dz13;\n\tvec3 d21 = dx21 * dx21 + dy21 * dy21 + dz21 * dz21;\n\tvec3 d22 = dx22 * dx22 + dy22 * dy22 + dz22 * dz22;\n\tvec3 d23 = dx23 * dx23 + dy23 * dy23 + dz23 * dz23;\n\tvec3 d31 = dx31 * dx31 + dy31 * dy31 + dz31 * dz31;\n\tvec3 d32 = dx32 * dx32 + dy32 * dy32 + dz32 * dz32;\n\tvec3 d33 = dx33 * dx33 + dy33 * dy33 + dz33 * dz33;\n\n\t// Do it right and sort out both F1 and F2\n\tvec3 d1a = min( d11, d12 );\n\td12 = max( d11, d12 );\n\td11 = min( d1a, d13 ); // Smallest now not in d12 or d13\n\td13 = max( d1a, d13 );\n\td12 = min( d12, d13 ); // 2nd smallest now not in d13\n\tvec3 d2a = min( d21, d22 );\n\td22 = max( d21, d22 );\n\td21 = min( d2a, d23 ); // Smallest now not in d22 or d23\n\td23 = max( d2a, d23 );\n\td22 = min( d22, d23 ); // 2nd smallest now not in d23\n\tvec3 d3a = min( d31, d32 );\n\td32 = max( d31, d32 );\n\td31 = min( d3a, d33 ); // Smallest now not in d32 or d33\n\td33 = max( d3a, d33 );\n\td32 = min( d32, d33 ); // 2nd smallest now not in d33\n\tvec3 da = min( d11, d21 );\n\td21 = max( d11, d21 );\n\td11 = min( da, d31 ); // Smallest now in d11\n\td31 = max( da, d31 ); // 2nd smallest now not in d31\n\td11.xy = ( d11.x < d11.y ) ? d11.xy : d11.yx;\n\td11.xz = ( d11.x < d11.z ) ? d11.xz : d11.zx; // d11.x now smallest\n\td12 = min( d12, d21 ); // 2nd smallest now not in d21\n\td12 = min( d12, d22 ); // nor in d22\n\td12 = min( d12, d31 ); // nor in d31\n\td12 = min( d12, d32 ); // nor in d32\n\td11.yz = min( d11.yz, d12.xy ); // nor in d12.yz\n\td11.y = min( d11.y, d12.z ); // Only two more to go\n\td11.y = min( d11.y, d11.z ); // Done! (Phew! )\n\treturn sqrt( d11.xy ); // F1, F2\n\n}\n"; // eslint-disable-line

var noise_common = "#define GLSLIFY 1\n// Modulo 289 without a division (only multiplications)\nvec4 mod289( vec4 x ) {\n\n    return x - floor( x * ( 1.0 / 289.0 ) ) * 289.0;\n\n}\n\nvec3 mod289( vec3 x ) {\n\n    return x - floor( x * ( 1.0 / 289.0 ) ) * 289.0;\n\n}\n\nvec2 mod289( vec2 x ) {\n\n    return x - floor( x * ( 1.0 / 289.0 ) ) * 289.0;\n\n}\n\nfloat mod289( float x ) {\n\n    return x - floor( x * ( 1.0 / 289.0 ) ) * 289.0;\n\n}\n\n// Modulo 7 without a division\nvec4 mod7( vec4 x ) {\n\n    return x - floor( x * ( 1.0 / 7.0 ) ) * 7.0;\n\n}\n\nvec3 mod7( vec3 x ) {\n\n    return x - floor( x * ( 1.0 / 7.0 ) ) * 7.0;\n\n}\n\n// Permutation polynomial: (34x^2 + x) mod 289\nvec4 permute( vec4 x ) {\n\n    return mod289( ( 34.0 * x + 1.0 ) * x);\n\n}\n\nvec3 permute( vec3 x ) {\n\n    return mod289( ( 34.0 * x + 1.0 ) * x );\n\n}\n\nfloat permute( float x ) {\n\n  return mod289( ( ( x * 34.0 ) + 1.0 ) * x );\n\n}\n\nvec4 taylorInvSqrt( vec4 r ) {\n\n    return 1.79284291400159 - 0.85373472095314 * r;\n\n}\n\nfloat taylorInvSqrt( float r ) {\n\n    return 1.79284291400159 - 0.85373472095314 * r;\n\n}\n\nvec4 fade( vec4 t ) {\n\n    return t * t * t * ( t * ( t * 6.0 - 15.0 ) + 10.0 );\n\n}\n\nvec3 fade( vec3 t ) {\n\n    return t * t * t * ( t * ( t * 6.0 - 15.0 ) + 10.0 );\n\n}\n\nvec2 fade( vec2 t ) {\n\n    return t * t * t * ( t * ( t * 6.0 - 15.0 ) + 10.0 );\n\n}\n\n#define K 0.142857142857 // 1/7\n#define Ko 0.428571428571 // 1/2-K/2\n#define K2 0.020408163265306 // 1/(7*7)\n#define Kd2 0.0714285714285 // K/2\n#define Kz 0.166666666667 // 1/6\n#define Kzo 0.416666666667 // 1/2-1/6*2\n#define jitter 1.0 // smaller jitter gives more regular pattern\n#define jitter1 0.8 // smaller jitter gives less errors in F1 F2\n"; // eslint-disable-line

var noise_perlin = "#define GLSLIFY 1\n#include <noise_perlin_2D>\n#include <noise_perlin_3D>\n#include <noise_perlin_4D>\n"; // eslint-disable-line

var noise_perlin_2D = "#define GLSLIFY 1\n//\n// GLSL textureless classic 2D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\n// Classic Perlin noise\nfloat perlin( vec2 P ) {\n\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod289(Pi); // To avoid truncation effects in permutation\n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n\n    vec4 i = permute(permute(ix) + iy);\n\n    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n    vec4 gy = abs(gx) - 0.5 ;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n\n    vec2 g00 = vec2(gx.x,gy.x);\n    vec2 g10 = vec2(gx.y,gy.y);\n    vec2 g01 = vec2(gx.z,gy.z);\n    vec2 g11 = vec2(gx.w,gy.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n    g00 *= norm.x;\n    g01 *= norm.y;\n    g10 *= norm.z;\n    g11 *= norm.w;\n\n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n\n    vec2 fade_xy = fade(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n\n}\n\n// Classic Perlin noise, periodic variant\nfloat perlin( vec2 P, vec2 rep ) {\n\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\n    Pi = mod289(Pi);        // To avoid truncation effects in permutation\n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n\n    vec4 i = permute(permute(ix) + iy);\n\n    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n    vec4 gy = abs(gx) - 0.5 ;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n\n    vec2 g00 = vec2(gx.x,gy.x);\n    vec2 g10 = vec2(gx.y,gy.y);\n    vec2 g01 = vec2(gx.z,gy.z);\n    vec2 g11 = vec2(gx.w,gy.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n    g00 *= norm.x;\n    g01 *= norm.y;\n    g10 *= norm.z;\n    g11 *= norm.w;\n\n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n\n    vec2 fade_xy = fade(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n\n}\n"; // eslint-disable-line

var noise_perlin_3D = "#define GLSLIFY 1\n//\n// GLSL textureless classic 3D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\n// Classic Perlin noise\nfloat perlin( vec3 P ) {\n\n    vec3 Pi0 = floor(P); // Integer part for indexing\n    vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n\n}\n\n// Classic Perlin noise, periodic variant\nfloat perlin( vec3 P, vec3 rep ) {\n\n    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n\n}\n"; // eslint-disable-line

var noise_perlin_4D = "#define GLSLIFY 1\n//\n// GLSL textureless classic 4D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\n// Classic Perlin noise\nfloat perlin( vec4 P ) {\n\n    vec4 Pi0 = floor(P); // Integer part for indexing\n    vec4 Pi1 = Pi0 + 1.0; // Integer part + 1\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec4 Pf0 = fract(P); // Fractional part for interpolation\n    vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = vec4(Pi0.zzzz);\n    vec4 iz1 = vec4(Pi1.zzzz);\n    vec4 iw0 = vec4(Pi0.wwww);\n    vec4 iw1 = vec4(Pi1.wwww);\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n    vec4 ixy00 = permute(ixy0 + iw0);\n    vec4 ixy01 = permute(ixy0 + iw1);\n    vec4 ixy10 = permute(ixy1 + iw0);\n    vec4 ixy11 = permute(ixy1 + iw1);\n\n    vec4 gx00 = ixy00 * (1.0 / 7.0);\n    vec4 gy00 = floor(gx00) * (1.0 / 7.0);\n    vec4 gz00 = floor(gy00) * (1.0 / 6.0);\n    gx00 = fract(gx00) - 0.5;\n    gy00 = fract(gy00) - 0.5;\n    gz00 = fract(gz00) - 0.5;\n    vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n    vec4 sw00 = step(gw00, vec4(0.0));\n    gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n    gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n    vec4 gx01 = ixy01 * (1.0 / 7.0);\n    vec4 gy01 = floor(gx01) * (1.0 / 7.0);\n    vec4 gz01 = floor(gy01) * (1.0 / 6.0);\n    gx01 = fract(gx01) - 0.5;\n    gy01 = fract(gy01) - 0.5;\n    gz01 = fract(gz01) - 0.5;\n    vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n    vec4 sw01 = step(gw01, vec4(0.0));\n    gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n    gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n    vec4 gx10 = ixy10 * (1.0 / 7.0);\n    vec4 gy10 = floor(gx10) * (1.0 / 7.0);\n    vec4 gz10 = floor(gy10) * (1.0 / 6.0);\n    gx10 = fract(gx10) - 0.5;\n    gy10 = fract(gy10) - 0.5;\n    gz10 = fract(gz10) - 0.5;\n    vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n    vec4 sw10 = step(gw10, vec4(0.0));\n    gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n    gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n    vec4 gx11 = ixy11 * (1.0 / 7.0);\n    vec4 gy11 = floor(gx11) * (1.0 / 7.0);\n    vec4 gz11 = floor(gy11) * (1.0 / 6.0);\n    gx11 = fract(gx11) - 0.5;\n    gy11 = fract(gy11) - 0.5;\n    gz11 = fract(gz11) - 0.5;\n    vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n    vec4 sw11 = step(gw11, vec4(0.0));\n    gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n    gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n    vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n    vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n    vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n    vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n    vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n    vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n    vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n    vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n    vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n    vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n    vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n    vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n    vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n    vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n    vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n    vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n    vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n    g0000 *= norm00.x;\n    g0100 *= norm00.y;\n    g1000 *= norm00.z;\n    g1100 *= norm00.w;\n\n    vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n    g0001 *= norm01.x;\n    g0101 *= norm01.y;\n    g1001 *= norm01.z;\n    g1101 *= norm01.w;\n\n    vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n    g0010 *= norm10.x;\n    g0110 *= norm10.y;\n    g1010 *= norm10.z;\n    g1110 *= norm10.w;\n\n    vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n    g0011 *= norm11.x;\n    g0111 *= norm11.y;\n    g1011 *= norm11.z;\n    g1111 *= norm11.w;\n\n    float n0000 = dot(g0000, Pf0);\n    float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n    float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n    float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n    float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n    float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n    float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n    float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n    float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n    float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n    float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n    float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n    float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n    float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n    float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n    float n1111 = dot(g1111, Pf1);\n\n    vec4 fade_xyzw = fade(Pf0);\n    vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n    vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n    vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n    vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n    float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n    return 2.2 * n_xyzw;\n\n}\n\n// Classic Perlin noise, periodic version\nfloat perlin( vec4 P, vec4 rep ) {\n\n    vec4 Pi0 = mod(floor(P), rep); // Integer part modulo rep\n    vec4 Pi1 = mod(Pi0 + 1.0, rep); // Integer part + 1 mod rep\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec4 Pf0 = fract(P); // Fractional part for interpolation\n    vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = vec4(Pi0.zzzz);\n    vec4 iz1 = vec4(Pi1.zzzz);\n    vec4 iw0 = vec4(Pi0.wwww);\n    vec4 iw1 = vec4(Pi1.wwww);\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n    vec4 ixy00 = permute(ixy0 + iw0);\n    vec4 ixy01 = permute(ixy0 + iw1);\n    vec4 ixy10 = permute(ixy1 + iw0);\n    vec4 ixy11 = permute(ixy1 + iw1);\n\n    vec4 gx00 = ixy00 * (1.0 / 7.0);\n    vec4 gy00 = floor(gx00) * (1.0 / 7.0);\n    vec4 gz00 = floor(gy00) * (1.0 / 6.0);\n    gx00 = fract(gx00) - 0.5;\n    gy00 = fract(gy00) - 0.5;\n    gz00 = fract(gz00) - 0.5;\n    vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n    vec4 sw00 = step(gw00, vec4(0.0));\n    gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n    gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n    vec4 gx01 = ixy01 * (1.0 / 7.0);\n    vec4 gy01 = floor(gx01) * (1.0 / 7.0);\n    vec4 gz01 = floor(gy01) * (1.0 / 6.0);\n    gx01 = fract(gx01) - 0.5;\n    gy01 = fract(gy01) - 0.5;\n    gz01 = fract(gz01) - 0.5;\n    vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n    vec4 sw01 = step(gw01, vec4(0.0));\n    gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n    gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n    vec4 gx10 = ixy10 * (1.0 / 7.0);\n    vec4 gy10 = floor(gx10) * (1.0 / 7.0);\n    vec4 gz10 = floor(gy10) * (1.0 / 6.0);\n    gx10 = fract(gx10) - 0.5;\n    gy10 = fract(gy10) - 0.5;\n    gz10 = fract(gz10) - 0.5;\n    vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n    vec4 sw10 = step(gw10, vec4(0.0));\n    gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n    gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n    vec4 gx11 = ixy11 * (1.0 / 7.0);\n    vec4 gy11 = floor(gx11) * (1.0 / 7.0);\n    vec4 gz11 = floor(gy11) * (1.0 / 6.0);\n    gx11 = fract(gx11) - 0.5;\n    gy11 = fract(gy11) - 0.5;\n    gz11 = fract(gz11) - 0.5;\n    vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n    vec4 sw11 = step(gw11, vec4(0.0));\n    gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n    gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n    vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n    vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n    vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n    vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n    vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n    vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n    vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n    vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n    vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n    vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n    vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n    vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n    vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n    vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n    vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n    vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n    vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n    g0000 *= norm00.x;\n    g0100 *= norm00.y;\n    g1000 *= norm00.z;\n    g1100 *= norm00.w;\n\n    vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n    g0001 *= norm01.x;\n    g0101 *= norm01.y;\n    g1001 *= norm01.z;\n    g1101 *= norm01.w;\n\n    vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n    g0010 *= norm10.x;\n    g0110 *= norm10.y;\n    g1010 *= norm10.z;\n    g1110 *= norm10.w;\n\n    vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n    g0011 *= norm11.x;\n    g0111 *= norm11.y;\n    g1011 *= norm11.z;\n    g1111 *= norm11.w;\n\n    float n0000 = dot(g0000, Pf0);\n    float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n    float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n    float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n    float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n    float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n    float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n    float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n    float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n    float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n    float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n    float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n    float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n    float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n    float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n    float n1111 = dot(g1111, Pf1);\n\n    vec4 fade_xyzw = fade(Pf0);\n    vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n    vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n    vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n    vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n    float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n    return 2.2 * n_xyzw;\n\n}\n"; // eslint-disable-line

var noise_psrd_2D = "#define GLSLIFY 1\n// Periodic (tiling) 2-D simplex noise (hexagonal lattice gradient noise)\n// with rotating gradients and analytic derivatives.\n// Variants also without the derivative (no \"d\" in the name), without\n// the tiling property (no \"p\" in the name) and without the rotating\n// gradients (no \"r\" in the name).\n//\n// This is (yet) another variation on simplex noise. It's similar to the\n// version presented by Ken Perlin, but the grid is axis-aligned and\n// slightly stretched in the y direction to permit rectangular tiling.\n//\n// The noise can be made to tile seamlessly to any integer period in x and\n// any even integer period in y. Odd periods may be specified for y, but\n// then the actual tiling period will be twice that number.\n//\n// The rotating gradients give the appearance of a swirling motion, and can\n// serve a similar purpose for animation as motion along z in 3-D noise.\n// The rotating gradients in conjunction with the analytic derivatives\n// can make \"flow noise\" effects as presented by Perlin and Neyret.\n//\n// vec3 {p}s{r}dnoise(vec2 pos {, vec2 per} {, float rot})\n// \"pos\" is the input (x,y) coordinate\n// \"per\" is the x and y period, where per.x is a positive integer\n//    and per.y is a positive even integer\n// \"rot\" is the angle to rotate the gradients (any float value,\n//    where 0.0 is no rotation and 1.0 is one full turn)\n// The first component of the 3-element return vector is the noise value.\n// The second and third components are the x and y partial derivatives.\n//\n// float {p}s{r}noise(vec2 pos {, vec2 per} {, float rot})\n// \"pos\" is the input (x,y) coordinate\n// \"per\" is the x and y period, where per.x is a positive integer\n//    and per.y is a positive even integer\n// \"rot\" is the angle to rotate the gradients (any float value,\n//    where 0.0 is no rotation and 1.0 is one full turn)\n// The return value is the noise value.\n// Partial derivatives are not computed, making these functions faster.\n//\n// Author: Stefan Gustavson (stefan.gustavson@gmail.com)\n// Version 2016-05-10.\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// idea of using a permutation polynomial.\n//\n// Copyright (c) 2016 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\n// Hashed 2-D gradients with an extra rotation.\n// (The constant 0.0243902439 is 1/41)\nvec2 rgrad2( vec2 p, float rot ) {\n\n    // For more isotropic gradients, sin/cos can be used instead.\n    float u = permute( permute( p.x ) + p.y ) * 0.0243902439 + rot; // Rotate by shift\n    u = fract( u ) * 6.28318530718; // 2*pi\n    return vec2( cos( u ), sin( u ));\n\n}\n\n//\n// 2-D tiling simplex noise with rotating gradients and analytical derivative.\n// The first component of the 3-element return vector is the noise value,\n// and the second and third components are the x and y partial derivatives.\n//\nvec3 psrdnoise(vec2 pos, vec2 per, float rot) {\n  // Hack: offset y slightly to hide some rare artifacts\n  pos.y += 0.01;\n  // Skew to hexagonal grid\n  vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\n\n  vec2 i0 = floor(uv);\n  vec2 f0 = fract(uv);\n  // Traversal order\n  vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\n  // Unskewed grid points in (x,y) space\n  vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n  vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\n  vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n\n  // Integer grid point indices in (u,v) space\n  i1 = i0 + i1;\n  vec2 i2 = i0 + vec2(1.0, 1.0);\n\n  // Vectors in unskewed (x,y) coordinates from\n  // each of the simplex corners to the evaluation point\n  vec2 d0 = pos - p0;\n  vec2 d1 = pos - p1;\n  vec2 d2 = pos - p2;\n\n  // Wrap i0, i1 and i2 to the desired period before gradient hashing:\n  // wrap points in (x,y), map to (u,v)\n  vec3 xw = mod(vec3(p0.x, p1.x, p2.x), per.x);\n  vec3 yw = mod(vec3(p0.y, p1.y, p2.y), per.y);\n  vec3 iuw = xw + 0.5 * yw;\n  vec3 ivw = yw;\n\n  // Create gradients from indices\n  vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\n  vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\n  vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\n\n  // Gradients dot vectors to corresponding corners\n  // (The derivatives of this are simply the gradients)\n  vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\n\n  // Radial weights from corners\n  // 0.8 is the square of 2/sqrt(5), the distance from\n  // a grid point to the nearest simplex boundary\n  vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\n\n  // Partial derivatives for analytical gradient computation\n  vec3 dtdx = -2.0 * vec3(d0.x, d1.x, d2.x);\n  vec3 dtdy = -2.0 * vec3(d0.y, d1.y, d2.y);\n\n  // Set influence of each surflet to zero outside radius sqrt(0.8)\n  if (t.x < 0.0) {\n    dtdx.x = 0.0;\n    dtdy.x = 0.0;\n\tt.x = 0.0;\n  }\n  if (t.y < 0.0) {\n    dtdx.y = 0.0;\n    dtdy.y = 0.0;\n\tt.y = 0.0;\n  }\n  if (t.z < 0.0) {\n    dtdx.z = 0.0;\n    dtdy.z = 0.0;\n\tt.z = 0.0;\n  }\n\n  // Fourth power of t (and third power for derivative)\n  vec3 t2 = t * t;\n  vec3 t4 = t2 * t2;\n  vec3 t3 = t2 * t;\n\n  // Final noise value is:\n  // sum of ((radial weights) times (gradient dot vector from corner))\n  float n = dot(t4, w);\n\n  // Final analytical derivative (gradient of a sum of scalar products)\n  vec2 dt0 = vec2(dtdx.x, dtdy.x) * 4.0 * t3.x;\n  vec2 dn0 = t4.x * g0 + dt0 * w.x;\n  vec2 dt1 = vec2(dtdx.y, dtdy.y) * 4.0 * t3.y;\n  vec2 dn1 = t4.y * g1 + dt1 * w.y;\n  vec2 dt2 = vec2(dtdx.z, dtdy.z) * 4.0 * t3.z;\n  vec2 dn2 = t4.z * g2 + dt2 * w.z;\n\n  return 11.0*vec3(n, dn0 + dn1 + dn2);\n}\n\n//\n// 2-D tiling simplex noise with fixed gradients\n// and analytical derivative.\n// This function is implemented as a wrapper to \"psrdnoise\",\n// at the minimal cost of three extra additions.\n//\nvec3 psdnoise(vec2 pos, vec2 per) {\n  return psrdnoise(pos, per, 0.0);\n}\n\n//\n// 2-D tiling simplex noise with rotating gradients,\n// but without the analytical derivative.\n//\nfloat psrnoise(vec2 pos, vec2 per, float rot) {\n  // Offset y slightly to hide some rare artifacts\n  pos.y += 0.001;\n  // Skew to hexagonal grid\n  vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\n\n  vec2 i0 = floor(uv);\n  vec2 f0 = fract(uv);\n  // Traversal order\n  vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\n  // Unskewed grid points in (x,y) space\n  vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n  vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\n  vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n\n  // Integer grid point indices in (u,v) space\n  i1 = i0 + i1;\n  vec2 i2 = i0 + vec2(1.0, 1.0);\n\n  // Vectors in unskewed (x,y) coordinates from\n  // each of the simplex corners to the evaluation point\n  vec2 d0 = pos - p0;\n  vec2 d1 = pos - p1;\n  vec2 d2 = pos - p2;\n\n  // Wrap i0, i1 and i2 to the desired period before gradient hashing:\n  // wrap points in (x,y), map to (u,v)\n  vec3 xw = mod(vec3(p0.x, p1.x, p2.x), per.x);\n  vec3 yw = mod(vec3(p0.y, p1.y, p2.y), per.y);\n  vec3 iuw = xw + 0.5 * yw;\n  vec3 ivw = yw;\n\n  // Create gradients from indices\n  vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\n  vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\n  vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\n\n  // Gradients dot vectors to corresponding corners\n  // (The derivatives of this are simply the gradients)\n  vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\n\n  // Radial weights from corners\n  // 0.8 is the square of 2/sqrt(5), the distance from\n  // a grid point to the nearest simplex boundary\n  vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\n\n  // Set influence of each surflet to zero outside radius sqrt(0.8)\n  t = max(t, 0.0);\n\n  // Fourth power of t\n  vec3 t2 = t * t;\n  vec3 t4 = t2 * t2;\n\n  // Final noise value is:\n  // sum of ((radial weights) times (gradient dot vector from corner))\n  float n = dot(t4, w);\n\n  // Rescale to cover the range [-1,1] reasonably well\n  return 11.0*n;\n}\n\n//\n// 2-D tiling simplex noise with fixed gradients,\n// without the analytical derivative.\n// This function is implemented as a wrapper to \"psrnoise\",\n// at the minimal cost of three extra additions.\n//\nfloat psnoise(vec2 pos, vec2 per) {\n  return psrnoise(pos, per, 0.0);\n}\n\n//\n// 2-D non-tiling simplex noise with rotating gradients and analytical derivative.\n// The first component of the 3-element return vector is the noise value,\n// and the second and third components are the x and y partial derivatives.\n//\nvec3 srdnoise(vec2 pos, float rot) {\n  // Offset y slightly to hide some rare artifacts\n  pos.y += 0.001;\n  // Skew to hexagonal grid\n  vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\n\n  vec2 i0 = floor(uv);\n  vec2 f0 = fract(uv);\n  // Traversal order\n  vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\n  // Unskewed grid points in (x,y) space\n  vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n  vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\n  vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n\n  // Integer grid point indices in (u,v) space\n  i1 = i0 + i1;\n  vec2 i2 = i0 + vec2(1.0, 1.0);\n\n  // Vectors in unskewed (x,y) coordinates from\n  // each of the simplex corners to the evaluation point\n  vec2 d0 = pos - p0;\n  vec2 d1 = pos - p1;\n  vec2 d2 = pos - p2;\n\n  vec3 x = vec3(p0.x, p1.x, p2.x);\n  vec3 y = vec3(p0.y, p1.y, p2.y);\n  vec3 iuw = x + 0.5 * y;\n  vec3 ivw = y;\n\n  // Avoid precision issues in permutation\n  iuw = mod289(iuw);\n  ivw = mod289(ivw);\n\n  // Create gradients from indices\n  vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\n  vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\n  vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\n\n  // Gradients dot vectors to corresponding corners\n  // (The derivatives of this are simply the gradients)\n  vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\n\n  // Radial weights from corners\n  // 0.8 is the square of 2/sqrt(5), the distance from\n  // a grid point to the nearest simplex boundary\n  vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\n\n  // Partial derivatives for analytical gradient computation\n  vec3 dtdx = -2.0 * vec3(d0.x, d1.x, d2.x);\n  vec3 dtdy = -2.0 * vec3(d0.y, d1.y, d2.y);\n\n  // Set influence of each surflet to zero outside radius sqrt(0.8)\n  if (t.x < 0.0) {\n    dtdx.x = 0.0;\n    dtdy.x = 0.0;\n\tt.x = 0.0;\n  }\n  if (t.y < 0.0) {\n    dtdx.y = 0.0;\n    dtdy.y = 0.0;\n\tt.y = 0.0;\n  }\n  if (t.z < 0.0) {\n    dtdx.z = 0.0;\n    dtdy.z = 0.0;\n\tt.z = 0.0;\n  }\n\n  // Fourth power of t (and third power for derivative)\n  vec3 t2 = t * t;\n  vec3 t4 = t2 * t2;\n  vec3 t3 = t2 * t;\n\n  // Final noise value is:\n  // sum of ((radial weights) times (gradient dot vector from corner))\n  float n = dot(t4, w);\n\n  // Final analytical derivative (gradient of a sum of scalar products)\n  vec2 dt0 = vec2(dtdx.x, dtdy.x) * 4.0 * t3.x;\n  vec2 dn0 = t4.x * g0 + dt0 * w.x;\n  vec2 dt1 = vec2(dtdx.y, dtdy.y) * 4.0 * t3.y;\n  vec2 dn1 = t4.y * g1 + dt1 * w.y;\n  vec2 dt2 = vec2(dtdx.z, dtdy.z) * 4.0 * t3.z;\n  vec2 dn2 = t4.z * g2 + dt2 * w.z;\n\n  return 11.0*vec3(n, dn0 + dn1 + dn2);\n}\n\n//\n// 2-D non-tiling simplex noise with fixed gradients and analytical derivative.\n// This function is implemented as a wrapper to \"srdnoise\",\n// at the minimal cost of three extra additions.\n//\nvec3 sdnoise(vec2 pos) {\n  return srdnoise(pos, 0.0);\n}\n\n//\n// 2-D non-tiling simplex noise with rotating gradients,\n// without the analytical derivative.\n//\nfloat srnoise(vec2 pos, float rot) {\n  // Offset y slightly to hide some rare artifacts\n  pos.y += 0.001;\n  // Skew to hexagonal grid\n  vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\n\n  vec2 i0 = floor(uv);\n  vec2 f0 = fract(uv);\n  // Traversal order\n  vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\n  // Unskewed grid points in (x,y) space\n  vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n  vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\n  vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n\n  // Integer grid point indices in (u,v) space\n  i1 = i0 + i1;\n  vec2 i2 = i0 + vec2(1.0, 1.0);\n\n  // Vectors in unskewed (x,y) coordinates from\n  // each of the simplex corners to the evaluation point\n  vec2 d0 = pos - p0;\n  vec2 d1 = pos - p1;\n  vec2 d2 = pos - p2;\n\n  // Wrap i0, i1 and i2 to the desired period before gradient hashing:\n  // wrap points in (x,y), map to (u,v)\n  vec3 x = vec3(p0.x, p1.x, p2.x);\n  vec3 y = vec3(p0.y, p1.y, p2.y);\n  vec3 iuw = x + 0.5 * y;\n  vec3 ivw = y;\n\n  // Avoid precision issues in permutation\n  iuw = mod289(iuw);\n  ivw = mod289(ivw);\n\n  // Create gradients from indices\n  vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\n  vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\n  vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\n\n  // Gradients dot vectors to corresponding corners\n  // (The derivatives of this are simply the gradients)\n  vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\n\n  // Radial weights from corners\n  // 0.8 is the square of 2/sqrt(5), the distance from\n  // a grid point to the nearest simplex boundary\n  vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\n\n  // Set influence of each surflet to zero outside radius sqrt(0.8)\n  t = max(t, 0.0);\n\n  // Fourth power of t\n  vec3 t2 = t * t;\n  vec3 t4 = t2 * t2;\n\n  // Final noise value is:\n  // sum of ((radial weights) times (gradient dot vector from corner))\n  float n = dot(t4, w);\n\n  // Rescale to cover the range [-1,1] reasonably well\n  return 11.0*n;\n}\n\n//\n// 2-D non-tiling simplex noise with fixed gradients,\n// without the analytical derivative.\n// This function is implemented as a wrapper to \"srnoise\",\n// at the minimal cost of three extra additions.\n// Note: if this kind of noise is all you want, there are faster\n// GLSL implementations of non-tiling simplex noise out there.\n// This one is included mainly for completeness and compatibility\n// with the other functions in the file.\n//\nfloat snoise(vec2 pos) {\n  return srnoise(pos, 0.0);\n}\n"; // eslint-disable-line

var noise_simplex = "#define GLSLIFY 1\n#include <noise_simplex_2D>\n#include <noise_simplex_3D>\n#include <noise_simplex_3D_grad>\n#include <noise_simplex_4D>\n"; // eslint-disable-line

var noise_simplex_2D = "#define GLSLIFY 1\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n//\n\nfloat simplex( vec2 v ) {\n\n    const vec4 C = vec4( 0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439 ); // 1.0 / 41.0\n    // First corner\n    vec2 i  = floor( v + dot( v, C.yy ) );\n    vec2 x0 = v - i + dot( i, C.xx );\n\n    // Other corners\n    vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = ( x0.x > x0.y ) ? vec2( 1.0, 0.0 ) : vec2( 0.0, 1.0 );\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289( i ); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3( 0.0, i1.y, 1.0 ) )\n        + i.x + vec3( 0.0, i1.x, 1.0 ) );\n\n    vec3 m = max( 0.5 - vec3( dot( x0, x0 ), dot( x12.xy, x12.xy ), dot( x12.zw, x12.zw ) ), 0.0 );\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract( p * C.www ) - 1.0;\n    vec3 h = abs( x ) - 0.5;\n    vec3 ox = floor( x + 0.5 );\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0 * a0 + h * h );\n\n    // Compute final noise value at P\n    vec3 g;\n    g.x  = a0.x * x0.x + h.x * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot( m, g );\n\n}\n"; // eslint-disable-line

var noise_simplex_3D = "#define GLSLIFY 1\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n//\n\nfloat simplex( vec3 v ) {\n\n    const vec2 C = vec2( 1.0 / 6.0, 1.0 / 3.0 );\n    const vec4 D = vec4( 0.0, 0.5, 1.0, 2.0 );\n\n    // First corner\n    vec3 i  = floor( v + dot( v, C.yyy ) );\n    vec3 x0 = v - i + dot( i, C.xxx );\n\n    // Other corners\n    vec3 g = step( x0.yzx, x0.xyz );\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289( i );\n    vec4 p = permute( permute( permute(\n                i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n            + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n            + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3 ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor( p * ns.z * ns.z );  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs( x ) - abs( y );\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor( b0 ) * 2.0 + 1.0;\n    vec4 s1 = floor( b1 ) * 2.0 + 1.0;\n    vec4 sh = - step( h, vec4( 0.0 ) );\n\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww ;\n\n    vec3 p0 = vec3( a0.xy, h.x );\n    vec3 p1 = vec3( a0.zw, h.y );\n    vec3 p2 = vec3( a1.xy, h.z );\n    vec3 p3 = vec3( a1.zw, h.w );\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt( vec4( dot( p0, p0 ), dot( p1, p1 ), dot( p2, p2 ), dot( p3, p3 ) ) );\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max( 0.6 - vec4( dot( x0, x0 ), dot( x1, x1 ), dot( x2, x2 ), dot( x3, x3 ) ), 0.0 );\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot( p0, x0 ), dot( p1, x1 ),\n                                dot( p2, x2 ), dot( p3, x3 ) ) );\n\n}\n"; // eslint-disable-line

var noise_simplex_3D_grad = "#define GLSLIFY 1\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20150104 (JcBernack)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n//\n\nfloat simplex( vec3 v, out vec3 gradient ) {\n\n    const vec2  C = vec2( 1.0 / 6.0, 1.0 / 3.0 );\n    const vec4  D = vec4( 0.0, 0.5, 1.0, 2.0 );\n\n    // First corner\n    vec3 i  = floor( v + dot( v, C.yyy ) );\n    vec3 x0 = v - i + dot( i, C.xxx ) ;\n\n    // Other corners\n    vec3 g = step( x0.yzx, x0.xyz );\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289( i );\n    vec4 p = permute( permute( permute(\n                i.z + vec4( 0.0, i1.z, i2.z, 1.0 ) )\n            + i.y + vec4( 0.0, i1.y, i2.y, 1.0 ) )\n            + i.x + vec4( 0.0, i1.x, i2.x, 1.0 ) );\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3 ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ * ns.x + ns.yyyy;\n    vec4 y = y_ * ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs( x ) - abs( y );\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor( b0 ) * 2.0 + 1.0;\n    vec4 s1 = floor( b1 ) * 2.0 + 1.0;\n    vec4 sh = - step( h, vec4( 0.0 ) );\n\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww ;\n\n    vec3 p0 = vec3( a0.xy, h.x );\n    vec3 p1 = vec3( a0.zw, h.y );\n    vec3 p2 = vec3( a1.xy, h.z );\n    vec3 p3 = vec3( a1.zw, h.w );\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt( vec4( dot( p0, p0 ), dot( p1, p1 ), dot( p2, p2 ), dot( p3, p3 ) ) );\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max( 0.6 - vec4( dot( x0, x0 ), dot( x1, x1 ), dot( x2, x2 ), dot( x3, x3 ) ), 0.0 );\n    vec4 m2 = m * m;\n    vec4 m4 = m2 * m2;\n    vec4 pdotx = vec4( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 ), dot( p3, x3 ) );\n\n    // Determine noise gradient\n    vec4 temp = m2 * m * pdotx;\n    gradient = - 8.0 * ( temp.x * x0 + temp.y * x1 + temp.z * x2 + temp.w * x3 );\n    gradient += m4.x * p0 + m4.y * p1 + m4.z * p2 + m4.w * p3;\n    gradient *= 42.0;\n\n    return 42.0 * dot( m4, pdotx );\n\n}\n"; // eslint-disable-line

var noise_simplex_4D = "#define GLSLIFY 1\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n//\n\nvec4 grad4( float j, vec4 ip ) {\n\n    const vec4 ones = vec4( 1.0, 1.0, 1.0, -1.0 );\n    vec4 p, s;\n\n    p.xyz = floor( fract( vec3( j ) * ip.xyz ) * 7.0 ) * ip.z - 1.0;\n    p.w = 1.5 - dot( abs( p.xyz ), ones.xyz );\n    s = vec4( lessThan( p, vec4( 0.0 ) ) );\n    p.xyz = p.xyz + ( s.xyz * 2.0 - 1.0 ) * s.www;\n\n    return p;\n\n}\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat simplex(vec4 v) {\n\n    const vec4 C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                        -0.447213595499958); // -1 + 4 * G4\n\n    // First corner\n    vec4 i  = floor( v + dot( v, vec4( F4 ) ) );\n    vec4 x0 = v - i + dot( i, C.xxxx );\n\n    // Other corners\n\n    // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n    vec4 i0;\n    vec3 isX = step( x0.yzw, x0.xxx );\n    vec3 isYZ = step( x0.zww, x0.yyz );\n    i0.x = isX.x + isX.y + isX.z;\n    i0.yzw = 1.0 - isX;\n    i0.y += isYZ.x + isYZ.y;\n    i0.zw += 1.0 - isYZ.xy;\n    i0.z += isYZ.z;\n    i0.w += 1.0 - isYZ.z;\n\n    vec4 i3 = clamp( i0, 0.0, 1.0 );\n    vec4 i2 = clamp( i0 - 1.0, 0.0, 1.0 );\n    vec4 i1 = clamp( i0 - 2.0, 0.0, 1.0 );\n\n    vec4 x1 = x0 - i1 + C.xxxx;\n    vec4 x2 = x0 - i2 + C.yyyy;\n    vec4 x3 = x0 - i3 + C.zzzz;\n    vec4 x4 = x0 + C.wwww;\n\n    // Permutations\n    i = mod289( i );\n    float j0 = permute( permute( permute( permute( i.w ) + i.z ) + i.y ) + i.x );\n    vec4 j1 = permute( permute( permute( permute (\n                i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n            + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n            + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n            + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n    // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n    // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n    vec4 ip = vec4( 1.0 / 294.0, 1.0 / 49.0, 1.0 / 7.0, 0.0 );\n\n    vec4 p0 = grad4(j0,   ip);\n    vec4 p1 = grad4(j1.x, ip);\n    vec4 p2 = grad4(j1.y, ip);\n    vec4 p3 = grad4(j1.z, ip);\n    vec4 p4 = grad4(j1.w, ip);\n\n    // Normalise gradients\n    vec4 norm = taylorInvSqrt( vec4( dot( p0, p0 ), dot( p1, p1 ), dot( p2, p2 ), dot( p3, p3 ) ) );\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    p4 *= taylorInvSqrt( dot( p4, p4 ) );\n\n    // Mix contributions from the five corners\n    vec3 m0 = max( 0.6 - vec3( dot( x0, x0 ), dot( x1, x1 ), dot( x2, x2 ) ), 0.0 );\n    vec2 m1 = max( 0.6 - vec2( dot( x3, x3 ), dot( x4, x4 ) ), 0.0 );\n    m0 = m0 * m0;\n    m1 = m1 * m1;\n    return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n                + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n}\n"; // eslint-disable-line

var pbr_frag_define = "#define GLSLIFY 1\n#define MIN_PERCEPTUAL_ROUGHNESS 0.045\n#define MIN_ROUGHNESS            0.002025\n\nuniform float material_AlphaCutoff;\nuniform vec4 material_BaseColor;\nuniform float material_Metal;\nuniform float material_Roughness;\nuniform float material_IOR;\nuniform vec3 material_PBRSpecularColor;\nuniform float material_Glossiness;\nuniform vec3 material_EmissiveColor;\nuniform float material_NormalIntensity;\nuniform float material_OcclusionIntensity;\nuniform float material_OcclusionTextureCoord;\n\n#ifdef MATERIAL_ENABLE_CLEAR_COAT\n    uniform float material_ClearCoat;\n    uniform float material_ClearCoatRoughness;\n\n    #ifdef MATERIAL_HAS_CLEAR_COAT_TEXTURE\n        uniform sampler2D material_ClearCoatTexture;\n    #endif\n\n    #ifdef MATERIAL_HAS_CLEAR_COAT_ROUGHNESS_TEXTURE\n        uniform sampler2D material_ClearCoatRoughnessTexture;\n    #endif\n\n    #ifdef MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE\n        uniform sampler2D material_ClearCoatNormalTexture;\n    #endif\n#endif\n\n#ifdef MATERIAL_ENABLE_ANISOTROPY\n    uniform vec3 material_AnisotropyInfo;\n    #ifdef MATERIAL_HAS_ANISOTROPY_TEXTURE\n        uniform sampler2D material_AnisotropyTexture;\n    #endif\n#endif\n\n// Texture\n#ifdef MATERIAL_HAS_BASETEXTURE\n    uniform sampler2D material_BaseTexture;\n#endif\n\n#ifdef MATERIAL_HAS_NORMALTEXTURE\n    uniform sampler2D material_NormalTexture;\n#endif\n\n#ifdef MATERIAL_HAS_EMISSIVETEXTURE\n    uniform sampler2D material_EmissiveTexture;\n#endif\n\n#ifdef MATERIAL_HAS_ROUGHNESS_METALLIC_TEXTURE\n    uniform sampler2D material_RoughnessMetallicTexture;\n#endif\n\n#ifdef MATERIAL_HAS_SPECULAR_GLOSSINESS_TEXTURE\n    uniform sampler2D material_SpecularGlossinessTexture;\n#endif\n\n#ifdef MATERIAL_HAS_OCCLUSION_TEXTURE\n    uniform sampler2D material_OcclusionTexture;\n#endif\n\n#ifdef MATERIAL_ENABLE_SHEEN\n    uniform float material_SheenRoughness;\n    uniform vec3 material_SheenColor;\n    #ifdef MATERIAL_HAS_SHEEN_TEXTURE\n       uniform sampler2D material_SheenTexture;\n    #endif\n\n    #ifdef MATERIAL_HAS_SHEEN_ROUGHNESS_TEXTURE\n       uniform sampler2D material_SheenRoughnessTexture;\n    #endif\n#endif\n\n#ifdef MATERIAL_ENABLE_IRIDESCENCE\n    uniform vec4 material_IridescenceInfo;\n    #ifdef MATERIAL_HAS_IRIDESCENCE_THICKNESS_TEXTURE\n       uniform sampler2D material_IridescenceThicknessTexture;\n    #endif\n\n    #ifdef MATERIAL_HAS_IRIDESCENCE_TEXTURE\n       uniform sampler2D material_IridescenceTexture;\n    #endif\n#endif\n\n#ifdef MATERIAL_ENABLE_TRANSMISSION\n    uniform float material_Transmission;\n    #ifdef MATERIAL_HAS_TRANSMISSION_TEXTURE\n        uniform sampler2D material_TransmissionTexture;\n    #endif\n\n    #ifdef MATERIAL_HAS_THICKNESS\n        uniform vec3 material_AttenuationColor;\n        uniform float material_AttenuationDistance;\n        uniform float material_Thickness;\n\n        #ifdef MATERIAL_HAS_THICKNESS_TEXTURE\n            uniform sampler2D material_ThicknessTexture;\n        #endif\n    #endif\n#endif\n\n// Runtime\nstruct ReflectedLight {\n    vec3 directDiffuse;\n    vec3 directSpecular;\n    vec3 indirectDiffuse;\n    vec3 indirectSpecular;\n};\n\nstruct Geometry {\n    vec3  position;\n    vec3  normal;\n    vec3  viewDir;\n    float dotNV;\n    \n    #ifdef MATERIAL_ENABLE_CLEAR_COAT\n        vec3 clearCoatNormal;\n        float clearCoatDotNV;\n    #endif\n\n    #ifdef MATERIAL_ENABLE_ANISOTROPY\n        vec3  anisotropicT;\n        vec3  anisotropicB;\n        vec3  anisotropicN;\n        float anisotropy;\n    #endif\n};\n\nstruct Material {\n    vec3  diffuseColor;\n    float roughness;\n    vec3  specularColor;\n    float opacity;\n    float f0;\n    float diffuseAO;\n    float specularAO;\n    vec3  envSpecularDFG;\n    float IOR;\n\n    #ifdef MATERIAL_ENABLE_CLEAR_COAT\n        float clearCoat;\n        float clearCoatRoughness;\n    #endif\n\n    #ifdef MATERIAL_ENABLE_IRIDESCENCE\n        float iridescenceIOR;\n        float iridescenceFactor;\n        float iridescenceThickness;\n        vec3 iridescenceSpecularColor;\n    #endif\n\n    #ifdef MATERIAL_ENABLE_SHEEN\n        float sheenRoughness;\n        vec3  sheenColor;\n        float sheenScaling;\n        float approxIBLSheenDG;\n    #endif\n\n    #ifdef MATERIAL_ENABLE_TRANSMISSION \n        vec3 absorptionCoefficient;\n        float transmission;\n        float thickness;\n    #endif\n};"; // eslint-disable-line

var pbr_helper = "#define GLSLIFY 1\n#include <normal_get>\n#include <brdf>\n#include <btdf>\n\n// direct + indirect\n#include <direct_irradiance_frag_define>\n#include <ibl_frag_define>\n\nfloat computeSpecularOcclusion(float ambientOcclusion, float roughness, float dotNV ) {\n    return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n\nfloat getAARoughnessFactor(vec3 normal) {\n    // Kaplanyan 2016, \"Stable specular highlights\"\n    // Tokuyoshi 2017, \"Error Reduction and Simplification for Shading Anti-Aliasing\"\n    // Tokuyoshi and Kaplanyan 2019, \"Improved Geometric Specular Antialiasing\"\n    #ifdef HAS_DERIVATIVES\n        vec3 dxy = max( abs(dFdx(normal)), abs(dFdy(normal)) );\n        return max( max(dxy.x, dxy.y), dxy.z );\n    #else\n        return 0.0;\n    #endif\n}\n\n#ifdef MATERIAL_ENABLE_ANISOTROPY\n    // Aniso Bent Normals\n    // Mc Alley https://www.gdcvault.com/play/1022235/Rendering-the-World-of-Far \n    vec3 getAnisotropicBentNormal(Geometry geometry, vec3 n, float roughness) {\n        vec3  anisotropyDirection = geometry.anisotropy >= 0.0 ? geometry.anisotropicB : geometry.anisotropicT;\n        vec3  anisotropicTangent  = cross(anisotropyDirection, geometry.viewDir);\n        vec3  anisotropicNormal   = cross(anisotropicTangent, anisotropyDirection);\n        // reduce stretching for (roughness < 0.2), refer to https://advances.realtimerendering.com/s2018/Siggraph%202018%20HDRP%20talk_with%20notes.pdf 80\n        vec3  bentNormal          = normalize( mix(n, anisotropicNormal, abs(geometry.anisotropy) * saturate( 5.0 * roughness)) );\n\n        return bentNormal;\n    }\n#endif\n\nvoid initGeometry(out Geometry geometry, bool isFrontFacing){\n    geometry.position = v_pos;\n    #ifdef CAMERA_ORTHOGRAPHIC\n        geometry.viewDir =  -camera_Forward;\n    #else\n        geometry.viewDir =  normalize(camera_Position - v_pos);\n    #endif\n    #if defined(MATERIAL_HAS_NORMALTEXTURE) || defined(MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE) || defined(MATERIAL_ENABLE_ANISOTROPY)\n        mat3 tbn = getTBN(isFrontFacing);\n    #endif\n\n    #ifdef MATERIAL_HAS_NORMALTEXTURE\n        geometry.normal = getNormalByNormalTexture(tbn, material_NormalTexture, material_NormalIntensity, v_uv, isFrontFacing);\n    #else\n        geometry.normal = getNormal(isFrontFacing);\n    #endif\n\n    geometry.dotNV = saturate( dot(geometry.normal, geometry.viewDir) );\n\n    #ifdef MATERIAL_ENABLE_CLEAR_COAT\n        #ifdef MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE\n            geometry.clearCoatNormal = getNormalByNormalTexture(tbn, material_ClearCoatNormalTexture, material_NormalIntensity, v_uv, isFrontFacing);\n        #else\n            geometry.clearCoatNormal = getNormal(isFrontFacing);\n        #endif\n        geometry.clearCoatDotNV = saturate( dot(geometry.clearCoatNormal, geometry.viewDir) );\n    #endif\n\n    #ifdef MATERIAL_ENABLE_ANISOTROPY\n        float anisotropy = material_AnisotropyInfo.z;\n        vec3 anisotropicDirection = vec3(material_AnisotropyInfo.xy, 0.0);\n        #ifdef MATERIAL_HAS_ANISOTROPY_TEXTURE\n            vec3 anisotropyTextureInfo = texture2D( material_AnisotropyTexture, v_uv ).rgb;\n            anisotropy *= anisotropyTextureInfo.b;\n            anisotropicDirection.xy *= anisotropyTextureInfo.rg * 2.0 - 1.0;\n        #endif\n\n        geometry.anisotropy = anisotropy;\n        geometry.anisotropicT = normalize(tbn * anisotropicDirection);\n        geometry.anisotropicB = normalize(cross(geometry.normal, geometry.anisotropicT));\n    #endif\n}\n\nvoid initMaterial(out Material material, inout Geometry geometry){\n        vec4 baseColor = material_BaseColor;\n        float metal = material_Metal;\n        float roughness = material_Roughness;\n        vec3 specularColor = material_PBRSpecularColor;\n        float glossiness = material_Glossiness;\n        float alphaCutoff = material_AlphaCutoff;\n        float f0 = pow2( (material_IOR - 1.0) / (material_IOR + 1.0) );\n\n        material.f0 = f0;\n        material.IOR = material_IOR;\n\n        #ifdef MATERIAL_HAS_BASETEXTURE\n            baseColor *= texture2DSRGB(material_BaseTexture, v_uv);\n        #endif\n\n        #ifdef RENDERER_ENABLE_VERTEXCOLOR\n            baseColor *= v_color;\n        #endif\n\n        #ifdef MATERIAL_IS_ALPHA_CUTOFF\n            if( baseColor.a < alphaCutoff ) {\n                discard;\n            }\n        #endif\n\n        #ifdef MATERIAL_HAS_ROUGHNESS_METALLIC_TEXTURE\n            vec4 metalRoughMapColor = texture2D( material_RoughnessMetallicTexture, v_uv );\n            roughness *= metalRoughMapColor.g;\n            metal *= metalRoughMapColor.b;\n        #endif\n\n        #ifdef MATERIAL_HAS_SPECULAR_GLOSSINESS_TEXTURE\n            vec4 specularGlossinessColor = texture2DSRGB(material_SpecularGlossinessTexture, v_uv);\n            specularColor *= specularGlossinessColor.rgb;\n            glossiness *= specularGlossinessColor.a;\n        #endif\n\n        #ifdef IS_METALLIC_WORKFLOW\n            material.diffuseColor = baseColor.rgb * ( 1.0 - metal );\n            material.specularColor = mix( vec3(f0), baseColor.rgb, metal );\n            material.roughness = roughness;\n        #else\n            float specularStrength = max( max( specularColor.r, specularColor.g ), specularColor.b );\n            material.diffuseColor = baseColor.rgb * ( 1.0 - specularStrength );\n            material.specularColor = specularColor;\n            material.roughness = 1.0 - glossiness;\n        #endif\n\n        material.roughness = max(MIN_PERCEPTUAL_ROUGHNESS, min(material.roughness + getAARoughnessFactor(geometry.normal), 1.0));\n\n        #ifdef MATERIAL_ENABLE_CLEAR_COAT\n            material.clearCoat = material_ClearCoat;\n            material.clearCoatRoughness = material_ClearCoatRoughness;\n            #ifdef MATERIAL_HAS_CLEAR_COAT_TEXTURE\n                material.clearCoat *= texture2D( material_ClearCoatTexture, v_uv ).r;\n            #endif\n            #ifdef MATERIAL_HAS_CLEAR_COAT_ROUGHNESS_TEXTURE\n                material.clearCoatRoughness *= texture2D( material_ClearCoatRoughnessTexture, v_uv ).g;\n            #endif\n            material.clearCoat = saturate( material.clearCoat );\n            material.clearCoatRoughness = max(MIN_PERCEPTUAL_ROUGHNESS, min(material.clearCoatRoughness + getAARoughnessFactor(geometry.clearCoatNormal), 1.0));\n        #endif\n\n        #ifdef MATERIAL_IS_TRANSPARENT\n            material.opacity = baseColor.a;\n        #else\n            material.opacity = 1.0;\n        #endif\n        #ifdef MATERIAL_ENABLE_ANISOTROPY\n            geometry.anisotropicN = getAnisotropicBentNormal(geometry, geometry.normal, material.roughness);\n        #endif\n\n        material.envSpecularDFG = envBRDFApprox(material.specularColor, material.roughness, geometry.dotNV );\n\n        // AO\n        float diffuseAO = 1.0;\n        float specularAO = 1.0;\n\n        #ifdef MATERIAL_HAS_OCCLUSION_TEXTURE\n            vec2 aoUV = v_uv;\n            #ifdef RENDERER_HAS_UV1\n                if(material_OcclusionTextureCoord == 1.0){\n                    aoUV = v_uv1;\n                }\n            #endif\n            diffuseAO = ((texture2D(material_OcclusionTexture, aoUV)).r - 1.0) * material_OcclusionIntensity + 1.0;\n        #endif\n\n        #if defined(MATERIAL_HAS_OCCLUSION_TEXTURE) && defined(SCENE_USE_SPECULAR_ENV) \n            specularAO = saturate( pow( geometry.dotNV + diffuseAO, exp2( - 16.0 * material.roughness - 1.0 ) ) - 1.0 + diffuseAO );\n        #endif\n\n        material.diffuseAO = diffuseAO;\n        material.specularAO = specularAO;\n\n        // Sheen\n        #ifdef MATERIAL_ENABLE_SHEEN\n            vec3 sheenColor = material_SheenColor;\n            #ifdef MATERIAL_HAS_SHEEN_TEXTURE\n                sheenColor *= texture2DSRGB(material_SheenTexture, v_uv).rgb;\n            #endif\n            material.sheenColor = sheenColor;\n\n            material.sheenRoughness = material_SheenRoughness;\n            #ifdef MATERIAL_HAS_SHEEN_ROUGHNESS_TEXTURE\n                material.sheenRoughness *= texture2D(material_SheenRoughnessTexture, v_uv).a;\n            #endif\n\n            material.sheenRoughness = max(MIN_PERCEPTUAL_ROUGHNESS, min(material.sheenRoughness + getAARoughnessFactor(geometry.normal), 1.0));\n            material.approxIBLSheenDG = prefilteredSheenDFG(geometry.dotNV, material.sheenRoughness);\n            material.sheenScaling = 1.0 - material.approxIBLSheenDG * max(max(material.sheenColor.r, material.sheenColor.g), material.sheenColor.b);\n        #endif\n\n        // Iridescence\n        #ifdef MATERIAL_ENABLE_IRIDESCENCE\n            material.iridescenceFactor = material_IridescenceInfo.x;\n            material.iridescenceIOR = material_IridescenceInfo.y;\n\n            #ifdef MATERIAL_HAS_IRIDESCENCE_THICKNESS_TEXTURE\n               float iridescenceThicknessWeight = texture2D( material_IridescenceThicknessTexture, v_uv).g;\n               material.iridescenceThickness = mix(material_IridescenceInfo.z, material_IridescenceInfo.w, iridescenceThicknessWeight);\n            #else\n               material.iridescenceThickness = material_IridescenceInfo.w;\n            #endif\n\n            #ifdef MATERIAL_HAS_IRIDESCENCE_TEXTURE\n               material.iridescenceFactor *= texture2D( material_IridescenceTexture, v_uv).r;\n            #endif\n             \n            #ifdef MATERIAL_ENABLE_IRIDESCENCE\n                float topIOR = 1.0;\n                material.iridescenceSpecularColor = evalIridescenceSpecular(topIOR, geometry.dotNV, material.iridescenceIOR, material.specularColor, material.iridescenceThickness);   \n            #endif\n        #endif\n\n        // Transmission\n        #ifdef MATERIAL_ENABLE_TRANSMISSION \n            material.transmission = material_Transmission;\n            #ifdef MATERIAL_HAS_TRANSMISSION_TEXTURE\n                material.transmission *= texture2D(material_TransmissionTexture, v_uv).r;\n            #endif\n\n            #ifdef MATERIAL_HAS_THICKNESS\n                material.absorptionCoefficient = -log(material_AttenuationColor + HALF_EPS) / max(HALF_EPS, material_AttenuationDistance);\n                material.thickness = max(material_Thickness, 0.0001);\n                #ifdef MATERIAL_HAS_THICKNESS_TEXTURE\n                    material.thickness *= texture2D( material_ThicknessTexture, v_uv).g;\n                #endif\n            #endif    \n        #endif\n\n}\n\n"; // eslint-disable-line

var brdf = "#define GLSLIFY 1\n#ifdef MATERIAL_ENABLE_SHEEN\n    uniform sampler2D scene_PrefilteredDFG;\n#endif\n\nfloat F_Schlick(float f0, float dotLH) {\n\treturn f0 + 0.96 * (pow(1.0 - dotLH, 5.0));\n}\n\nvec3 F_Schlick(vec3 specularColor, float dotLH ) {\n\n\t// Original approximation by Christophe Schlick '94\n\t// float fresnel = pow( 1.0 - dotLH, 5.0 );\n\n\t// Optimized variant (presented by Epic at SIGGRAPH '13)\n\t// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n\n}\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat G_GGX_SmithCorrelated(float alpha, float dotNL, float dotNV ) {\n\n\tfloat a2 = pow2( alpha );\n\n\t// dotNL and dotNV are explicitly swapped. This is not a mistake.\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\n\treturn 0.5 / max( gv + gl, EPSILON );\n\n}\n\n#ifdef MATERIAL_ENABLE_ANISOTROPY\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    // Heitz http://jcgt.org/published/0003/02/03/paper.pdf\n    float G_GGX_SmithCorrelated_Anisotropic(float at, float ab, float ToV, float BoV, float ToL, float BoL, float NoV, float NoL) {\n        float lambdaV = NoL * length(vec3(at * ToV, ab * BoV, NoV));\n        float lambdaL = NoV * length(vec3(at * ToL, ab * BoL, NoL));\n        return 0.5 / max(lambdaV + lambdaL, EPSILON);\n    }\n#endif\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disney’s reparameterization\nfloat D_GGX(float alpha, float dotNH ) {\n\n\tfloat a2 = pow2( alpha );\n\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1\n\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n\n}\n\n#ifdef MATERIAL_ENABLE_SHEEN\n    // http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\n    float D_Charlie(float roughness, float dotNH) {\n        float invAlpha  = 1.0 / roughness;\n        float cos2h = dotNH * dotNH;\n        float sin2h = max(1.0 - cos2h, 0.0078125); // 2^(-14/2), so sin2h^2 > 0 in fp16\n        return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n    }\n\n    // Neubelt and Pettineo 2013, \"Crafting a Next-gen Material Pipeline for The Order: 1886\".\n    float V_Neubelt(float NoV, float NoL) {\n        return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n    }\n\n    vec3 sheenBRDF(vec3 incidentDirection, Geometry geometry, vec3 sheenColor, float sheenRoughness) {\n        vec3 halfDir = normalize(incidentDirection + geometry.viewDir);\n        float dotNL = saturate(dot(geometry.normal, incidentDirection));\n        float dotNH = saturate(dot(geometry.normal, halfDir));\n        float D = D_Charlie(sheenRoughness, dotNH);\n        float V = V_Neubelt(geometry.dotNV, dotNL);\n        vec3 F = sheenColor;\n        return  D * V * F;\n    }\n\n    float prefilteredSheenDFG(float dotNV, float sheenRoughness) {\n        #ifdef HAS_TEX_LOD\n            return texture2DLodEXT(scene_PrefilteredDFG, vec2(dotNV, sheenRoughness), 0.0).b;\n        #else\n            return texture2D(scene_PrefilteredDFG, vec2(dotNV, sheenRoughness),0.0).b;\n        #endif  \n    }\n#endif\n\n#ifdef MATERIAL_ENABLE_ANISOTROPY\n    // GGX Distribution Anisotropic\n    // https://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf Addenda\n    float D_GGX_Anisotropic(float at, float ab, float ToH, float BoH, float NoH) {\n        float a2 = at * ab;\n        vec3 d = vec3(ab * ToH, at * BoH, a2 * NoH);\n        float d2 = dot(d, d);\n        float b2 = a2 / d2;\n        return a2 * b2 * b2 * RECIPROCAL_PI;\n    }\n#endif\n\nfloat DG_GGX(float alpha, float dotNV, float dotNL, float dotNH) {\n\tfloat D = D_GGX( alpha, dotNH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n    return G * D;\n}\n\n#ifdef MATERIAL_ENABLE_ANISOTROPY\n    float DG_GGX_anisotropic(vec3 h, vec3 l, Geometry geometry, float alpha, float dotNV, float dotNL, float dotNH) {\n        vec3 t = geometry.anisotropicT;\n        vec3 b = geometry.anisotropicB;\n        vec3 v = geometry.viewDir;\n\n        float dotTV = dot(t, v);\n        float dotBV = dot(b, v);\n        float dotTL = dot(t, l);\n        float dotBL = dot(b, l);\n        float dotTH = dot(t, h);\n        float dotBH = dot(b, h);\n\n        // Aniso parameter remapping\n        // https://blog.selfshadow.com/publications/s2017-shading-course/imageworks/s2017_pbs_imageworks_slides_v2.pdf page 24\n        float at = max(alpha * (1.0 + geometry.anisotropy), MIN_ROUGHNESS);\n        float ab = max(alpha * (1.0 - geometry.anisotropy), MIN_ROUGHNESS);\n\n        // specular anisotropic BRDF\n        float D = D_GGX_Anisotropic(at, ab, dotTH, dotBH, dotNH);\n        float G = G_GGX_SmithCorrelated_Anisotropic(at, ab, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL);\n\n        return G * D;\n    }\n#endif\n\n#ifdef MATERIAL_ENABLE_IRIDESCENCE\n    vec3 iorToFresnel0(vec3 transmittedIOR, float incidentIOR) {\n        return pow((transmittedIOR - incidentIOR) / (transmittedIOR + incidentIOR),vec3(2.0));\n    } \n\n    float iorToFresnel0(float transmittedIOR, float incidentIOR) {\n        return pow((transmittedIOR - incidentIOR) / (transmittedIOR + incidentIOR),2.0);\n    } \n\n    // Assume air interface for top\n    // Note: We don't handle the case fresnel0 == 1\n    vec3 fresnelToIOR(vec3 f0){\n        vec3 sqrtF0 = sqrt(f0);\n        return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);\n    }\n\n    // Fresnel equations for dielectric/dielectric interfaces.\n    // Ref: https://belcour.github.io/blog/research/publication/2017/05/01/brdf-thin-film.html\n    // Evaluation XYZ sensitivity curves in Fourier space\n    vec3 evalSensitivity(float opd, vec3 shift){\n        // Use Gaussian fits, given by 3 parameters: val, pos and var\n        float phase = 2.0 * PI * opd * 1.0e-9;\n        const vec3 val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);\n        const vec3 pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);\n        const vec3 var = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);\n        vec3 xyz = val * sqrt(2.0 * PI * var) * cos(pos * phase + shift) * exp(-var * pow2(phase));\n        xyz.x += 9.7470e-14 * sqrt(2.0 * PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * pow2(phase));\n        xyz /= 1.0685e-7;\n        // XYZ to RGB color space\n        const mat3 XYZ_TO_RGB = mat3( 3.2404542, -0.9692660,  0.0556434,\n                                     -1.5371385,  1.8760108, -0.2040259,\n                                     -0.4985314,  0.0415560,  1.0572252);\n        vec3 rgb = XYZ_TO_RGB * xyz;\n        return rgb;\n    }\n\n    vec3 evalIridescenceSpecular(float outsideIOR, float dotNV, float thinIOR, vec3 baseF0,float iridescenceThickness){ \n        vec3 iridescence = vec3(1.0);\n        // Force iridescenceIOR -> outsideIOR when thinFilmThickness -> 0.0\n        float iridescenceIOR = mix( outsideIOR, thinIOR, smoothstep( 0.0, 0.03, iridescenceThickness ) );\n        // Evaluate the cosTheta on the base layer (Snell law)\n        float sinTheta2Sq = pow( outsideIOR / iridescenceIOR, 2.0) * (1.0 - pow( dotNV, 2.0));\n        float cosTheta2Sq = 1.0 - sinTheta2Sq;\n        // Handle total internal reflection\n        if (cosTheta2Sq < 0.0) {\n           return iridescence;\n        }\n        float cosTheta2 = sqrt(cosTheta2Sq);\n            \n        // First interface\n        float f0 = iorToFresnel0(iridescenceIOR, outsideIOR);\n        float reflectance = F_Schlick(f0, dotNV);\n        float t121 = 1.0 - reflectance;\n        float phi12 = 0.0;\n        // iridescenceIOR has limited greater than 1.0\n        // if (iridescenceIOR < outsideIOR) {phi12 = PI;} \n        float phi21 = PI - phi12;\n        \n        // Second interface\n        vec3 baseIOR = fresnelToIOR(clamp(baseF0, 0.0, 0.9999)); // guard against 1.0\n        vec3 r1  = iorToFresnel0(baseIOR, iridescenceIOR);\n        vec3 r23 = F_Schlick(r1, cosTheta2);\n        vec3 phi23 =vec3(0.0);\n        if (baseIOR[0] < iridescenceIOR) {phi23[0] = PI;}\n        if (baseIOR[1] < iridescenceIOR) {phi23[1] = PI;}\n        if (baseIOR[2] < iridescenceIOR) {phi23[2] = PI;}\n        \n        // Phase shift\n        float opd = 2.0 * iridescenceIOR  * iridescenceThickness * cosTheta2;\n        vec3 phi = vec3(phi21) + phi23;\n        \n        // Compound terms\n        vec3 r123 = clamp(reflectance * r23, 1e-5, 0.9999);\n        vec3 sr123 = sqrt(r123);\n        vec3 rs = pow2(t121) * r23 / (vec3(1.0) - r123);\n        // Reflectance term for m = 0 (DC term amplitude)\n        vec3 c0 = reflectance + rs;\n        iridescence = c0;\n        // Reflectance term for m > 0 (pairs of diracs)\n        vec3 cm = rs - t121;\n        for (int m = 1; m <= 2; ++m) {\n             cm *= sr123;\n             vec3 sm = 2.0 * evalSensitivity(float(m) * opd, float(m) * phi);\n             iridescence += cm * sm;\n            }\n        return iridescence = max(iridescence, vec3(0.0)); \n    }\n#endif\n\n// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility\nvec3 BRDF_Specular_GGX(vec3 incidentDirection, Geometry geometry, Material material, vec3 normal, vec3 specularColor, float roughness ) {\n\n\tfloat alpha = pow2( roughness ); // UE4's roughness\n\n\tvec3 halfDir = normalize( incidentDirection + geometry.viewDir );\n\n\tfloat dotNL = saturate( dot( normal, incidentDirection ) );\n\tfloat dotNV = saturate( dot( normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentDirection, halfDir ) );\n\n    vec3 F = F_Schlick( specularColor, dotLH );\n    #ifdef MATERIAL_ENABLE_IRIDESCENCE\n        F = mix(F, material.iridescenceSpecularColor, material.iridescenceFactor);\n    #endif\n\n    #ifdef MATERIAL_ENABLE_ANISOTROPY\n        float GD = DG_GGX_anisotropic(halfDir, incidentDirection, geometry, alpha, dotNV, dotNL, dotNH);\n    #else\n        float GD = DG_GGX(alpha, dotNV, dotNL, dotNH);\n    #endif\n\n    return F * GD;\n}\n\nvec3 BRDF_Diffuse_Lambert(vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\n"; // eslint-disable-line

var direct_irradiance_frag_define = "#define GLSLIFY 1\n#include <ShadowFragmentDeclaration>\n\nvoid sheenLobe(Geometry geometry, Material material, vec3 incidentDirection, vec3 attenuationIrradiance, inout vec3 diffuseColor, inout vec3 specularColor){\n    #ifdef MATERIAL_ENABLE_SHEEN\n        diffuseColor *= material.sheenScaling;\n        specularColor *= material.sheenScaling;\n\n        specularColor += attenuationIrradiance * sheenBRDF(incidentDirection, geometry, material.sheenColor, material.sheenRoughness);\n    #endif\n}\n\nvoid addDirectRadiance(vec3 incidentDirection, vec3 color, Geometry geometry, Material material, inout ReflectedLight reflectedLight) {\n    float attenuation = 1.0;\n\n    #ifdef MATERIAL_ENABLE_CLEAR_COAT\n        float clearCoatDotNL = saturate( dot( geometry.clearCoatNormal, incidentDirection ) );\n        vec3 clearCoatIrradiance = clearCoatDotNL * color;\n\n        reflectedLight.directSpecular += material.clearCoat * clearCoatIrradiance * BRDF_Specular_GGX( incidentDirection, geometry, material, geometry.clearCoatNormal, vec3( 0.04 ), material.clearCoatRoughness );\n        attenuation -= material.clearCoat * F_Schlick(material.f0, geometry.clearCoatDotNV);\n    #endif\n\n    float dotNL = saturate( dot( geometry.normal, incidentDirection ) );\n    vec3 irradiance = dotNL * color * PI;\n\n    reflectedLight.directSpecular += attenuation * irradiance * BRDF_Specular_GGX( incidentDirection, geometry, material, geometry.normal, material.specularColor, material.roughness);\n    reflectedLight.directDiffuse += attenuation * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n    // Sheen Lobe\n    sheenLobe(geometry, material, incidentDirection, attenuation * irradiance, reflectedLight.directDiffuse, reflectedLight.directSpecular);\n\n}\n\n#ifdef SCENE_DIRECT_LIGHT_COUNT\n\n    void addDirectionalDirectLightRadiance(DirectLight directionalLight, Geometry geometry, Material material, inout ReflectedLight reflectedLight) {\n        vec3 color = directionalLight.color;\n        vec3 direction = -directionalLight.direction;\n\n\t\taddDirectRadiance( direction, color, geometry, material, reflectedLight );\n\n    }\n\n#endif\n\n#ifdef SCENE_POINT_LIGHT_COUNT\n\n\tvoid addPointDirectLightRadiance(PointLight pointLight, Geometry geometry, Material material, inout ReflectedLight reflectedLight) {\n\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tvec3 direction = normalize( lVector );\n\n\t\tfloat lightDistance = length( lVector );\n\n\t\tvec3 color = pointLight.color;\n\t\tcolor *= clamp(1.0 - pow(lightDistance/pointLight.distance, 4.0), 0.0, 1.0);\n\n\t\taddDirectRadiance( direction, color, geometry, material, reflectedLight );\n\n\t}\n\n#endif\n\n#ifdef SCENE_SPOT_LIGHT_COUNT\n\n\tvoid addSpotDirectLightRadiance(SpotLight spotLight, Geometry geometry, Material material, inout ReflectedLight reflectedLight) {\n\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tvec3 direction = normalize( lVector );\n\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( direction, -spotLight.direction );\n\n\t\tfloat spotEffect = smoothstep( spotLight.penumbraCos, spotLight.angleCos, angleCos );\n\t\tfloat decayEffect = clamp(1.0 - pow(lightDistance/spotLight.distance, 4.0), 0.0, 1.0);\n\n\t\tvec3 color = spotLight.color;\n\t\tcolor *= spotEffect * decayEffect;\n\n\t\taddDirectRadiance( direction, color, geometry, material, reflectedLight );\n\n\t}\n\n#endif\n\nvoid addTotalDirectRadiance(Geometry geometry, Material material, inout ReflectedLight reflectedLight){\n    float shadowAttenuation = 1.0;\n\n    #ifdef SCENE_DIRECT_LIGHT_COUNT\n        shadowAttenuation = 1.0;\n        #ifdef SCENE_IS_CALCULATE_SHADOWS\n            shadowAttenuation *= sampleShadowMap();\n        #endif\n\n        DirectLight directionalLight;\n        for ( int i = 0; i < SCENE_DIRECT_LIGHT_COUNT; i ++ ) {\n            // warning: use `continue` syntax may trigger flickering bug in safri 16.1.\n            if(!isRendererCulledByLight(renderer_Layer.xy, scene_DirectLightCullingMask[i])){\n                directionalLight.color = scene_DirectLightColor[i];\n                #ifdef SCENE_IS_CALCULATE_SHADOWS\n                    if (i == 0) { // Sun light index is always 0\n                        directionalLight.color *= shadowAttenuation;\n                    }\n                #endif\n                directionalLight.direction = scene_DirectLightDirection[i];\n                addDirectionalDirectLightRadiance( directionalLight, geometry, material, reflectedLight );\n            }\n        }\n\n    #endif\n\n    #ifdef SCENE_POINT_LIGHT_COUNT\n\n        PointLight pointLight;\n\n        for ( int i = 0; i < SCENE_POINT_LIGHT_COUNT; i ++ ) {\n            if(!isRendererCulledByLight(renderer_Layer.xy, scene_PointLightCullingMask[i])){\n                pointLight.color = scene_PointLightColor[i];\n                pointLight.position = scene_PointLightPosition[i];\n                pointLight.distance = scene_PointLightDistance[i];\n\n                addPointDirectLightRadiance( pointLight, geometry, material, reflectedLight );\n            } \n        }\n\n    #endif\n\n    #ifdef SCENE_SPOT_LIGHT_COUNT\n\n        SpotLight spotLight;\n\n        for ( int i = 0; i < SCENE_SPOT_LIGHT_COUNT; i ++ ) {\n            if(!isRendererCulledByLight(renderer_Layer.xy, scene_SpotLightCullingMask[i])){\n                spotLight.color = scene_SpotLightColor[i];\n                spotLight.position = scene_SpotLightPosition[i];\n                spotLight.direction = scene_SpotLightDirection[i];\n                spotLight.distance = scene_SpotLightDistance[i];\n                spotLight.angleCos = scene_SpotLightAngleCos[i];\n                spotLight.penumbraCos = scene_SpotLightPenumbraCos[i];\n\n                addSpotDirectLightRadiance( spotLight, geometry, material, reflectedLight );\n            } \n        }\n\n    #endif\n}"; // eslint-disable-line

var ibl_frag_define = "#define GLSLIFY 1\n// ------------------------Diffuse------------------------\n\n// sh need be pre-scaled in CPU.\nvec3 getLightProbeIrradiance(vec3 sh[9], vec3 normal){\n      normal.x = -normal.x;\n      vec3 result = sh[0] +\n\n            sh[1] * (normal.y) +\n            sh[2] * (normal.z) +\n            sh[3] * (normal.x) +\n\n            sh[4] * (normal.y * normal.x) +\n            sh[5] * (normal.y * normal.z) +\n            sh[6] * (3.0 * normal.z * normal.z - 1.0) +\n            sh[7] * (normal.z * normal.x) +\n            sh[8] * (normal.x * normal.x - normal.y * normal.y);\n    \n    return max(result, vec3(0.0));\n\n}\n\n// ------------------------Specular------------------------\n\n// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nvec3 envBRDFApprox(vec3 specularColor,float roughness, float dotNV ) {\n\n    const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\n    const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\n    vec4 r = roughness * c0 + c1;\n\n    float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\n    vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\n    return specularColor * AB.x + AB.y;\n}\n\nfloat getSpecularMIPLevel(float roughness, int maxMIPLevel ) {\n    return roughness * float(maxMIPLevel);\n}\n\nvec3 getReflectedVector(Geometry geometry, vec3 n) {\n    #ifdef MATERIAL_ENABLE_ANISOTROPY\n        vec3 r = reflect(-geometry.viewDir, geometry.anisotropicN);\n    #else\n        vec3 r = reflect(-geometry.viewDir, n);\n    #endif\n\n    return r;\n}\n\nvec3 getLightProbeRadiance(Geometry geometry, vec3 normal, float roughness, int maxMIPLevel, float specularIntensity) {\n\n    #ifndef SCENE_USE_SPECULAR_ENV\n        return vec3(0);\n    #else\n        vec3 reflectVec = getReflectedVector(geometry, normal);\n        reflectVec.x = -reflectVec.x; // TextureCube is left-hand,so x need inverse\n        \n        float specularMIPLevel = getSpecularMIPLevel(roughness, maxMIPLevel );\n\n        #ifdef HAS_TEX_LOD\n            vec4 envMapColor = textureCubeLodEXT( scene_EnvSpecularSampler, reflectVec, specularMIPLevel );\n        #else\n            vec4 envMapColor = textureCube( scene_EnvSpecularSampler, reflectVec, specularMIPLevel );\n        #endif\n\n        #ifdef SCENE_IS_DECODE_ENV_RGBM\n            envMapColor.rgb = RGBMToLinear(envMapColor, 5.0).rgb;\n        #elif defined(ENGINE_NO_SRGB)\n            envMapColor = sRGBToLinear(envMapColor);\n        #endif\n        \n        return envMapColor.rgb * specularIntensity;\n\n    #endif\n\n}\n\nvoid evaluateSheenIBL(Geometry geometry, Material material, float radianceAttenuation, inout vec3 diffuseColor, inout vec3 specularColor){\n    #ifdef MATERIAL_ENABLE_SHEEN\n        diffuseColor *= material.sheenScaling;\n        specularColor *= material.sheenScaling;\n\n        vec3 reflectance = material.specularAO * radianceAttenuation * material.approxIBLSheenDG * material.sheenColor;\n        specularColor += reflectance;\n    #endif\n}"; // eslint-disable-line

var pbr_frag = "#define GLSLIFY 1\nGeometry geometry;\nMaterial material;\nReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\ninitGeometry(geometry, gl_FrontFacing);\ninitMaterial(material, geometry);\n\n// Direct Light\naddTotalDirectRadiance(geometry, material, reflectedLight);\n\n// IBL diffuse\n#ifdef SCENE_USE_SH\n    vec3 irradiance = getLightProbeIrradiance(scene_EnvSH, geometry.normal);\n    irradiance *= scene_EnvMapLight.diffuseIntensity;\n#else\n   vec3 irradiance = scene_EnvMapLight.diffuse * scene_EnvMapLight.diffuseIntensity;\n   irradiance *= PI;\n#endif\n\nreflectedLight.indirectDiffuse += material.diffuseAO * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n// IBL specular\nvec3 radiance = getLightProbeRadiance(geometry, geometry.normal, material.roughness, int(scene_EnvMapLight.mipMapLevel), scene_EnvMapLight.specularIntensity);\nfloat radianceAttenuation = 1.0;\n\n// IBL Clear Coat\n#ifdef MATERIAL_ENABLE_CLEAR_COAT\n    vec3 clearCoatRadiance = getLightProbeRadiance( geometry, geometry.clearCoatNormal, material.clearCoatRoughness, int(scene_EnvMapLight.mipMapLevel), scene_EnvMapLight.specularIntensity );\n\n    reflectedLight.indirectSpecular += material.specularAO * clearCoatRadiance * material.clearCoat * envBRDFApprox(vec3( 0.04 ), material.clearCoatRoughness, geometry.clearCoatDotNV);\n    radianceAttenuation -= material.clearCoat * F_Schlick(material.f0, geometry.clearCoatDotNV);\n#endif\n\n#ifdef MATERIAL_ENABLE_IRIDESCENCE\n    vec3 speculaColor = mix(material.specularColor, material.iridescenceSpecularColor, material.iridescenceFactor);\n#else\n    vec3 speculaColor = material.specularColor;\n#endif\n\nreflectedLight.indirectSpecular += material.specularAO * radianceAttenuation * radiance * envBRDFApprox(speculaColor, material.roughness, geometry.dotNV);\n\n// IBL Sheen\nevaluateSheenIBL(geometry, material, radianceAttenuation, reflectedLight.indirectDiffuse, reflectedLight.indirectSpecular);\n\n// Final color\nvec3 totalDiffuseColor = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\nvec3 totalSpecularColor = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\n#ifdef MATERIAL_ENABLE_TRANSMISSION \n    vec3 refractionTransmitted = evaluateTransmission(geometry, material);\n    totalDiffuseColor = mix(totalDiffuseColor, refractionTransmitted, material.transmission);\n#endif\n\nvec4 finalColor = vec4(totalDiffuseColor + totalSpecularColor, material.opacity);\n\n// Emissive\nvec3 emissiveRadiance = material_EmissiveColor;\n#ifdef MATERIAL_HAS_EMISSIVETEXTURE\n    emissiveRadiance *= texture2DSRGB(material_EmissiveTexture, v_uv).rgb;\n#endif\n\nfinalColor.rgb += emissiveRadiance;\n\ngl_FragColor = finalColor;\n"; // eslint-disable-line

var btdf = "#define GLSLIFY 1\n#include <refraction>\n\n#ifdef MATERIAL_ENABLE_TRANSMISSION \n    uniform sampler2D camera_OpaqueTexture;\n    vec3 evaluateTransmission(Geometry geometry, Material material) {\n        RefractionModelResult ray;\n        #if REFRACTION_MODE == 0  \n            // RefractionMode.Sphere\n            refractionModelSphere(-geometry.viewDir, geometry.position, geometry.normal, material.IOR, material.thickness, ray);\n        #elif REFRACTION_MODE == 1\n            // RefractionMode.Planar\n            refractionModelPlanar(-geometry.viewDir, geometry.position, geometry.normal, material.IOR, material.thickness, ray);\n        #endif\n\n        vec3 refractedRayExit = ray.positionExit;\n\n        // We calculate the screen space position of the refracted point\n        vec4 samplingPositionNDC = camera_ProjMat * camera_ViewMat * vec4( refractedRayExit, 1.0 );\n        vec2 refractionCoords = (samplingPositionNDC.xy / samplingPositionNDC.w) * 0.5 + 0.5;\n\n        // Sample the opaque texture to get the transmitted light\n        vec3 refractionTransmitted = texture2DSRGB(camera_OpaqueTexture, refractionCoords).rgb;\n        refractionTransmitted *= material.diffuseColor;\n         \n        // Use specularFGD as an approximation of the fresnel effect\n        // https://blog.selfshadow.com/publications/s2017-shading-course/imageworks/s2017_pbs_imageworks_slides_v2.pdf\n        refractionTransmitted *= (1.0 - material.envSpecularDFG);\n\n       #ifdef MATERIAL_HAS_THICKNESS\n            // Absorption coefficient from Disney: http://blog.selfshadow.com/publications/s2015-shading-course/burley/s2015_pbs_disney_bsdf_notes.pdf\n            vec3 transmittance = min(vec3(1.0), exp(-material.absorptionCoefficient * ray.transmissionLength));\n            refractionTransmitted *= transmittance;\n       #endif\n        \n    return refractionTransmitted;\n    }\n#endif"; // eslint-disable-line

var refraction = "#define GLSLIFY 1\n#ifdef MATERIAL_ENABLE_TRANSMISSION \n\tstruct RefractionModelResult {\n\t    float transmissionLength;         // length of the transmission during refraction through the shape\n\t    vec3 positionExit;      // out ray position\n\t    // vec3 directionExit;     // out ray direction\n\t};\n\n\t//https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@15.0/manual/refraction-models.html\n\t void refractionModelSphere(vec3 V, vec3 positionWS, vec3 normalWS, float ior, float thickness, out RefractionModelResult ray) {\n\t    // Refracted ray\n\t    vec3 R1 = refract(V, normalWS, 1.0 / ior);\n\t    // Center of the tangent sphere\n\t    // vec3 C = positionWS - normalWS * thickness * 0.5;\n\n\t    // Second refraction (tangent sphere out)\n\t    float dist = dot(-normalWS, R1) * thickness;\n\t    // Out hit point in the tangent sphere\n\t    vec3 P1 = positionWS + R1 * dist;\n\t    // Out normal\n\t    // vec3 N1 = safeNormalize(C - P1);\n\t    // Out refracted ray\n\t    // vec3 R2 = refract(R1, N1, ior);\n\n\t    ray.transmissionLength = dist;\n\t    ray.positionExit = P1;\n\t    // ray.directionExit = R2; \n\t}\n\n\tvoid refractionModelPlanar(vec3 V, vec3 positionWS, vec3 normalWS, float ior, float thickness, out RefractionModelResult ray) {\n\t    // Refracted ray\n\t    vec3 R = refract(V, normalWS, 1.0 / ior);\n\t    // Optical depth within the thin plane\n\t    float dist = thickness / max(dot(-normalWS, R), 1e-5f);\n\n\t    ray.transmissionLength = dist;\n\t    ray.positionExit = vec3(positionWS + R * dist);\n\t    // ray.directionExit = V;\n\t}\n\n#endif"; // eslint-disable-line

var PBRShaderLib = {
    pbr_frag_define: pbr_frag_define,
    pbr_helper: pbr_helper,
    brdf: brdf,
    direct_irradiance_frag_define: direct_irradiance_frag_define,
    ibl_frag_define: ibl_frag_define,
    pbr_frag: pbr_frag,
    btdf: btdf,
    refraction: refraction
};

var ShadowCoord = "#define GLSLIFY 1\nuniform mat4 scene_ShadowMatrices[SCENE_SHADOW_CASCADED_COUNT + 1];\nuniform vec4 scene_ShadowSplitSpheres[4];\n\nmediump int computeCascadeIndex(vec3 positionWS) {\n    vec3 fromCenter0 = positionWS - scene_ShadowSplitSpheres[0].xyz;\n    vec3 fromCenter1 = positionWS - scene_ShadowSplitSpheres[1].xyz;\n    vec3 fromCenter2 = positionWS - scene_ShadowSplitSpheres[2].xyz;\n    vec3 fromCenter3 = positionWS - scene_ShadowSplitSpheres[3].xyz;\n\n    mediump vec4 comparison = vec4(\n        dot(fromCenter0, fromCenter0) < scene_ShadowSplitSpheres[0].w,\n        dot(fromCenter1, fromCenter1) < scene_ShadowSplitSpheres[1].w,\n        dot(fromCenter2, fromCenter2) < scene_ShadowSplitSpheres[2].w,\n        dot(fromCenter3, fromCenter3) < scene_ShadowSplitSpheres[3].w);\n    comparison.yzw = clamp(comparison.yzw - comparison.xyz,0.0,1.0);//keep the nearest\n    mediump vec4 indexCoefficient = vec4(4.0,3.0,2.0,1.0);\n    mediump int index = 4 - int(dot(comparison, indexCoefficient));\n    return index;\n}\n\nvec3 getShadowCoord() {\n    #if SCENE_SHADOW_CASCADED_COUNT == 1\n        mediump int cascadeIndex = 0;\n    #else\n        mediump int cascadeIndex = computeCascadeIndex(v_pos);\n    #endif\n\n    #ifdef GRAPHICS_API_WEBGL2\n        mat4 shadowMatrix = scene_ShadowMatrices[cascadeIndex];\n    #else\n        mat4 shadowMatrix;\n        #if SCENE_SHADOW_CASCADED_COUNT == 4\n            if (cascadeIndex == 0) {\n                shadowMatrix = scene_ShadowMatrices[0];\n            } else if (cascadeIndex == 1) {\n                shadowMatrix = scene_ShadowMatrices[1];\n            } else if (cascadeIndex == 2) {\n                shadowMatrix = scene_ShadowMatrices[2];\n            } else if (cascadeIndex == 3) {\n                shadowMatrix = scene_ShadowMatrices[3];\n            } else {\n                shadowMatrix = scene_ShadowMatrices[4];\n            }\n        #endif\n        #if SCENE_SHADOW_CASCADED_COUNT == 2\n            if (cascadeIndex == 0) {\n                shadowMatrix = scene_ShadowMatrices[0];\n            } else if (cascadeIndex == 1) {\n                shadowMatrix = scene_ShadowMatrices[1];\n            } else {\n                shadowMatrix = scene_ShadowMatrices[2];\n            } \n        #endif\n        #if SCENE_SHADOW_CASCADED_COUNT == 1\n            if (cascadeIndex == 0) {\n                shadowMatrix = scene_ShadowMatrices[0];\n            } else  {\n                shadowMatrix = scene_ShadowMatrices[1];\n            } \n        #endif\n    #endif\n\n    vec4 shadowCoord = shadowMatrix * vec4(v_pos, 1.0);\n    return shadowCoord.xyz;\n}\n"; // eslint-disable-line

var ShadowFragmentDeclaration = "#define GLSLIFY 1\n#if defined(SCENE_SHADOW_TYPE) && defined(RENDERER_IS_RECEIVE_SHADOWS)\n    #define SCENE_IS_CALCULATE_SHADOWS\n#endif\n\n#ifdef SCENE_IS_CALCULATE_SHADOWS\n    #if SCENE_SHADOW_CASCADED_COUNT == 1\n        varying vec3 v_shadowCoord;\n    #else\n        #include <ShadowCoord>\n    #endif\n    \n    // intensity, null, fadeScale, fadeBias\n    uniform vec4 scene_ShadowInfo;\n    uniform vec4 scene_ShadowMapSize;\n\n    #ifdef GRAPHICS_API_WEBGL2\n        uniform mediump sampler2DShadow scene_ShadowMap;\n        #define SAMPLE_TEXTURE2D_SHADOW(textureName, coord3) textureLod(textureName, coord3 , 0.0)\n        #define TEXTURE2D_SHADOW_PARAM(shadowMap) mediump sampler2DShadow shadowMap\n    #else\n        uniform sampler2D scene_ShadowMap;\n        #ifdef ENGINE_NO_DEPTH_TEXTURE\n            const vec4 bitShift = vec4(1.0, 1.0/256.0, 1.0/(256.0*256.0), 1.0/(256.0*256.0*256.0));\n            /**\n            * Unpack depth value.\n            */\n            float unpack(const in vec4 rgbaDepth) {\n                return dot(rgbaDepth, bitShift);\n            }\n            #define SAMPLE_TEXTURE2D_SHADOW(textureName, coord3) (unpack(texture2D(textureName, coord3.xy)) < coord3.z ? 0.0 : 1.0)\n        #else\n            #define SAMPLE_TEXTURE2D_SHADOW(textureName, coord3) (texture2D(textureName, coord3.xy).r < coord3.z ? 0.0 : 1.0)\n        #endif\n        #define TEXTURE2D_SHADOW_PARAM(shadowMap) mediump sampler2D shadowMap\n    #endif\n\n    #if SCENE_SHADOW_TYPE == 2\n        float sampleShadowMapFiltered4(TEXTURE2D_SHADOW_PARAM(shadowMap), vec3 shadowCoord, vec4 shadowMapSize) {\n            float attenuation;\n            vec4 attenuation4;\n            vec2 offset=shadowMapSize.xy/2.0;\n            vec3 shadowCoord0=shadowCoord + vec3(-offset,0.0);\n            vec3 shadowCoord1=shadowCoord + vec3(offset.x,-offset.y,0.0);\n            vec3 shadowCoord2=shadowCoord + vec3(-offset.x,offset.y,0.0);\n            vec3 shadowCoord3=shadowCoord + vec3(offset,0.0);\n            attenuation4.x = SAMPLE_TEXTURE2D_SHADOW(shadowMap, shadowCoord0);\n            attenuation4.y = SAMPLE_TEXTURE2D_SHADOW(shadowMap, shadowCoord1);\n            attenuation4.z = SAMPLE_TEXTURE2D_SHADOW(shadowMap, shadowCoord2);\n            attenuation4.w = SAMPLE_TEXTURE2D_SHADOW(shadowMap, shadowCoord3);\n            attenuation = dot(attenuation4, vec4(0.25));\n            return attenuation;\n        }\n    #endif\n\n    #if SCENE_SHADOW_TYPE == 3\n        #include <shadow_sample_tent>\n\n        float sampleShadowMapFiltered9(TEXTURE2D_SHADOW_PARAM(shadowMap), vec3 shadowCoord, vec4 shadowmapSize) {\n            float attenuation;\n            float fetchesWeights[9];\n            vec2 fetchesUV[9];\n            sampleShadowComputeSamplesTent5x5(shadowmapSize, shadowCoord.xy, fetchesWeights, fetchesUV);\n            attenuation = fetchesWeights[0] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[0].xy, shadowCoord.z));\n            attenuation += fetchesWeights[1] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[1].xy, shadowCoord.z));\n            attenuation += fetchesWeights[2] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[2].xy, shadowCoord.z));\n            attenuation += fetchesWeights[3] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[3].xy, shadowCoord.z));\n            attenuation += fetchesWeights[4] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[4].xy, shadowCoord.z));\n            attenuation += fetchesWeights[5] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[5].xy, shadowCoord.z));\n            attenuation += fetchesWeights[6] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[6].xy, shadowCoord.z));\n            attenuation += fetchesWeights[7] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[7].xy, shadowCoord.z));\n            attenuation += fetchesWeights[8] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[8].xy, shadowCoord.z));\n            return attenuation;\n        }\n    #endif\n\n    float getShadowFade(vec3 positionWS){\n        vec3 camToPixel = positionWS - camera_Position;\n        float distanceCamToPixel2 = dot(camToPixel, camToPixel);\n        return saturate( distanceCamToPixel2 * scene_ShadowInfo.z + scene_ShadowInfo.w );\n    }\n\n    float sampleShadowMap() {\n        #if SCENE_SHADOW_CASCADED_COUNT == 1\n            vec3 shadowCoord = v_shadowCoord;\n        #else\n            vec3 shadowCoord = getShadowCoord();\n        #endif\n        \n        float attenuation = 1.0;\n        if(shadowCoord.z > 0.0 && shadowCoord.z < 1.0) {\n        #if SCENE_SHADOW_TYPE == 1\n            attenuation = SAMPLE_TEXTURE2D_SHADOW(scene_ShadowMap, shadowCoord);\n        #endif\n\n        #if SCENE_SHADOW_TYPE == 2\n            attenuation = sampleShadowMapFiltered4(scene_ShadowMap, shadowCoord, scene_ShadowMapSize);\n        #endif\n\n        #if SCENE_SHADOW_TYPE == 3\n            attenuation = sampleShadowMapFiltered9(scene_ShadowMap, shadowCoord, scene_ShadowMapSize);\n        #endif\n\n        float shadowFade = getShadowFade(v_pos);\n        attenuation = mix(1.0, mix(attenuation, 1.0, shadowFade), scene_ShadowInfo.x);\n        }\n        return attenuation;\n    }\n#endif"; // eslint-disable-line

var shadow_sample_tent = "#define GLSLIFY 1\n// ------------------------------------------------------------------\n//  PCF Filtering Tent Functions\n// ------------------------------------------------------------------\n\n// Assuming a isoceles right angled triangle of height \"triangleHeight\" (as drawn below).\n// This function return the area of the triangle above the first texel(in Y the first texel).\n//\n// |\\      <-- 45 degree slop isosceles right angled triangle\n// | \\\n// ----    <-- length of this side is \"triangleHeight\"\n// _ _ _ _ <-- texels\nfloat sampleShadowGetIRTriangleTexelArea(float triangleHeight) {\n    return triangleHeight - 0.5;\n}\n\n// Assuming a isoceles triangle of 1.5 texels height and 3 texels wide lying on 4 texels.\n// This function return the area of the triangle above each of those texels.\n//    |    <-- offset from -0.5 to 0.5, 0 meaning triangle is exactly in the center\n//   / \\   <-- 45 degree slop isosceles triangle (ie tent projected in 2D)\n//  /   \\\n// _ _ _ _ <-- texels\n// X Y Z W <-- result indices (in computedArea.xyzw and computedAreaUncut.xyzw)\n// Top point at (right,top) in a texel,left bottom point at (middle,middle) in a texel,right bottom point at (middle,middle) in a texel.\nvoid sampleShadowGetTexelAreasTent3x3(float offset, out vec4 computedArea, out vec4 computedAreaUncut) {\n    // Compute the exterior areas,a and h is same.\n    float a = offset + 0.5;\n    float offsetSquaredHalved = a * a * 0.5;\n    computedAreaUncut.x = computedArea.x = offsetSquaredHalved - offset;\n    computedAreaUncut.w = computedArea.w = offsetSquaredHalved;\n\n    // Compute the middle areas\n    // For Y : We find the area in Y of as if the left section of the isoceles triangle would\n    // intersect the axis between Y and Z (ie where offset = 0).\n    computedAreaUncut.y = sampleShadowGetIRTriangleTexelArea(1.5 - offset);\n    // This area is superior to the one we are looking for if (offset < 0) thus we need to\n    // subtract the area of the triangle defined by (0,1.5-offset), (0,1.5+offset), (-offset,1.5).\n    float clampedOffsetLeft = min(offset,0.0);\n    float areaOfSmallLeftTriangle = clampedOffsetLeft * clampedOffsetLeft;\n    computedArea.y = computedAreaUncut.y - areaOfSmallLeftTriangle;\n\n    // We do the same for the Z but with the right part of the isoceles triangle\n    computedAreaUncut.z = sampleShadowGetIRTriangleTexelArea(1.5 + offset);\n    float clampedOffsetRight = max(offset,0.0);\n    float areaOfSmallRightTriangle = clampedOffsetRight * clampedOffsetRight;\n    computedArea.z = computedAreaUncut.z - areaOfSmallRightTriangle;\n}\n\n// Assuming a isoceles triangle of 2.5 texel height and 5 texels wide lying on 6 texels.\n// This function return the weight of each texels area relative to the full triangle area.\n//  /       \\\n// _ _ _ _ _ _ <-- texels\n// 0 1 2 3 4 5 <-- computed area indices (in texelsWeights[])\n// Top point at (right,top) in a texel,left bottom point at (middle,middle) in a texel,right bottom point at (middle,middle) in a texel.\nvoid sampleShadowGetTexelWeightsTent5x5(float offset, out vec3 texelsWeightsA, out vec3 texelsWeightsB) {\n    vec4 areaFrom3texelTriangle;\n    vec4 areaUncutFrom3texelTriangle;\n    sampleShadowGetTexelAreasTent3x3(offset, areaFrom3texelTriangle, areaUncutFrom3texelTriangle);\n\n    // Triangle slope is 45 degree thus we can almost reuse the result of the 3 texel wide computation.\n    // the 5 texel wide triangle can be seen as the 3 texel wide one but shifted up by one unit/texel.\n    // 0.16 is 1/(the triangle area)\n    texelsWeightsA.x = 0.16 * (areaFrom3texelTriangle.x);\n    texelsWeightsA.y = 0.16 * (areaUncutFrom3texelTriangle.y);\n    texelsWeightsA.z = 0.16 * (areaFrom3texelTriangle.y + 1.0);\n    texelsWeightsB.x = 0.16 * (areaFrom3texelTriangle.z + 1.0);\n    texelsWeightsB.y = 0.16 * (areaUncutFrom3texelTriangle.z);\n    texelsWeightsB.z = 0.16 * (areaFrom3texelTriangle.w);\n}\n\n// 5x5 Tent filter (45 degree sloped triangles in U and V)\nvoid sampleShadowComputeSamplesTent5x5(vec4 shadowMapTextureTexelSize, vec2 coord, out float fetchesWeights[9], out vec2 fetchesUV[9])\n{\n    // tent base is 5x5 base thus covering from 25 to 36 texels, thus we need 9 bilinear PCF fetches\n    vec2 tentCenterInTexelSpace = coord.xy * shadowMapTextureTexelSize.zw;\n    vec2 centerOfFetchesInTexelSpace = floor(tentCenterInTexelSpace + 0.5);\n    vec2 offsetFromTentCenterToCenterOfFetches = tentCenterInTexelSpace - centerOfFetchesInTexelSpace;\n\n    // find the weight of each texel based on the area of a 45 degree slop tent above each of them.\n    vec3 texelsWeightsUA, texelsWeightsUB;\n    vec3 texelsWeightsVA, texelsWeightsVB;\n    sampleShadowGetTexelWeightsTent5x5(offsetFromTentCenterToCenterOfFetches.x, texelsWeightsUA, texelsWeightsUB);\n    sampleShadowGetTexelWeightsTent5x5(offsetFromTentCenterToCenterOfFetches.y, texelsWeightsVA, texelsWeightsVB);\n\n    // each fetch will cover a group of 2x2 texels, the weight of each group is the sum of the weights of the texels\n    vec3 fetchesWeightsU = vec3(texelsWeightsUA.xz, texelsWeightsUB.y) + vec3(texelsWeightsUA.y, texelsWeightsUB.xz);\n    vec3 fetchesWeightsV = vec3(texelsWeightsVA.xz, texelsWeightsVB.y) + vec3(texelsWeightsVA.y, texelsWeightsVB.xz);\n\n    // move the PCF bilinear fetches to respect texels weights\n    vec3 fetchesOffsetsU = vec3(texelsWeightsUA.y, texelsWeightsUB.xz) / fetchesWeightsU.xyz + vec3(-2.5,-0.5,1.5);\n    vec3 fetchesOffsetsV = vec3(texelsWeightsVA.y, texelsWeightsVB.xz) / fetchesWeightsV.xyz + vec3(-2.5,-0.5,1.5);\n    fetchesOffsetsU *= shadowMapTextureTexelSize.xxx;\n    fetchesOffsetsV *= shadowMapTextureTexelSize.yyy;\n\n    vec2 bilinearFetchOrigin = centerOfFetchesInTexelSpace * shadowMapTextureTexelSize.xy;\n    fetchesUV[0] = bilinearFetchOrigin + vec2(fetchesOffsetsU.x, fetchesOffsetsV.x);\n    fetchesUV[1] = bilinearFetchOrigin + vec2(fetchesOffsetsU.y, fetchesOffsetsV.x);\n    fetchesUV[2] = bilinearFetchOrigin + vec2(fetchesOffsetsU.z, fetchesOffsetsV.x);\n    fetchesUV[3] = bilinearFetchOrigin + vec2(fetchesOffsetsU.x, fetchesOffsetsV.y);\n    fetchesUV[4] = bilinearFetchOrigin + vec2(fetchesOffsetsU.y, fetchesOffsetsV.y);\n    fetchesUV[5] = bilinearFetchOrigin + vec2(fetchesOffsetsU.z, fetchesOffsetsV.y);\n    fetchesUV[6] = bilinearFetchOrigin + vec2(fetchesOffsetsU.x, fetchesOffsetsV.z);\n    fetchesUV[7] = bilinearFetchOrigin + vec2(fetchesOffsetsU.y, fetchesOffsetsV.z);\n    fetchesUV[8] = bilinearFetchOrigin + vec2(fetchesOffsetsU.z, fetchesOffsetsV.z);\n\n    fetchesWeights[0] = fetchesWeightsU.x * fetchesWeightsV.x;\n    fetchesWeights[1] = fetchesWeightsU.y * fetchesWeightsV.x;\n    fetchesWeights[2] = fetchesWeightsU.z * fetchesWeightsV.x;\n    fetchesWeights[3] = fetchesWeightsU.x * fetchesWeightsV.y;\n    fetchesWeights[4] = fetchesWeightsU.y * fetchesWeightsV.y;\n    fetchesWeights[5] = fetchesWeightsU.z * fetchesWeightsV.y;\n    fetchesWeights[6] = fetchesWeightsU.x * fetchesWeightsV.z;\n    fetchesWeights[7] = fetchesWeightsU.y * fetchesWeightsV.z;\n    fetchesWeights[8] = fetchesWeightsU.z * fetchesWeightsV.z;\n}"; // eslint-disable-line

var ShadowVertexDeclaration = "#define GLSLIFY 1\n#if defined(SCENE_SHADOW_TYPE) && defined(RENDERER_IS_RECEIVE_SHADOWS)\n    #define SCENE_IS_CALCULATE_SHADOWS\n#endif\n\n#ifdef SCENE_IS_CALCULATE_SHADOWS\n    #if SCENE_SHADOW_CASCADED_COUNT==1\n        #include <ShadowCoord>\n        varying vec3 v_shadowCoord;\n    #endif\n#endif"; // eslint-disable-line

var ShadowVertex = "#define GLSLIFY 1\n#ifdef SCENE_IS_CALCULATE_SHADOWS\n    #if SCENE_SHADOW_CASCADED_COUNT == 1\n        v_shadowCoord = getShadowCoord();\n    #endif\n#endif"; // eslint-disable-line

var ShadowLib = {
    ShadowCoord: ShadowCoord,
    ShadowFragmentDeclaration: ShadowFragmentDeclaration,
    shadow_sample_tent: shadow_sample_tent,
    ShadowVertexDeclaration: ShadowVertexDeclaration,
    ShadowVertex: ShadowVertex
};

var particle_common = "#define GLSLIFY 1\n\nvec3 rotationByEuler(in vec3 vector, in vec3 rot) {\n    float halfRoll = rot.z * 0.5;\n    float halfPitch = rot.x * 0.5;\n    float halfYaw = rot.y * 0.5;\n\n    float sinRoll = sin(halfRoll);\n    float cosRoll = cos(halfRoll);\n    float sinPitch = sin(halfPitch);\n    float cosPitch = cos(halfPitch);\n    float sinYaw = sin(halfYaw);\n    float cosYaw = cos(halfYaw);\n\n    float quaX = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);\n    float quaY = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);\n    float quaZ = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);\n    float quaW = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);\n\n    // vec4 q=vec4(quaX,quaY,quaZ,quaW);\n    // vec3 temp = cross(q.xyz, vector) + q.w * vector;\n    // return (cross(temp, -q.xyz) + dot(q.xyz,vector) * q.xyz + q.w * temp);\n\n    float x = quaX + quaX;\n    float y = quaY + quaY;\n    float z = quaZ + quaZ;\n    float wx = quaW * x;\n    float wy = quaW * y;\n    float wz = quaW * z;\n    float xx = quaX * x;\n    float xy = quaX * y;\n    float xz = quaX * z;\n    float yy = quaY * y;\n    float yz = quaY * z;\n    float zz = quaZ * z;\n\n    return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\n\t((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\n\t((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\n}\n\n//假定axis已经归一化\nvec3 rotationByAxis(in vec3 vector, in vec3 axis, in float angle) {\n    float halfAngle = angle * 0.5;\n    float sin = sin(halfAngle);\n\n    float quaX = axis.x * sin;\n    float quaY = axis.y * sin;\n    float quaZ = axis.z * sin;\n    float quaW = cos(halfAngle);\n\n    // vec4 q=vec4(quaX,quaY,quaZ,quaW);\n    // vec3 temp = cross(q.xyz, vector) + q.w * vector;\n    // return (cross(temp, -q.xyz) + dot(q.xyz,vector) * q.xyz + q.w * temp);\n\n    float x = quaX + quaX;\n    float y = quaY + quaY;\n    float z = quaZ + quaZ;\n    float wx = quaW * x;\n    float wy = quaW * y;\n    float wz = quaW * z;\n    float xx = quaX * x;\n    float xy = quaX * y;\n    float xz = quaX * z;\n    float yy = quaY * y;\n    float yz = quaY * z;\n    float zz = quaZ * z;\n\n    return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\n\t((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\n\t((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\n}\n\nvec3 rotationByQuaternions(in vec3 v, in vec4 q) {\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\nfloat evaluateParticleCurve(in vec2 keys[4], in float normalizedAge) {\n    float value;\n    for (int i = 1; i < 4; i++) {\n        vec2 key = keys[i];\n        float time = key.x;\n        if (time >= normalizedAge) {\n            vec2 lastKey = keys[i - 1];\n            float lastTime = lastKey.x;\n            float age = (normalizedAge - lastTime) / (time - lastTime);\n            value = mix(lastKey.y, key.y, age);\n            break;\n        }\n    }\n    return value;\n}\n\nfloat evaluateParticleCurveCumulative(in vec2 keys[4], in float normalizedAge, out float currentValue){\n    float cumulativeValue = 0.0;\n    for (int i = 1; i < 4; i++){\n\t    vec2 key = keys[i];\n\t    float time = key.x;\n\t    vec2 lastKey = keys[i - 1];\n\t    float lastValue = lastKey.y;\n\n\t    if (time >= normalizedAge){\n\t\t    float lastTime = lastKey.x;\n            float offsetTime = normalizedAge - lastTime;\n\t\t    float age = offsetTime / (time - lastTime);\n            currentValue = mix(lastValue, key.y, age);\n\t\t    cumulativeValue += (lastValue + currentValue) * 0.5 * offsetTime;\n\t\t    break;\n\t\t}\n\t    else{\n\t\t    cumulativeValue += (lastValue + key.y) * 0.5 * (time - lastKey.x);\n\t\t}\n\t}\n    return cumulativeValue;\n}"; // eslint-disable-line

var velocity_over_lifetime_module = "#define GLSLIFY 1\n#if defined(RENDERER_VOL_CONSTANT_MODE) || defined(RENDERER_VOL_CURVE_MODE)\n    #define _VOL_MODULE_ENABLED\n#endif\n\n#ifdef _VOL_MODULE_ENABLED\n    uniform int renderer_VOLSpace;\n\n    #ifdef RENDERER_VOL_CONSTANT_MODE\n        uniform vec3 renderer_VOLMaxConst;\n\n         #ifdef RENDERER_VOL_IS_RANDOM_TWO\n            uniform vec3 renderer_VOLMinConst;\n        #endif\n    #endif\n\n    #ifdef RENDERER_VOL_CURVE_MODE\n        uniform vec2 renderer_VOLMaxGradientX[4]; // x:time y:value\n        uniform vec2 renderer_VOLMaxGradientY[4]; // x:time y:value\n        uniform vec2 renderer_VOLMaxGradientZ[4]; // x:time y:value\n\n        #ifdef RENDERER_VOL_IS_RANDOM_TWO\n            uniform vec2 renderer_VOLMinGradientX[4]; // x:time y:value\n            uniform vec2 renderer_VOLMinGradientY[4]; // x:time y:value\n            uniform vec2 renderer_VOLMinGradientZ[4]; // x:time y:value\n        #endif\n    #endif\n\n    vec3 computeVelocityPositionOffset(in float normalizedAge, in float age, out vec3 currentVelocity) {\n        vec3 velocityPosition;\n\n        #ifdef RENDERER_VOL_CONSTANT_MODE\n            currentVelocity = renderer_VOLMaxConst;\n            #ifdef RENDERER_VOL_IS_RANDOM_TWO\n                currentVelocity = mix(renderer_VOLMinConst, currentVelocity, a_Random1.yzw);\n            #endif\n\n            velocityPosition = currentVelocity * age;\n        #endif\n\n        #ifdef RENDERER_VOL_CURVE_MODE\n            velocityPosition = vec3(\n            evaluateParticleCurveCumulative(renderer_VOLMaxGradientX, normalizedAge, currentVelocity.x),\n            evaluateParticleCurveCumulative(renderer_VOLMaxGradientY, normalizedAge, currentVelocity.y),\n            evaluateParticleCurveCumulative(renderer_VOLMaxGradientZ, normalizedAge, currentVelocity.z));\n\n            #ifdef RENDERER_VOL_IS_RANDOM_TWO\n                vec3 minCurrentVelocity;\n                vec3 minVelocityPosition = vec3(\n                    evaluateParticleCurveCumulative(renderer_VOLMinGradientX, normalizedAge, minCurrentVelocity.x),\n                    evaluateParticleCurveCumulative(renderer_VOLMinGradientY, normalizedAge, minCurrentVelocity.y),\n                    evaluateParticleCurveCumulative(renderer_VOLMinGradientZ, normalizedAge, minCurrentVelocity.z));\n\n                currentVelocity = mix(minCurrentVelocity, currentVelocity, a_Random1.yzw);\n                velocityPosition = mix(minVelocityPosition, velocityPosition, a_Random1.yzw);\n            #endif\n\n            velocityPosition *= vec3(a_ShapePositionStartLifeTime.w);\n        #endif\n        return velocityPosition;\n    }\n#endif\n"; // eslint-disable-line

var rotation_over_lifetime_module = "#define GLSLIFY 1\n#if defined(RENDERER_ROL_CONSTANT_MODE) || defined(RENDERER_ROL_CURVE_MODE)\n    #ifdef RENDERER_ROL_CURVE_MODE\n        uniform vec2 renderer_ROLMaxCurveZ[4];\n        // #ifdef RENDERER_ROL_IS_SEPARATE\n        //     uniform vec2 renderer_ROLMaxCurveX[4];\n        //     uniform vec2 renderer_ROLMaxCurveY[4];\n        // #endif\n        #ifdef RENDERER_ROL_IS_RANDOM_TWO\n            uniform vec2 renderer_ROLMinCurveZ[4];\n            // #ifdef RENDERER_ROL_IS_SEPARATE\n            //     uniform vec2 renderer_ROLMinCurveX[4];\n            //     uniform vec2 renderer_ROLMinCurveY[4];\n            // #endif\n        #endif\n    #else\n        uniform vec3 renderer_ROLMaxConst;\n        #ifdef RENDERER_ROL_IS_RANDOM_TWO\n            uniform vec3 renderer_ROLMinConst;\n        #endif\n    #endif\n#endif\n\nfloat computeParticleRotationFloat(in float rotation, in float age, in float normalizedAge) {\n    #if defined(RENDERER_ROL_CONSTANT_MODE) || defined(RENDERER_ROL_CURVE_MODE)\n        #ifdef RENDERER_ROL_CURVE_MODE\n            float lifeRotation = evaluateParticleCurveCumulative(renderer_ROLMaxCurveZ, normalizedAge);\n            #ifdef RENDERER_ROL_IS_RANDOM_TWO\n                lifeRotation = mix(evaluateParticleCurveCumulative(renderer_ROLMinCurveZ, normalizedAge), lifeRotation, a_Random0.w);\n            #endif\n            rotation += lifeRotation * a_ShapePositionStartLifeTime.w;\n        #else\n            float lifeRotation = renderer_ROLMaxConst.z;\n            #ifdef RENDERER_ROL_IS_RANDOM_TWO\n                lifeRotation = mix(renderer_ROLMinConst.z, lifeRotation, a_Random0.w);\n            #endif\n            rotation += lifeRotation * age;\n        #endif\n    #endif\n    return rotation;\n}\n\n#if defined(RENDERER_MODE_MESH) && (defined(ROTATION_OVER_LIFETIME) || defined(ROTATION_OVER_LIFETIME_SEPARATE))\nvec3 computeParticleRotationVec3(in vec3 rotation,\n    in float age,\n    in float normalizedAge) {\n#ifdef ROTATION_OVER_LIFETIME\n    #ifdef ROTATION_OVER_LIFETIME_CONSTANT\n        float ageRot = u_ROLAngularVelocityConst * age;\n        rotation += ageRot;\n    #endif\n    #ifdef ROTATION_OVER_LIFETIME_CURVE\n        rotation += getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient, normalizedAge);\n    #endif\n    #ifdef ROTATION_OVER_LIFETIME_RANDOM_CONSTANTS\n        float ageRot = mix(u_ROLAngularVelocityConst, u_ROLAngularVelocityConstMax, a_Random0.w) * age;\n        rotation += ageRot;\n    #endif\n    #ifdef ROTATION_OVER_LIFETIME_RANDOM_CURVES\n        rotation += mix(\n        getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient, normalizedAge),\n        getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMax,\n            normalizedAge),\n        a_Random0.w);\n    #endif\n#endif\n\n#ifdef ROTATION_OVER_LIFETIME_SEPARATE\n    #ifdef ROTATION_OVER_LIFETIME_CONSTANT\n        vec3 ageRot = u_ROLAngularVelocityConstSeparate * age;\n        rotation += ageRot;\n    #endif\n    #ifdef ROTATION_OVER_LIFETIME_CURVE\n        rotation += vec3(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientX,\n                 normalizedAge),\n        getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientY,\n            normalizedAge),\n        getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,\n            normalizedAge));\n    #endif\n    #ifdef ROTATION_OVER_LIFETIME_RANDOM_CONSTANTS\n        vec3 ageRot = mix(u_ROLAngularVelocityConstSeparate,\n                  renderer_ROLMaxConst,\n                  a_Random0.w)\n        * age;\n        rotation += ageRot;\n    #endif\n    #ifdef ROTATION_OVER_LIFETIME_RANDOM_CURVES\n        rotation += vec3(mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientX,\n                     normalizedAge),\n                 getTotalValueFromGradientFloat(renderer_ROLMaxCurveX,\n                     normalizedAge),\n                 a_Random0.w),\n        mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientY,\n            normalizedAge),\n            getTotalValueFromGradientFloat(renderer_ROLMaxCurveY,\n            normalizedAge),\n            a_Random0.w),\n        mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,\n            normalizedAge),\n            getTotalValueFromGradientFloat(renderer_ROLMaxCurveZ,\n            normalizedAge),\n            a_Random0.w));\n    #endif\n#endif\n    return rotation;\n}\n#endif\n"; // eslint-disable-line

var size_over_lifetime_module = "#define GLSLIFY 1\n#ifdef RENDERER_SOL_CURVE_MODE\n    uniform vec2 renderer_SOLMaxCurveX[4]; // x:time y:value\n    #ifdef RENDERER_SOL_IS_SEPARATE\n        uniform vec2 renderer_SOLMaxCurveY[4]; // x:time y:value\n        uniform vec2 renderer_SOLMaxCurveZ[4]; // x:time y:value\n    #endif\n\n    #ifdef RENDERER_SOL_IS_RANDOM_TWO\n        uniform vec2 renderer_SOLMinCurveX[4]; // x:time y:value\n        #ifdef RENDERER_SOL_IS_SEPARATE\n            uniform vec2 renderer_SOLMinCurveY[4]; // x:time y:value\n            uniform vec2 renderer_SOLMinCurveZ[4]; // x:time y:value\n        #endif\n    #endif\n#endif\n\nvec2 computeParticleSizeBillboard(in vec2 size, in float normalizedAge) {\n    #ifdef RENDERER_SOL_CURVE_MODE\n        float lifeSizeX = evaluateParticleCurve(renderer_SOLMaxCurveX, normalizedAge);\n        #ifdef RENDERER_SOL_IS_RANDOM_TWO\n            lifeSizeX = mix(evaluateParticleCurve(renderer_SOLMinCurveX, normalizedAge), lifeSizeX, a_Random0.z);\n        #endif\n\n        #ifdef RENDERER_SOL_IS_SEPARATE\n            float lifeSizeY = evaluateParticleCurve(renderer_SOLMaxCurveY, normalizedAge);\n            #ifdef RENDERER_SOL_IS_RANDOM_TWO\n                lifeSizeY = mix(evaluateParticleCurve(renderer_SOLMinCurveY, normalizedAge), lifeSizeY, a_Random0.z);\n            #endif\n            size *= vec2(lifeSizeX, lifeSizeY);\n        #else\n            size *= lifeSizeX;\n        #endif\n    #endif\n    return size;\n}\n\n#ifdef RENDERER_MODE_MESH\n    vec3 computeParticleSizeMesh(in vec3 size, in float normalizedAge) {\n        #ifdef RENDERER_SOL_CURVE\n            size *= evaluateParticleCurve(renderer_SOLMaxCurveX, normalizedAge);\n        #endif\n        #ifdef RENDERER_SOL_RANDOM_CURVES\n            size *= mix(evaluateParticleCurve(renderer_SOLMaxCurveX, normalizedAge),\n            evaluateParticleCurve(u_SOLSizeGradientMax, normalizedAge),\n            a_Random0.z);\n        #endif\n        #ifdef RENDERER_SOL_CURVE_SEPARATE\n            size *= vec3(evaluateParticleCurve(renderer_SOLMinCurveX, normalizedAge),\n            evaluateParticleCurve(renderer_SOLMinCurveY, normalizedAge),\n            evaluateParticleCurve(renderer_SOLMinCurveZ, normalizedAge));\n        #endif\n        #ifdef RENDERER_SOL_RANDOM_CURVES_SEPARATE\n            size *= vec3(mix(evaluateParticleCurve(renderer_SOLMinCurveX, normalizedAge),\n                    evaluateParticleCurve(renderer_SOLMaxCurveX, normalizedAge),\n                    a_Random0.z),\n            mix(evaluateParticleCurve(renderer_SOLMinCurveY, normalizedAge),\n                evaluateParticleCurve(renderer_SOLMaxCurveY, normalizedAge),\n                a_Random0.z),\n            mix(evaluateParticleCurve(renderer_SOLMinCurveZ, normalizedAge),\n                evaluateParticleCurve(renderer_SOLMaxCurveZ, normalizedAge),\n                a_Random0.z));\n        #endif\n        return size;\n    }\n#endif"; // eslint-disable-line

var color_over_lifetime_module = "#define GLSLIFY 1\n#if defined(RENDERER_COL_GRADIENT) || defined(RENDERER_COL_RANDOM_GRADIENTS)\n    uniform vec4 renderer_COLMaxGradientColor[4]; // x:time y:r z:g w:b\n    uniform vec2 renderer_COLMaxGradientAlpha[4]; // x:time y:alpha\n\n    #ifdef RENDERER_COL_RANDOM_GRADIENTS\n        uniform vec4 renderer_COLMinGradientColor[4]; // x:time y:r z:g w:b\n        uniform vec2 renderer_COLMinGradientAlpha[4]; // x:time y:alpha\n    #endif\n\n    uniform vec4 renderer_COLGradientKeysMaxTime; // x: minColorKeysMaxTime, y: minAlphaKeysMaxTime, z: maxColorKeysMaxTime, w: maxAlphaKeysMaxTime\n#endif\n\n#if defined(RENDERER_COL_GRADIENT) || defined(RENDERER_COL_RANDOM_GRADIENTS)\n    vec4 evaluateParticleGradient(in vec4 colorKeys[4], in float colorKeysMaxTime, in vec2 alphaKeys[4], in float alphaKeysMaxTime, in float normalizedAge){\n        vec4 value;\n        float alphaAge = min(normalizedAge, alphaKeysMaxTime);\n        for(int i = 0; i < 4; i++){\n            vec2 key = alphaKeys[i];\n            float time = key.x;\n            if(alphaAge <= time){\n                if(i == 0){\n                    value.a = alphaKeys[0].y;\n                }\n                else {\n                    vec2 lastKey = alphaKeys[i-1];\n                    float lastTime = lastKey.x;\n                    float age = (alphaAge - lastTime) / (time - lastTime);\n                    value.a = mix(lastKey.y, key.y, age);\n                }\n                break;\n            }\n        }\n        \n        float colorAge = min(normalizedAge, colorKeysMaxTime);\n        for(int i = 0; i < 4; i++){\n            vec4 key = colorKeys[i];\n            float time = key.x;\n            if(colorAge <= time){\n                if(i == 0){\n                    value.rgb = colorKeys[0].yzw;\n                }\n                else {\n                    vec4 lastKey = colorKeys[i-1];\n                    float lastTime = lastKey.x;\n                    float age = (colorAge - lastTime) / (time-lastTime);\n                    value.rgb = mix(lastKey.yzw, key.yzw, age);\n                }\n                break;\n            }\n        }\n        return value;\n    }\n#endif\n\nvec4 computeParticleColor(in vec4 color, in float normalizedAge) {\n    #if defined(RENDERER_COL_GRADIENT) || defined(RENDERER_COL_RANDOM_GRADIENTS)\n       vec4 gradientColor = evaluateParticleGradient(renderer_COLMaxGradientColor, renderer_COLGradientKeysMaxTime.z, renderer_COLMaxGradientAlpha, renderer_COLGradientKeysMaxTime.w, normalizedAge);\n    #endif\n\n    #ifdef RENDERER_COL_RANDOM_GRADIENTS\n        gradientColor = mix(evaluateParticleGradient(renderer_COLMinGradientColor,renderer_COLGradientKeysMaxTime.x, renderer_COLMinGradientAlpha, renderer_COLGradientKeysMaxTime.y, normalizedAge), gradientColor, a_Random0.y);\n    #endif\n\n    #if defined(RENDERER_COL_GRADIENT) || defined(RENDERER_COL_RANDOM_GRADIENTS)\n       color *= gradientColor;\n    #endif\n\n    return color;\n}\n"; // eslint-disable-line

var texture_sheet_animation_module = "#define GLSLIFY 1\n#if defined(RENDERER_TSA_FRAME_CURVE) || defined(RENDERER_TSA_FRAME_RANDOM_CURVES)\n    uniform float renderer_TSACycles;\n    uniform vec3 renderer_TSATillingParams; // x:subU y:subV z:tileCount\n    uniform vec2 renderer_TSAFrameMaxCurve[4]; // x:time y:value\n\n    #ifdef RENDERER_TSA_FRAME_RANDOM_CURVES\n        uniform vec2 renderer_TSAFrameMinCurve[4]; // x:time y:value\n    #endif\n#endif\n\nvec2 computeParticleUV(in vec2 uv, in float normalizedAge) {\n    #if defined(RENDERER_TSA_FRAME_CURVE) || defined(RENDERER_TSA_FRAME_RANDOM_CURVES)\n        float scaledNormalizedAge = normalizedAge * renderer_TSACycles;\n        float cycleNormalizedAge = scaledNormalizedAge - floor(scaledNormalizedAge);\n        float normalizedFrame = evaluateParticleCurve(renderer_TSAFrameMaxCurve, cycleNormalizedAge);\n        #ifdef RENDERER_TSA_FRAME_RANDOM_CURVES\n            normalizedFrame = mix(evaluateParticleCurve(renderer_TSAFrameMinCurve, cycleNormalizedAge), normalizedFrame, a_Random1.x);\n        #endif\n\n        float frame = floor(normalizedFrame * renderer_TSATillingParams.z);\n\n        float tileRow = frame * renderer_TSATillingParams.x;\n        float tileRowIndex = floor(tileRow);\n        uv.x += tileRow - tileRowIndex;\n        uv.y += tileRowIndex * renderer_TSATillingParams.y;\n    #endif\n    \n    return uv;\n}\n"; // eslint-disable-line

var force_over_lifetime_module = "#define GLSLIFY 1\n#if defined(RENDERER_FOL_CONSTANT_MODE) || defined(RENDERER_FOL_CURVE_MODE)\n    #define _FOL_MODULE_ENABLED\n#endif\n\n#ifdef _FOL_MODULE_ENABLED\n    attribute vec4 a_Random2;\n\n    uniform int renderer_FOLSpace;\n\n    #ifdef RENDERER_FOL_CONSTANT_MODE\n        uniform vec3 renderer_FOLMaxConst;\n\n        #ifdef RENDERER_FOL_IS_RANDOM_TWO\n            uniform vec3 renderer_FOLMinConst;\n        #endif\n\n    #endif\n\n    #ifdef RENDERER_FOL_CURVE_MODE\n        uniform vec2 renderer_FOLMaxGradientX[4];\n        uniform vec2 renderer_FOLMaxGradientY[4];\n        uniform vec2 renderer_FOLMaxGradientZ[4];\n\n        #ifdef RENDERER_FOL_IS_RANDOM_TWO\n            uniform vec2 renderer_FOLMinGradientX[4];\n            uniform vec2 renderer_FOLMinGradientY[4];\n            uniform vec2 renderer_FOLMinGradientZ[4];\n        #endif\n    #endif\n\n    // (tHat - t1) * (tHat - t1) * (tHat - t1) * (a2 - a1) / ((t2 - t1) * 6.0) + a1 * (tHat - t1) * (tHat - t1) * 0.5 + v1 * (tHat - t1);\n    // to = tHat - t1; tr = t2 - t1\n    float computeDisplacementIntegral(in float to, in float tr, in float a1, in float a2, in float v1) {\n        return to * to * to * (a2 - a1) / (tr * 6.0) + a1 * to * to * 0.5 + v1 * to;\n    }\n\n    float evaluateForceParticleCurveCumulative(in vec2 keys[4], in float normalizedAge, out float velocityCumulative) {\n        float cumulativeValue = 0.0;\n        velocityCumulative = 0.0;\n\n        for (int i = 1; i < 4; i++){\n            vec2 key = keys[i];\n            vec2 lastKey = keys[i - 1];\n            float timeRange = (key.x - lastKey.x) * a_ShapePositionStartLifeTime.w;\n\n            if (key.x >= normalizedAge){\n                float timeOffset = (normalizedAge - lastKey.x) * a_ShapePositionStartLifeTime.w;\n                cumulativeValue += computeDisplacementIntegral(timeOffset, timeRange, lastKey.y, key.y, velocityCumulative);\n\n                float finalAcceleration = mix(lastKey.y, key.y, timeOffset / timeRange);\n                velocityCumulative += 0.5 * timeOffset * (finalAcceleration + lastKey.y);\n                break;\n            } else {  \n                cumulativeValue += computeDisplacementIntegral(timeRange, timeRange, lastKey.y, key.y, velocityCumulative);\n                velocityCumulative += 0.5 * timeRange * (lastKey.y + key.y);\n            }\n        }\n        return cumulativeValue;\n    }\n\n    vec3 computeForcePositionOffset(in float normalizedAge, in float age, out vec3 velocityOffset) {\n        vec3 forcePosition;\n\n        #if defined(RENDERER_FOL_CONSTANT_MODE)\n            vec3 forceAcceleration = renderer_FOLMaxConst;\n\n            #ifdef RENDERER_FOL_IS_RANDOM_TWO\n                forceAcceleration = mix(renderer_FOLMinConst, forceAcceleration, vec3(a_Random2.x, a_Random2.y, a_Random2.z));\n            #endif\n\n            velocityOffset = forceAcceleration * age;\n\n            forcePosition = 0.5 * forceAcceleration * age * age;\n        #elif defined(RENDERER_FOL_CURVE_MODE)\n            forcePosition = vec3(\n                evaluateForceParticleCurveCumulative(renderer_FOLMaxGradientX, normalizedAge, velocityOffset.x),\n                evaluateForceParticleCurveCumulative(renderer_FOLMaxGradientY, normalizedAge, velocityOffset.y),\n                evaluateForceParticleCurveCumulative(renderer_FOLMaxGradientZ, normalizedAge, velocityOffset.z)\n            );\n            #ifdef RENDERER_FOL_IS_RANDOM_TWO\n                vec3 minVelocityOffset;\n\n                forcePosition = vec3(\n                    mix(evaluateForceParticleCurveCumulative(renderer_FOLMinGradientX, normalizedAge, minVelocityOffset.x), forcePosition.x, a_Random2.x),\n                    mix(evaluateForceParticleCurveCumulative(renderer_FOLMinGradientY, normalizedAge, minVelocityOffset.y), forcePosition.y, a_Random2.y),\n                    mix(evaluateForceParticleCurveCumulative(renderer_FOLMinGradientZ, normalizedAge, minVelocityOffset.z), forcePosition.z, a_Random2.z)\n                );\n\n                velocityOffset = mix(minVelocityOffset, velocityOffset, vec3(a_Random2.x, a_Random2.y, a_Random2.z));\n            #endif\n        #endif\n        return forcePosition;\n    }\n#endif"; // eslint-disable-line

var sphere_billboard = "#define GLSLIFY 1\n#ifdef RENDERER_MODE_SPHERE_BILLBOARD\n\tvec2 corner = a_CornerTextureCoordinate.xy + renderer_PivotOffset.xy;\n\tvec3 sideVector = normalize(cross(camera_Forward, camera_Up));\n\tvec3 upVector = normalize(cross(sideVector, camera_Forward));\n\tcorner *= computeParticleSizeBillboard(a_StartSize.xy, normalizedAge);\n    #if defined(RENDERER_ROL_CONSTANT_MODE) || defined(RENDERER_ROL_CURVE_MODE)\n        if (renderer_ThreeDStartRotation) {\n            vec3 rotation = vec3(a_StartRotation0.xy, computeParticleRotationFloat(a_StartRotation0.z, age, normalizedAge));\n            center += renderer_SizeScale.xzy * rotationByEuler(corner.x * sideVector + corner.y * upVector, rotation);\n        } else {\n            float rot = computeParticleRotationFloat(a_StartRotation0.x, age, normalizedAge);\n            float c = cos(rot);\n            float s = sin(rot);\n            mat2 rotation = mat2(c, -s, s, c);\n            corner = rotation * corner;\n            center += renderer_SizeScale.xzy * (corner.x * sideVector + corner.y * upVector);\n        }\n    #else\n        if (renderer_ThreeDStartRotation) {\n            center += renderer_SizeScale.xzy * rotationByEuler(corner.x * sideVector + corner.y * upVector, a_StartRotation0);\n        } else {\n            float c = cos(a_StartRotation0.x);\n            float s = sin(a_StartRotation0.x);\n            mat2 rotation = mat2(c, -s, s, c);\n            corner = rotation * corner;\n            center += renderer_SizeScale.xzy * (corner.x * sideVector + corner.y * upVector);\n        }\n    #endif\n#endif"; // eslint-disable-line

var stretched_billboard = "#define GLSLIFY 1\n#ifdef RENDERER_MODE_STRETCHED_BILLBOARD\n\tvec2 corner = a_CornerTextureCoordinate.xy + renderer_PivotOffset.xy;\n\tvec3 velocity = rotationByQuaternions(renderer_SizeScale * localVelocity, worldRotation) + worldVelocity;\n\tvec3 cameraUpVector = normalize(velocity);\n\tvec3 direction = normalize(center - camera_Position);\n\tvec3 sideVector = normalize(cross(direction, normalize(velocity)));\n\n\tsideVector = renderer_SizeScale.xzy * sideVector;\n\tcameraUpVector = length(vec3(renderer_SizeScale.x, 0.0, 0.0)) * cameraUpVector;\n\n\tvec2 size = computeParticleSizeBillboard(a_StartSize.xy, normalizedAge);\n\n\tconst mat2 rotationZHalfPI = mat2(0.0, -1.0, 1.0, 0.0);\n\tcorner = rotationZHalfPI * corner;\n\tcorner.y = corner.y - abs(corner.y);\n\n\tfloat speed = length(velocity); // TODO:\n\tcenter += sign(renderer_SizeScale.x) * (sign(renderer_StretchedBillboardLengthScale) * size.x * corner.x * sideVector\n\t        + (speed * renderer_StretchedBillboardSpeedScale + size.y * renderer_StretchedBillboardLengthScale) * corner.y * cameraUpVector);\n#endif"; // eslint-disable-line

var vertical_billboard = "#define GLSLIFY 1\n#ifdef RENDERER_MODE_VERTICAL_BILLBOARD\n\tvec2 corner = a_CornerTextureCoordinate.xy + renderer_PivotOffset.xy; // Billboard模式z轴无效\n\tconst vec3 cameraUpVector = vec3(0.0, 1.0, 0.0);\n\tvec3 sideVector = normalize(cross(camera_Forward, cameraUpVector));\n\n\tfloat rot = computeParticleRotationFloat(a_StartRotation0.x, age, normalizedAge);\n\tfloat c = cos(rot);\n\tfloat s = sin(rot);\n\tmat2 rotation = mat2(c, -s, s, c);\n\tcorner = rotation * corner * cos(0.78539816339744830961566084581988); // TODO:临时缩小cos45,不确定U3D原因\n\tcorner *= computeParticleSizeBillboard(a_StartSize.xy, normalizedAge);\n\tcenter += renderer_SizeScale.xzy * (corner.x * sideVector + corner.y * cameraUpVector);\n#endif"; // eslint-disable-line

var horizontal_billboard = "#define GLSLIFY 1\n#ifdef RENDERER_MODE_HORIZONTAL_BILLBOARD\n\tvec2 corner = a_CornerTextureCoordinate.xy + renderer_PivotOffset.xy; // Billboard模式z轴无效\n\tconst vec3 cameraUpVector = vec3(0.0, 0.0, 1.0);\n\tconst vec3 sideVector = vec3(-1.0, 0.0, 0.0);\n\n\tfloat rot = computeParticleRotationFloat(a_StartRotation0.x, age, normalizedAge);\n\tfloat c = cos(rot);\n\tfloat s = sin(rot);\n\tmat2 rotation = mat2(c, -s, s, c);\n\tcorner = rotation * corner * cos(0.78539816339744830961566084581988); // TODO:临时缩小cos45,不确定U3D原因\n\tcorner *= computeParticleSizeBillboard(a_StartSize.xy, normalizedAge);\n\tcenter += renderer_SizeScale.xzy * (corner.x * sideVector + corner.y * cameraUpVector);\n#endif"; // eslint-disable-line

var particle_mesh = "#define GLSLIFY 1\n#ifdef RENDERER_MODE_MESH\n\tvec3 size = computeParticleSizeMesh(a_StartSize, normalizedAge);\n    #if defined(RENDERER_ROL_CONSTANT_MODE) || defined(RENDERER_ROL_CURVE_MODE)\n        if (renderer_ThreeDStartRotation) {\n            vec3 rotation = vec3(\n            a_StartRotation0.xy,\n            computeParticleRotationFloat(a_StartRotation0.z, age, normalizedAge));\n            center += rotationByQuaternions(\n            renderer_SizeScale * rotationByEuler(a_MeshPosition * size, rotation),\n            worldRotation);\n        } else {\n        #ifdef RENDERER_ROL_IS_SEPARATE\n            float angle = computeParticleRotationFloat(a_StartRotation0.x, age, normalizedAge);\n            if (a_ShapePositionStartLifeTime.x != 0.0 || a_ShapePositionStartLifeTime.y != 0.0) {\n            center += (rotationByQuaternions(\n                rotationByAxis(\n                renderer_SizeScale * a_MeshPosition * size,\n                normalize(cross(vec3(0.0, 0.0, 1.0),\n                    vec3(a_ShapePositionStartLifeTime.xy, 0.0))),\n                angle),\n                worldRotation)); //已验证\n            } else {\n            #ifdef SHAPE\n                center += renderer_SizeScale.xzy * (rotationByQuaternions(rotationByAxis(a_MeshPosition * size, vec3(0.0, -1.0, 0.0), angle), worldRotation));\n            #else\n                if (renderer_SimulationSpace == 1)\n                    center += rotationByAxis(renderer_SizeScale * a_MeshPosition * size,\n                    vec3(0.0, 0.0, -1.0),\n                    angle); //已验证\n                else if (renderer_SimulationSpace == 0)\n                    center += rotationByQuaternions(\n                    renderer_SizeScale * rotationByAxis(a_MeshPosition * size, vec3(0.0, 0.0, -1.0), angle),\n                    worldRotation); //已验证\n            #endif\n            }\n        #endif\n        #ifdef ROTATION_OVER_LIFETIME_SEPARATE\n            // TODO:是否应合并if(renderer_ThreeDStartRotation)分支代码,待测试\n            vec3 angle = computeParticleRotationVec3(\n            vec3(0.0, 0.0, -a_StartRotation0.x), age, normalizedAge);\n            center += (rotationByQuaternions(\n            rotationByEuler(renderer_SizeScale * a_MeshPosition * size,\n                vec3(angle.x, angle.y, angle.z)),\n            worldRotation)); //已验证\n        #endif\n        }\n    #else\n        if (renderer_ThreeDStartRotation) {\n            center += rotationByQuaternions(\n            renderer_SizeScale * rotationByEuler(a_MeshPosition * size, a_StartRotation0),\n            worldRotation); //已验证\n        } else {\n            if (a_ShapePositionStartLifeTime.x != 0.0 || a_ShapePositionStartLifeTime.y != 0.0) {\n            if (renderer_SimulationSpace == 1)\n                center += rotationByAxis(\n                renderer_SizeScale * a_MeshPosition * size,\n                normalize(cross(vec3(0.0, 0.0, 1.0),\n                    vec3(a_ShapePositionStartLifeTime.xy, 0.0))),\n                a_StartRotation0.x);\n            else if (renderer_SimulationSpace == 0)\n                center += (rotationByQuaternions(\n                renderer_SizeScale * rotationByAxis(a_MeshPosition * size, normalize(cross(vec3(0.0, 0.0, 1.0),\n                                             vec3(a_ShapePositionStartLifeTime.xy, 0.0))), a_StartRotation0.x),\n                worldRotation)); //已验证\n            } else {\n        #ifdef SHAPE\n            if (renderer_SimulationSpace == 1)\n                center += renderer_SizeScale * rotationByAxis(a_MeshPosition * size, vec3(0.0, -1.0, 0.0), a_StartRotation0.x);\n            else if (renderer_SimulationSpace == 0)\n                center += rotationByQuaternions(\n                renderer_SizeScale * rotationByAxis(a_MeshPosition * size, vec3(0.0, -1.0, 0.0), a_StartRotation0.x),\n                worldRotation);\n        #else\n            if (renderer_SimulationSpace == 1)\n                center += rotationByAxis(renderer_SizeScale * a_MeshPosition * size,\n                vec3(0.0, 0.0, -1.0),\n                a_StartRotation0.x);\n            else if (renderer_SimulationSpace == 0)\n                center += rotationByQuaternions(\n                renderer_SizeScale * rotationByAxis(a_MeshPosition * size, vec3(0.0, 0.0, -1.0), a_StartRotation0.x),\n                worldRotation); //已验证\n        #endif\n            }\n        }\n    #endif\n\tv_MeshColor = a_MeshColor;\n#endif"; // eslint-disable-line

var ParticleShaderLib = {
    particle_common: particle_common,
    velocity_over_lifetime_module: velocity_over_lifetime_module,
    rotation_over_lifetime_module: rotation_over_lifetime_module,
    size_over_lifetime_module: size_over_lifetime_module,
    color_over_lifetime_module: color_over_lifetime_module,
    texture_sheet_animation_module: texture_sheet_animation_module,
    force_over_lifetime_module: force_over_lifetime_module,
    sphere_billboard: sphere_billboard,
    stretched_billboard: stretched_billboard,
    vertical_billboard: vertical_billboard,
    horizontal_billboard: horizontal_billboard,
    particle_mesh: particle_mesh
};

var normal_get = "#define GLSLIFY 1\n// gl_FrontFacing has random value on Adreno GPUs\n// the Adreno bug is only when gl_FrontFacing is inside a function\n// https://bugs.chromium.org/p/chromium/issues/detail?id=1154842\nvec3 getNormal(bool isFrontFacing){\n    #ifdef RENDERER_HAS_NORMAL\n        vec3 normal = normalize(v_normal);\n    #elif defined(HAS_DERIVATIVES)\n        vec3 pos_dx = dFdx(v_pos);\n        vec3 pos_dy = dFdy(v_pos);\n        vec3 normal = normalize( cross(pos_dx, pos_dy) );\n        normal *= camera_ProjectionParams.x;\n    #else\n        vec3 normal = vec3(0, 0, 1);\n    #endif\n\n    normal *= float( isFrontFacing ) * 2.0 - 1.0;\n    return normal;\n}\n\nvec3 getNormalByNormalTexture(mat3 tbn, sampler2D normalTexture, float normalIntensity, vec2 uv, bool isFrontFacing){\n    vec3 normal = texture2D(normalTexture, uv).rgb;\n    normal = normalize(tbn * ((2.0 * normal - 1.0) * vec3(normalIntensity, normalIntensity, 1.0)));\n    normal *= float( isFrontFacing ) * 2.0 - 1.0;\n\n    return normal;\n}\n\nmat3 getTBN(bool isFrontFacing){\n    #if defined(RENDERER_HAS_NORMAL) && defined(RENDERER_HAS_TANGENT) && ( defined(MATERIAL_HAS_NORMALTEXTURE) || defined(MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE) || defined(MATERIAL_ENABLE_ANISOTROPY) )\n        mat3 tbn = v_TBN;\n    #else\n        vec3 normal = getNormal(isFrontFacing);\n        vec3 position = v_pos;\n        vec2 uv = isFrontFacing? v_uv: -v_uv;\n\n        #ifdef HAS_DERIVATIVES\n            // ref: http://www.thetenthplanet.de/archives/1180\n            // get edge vectors of the pixel triangle\n\t        vec3 dp1 = dFdx(position);\n\t        vec3 dp2 = dFdy(position);\n\t        vec2 duv1 = dFdx(uv);\n\t        vec2 duv2 = dFdy(uv);\n\n\t        // solve the linear system\n\t        vec3 dp2perp = cross(dp2, normal);\n\t        vec3 dp1perp = cross(normal, dp1);\n\t        vec3 tangent = dp2perp * duv1.x + dp1perp * duv2.x;\n\t        vec3 bitangent = dp2perp * duv1.y + dp1perp * duv2.y;\n\n\t        // construct a scale-invariant frame \n            float denom = max( dot(tangent, tangent), dot(bitangent, bitangent) );\n            float invmax = (denom == 0.0) ? 0.0 : camera_ProjectionParams.x / sqrt( denom );\n\t        mat3 tbn = mat3(tangent * invmax, bitangent * invmax, normal);\n        #else\n            mat3 tbn = mat3(vec3(0.0), vec3(0.0), normal);\n        #endif\n    #endif\n\t\n    return tbn;\n}"; // eslint-disable-line

var ShaderLib = _extends$2({
    common: common,
    common_vert: common_vert,
    transform_declare: transform_declare,
    camera_declare: camera_declare,
    color_share: color_share,
    normal_share: normal_share,
    uv_share: uv_share,
    worldpos_share: worldpos_share,
    FogVertexDeclaration: FogVertexDeclaration,
    FogFragmentDeclaration: FogFragmentDeclaration,
    begin_normal_vert: begin_normal_vert,
    begin_position_vert: begin_position_vert,
    position_vert: position_vert,
    color_vert: color_vert,
    normal_vert: normal_vert,
    skinning_vert: skinning_vert,
    blendShape_input: blendShape_input,
    blendShape_vert: blendShape_vert,
    uv_vert: uv_vert,
    worldpos_vert: worldpos_vert,
    FogVertex: FogVertex,
    light_frag_define: light_frag_define,
    mobile_material_frag: mobile_material_frag,
    FogFragment: FogFragment,
    begin_mobile_frag: begin_mobile_frag,
    begin_viewdir_frag: begin_viewdir_frag,
    mobile_blinnphong_frag: mobile_blinnphong_frag,
    noise_common: noise_common,
    noise_cellular_2D: noise_cellular_2D,
    noise_cellular_2x2: noise_cellular_2x2,
    noise_cellular_2x2x2: noise_cellular_2x2x2,
    noise_cellular_3D: noise_cellular_3D,
    noise_cellular: noise_cellular,
    noise_perlin_2D: noise_perlin_2D,
    noise_perlin_3D: noise_perlin_3D,
    noise_perlin_4D: noise_perlin_4D,
    noise_perlin: noise_perlin,
    noise_psrd_2D: noise_psrd_2D,
    noise_simplex_2D: noise_simplex_2D,
    noise_simplex_3D_grad: noise_simplex_3D_grad,
    noise_simplex_3D: noise_simplex_3D,
    noise_simplex_4D: noise_simplex_4D,
    noise_simplex: noise_simplex
}, ShadowLib, PBRShaderLib, {
    normal_get: normal_get
}, ParticleShaderLib);

var ShaderFactory = /*#__PURE__*/ function() {
    function ShaderFactory() {}
    ShaderFactory.parseCustomMacros = function parseCustomMacros(macros) {
        return macros.map(function(m) {
            return "#define " + (m.value ? m.name + " " + m.value : m.name) + "\n";
        }).join("");
    };
    ShaderFactory.registerInclude = function registerInclude(includeName, includeSource) {
        if (ShaderLib[includeName]) {
            throw 'The "' + includeName + '" shader include already exist';
        }
        ShaderLib[includeName] = includeSource;
    };
    ShaderFactory.unRegisterInclude = function unRegisterInclude(includeName) {
        delete ShaderLib[includeName];
    };
    /**
   * @param regex The default regex is for engine's builtin glsl `#include` syntax,
   * since `ShaderLab` use the same parsing function but different syntax for `#include` --- `/^[ \t]*#include +"([\w\d.]+)"/gm`
   */ ShaderFactory.parseIncludes = function parseIncludes(src, regex) {
        if (regex === void 0) regex = /^[ \t]*#include +<([\w\d.]+)>/gm;
        function replace(match, slice) {
            var _$replace = ShaderLib[slice];
            if (_$replace === undefined) {
                Logger.error('Shader slice "' + match.trim() + '" not founded.');
                return "";
            }
            return ShaderFactory.parseIncludes(_$replace, regex);
        }
        return src.replace(regex, replace);
    };
    /**
   * Convert lower GLSL version to GLSL 300 es.
   * @param shader - code
   * @param isFrag - Whether it is a fragment shader.
   * */ ShaderFactory.convertTo300 = function convertTo300(shader, isFrag) {
        shader = shader.replace(/\bvarying\b/g, isFrag ? "in" : "out");
        shader = shader.replace(/\btexture(2D|Cube)\b/g, "texture");
        shader = shader.replace(/\btexture2DProj\b/g, "textureProj");
        if (isFrag) {
            shader = shader.replace(/\btexture(2D|Cube)LodEXT\b/g, "textureLod");
            shader = shader.replace(/\btexture(2D|Cube)GradEXT\b/g, "textureGrad");
            shader = shader.replace(/\btexture2DProjLodEXT\b/g, "textureProjLod");
            shader = shader.replace(/\btexture2DProjGradEXT\b/g, "textureProjGrad");
            shader = shader.replace(/\bgl_FragDepthEXT\b/g, "gl_FragDepth");
            if (!ShaderFactory._has300Output(shader)) {
                var isMRT = /\bgl_FragData\[.+?\]/g.test(shader);
                if (isMRT) {
                    shader = shader.replace(/\bgl_FragColor\b/g, "gl_FragData[0]");
                    var result = shader.match(/\bgl_FragData\[.+?\]/g);
                    shader = this._replaceMRTShader(shader, result);
                } else {
                    shader = shader.replace(/void\s+?main\s*\(/g, "out vec4 glFragColor;\nvoid main(");
                    shader = shader.replace(/\bgl_FragColor\b/g, "glFragColor");
                }
            }
        } else {
            shader = shader.replace(/\battribute\b/g, "in");
        }
        return shader;
    };
    ShaderFactory._has300Output = function _has300Output(fragmentShader) {
        return ShaderFactory._has300OutInFragReg.test(fragmentShader);
    };
    ShaderFactory._replaceMRTShader = function _replaceMRTShader(shader, result) {
        var declaration = "";
        var mrtIndexSet = new Set();
        for(var i = 0; i < result.length; i++){
            var res = result[i].match(/\bgl_FragData\[(.+?)\]/);
            mrtIndexSet.add(res[1]);
        }
        mrtIndexSet.forEach(function(index) {
            declaration += "layout(location=" + index + ") out vec4 fragOutColor" + index + ";\n";
        });
        declaration += "void main(";
        shader = shader.replace(/\bgl_FragData\[(.+?)\]/g, "fragOutColor$1");
        shader = shader.replace(/void\s+?main\s*\(/g, declaration);
        return shader;
    };
    return ShaderFactory;
}();
/** @internal */ ShaderFactory._shaderExtension = [
    "GL_EXT_shader_texture_lod",
    "GL_OES_standard_derivatives",
    "GL_EXT_draw_buffers",
    "GL_EXT_frag_depth"
].map(function(e) {
    return "#extension " + e + " : enable\n";
}).join("");
ShaderFactory._has300OutInFragReg = /\bout\s+(?:\w+\s+)?(?:vec4)\s+(?:\w+)\s*;/ // [layout(location = 0)] out [highp] vec4 [color];
;

/**
 * Shader tag key.
 */ var ShaderTagKey = /*#__PURE__*/ function() {
    function ShaderTagKey(name) {
        this.name = name;
        this._uniqueId = ShaderTagKey._nameCounter++;
    }
    /**
   * Get shader property by name.
   * @param name - Name of the shader property
   * @returns Shader property
   */ ShaderTagKey.getByName = function getByName(name) {
        var _nameMap, _name;
        var nameMap = ShaderTagKey._nameMap;
        return (_nameMap = nameMap)[_name = name] || (_nameMap[_name] = new ShaderTagKey(name));
    };
    return ShaderTagKey;
}();
ShaderTagKey._nameCounter = 0;
ShaderTagKey._nameMap = Object.create(null);

/**
 * Base class for shader structure.
 */ var ShaderPart = /*#__PURE__*/ function() {
    function ShaderPart() {
        this._tagsMap = Object.create(null);
    }
    var _proto = ShaderPart.prototype;
    _proto.setTag = function setTag(keyOrKeyName, value) {
        var key = typeof keyOrKeyName === "string" ? ShaderTagKey.getByName(keyOrKeyName) : keyOrKeyName;
        var tags = this._tagsMap;
        if (tags[key._uniqueId] !== undefined) {
            Logger.warn('The value of tag named "' + key.name + '" is being replaced.');
        }
        tags[key._uniqueId] = value;
    };
    _proto.deleteTag = function deleteTag(keyOrKeyName) {
        delete this._tagsMap[(typeof keyOrKeyName == "string" ? ShaderTagKey.getByName(keyOrKeyName) : keyOrKeyName)._uniqueId];
    };
    _proto.getTagValue = function getTagValue(keyOrKeyName) {
        return this._tagsMap[typeof keyOrKeyName == "string" ? ShaderTagKey.getByName(keyOrKeyName)._uniqueId : keyOrKeyName._uniqueId];
    };
    _create_class$2(ShaderPart, [
        {
            key: "name",
            get: /**
   * Name.
   */ function get() {
                return this._name;
            }
        }
    ]);
    return ShaderPart;
}();

/**
 * Shader uniform。
 * @internal
 */ var ShaderUniform = /*#__PURE__*/ function() {
    function ShaderUniform(engine) {
        this.textureUseCompareMode = false;
        var rhi = engine._hardwareRenderer;
        this._rhi = rhi;
        this._gl = rhi.gl;
    }
    var _proto = ShaderUniform.prototype;
    _proto.upload1f = function upload1f(shaderUniform, value) {
        if (this.cacheValue !== value) {
            this._gl.uniform1f(shaderUniform.location, value);
            this.cacheValue = value;
        }
    };
    _proto.upload1fv = function upload1fv(shaderUniform, value) {
        this._gl.uniform1fv(shaderUniform.location, value);
    };
    _proto.upload2f = function upload2f(shaderUniform, value) {
        var cacheValue = this.cacheValue;
        if (value.r !== undefined) {
            if (cacheValue.x !== value.r || cacheValue.y !== value.g) {
                this._gl.uniform2f(shaderUniform.location, value.r, value.g);
                cacheValue.x = value.r;
                cacheValue.y = value.g;
            }
        } else {
            if (cacheValue.x !== value.x || cacheValue.y !== value.y) {
                this._gl.uniform2f(shaderUniform.location, value.x, value.y);
                cacheValue.x = value.x;
                cacheValue.y = value.y;
            }
        }
    };
    _proto.upload2fv = function upload2fv(shaderUniform, value) {
        this._gl.uniform2fv(shaderUniform.location, value);
    };
    _proto.upload3f = function upload3f(shaderUniform, value) {
        var cacheValue = this.cacheValue;
        if (value.r !== undefined) {
            if (cacheValue.x !== value.r || cacheValue.y !== value.g || cacheValue.z !== value.b) {
                this._gl.uniform3f(shaderUniform.location, value.r, value.g, value.b);
                cacheValue.x = value.r;
                cacheValue.y = value.g;
                cacheValue.z = value.b;
            }
        } else {
            if (cacheValue.x !== value.x || cacheValue.y !== value.y || cacheValue.z !== value.z) {
                this._gl.uniform3f(shaderUniform.location, value.x, value.y, value.z);
                cacheValue.x = value.x;
                cacheValue.y = value.y;
                cacheValue.z = value.z;
            }
        }
    };
    _proto.upload3fv = function upload3fv(shaderUniform, value) {
        this._gl.uniform3fv(shaderUniform.location, value);
    };
    _proto.upload4f = function upload4f(shaderUniform, value) {
        var cacheValue = this.cacheValue;
        if (value.r !== undefined) {
            if (cacheValue.x !== value.r || cacheValue.y !== value.g || cacheValue.z !== value.b || cacheValue.w !== value.a) {
                this._gl.uniform4f(shaderUniform.location, value.r, value.g, value.b, value.a);
                cacheValue.x = value.r;
                cacheValue.y = value.g;
                cacheValue.z = value.b;
                cacheValue.w = value.a;
            }
        } else {
            if (cacheValue.x !== value.x || cacheValue.y !== value.y || cacheValue.z !== value.z || cacheValue.w !== value.w) {
                this._gl.uniform4f(shaderUniform.location, value.x, value.y, value.z, value.w);
                cacheValue.x = value.x;
                cacheValue.y = value.y;
                cacheValue.z = value.z;
                cacheValue.w = value.w;
            }
        }
    };
    _proto.upload4fv = function upload4fv(shaderUniform, value) {
        this._gl.uniform4fv(shaderUniform.location, value);
    };
    _proto.upload1i = function upload1i(shaderUniform, value) {
        if (this.cacheValue !== value) {
            this._gl.uniform1i(shaderUniform.location, value);
            this.cacheValue = value;
        }
    };
    _proto.upload1iv = function upload1iv(shaderUniform, value) {
        this._gl.uniform1iv(shaderUniform.location, value);
    };
    _proto.upload2i = function upload2i(shaderUniform, value) {
        var cacheValue = this.cacheValue;
        if (value.r !== undefined) {
            if (cacheValue.x !== value.r || cacheValue.y !== value.g) {
                this._gl.uniform2i(shaderUniform.location, value.r, value.g);
                cacheValue.x = value.r;
                cacheValue.y = value.g;
            }
        } else {
            if (cacheValue.x !== value.x || cacheValue.y !== value.y) {
                this._gl.uniform2i(shaderUniform.location, value.x, value.y);
                cacheValue.x = value.x;
                cacheValue.y = value.y;
            }
        }
    };
    _proto.upload2iv = function upload2iv(shaderUniform, value) {
        this._gl.uniform2iv(shaderUniform.location, value);
    };
    _proto.upload3i = function upload3i(shaderUniform, value) {
        var cacheValue = this.cacheValue;
        if (value.r !== undefined) {
            if (cacheValue.x !== value.r || cacheValue.y !== value.g || cacheValue.z !== value.b) {
                this._gl.uniform3i(shaderUniform.location, value.r, value.g, value.b);
                cacheValue.x = value.r;
                cacheValue.y = value.g;
                cacheValue.z = value.b;
            }
        } else {
            if (cacheValue.x !== value.x || cacheValue.y !== value.y || cacheValue.z !== value.z) {
                this._gl.uniform3i(shaderUniform.location, value.x, value.y, value.z);
                cacheValue.x = value.x;
                cacheValue.y = value.y;
                cacheValue.z = value.z;
            }
        }
    };
    _proto.upload3iv = function upload3iv(shaderUniform, value) {
        this._gl.uniform3iv(shaderUniform.location, value);
    };
    _proto.upload4i = function upload4i(shaderUniform, value) {
        var cacheValue = this.cacheValue;
        if (value.r !== undefined) {
            if (cacheValue.x !== value.r || cacheValue.y !== value.g || cacheValue.z !== value.b || cacheValue.w !== value.a) {
                this._gl.uniform4i(shaderUniform.location, value.r, value.g, value.b, value.a);
                cacheValue.x = value.r;
                cacheValue.y = value.g;
                cacheValue.z = value.b;
                cacheValue.w = value.a;
            }
        } else {
            if (cacheValue.x !== value.x || cacheValue.y !== value.y || cacheValue.z !== value.z || cacheValue.w !== value.w) {
                this._gl.uniform4i(shaderUniform.location, value.x, value.y, value.z, value.w);
                cacheValue.x = value.x;
                cacheValue.y = value.y;
                cacheValue.z = value.z;
                cacheValue.w = value.w;
            }
        }
    };
    _proto.upload4iv = function upload4iv(shaderUniform, value) {
        this._gl.uniform4iv(shaderUniform.location, value);
    };
    _proto.uploadMat4 = function uploadMat4(shaderUniform, value) {
        this._gl.uniformMatrix4fv(shaderUniform.location, false, value.elements);
    };
    _proto.uploadMat4v = function uploadMat4v(shaderUniform, value) {
        this._gl.uniformMatrix4fv(shaderUniform.location, false, value);
    };
    _proto.uploadTexture = function uploadTexture(shaderUniform, value) {
        var rhi = this._rhi;
        rhi.activeTexture(shaderUniform.textureIndex);
        rhi.bindTexture(value._platformTexture);
        value._setUseDepthCompareMode(shaderUniform.textureUseCompareMode);
    };
    _proto.uploadTextureArray = function uploadTextureArray(shaderUniform, value) {
        var rhi = this._rhi;
        var textureIndices = shaderUniform.textureIndex;
        for(var i = 0; i < value.length; i++){
            var texture = value[i];
            rhi.activeTexture(textureIndices[i]);
            rhi.bindTexture(texture._platformTexture);
            texture._setUseDepthCompareMode(shaderUniform.textureUseCompareMode);
        }
    };
    return ShaderUniform;
}();

/**
 * Shader uniform block.
 * @internal
 */ var ShaderUniformBlock = function ShaderUniformBlock() {
    this.constUniforms = [];
    this.textureUniforms = [];
};

/**
 * Shader program, corresponding to the GPU shader program.
 * @internal
 */ var ShaderProgram = /*#__PURE__*/ function() {
    function ShaderProgram(engine, vertexSource, fragmentSource) {
        this.sceneUniformBlock = new ShaderUniformBlock();
        this.cameraUniformBlock = new ShaderUniformBlock();
        this.rendererUniformBlock = new ShaderUniformBlock();
        this.materialUniformBlock = new ShaderUniformBlock();
        this.renderElementUniformBlock = new ShaderUniformBlock();
        this.otherUniformBlock = new ShaderUniformBlock();
        /** @internal */ this._uploadRenderCount = -1;
        /** @internal */ this._uploadSceneId = -1;
        /** @internal */ this._uploadCameraId = -1;
        /** @internal */ this._uploadRendererId = -1;
        /** @internal */ this._uploadMaterialId = -1;
        this.attributeLocation = Object.create(null);
        this._activeTextureUint = 0;
        this._engine = engine;
        this._gl = engine._hardwareRenderer.gl;
        this._glProgram = this._createProgram(vertexSource, fragmentSource);
        if (this._glProgram) {
            this._isValid = true;
            this._recordLocation();
        } else {
            this._isValid = false;
        }
        this.id = ShaderProgram._counter++;
    }
    var _proto = ShaderProgram.prototype;
    /**
   * Upload all shader data in shader uniform block.
   * @param uniformBlock - shader Uniform block
   * @param shaderData - shader data
   */ _proto.uploadAll = function uploadAll(uniformBlock, shaderData) {
        this.uploadUniforms(uniformBlock, shaderData);
        this.uploadTextures(uniformBlock, shaderData);
    };
    /**
   * Upload constant shader data in shader uniform block.
   * @param uniformBlock - shader Uniform block
   * @param shaderData - shader data
   */ _proto.uploadUniforms = function uploadUniforms(uniformBlock, shaderData) {
        var propertyValueMap = shaderData._propertyValueMap;
        var constUniforms = uniformBlock.constUniforms;
        for(var i = 0, n = constUniforms.length; i < n; i++){
            var uniform = constUniforms[i];
            var data = propertyValueMap[uniform.propertyId];
            data != null && uniform.applyFunc(uniform, data);
        }
    };
    /**
   * Upload texture shader data in shader uniform block.
   * @param uniformBlock - shader Uniform block
   * @param shaderData - shader data
   */ _proto.uploadTextures = function uploadTextures(uniformBlock, shaderData) {
        var propertyValueMap = shaderData._propertyValueMap;
        var textureUniforms = uniformBlock.textureUniforms;
        // textureUniforms property maybe null if ShaderUniformBlock not contain any texture.
        if (textureUniforms) {
            for(var i = 0, n = textureUniforms.length; i < n; i++){
                var uniform = textureUniforms[i];
                var texture = propertyValueMap[uniform.propertyId];
                if (texture && !texture.destroyed) {
                    uniform.applyFunc(uniform, texture);
                } else {
                    uniform.applyFunc(uniform, uniform.textureDefault);
                }
            }
        }
    };
    /**
   * Upload ungroup texture shader data in shader uniform block.
   */ _proto.uploadUnGroupTextures = function uploadUnGroupTextures() {
        var textureUniforms = this.otherUniformBlock.textureUniforms;
        // textureUniforms property maybe null if ShaderUniformBlock not contain any texture.
        if (textureUniforms) {
            for(var i = 0, n = textureUniforms.length; i < n; i++){
                var uniform = textureUniforms[i];
                uniform.applyFunc(uniform, uniform.textureDefault);
            }
        }
    };
    /**
   * Grouping other data.
   */ _proto.groupingOtherUniformBlock = function groupingOtherUniformBlock() {
        var _this_otherUniformBlock = this.otherUniformBlock, constUniforms = _this_otherUniformBlock.constUniforms, textureUniforms = _this_otherUniformBlock.textureUniforms;
        constUniforms.length > 0 && this._groupingSubOtherUniforms(constUniforms, false);
        textureUniforms.length > 0 && this._groupingSubOtherUniforms(textureUniforms, true);
    };
    /**
   * Bind this shader program.
   * @returns Whether the shader program is switched.
   */ _proto.bind = function bind() {
        var rhi = this._engine._hardwareRenderer;
        if (rhi._currentBindShaderProgram !== this) {
            this._gl.useProgram(this._glProgram);
            rhi._currentBindShaderProgram = this;
            return true;
        } else {
            return false;
        }
    };
    /**
   * Destroy this shader program.
   */ _proto.destroy = function destroy() {
        var gl = this._gl;
        this._glProgram && gl.deleteProgram(this._glProgram);
    };
    _proto._groupingSubOtherUniforms = function _groupingSubOtherUniforms(uniforms, isTexture) {
        for(var i = uniforms.length - 1; i >= 0; i--){
            var uniform = uniforms[i];
            var group = ShaderProperty._getShaderPropertyGroup(uniform.name);
            if (group !== undefined) {
                uniforms.splice(uniforms.indexOf(uniform), 1);
                this._groupingUniform(uniform, group, isTexture);
            }
        }
    };
    _proto._groupingUniform = function _groupingUniform(uniform, group, isTexture) {
        switch(group){
            case ShaderDataGroup.Scene:
                if (isTexture) {
                    this.sceneUniformBlock.textureUniforms.push(uniform);
                } else {
                    this.sceneUniformBlock.constUniforms.push(uniform);
                }
                break;
            case ShaderDataGroup.Camera:
                if (isTexture) {
                    this.cameraUniformBlock.textureUniforms.push(uniform);
                } else {
                    this.cameraUniformBlock.constUniforms.push(uniform);
                }
                break;
            case ShaderDataGroup.Renderer:
                if (isTexture) {
                    this.rendererUniformBlock.textureUniforms.push(uniform);
                } else {
                    this.rendererUniformBlock.constUniforms.push(uniform);
                }
                break;
            case ShaderDataGroup.Material:
                if (isTexture) {
                    this.materialUniformBlock.textureUniforms.push(uniform);
                } else {
                    this.materialUniformBlock.constUniforms.push(uniform);
                }
                break;
            case ShaderDataGroup.RenderElement:
                if (isTexture) {
                    this.renderElementUniformBlock.textureUniforms.push(uniform);
                } else {
                    this.renderElementUniformBlock.constUniforms.push(uniform);
                }
                break;
            default:
                if (isTexture) {
                    this.otherUniformBlock.textureUniforms.push(uniform);
                } else {
                    this.otherUniformBlock.constUniforms.push(uniform);
                }
        }
    };
    /**
   * Init and link program with shader.
   */ _proto._createProgram = function _createProgram(vertexSource, fragmentSource) {
        var gl = this._gl;
        // Create and compile shader
        var vertexShader = this._createShader(gl.VERTEX_SHADER, vertexSource);
        if (!vertexShader) {
            return null;
        }
        var fragmentShader = this._createShader(gl.FRAGMENT_SHADER, fragmentSource);
        if (!fragmentShader) {
            return null;
        }
        // Create program and link shader
        var program = gl.createProgram();
        if (!program) {
            console.warn("Context lost while create program.");
            return null;
        }
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.validateProgram(program);
        gl.deleteShader(vertexShader);
        gl.deleteShader(fragmentShader);
        if (Logger.isEnabled && !gl.getProgramParameter(program, gl.LINK_STATUS) && !gl.isContextLost()) {
            Logger.error("Could not link WebGL program\n\n" + ("Shader error: " + gl.getError() + "\n\n") + ("Validate status: " + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + "\n\n") + ("Program information log: " + gl.getProgramInfoLog(program)));
            gl.deleteProgram(program);
            return null;
        }
        return program;
    };
    _proto._createShader = function _createShader(shaderType, shaderSource) {
        var gl = this._gl;
        var shader = gl.createShader(shaderType);
        if (!shader) {
            console.warn("Context lost while create shader.");
            return null;
        }
        gl.shaderSource(shader, shaderSource);
        gl.compileShader(shader);
        if (Logger.isEnabled && !gl.getShaderParameter(shader, gl.COMPILE_STATUS) && !gl.isContextLost()) {
            console.warn("Could not compile WebGL shader\n\n" + ("Shader type: " + (shaderType == gl.VERTEX_SHADER ? "vertex" : "fragment") + "\n\n") + ("Shader information log:\n" + gl.getShaderInfoLog(shader) + "\n") + ("Shader source:\n" + ShaderProgram._addLineNum(shaderSource)));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    };
    /**
   * record the location of uniform/attribute.
   */ _proto._recordLocation = function _recordLocation() {
        var _this = this;
        var gl = this._gl;
        var program = this._glProgram;
        var uniformInfos = this._getUniformInfos();
        var attributeInfos = this._getAttributeInfos();
        var basicResources = this._engine._basicResources;
        uniformInfos.forEach(function(param) {
            var name = param.name, size = param.size, type = param.type;
            var shaderUniform = new ShaderUniform(_this._engine);
            var isArray = false;
            var isTexture = false;
            if (name.indexOf("[0]") > 0) {
                name = name.substr(0, name.length - 3);
                isArray = true;
            }
            var location = gl.getUniformLocation(program, name);
            shaderUniform.name = name;
            shaderUniform.propertyId = ShaderProperty.getByName(name)._uniqueId;
            shaderUniform.location = location;
            switch(type){
                case gl.FLOAT:
                    if (isArray) {
                        shaderUniform.applyFunc = shaderUniform.upload1fv;
                    } else {
                        shaderUniform.applyFunc = shaderUniform.upload1f;
                        shaderUniform.cacheValue = 0;
                    }
                    break;
                case gl.FLOAT_VEC2:
                    if (isArray) {
                        shaderUniform.applyFunc = shaderUniform.upload2fv;
                    } else {
                        shaderUniform.applyFunc = shaderUniform.upload2f;
                        shaderUniform.cacheValue = new Vector2(0, 0);
                    }
                    break;
                case gl.FLOAT_VEC3:
                    if (isArray) {
                        shaderUniform.applyFunc = shaderUniform.upload3fv;
                    } else {
                        shaderUniform.applyFunc = shaderUniform.upload3f;
                        shaderUniform.cacheValue = new Vector3(0, 0, 0);
                    }
                    break;
                case gl.FLOAT_VEC4:
                    if (isArray) {
                        shaderUniform.applyFunc = shaderUniform.upload4fv;
                    } else {
                        shaderUniform.applyFunc = shaderUniform.upload4f;
                        shaderUniform.cacheValue = new Vector4(0, 0, 0, 0);
                    }
                    break;
                case gl.BOOL:
                case gl.INT:
                    if (isArray) {
                        shaderUniform.applyFunc = shaderUniform.upload1iv;
                    } else {
                        shaderUniform.applyFunc = shaderUniform.upload1i;
                        shaderUniform.cacheValue = 0;
                    }
                    break;
                case gl.BOOL_VEC2:
                case gl.INT_VEC2:
                    if (isArray) {
                        shaderUniform.applyFunc = shaderUniform.upload2iv;
                    } else {
                        shaderUniform.applyFunc = shaderUniform.upload2i;
                        shaderUniform.cacheValue = new Vector2(0, 0);
                    }
                    break;
                case gl.BOOL_VEC3:
                case gl.INT_VEC3:
                    if (isArray) {
                        shaderUniform.applyFunc = shaderUniform.upload3iv;
                    } else {
                        shaderUniform.applyFunc = shaderUniform.upload3i;
                        shaderUniform.cacheValue = new Vector3(0, 0, 0);
                    }
                    break;
                case gl.BOOL_VEC4:
                case gl.INT_VEC4:
                    if (isArray) {
                        shaderUniform.applyFunc = shaderUniform.upload4iv;
                    } else {
                        shaderUniform.applyFunc = shaderUniform.upload4i;
                        shaderUniform.cacheValue = new Vector4(0, 0, 0);
                    }
                    break;
                case gl.FLOAT_MAT4:
                    shaderUniform.applyFunc = isArray ? shaderUniform.uploadMat4v : shaderUniform.uploadMat4;
                    break;
                case gl.SAMPLER_2D:
                case gl.SAMPLER_CUBE:
                case gl.UNSIGNED_INT_SAMPLER_2D:
                case gl.SAMPLER_2D_ARRAY:
                case gl.SAMPLER_2D_SHADOW:
                    var defaultTexture;
                    switch(type){
                        case gl.SAMPLER_2D:
                            defaultTexture = basicResources.whiteTexture2D;
                            break;
                        case gl.SAMPLER_CUBE:
                            defaultTexture = basicResources.whiteTextureCube;
                            break;
                        case gl.UNSIGNED_INT_SAMPLER_2D:
                            defaultTexture = basicResources.uintWhiteTexture2D;
                            break;
                        case gl.SAMPLER_2D_ARRAY:
                            defaultTexture = basicResources.whiteTexture2DArray;
                            break;
                        case gl.SAMPLER_2D_SHADOW:
                            defaultTexture = _this._engine._depthTexture2D;
                            shaderUniform.textureUseCompareMode = true;
                            break;
                    }
                    isTexture = true;
                    if (isArray) {
                        var defaultTextures = new Array(size);
                        var textureIndices = new Int32Array(size);
                        var glTextureIndices = new Array(size);
                        for(var i = 0; i < size; i++){
                            defaultTextures[i] = defaultTexture;
                            textureIndices[i] = _this._activeTextureUint;
                            glTextureIndices[i] = gl.TEXTURE0 + _this._activeTextureUint++;
                        }
                        shaderUniform.textureDefault = defaultTextures;
                        shaderUniform.textureIndex = glTextureIndices;
                        shaderUniform.applyFunc = shaderUniform.uploadTextureArray;
                        _this.bind();
                        gl.uniform1iv(location, textureIndices);
                    } else {
                        var glTextureIndex = gl.TEXTURE0 + _this._activeTextureUint;
                        shaderUniform.textureDefault = defaultTexture;
                        shaderUniform.textureIndex = glTextureIndex;
                        shaderUniform.applyFunc = shaderUniform.uploadTexture;
                        _this.bind();
                        gl.uniform1i(location, _this._activeTextureUint++);
                    }
                    break;
                default:
                    throw new Error("Unsupported uniform type");
            }
            var group = ShaderProperty._getShaderPropertyGroup(name);
            _this._groupingUniform(shaderUniform, group, isTexture);
        });
        attributeInfos.forEach(function(param) {
            var name = param.name;
            _this.attributeLocation[name] = gl.getAttribLocation(program, name);
        });
    };
    _proto._getUniformInfos = function _getUniformInfos() {
        var gl = this._gl;
        var program = this._glProgram;
        var uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
        var uniformInfos = new Array(uniformCount);
        for(var i = 0; i < uniformCount; ++i){
            var info = gl.getActiveUniform(program, i);
            uniformInfos[i] = info;
        }
        return uniformInfos;
    };
    _proto._getAttributeInfos = function _getAttributeInfos() {
        var gl = this._gl;
        var program = this._glProgram;
        var attributeInfos = new Array();
        var attributeCount = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
        for(var i = 0; i < attributeCount; ++i){
            var info = gl.getActiveAttrib(program, i);
            attributeInfos[i] = info;
        }
        return attributeInfos;
    };
    ShaderProgram._addLineNum = function _addLineNum(str) {
        var lines = str.split("\n");
        var limitLength = (lines.length + 1).toString().length + 6;
        var prefix;
        return lines.map(function(line, index) {
            prefix = "0:" + (index + 1);
            if (prefix.length >= limitLength) return prefix.substring(0, limitLength) + line;
            for(var i = 0; i < limitLength - prefix.length; i++)prefix += " ";
            return prefix + line;
        }).join("\n");
    };
    _create_class$2(ShaderProgram, [
        {
            key: "isValid",
            get: /**
   * Whether this shader program is valid.
   */ function get() {
                return this._isValid;
            }
        }
    ]);
    return ShaderProgram;
}();
ShaderProgram._counter = 0;

/**
 * @internal
 * Shader pass type
 */ var ShaderType = /*#__PURE__*/ function(ShaderType) {
    /** init by glsl */ ShaderType[ShaderType["Canonical"] = 0] = "Canonical";
    /** init by shader-lab */ ShaderType[ShaderType["ShaderLab"] = 1] = "ShaderLab";
    return ShaderType;
}({});

/**
 * Shader pass containing vertex and fragment source.
 */ var ShaderPass = /*#__PURE__*/ function(ShaderPart) {
    _inherits$2(ShaderPass, ShaderPart);
    function ShaderPass(nameOrVertexSource, vertexSourceOrFragmentSourceOrCode, fragmentSourceOrTagsOrVertexEntry, fragmentEntryOrTags, tags) {
        var _this;
        _this = ShaderPart.call(this) || this, /** @internal */ _this._shaderPassId = 0, /** @internal */ _this._renderStateDataMap = {}, /** @internal */ _this._shaderProgramPools = [], /** @internal */ _this._path = "", _this._platformMacros = [];
        _this._shaderPassId = ShaderPass._shaderPassCounter++;
        _this._type = ShaderType.Canonical;
        if (typeof fragmentEntryOrTags === "string") {
            _this._name = nameOrVertexSource;
            _this._shaderLabSource = vertexSourceOrFragmentSourceOrCode;
            _this._vertexEntry = fragmentSourceOrTagsOrVertexEntry;
            _this._fragmentEntry = fragmentEntryOrTags;
            tags = _extends$2({
                pipelineStage: PipelineStage.Forward
            }, tags);
            _this._type = ShaderType.ShaderLab;
        } else if (typeof fragmentSourceOrTagsOrVertexEntry === "string") {
            _this._name = nameOrVertexSource;
            _this._vertexSource = vertexSourceOrFragmentSourceOrCode;
            _this._fragmentSource = fragmentSourceOrTagsOrVertexEntry;
            tags = fragmentEntryOrTags != null ? fragmentEntryOrTags : {
                pipelineStage: PipelineStage.Forward
            };
        } else {
            _this._name = "Default";
            _this._vertexSource = nameOrVertexSource;
            _this._fragmentSource = vertexSourceOrFragmentSourceOrCode;
            tags = fragmentSourceOrTagsOrVertexEntry != null ? fragmentSourceOrTagsOrVertexEntry : {
                pipelineStage: PipelineStage.Forward
            };
        }
        for(var key in tags){
            _this.setTag(key, tags[key]);
        }
        return _this;
    }
    var _proto = ShaderPass.prototype;
    /**
   * @internal
   */ _proto._getShaderProgram = function _getShaderProgram(engine, macroCollection) {
        var shaderProgramPool = engine._getShaderProgramPool(this);
        var shaderProgram = shaderProgramPool.get(macroCollection);
        if (shaderProgram) {
            return shaderProgram;
        }
        if (this._type === ShaderType.Canonical) {
            shaderProgram = this._getCanonicalShaderProgram(engine, macroCollection);
        } else {
            shaderProgram = this._compileShaderProgram(engine, macroCollection, this._vertexEntry, this._fragmentEntry);
        }
        shaderProgramPool.cache(shaderProgram);
        return shaderProgram;
    };
    /**
   * @internal
   */ _proto._destroy = function _destroy() {
        var shaderProgramPools = this._shaderProgramPools;
        for(var i = 0, n = shaderProgramPools.length; i < n; i++){
            var shaderProgramPool = shaderProgramPools[i];
            shaderProgramPool._destroy();
            delete shaderProgramPool.engine._shaderProgramPools[this._shaderPassId];
        }
        // Clear array storing multiple engine shader program pools
        shaderProgramPools.length = 0;
    };
    /**
   * Shader Lab compilation
   */ _proto._compileShaderProgram = function _compileShaderProgram(engine, macroCollection, vertexEntry, fragmentEntry) {
        var _this = this, path = _this._path, platformMacros = _this._platformMacros;
        var isWebGL2 = engine._hardwareRenderer.isWebGL2;
        var macros = new Array();
        ShaderMacro._getMacrosElements(macroCollection, macros);
        platformMacros.length = 0;
        if (engine._hardwareRenderer.canIUse(GLCapabilityType.shaderTextureLod)) {
            platformMacros.push("HAS_TEX_LOD");
        }
        if (engine._hardwareRenderer.canIUse(GLCapabilityType.standardDerivatives)) {
            platformMacros.push("HAS_DERIVATIVES");
        }
        if (isWebGL2) {
            platformMacros.push("GRAPHICS_API_WEBGL2");
        } else {
            platformMacros.push("GRAPHICS_API_WEBGL1");
        }
        var start = performance.now();
        var shaderProgramSource = Shader._shaderLab._parseShaderPass(this._shaderLabSource, vertexEntry, fragmentEntry, macros, isWebGL2 ? ShaderPlatformTarget.GLES300 : ShaderPlatformTarget.GLES100, platformMacros, new URL(path, ShaderPass._shaderRootPath).href);
        Logger.info("[ShaderLab compilation] cost time: " + (performance.now() - start) + "ms");
        if (shaderProgramSource) {
            return new ShaderProgram(engine, shaderProgramSource.vertex, shaderProgramSource.fragment);
        } else {
            return new ShaderProgram(engine, "", "");
        }
    };
    // TODO: remove it after migrate all shader to `ShaderLab`.
    _proto._getCanonicalShaderProgram = function _getCanonicalShaderProgram(engine, macroCollection) {
        var isWebGL2 = engine._hardwareRenderer.isWebGL2;
        var macroNameList = new Array();
        ShaderMacro._getMacrosElements(macroCollection, macroNameList);
        var macroNameStr = ShaderFactory.parseCustomMacros(macroNameList);
        var versionStr = isWebGL2 ? "#version 300 es" : "#version 100";
        var graphicAPI = isWebGL2 ? "#define GRAPHICS_API_WEBGL2" : "#define GRAPHICS_API_WEBGL1";
        var precisionStr = "\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n      precision highp float;\n      precision highp int;\n    #else\n      precision mediump float;\n      precision mediump int;\n    #endif\n    ";
        if (engine._hardwareRenderer.canIUse(GLCapabilityType.shaderTextureLod)) {
            precisionStr += "#define HAS_TEX_LOD\n";
        }
        if (engine._hardwareRenderer.canIUse(GLCapabilityType.standardDerivatives)) {
            precisionStr += "#define HAS_DERIVATIVES\n";
        }
        var vertexSource = " " + versionStr + "\n        " + graphicAPI + "\n        " + macroNameStr + "\n      " + ShaderFactory.parseIncludes(this._vertexSource);
        var fragmentSource = " " + versionStr + "\n        " + graphicAPI + "\n        " + (isWebGL2 ? "" : ShaderFactory._shaderExtension) + "\n        " + precisionStr + "\n        " + macroNameStr + "\n      " + ShaderFactory.parseIncludes(this._fragmentSource);
        if (isWebGL2) {
            vertexSource = ShaderFactory.convertTo300(vertexSource);
            fragmentSource = ShaderFactory.convertTo300(fragmentSource, true);
        }
        var shaderProgram = new ShaderProgram(engine, vertexSource, fragmentSource);
        return shaderProgram;
    };
    return ShaderPass;
}(ShaderPart);
ShaderPass._shaderPassCounter = 0;
/** @internal */ ShaderPass._shaderRootPath = "shaders://root/";

/**
 * Sub shader.
 */ var SubShader = /*#__PURE__*/ function(ShaderPart) {
    _inherits$2(SubShader, ShaderPart);
    function SubShader(name, passes, tags) {
        var _this;
        _this = ShaderPart.call(this) || this;
        _this._name = name;
        var passCount = passes.length;
        if (passCount < 1) {
            throw " count must large than 0.";
        }
        _this._passes = passes.slice();
        for(var key in tags){
            _this.setTag(key, tags[key]);
        }
        return _this;
    }
    _create_class$2(SubShader, [
        {
            key: "passes",
            get: /**
   * Sub shader passes.
   */ function get() {
                return this._passes;
            }
        }
    ]);
    return SubShader;
}(ShaderPart);

/**
 * The blend state of the render target.
 */ var RenderTargetBlendState = function RenderTargetBlendState() {
    /** Whether to enable blend. */ this.enabled = false;
    /** color (RGB) blend operation. */ this.colorBlendOperation = BlendOperation.Add;
    /** alpha (A) blend operation. */ this.alphaBlendOperation = BlendOperation.Add;
    /** color blend factor (RGB) for source. */ this.sourceColorBlendFactor = BlendFactor.One;
    /** alpha blend factor (A) for source. */ this.sourceAlphaBlendFactor = BlendFactor.One;
    /** color blend factor (RGB) for destination. */ this.destinationColorBlendFactor = BlendFactor.Zero;
    /** alpha blend factor (A) for destination. */ this.destinationAlphaBlendFactor = BlendFactor.Zero;
    /** color mask. */ this.colorWriteMask = ColorWriteMask.All;
};

/**
 * Blend state.
 */ var BlendState = /*#__PURE__*/ function() {
    function BlendState() {
        /** The blend state of the render target. */ this.targetBlendState = new RenderTargetBlendState();
        /** Constant blend color. */ this.blendColor = new Color(0, 0, 0, 0);
        /** Whether to use (Alpha-to-Coverage) technology. */ this.alphaToCoverage = false;
    }
    var _proto = BlendState.prototype;
    /**
   * @internal
   */ _proto._applyShaderDataValue = function _applyShaderDataValue(renderStateDataMap, shaderData) {
        var blendState = this.targetBlendState;
        var enable0Property = renderStateDataMap[RenderStateElementKey.BlendStateEnabled0];
        if (enable0Property !== undefined) {
            var enabled = shaderData.getFloat(enable0Property);
            blendState.enabled = enabled !== undefined ? !!enabled : false;
        }
        var colorBlendOperation0Property = renderStateDataMap[RenderStateElementKey.BlendStateColorBlendOperation0];
        if (colorBlendOperation0Property !== undefined) {
            var _shaderData_getFloat;
            blendState.colorBlendOperation = (_shaderData_getFloat = shaderData.getFloat(colorBlendOperation0Property)) != null ? _shaderData_getFloat : BlendOperation.Add;
        }
        var alphaBlendOperation0Property = renderStateDataMap[RenderStateElementKey.BlendStateAlphaBlendOperation0];
        if (alphaBlendOperation0Property !== undefined) {
            var _shaderData_getFloat1;
            blendState.alphaBlendOperation = (_shaderData_getFloat1 = shaderData.getFloat(alphaBlendOperation0Property)) != null ? _shaderData_getFloat1 : BlendOperation.Add;
        }
        var sourceColorBlendFactor0Property = renderStateDataMap[RenderStateElementKey.BlendStateSourceColorBlendFactor0];
        if (sourceColorBlendFactor0Property !== undefined) {
            var _shaderData_getFloat2;
            blendState.sourceColorBlendFactor = (_shaderData_getFloat2 = shaderData.getFloat(sourceColorBlendFactor0Property)) != null ? _shaderData_getFloat2 : BlendFactor.One;
        }
        var sourceAlphaBlendFactor0Property = renderStateDataMap[RenderStateElementKey.BlendStateSourceAlphaBlendFactor0];
        if (sourceAlphaBlendFactor0Property !== undefined) {
            var _shaderData_getFloat3;
            blendState.sourceAlphaBlendFactor = (_shaderData_getFloat3 = shaderData.getFloat(sourceAlphaBlendFactor0Property)) != null ? _shaderData_getFloat3 : BlendFactor.One;
        }
        var destinationColorBlendFactor0Property = renderStateDataMap[RenderStateElementKey.BlendStateDestinationColorBlendFactor0];
        if (destinationColorBlendFactor0Property !== undefined) {
            var _shaderData_getFloat4;
            blendState.destinationColorBlendFactor = (_shaderData_getFloat4 = shaderData.getFloat(destinationColorBlendFactor0Property)) != null ? _shaderData_getFloat4 : BlendFactor.Zero;
        }
        var destinationAlphaBlendFactor0Property = renderStateDataMap[RenderStateElementKey.BlendStateDestinationAlphaBlendFactor0];
        if (destinationAlphaBlendFactor0Property !== undefined) {
            var _shaderData_getFloat5;
            blendState.destinationAlphaBlendFactor = (_shaderData_getFloat5 = shaderData.getFloat(destinationAlphaBlendFactor0Property)) != null ? _shaderData_getFloat5 : BlendFactor.Zero;
        }
        var colorWriteMask0Property = renderStateDataMap[RenderStateElementKey.BlendStateColorWriteMask0];
        if (colorWriteMask0Property !== undefined) {
            var _shaderData_getFloat6;
            blendState.colorWriteMask = (_shaderData_getFloat6 = shaderData.getFloat(colorWriteMask0Property)) != null ? _shaderData_getFloat6 : ColorWriteMask.All;
        }
        var blendColorProperty = renderStateDataMap[RenderStateElementKey.BlendStateBlendColor];
        if (blendColorProperty !== undefined) {
            var blendColor = shaderData.getColor(blendColorProperty);
            blendColor !== undefined && this.blendColor.copyFrom(blendColor);
        }
        var alphaToCoverageProperty = renderStateDataMap[RenderStateElementKey.BlendStateAlphaToCoverage];
        if (alphaToCoverageProperty !== undefined) {
            var alphaToCoverage = shaderData.getFloat(alphaToCoverageProperty);
            this.alphaToCoverage = alphaToCoverage !== undefined ? !!alphaToCoverage : false;
        }
    };
    /**
   * @internal
   * Apply the current blend state by comparing with the last blend state.
   */ _proto._apply = function _apply(hardwareRenderer, lastRenderState, customStates) {
        this._platformApply(hardwareRenderer, lastRenderState.blendState, customStates);
    };
    _proto._platformApply = function _platformApply(rhi, lastState, customStates) {
        var gl = rhi.gl;
        var lastTargetBlendState = lastState.targetBlendState;
        var _this_targetBlendState = this.targetBlendState, enabled = _this_targetBlendState.enabled, colorBlendOperation = _this_targetBlendState.colorBlendOperation, alphaBlendOperation = _this_targetBlendState.alphaBlendOperation, sourceColorBlendFactor = _this_targetBlendState.sourceColorBlendFactor, destinationColorBlendFactor = _this_targetBlendState.destinationColorBlendFactor, sourceAlphaBlendFactor = _this_targetBlendState.sourceAlphaBlendFactor, destinationAlphaBlendFactor = _this_targetBlendState.destinationAlphaBlendFactor, colorWriteMask = _this_targetBlendState.colorWriteMask;
        if (customStates) {
            var colorWriteMaskState = customStates[RenderStateElementKey.BlendStateColorWriteMask0];
            colorWriteMaskState !== undefined && (colorWriteMask = colorWriteMaskState);
        }
        if (enabled !== lastTargetBlendState.enabled) {
            if (enabled) {
                gl.enable(gl.BLEND);
            } else {
                gl.disable(gl.BLEND);
            }
            lastTargetBlendState.enabled = enabled;
        }
        if (enabled) {
            // apply blend factor.
            if (sourceColorBlendFactor !== lastTargetBlendState.sourceColorBlendFactor || destinationColorBlendFactor !== lastTargetBlendState.destinationColorBlendFactor || sourceAlphaBlendFactor !== lastTargetBlendState.sourceAlphaBlendFactor || destinationAlphaBlendFactor !== lastTargetBlendState.destinationAlphaBlendFactor) {
                gl.blendFuncSeparate(BlendState._getGLBlendFactor(rhi, sourceColorBlendFactor), BlendState._getGLBlendFactor(rhi, destinationColorBlendFactor), BlendState._getGLBlendFactor(rhi, sourceAlphaBlendFactor), BlendState._getGLBlendFactor(rhi, destinationAlphaBlendFactor));
                lastTargetBlendState.sourceColorBlendFactor = sourceColorBlendFactor;
                lastTargetBlendState.destinationColorBlendFactor = destinationColorBlendFactor;
                lastTargetBlendState.sourceAlphaBlendFactor = sourceAlphaBlendFactor;
                lastTargetBlendState.destinationAlphaBlendFactor = destinationAlphaBlendFactor;
            }
            // apply blend operation.
            if (colorBlendOperation !== lastTargetBlendState.colorBlendOperation || alphaBlendOperation !== lastTargetBlendState.alphaBlendOperation) {
                gl.blendEquationSeparate(BlendState._getGLBlendOperation(rhi, colorBlendOperation), BlendState._getGLBlendOperation(rhi, alphaBlendOperation));
                lastTargetBlendState.colorBlendOperation = colorBlendOperation;
                lastTargetBlendState.alphaBlendOperation = alphaBlendOperation;
            }
            // apply blend color.
            var blendColor = this.blendColor;
            if (!Color.equals(lastState.blendColor, blendColor)) {
                gl.blendColor(blendColor.r, blendColor.g, blendColor.b, blendColor.a);
                lastState.blendColor.copyFrom(blendColor);
            }
        }
        // apply color mask.
        if (colorWriteMask !== lastTargetBlendState.colorWriteMask) {
            gl.colorMask((colorWriteMask & ColorWriteMask.Red) !== 0, (colorWriteMask & ColorWriteMask.Green) !== 0, (colorWriteMask & ColorWriteMask.Blue) !== 0, (colorWriteMask & ColorWriteMask.Alpha) !== 0);
            lastTargetBlendState.colorWriteMask = colorWriteMask;
        }
        // apply alpha to coverage.
        var alphaToCoverage = this.alphaToCoverage;
        if (alphaToCoverage !== lastState.alphaToCoverage) {
            if (alphaToCoverage) {
                gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE);
            } else {
                gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
            }
            lastState.alphaToCoverage = alphaToCoverage;
        }
    };
    BlendState._getGLBlendFactor = function _getGLBlendFactor(rhi, blendFactor) {
        var gl = rhi.gl;
        switch(blendFactor){
            case BlendFactor.Zero:
                return gl.ZERO;
            case BlendFactor.One:
                return gl.ONE;
            case BlendFactor.SourceColor:
                return gl.SRC_COLOR;
            case BlendFactor.OneMinusSourceColor:
                return gl.ONE_MINUS_SRC_COLOR;
            case BlendFactor.DestinationColor:
                return gl.DST_COLOR;
            case BlendFactor.OneMinusDestinationColor:
                return gl.ONE_MINUS_DST_COLOR;
            case BlendFactor.SourceAlpha:
                return gl.SRC_ALPHA;
            case BlendFactor.OneMinusSourceAlpha:
                return gl.ONE_MINUS_SRC_ALPHA;
            case BlendFactor.DestinationAlpha:
                return gl.DST_ALPHA;
            case BlendFactor.OneMinusDestinationAlpha:
                return gl.ONE_MINUS_DST_ALPHA;
            case BlendFactor.SourceAlphaSaturate:
                return gl.SRC_ALPHA_SATURATE;
            case BlendFactor.BlendColor:
                return gl.CONSTANT_COLOR;
            case BlendFactor.OneMinusBlendColor:
                return gl.ONE_MINUS_CONSTANT_COLOR;
        }
    };
    BlendState._getGLBlendOperation = function _getGLBlendOperation(rhi, blendOperation) {
        var gl = rhi.gl;
        switch(blendOperation){
            case BlendOperation.Add:
                return gl.FUNC_ADD;
            case BlendOperation.Subtract:
                return gl.FUNC_SUBTRACT;
            case BlendOperation.ReverseSubtract:
                return gl.FUNC_REVERSE_SUBTRACT;
            case BlendOperation.Min:
                if (!rhi.canIUse(GLCapabilityType.blendMinMax)) {
                    throw new Error("BlendOperation.Min is not supported in this context");
                }
                return gl.MIN; // in webgl1.0 is an extension
            case BlendOperation.Max:
                if (!rhi.canIUse(GLCapabilityType.blendMinMax)) {
                    throw new Error("BlendOperation.Max is not supported in this context");
                }
                return gl.MAX; // in webgl1.0 is an extension
        }
    };
    return BlendState;
}();
__decorate$1([
    deepClone
], BlendState.prototype, "targetBlendState", void 0);
__decorate$1([
    deepClone
], BlendState.prototype, "blendColor", void 0);

/**
 * Depth state.
 */ var DepthState = /*#__PURE__*/ function() {
    function DepthState() {
        /** Whether to enable the depth test. */ this.enabled = true;
        /** Depth comparison function. */ this.compareFunction = CompareFunction.Less;
        /** Whether the depth value can be written.*/ this.writeEnabled = true;
    }
    var _proto = DepthState.prototype;
    /**
   * @internal
   */ _proto._applyShaderDataValue = function _applyShaderDataValue(renderStateDataMap, shaderData) {
        var enableProperty = renderStateDataMap[RenderStateElementKey.DepthStateEnabled];
        if (enableProperty !== undefined) {
            var enabled = shaderData.getFloat(enableProperty);
            this.enabled = enabled !== undefined ? !!enabled : false;
        }
        var writeEnabledProperty = renderStateDataMap[RenderStateElementKey.DepthStateWriteEnabled];
        if (writeEnabledProperty !== undefined) {
            var writeEnabled = shaderData.getFloat(writeEnabledProperty);
            this.writeEnabled = writeEnabled !== undefined ? !!writeEnabled : false;
        }
        var compareFunctionProperty = renderStateDataMap[RenderStateElementKey.DepthStateCompareFunction];
        if (compareFunctionProperty !== undefined) {
            var _shaderData_getFloat;
            this.compareFunction = (_shaderData_getFloat = shaderData.getFloat(compareFunctionProperty)) != null ? _shaderData_getFloat : CompareFunction.Less;
        }
    };
    /**
   * @internal
   * Apply the current depth state by comparing with the last depth state.
   */ _proto._apply = function _apply(hardwareRenderer, lastRenderState, customStates) {
        this._platformApply(hardwareRenderer, lastRenderState.depthState, customStates);
    };
    _proto._platformApply = function _platformApply(rhi, lastState, customStates) {
        var gl = rhi.gl;
        var _this = this, enabled = _this.enabled, compareFunction = _this.compareFunction, writeEnabled = _this.writeEnabled;
        if (customStates) {
            var enabledState = customStates[RenderStateElementKey.DepthStateEnabled];
            enabledState !== undefined && (enabled = enabledState);
        }
        if (enabled != lastState.enabled) {
            if (enabled) {
                gl.enable(gl.DEPTH_TEST);
            } else {
                gl.disable(gl.DEPTH_TEST);
            }
            lastState.enabled = enabled;
        }
        if (enabled) {
            // Apply compare func
            if (compareFunction != lastState.compareFunction) {
                gl.depthFunc(DepthState._getGLCompareFunction(rhi, compareFunction));
                lastState.compareFunction = compareFunction;
            }
        }
        // Apply write enabled
        if (writeEnabled != lastState.writeEnabled) {
            gl.depthMask(writeEnabled);
            lastState.writeEnabled = writeEnabled;
        }
    };
    DepthState._getGLCompareFunction = function _getGLCompareFunction(rhi, compareFunction) {
        var gl = rhi.gl;
        switch(compareFunction){
            case CompareFunction.Never:
                return gl.NEVER;
            case CompareFunction.Less:
                return gl.LESS;
            case CompareFunction.Equal:
                return gl.EQUAL;
            case CompareFunction.LessEqual:
                return gl.LEQUAL;
            case CompareFunction.Greater:
                return gl.GREATER;
            case CompareFunction.NotEqual:
                return gl.NOTEQUAL;
            case CompareFunction.GreaterEqual:
                return gl.GEQUAL;
            case CompareFunction.Always:
                return gl.ALWAYS;
        }
    };
    return DepthState;
}();

/**
 * Raster state.
 */ var RasterState = /*#__PURE__*/ function() {
    function RasterState() {
        /** Specifies whether or not front- and/or back-facing polygons can be culled. */ this.cullMode = CullMode.Back;
        /** The multiplier by which an implementation-specific value is multiplied with to create a constant depth offset. */ this.depthBias = 0;
        /** The scale factor for the variable depth offset for each polygon. */ this.slopeScaledDepthBias = 0;
        /** @internal */ this._cullFaceEnable = true;
        /** @internal */ this._frontFaceInvert = false;
    }
    var _proto = RasterState.prototype;
    /**
   * @internal
   */ _proto._applyShaderDataValue = function _applyShaderDataValue(renderStateDataMap, shaderData) {
        var cullModeProperty = renderStateDataMap[RenderStateElementKey.RasterStateCullMode];
        if (cullModeProperty !== undefined) {
            var _shaderData_getFloat;
            this.cullMode = (_shaderData_getFloat = shaderData.getFloat(cullModeProperty)) != null ? _shaderData_getFloat : CullMode.Back;
        }
        var depthBiasProperty = renderStateDataMap[RenderStateElementKey.RasterStateDepthBias];
        if (depthBiasProperty !== undefined) {
            var _shaderData_getFloat1;
            this.depthBias = (_shaderData_getFloat1 = shaderData.getFloat(depthBiasProperty)) != null ? _shaderData_getFloat1 : 0;
        }
        var slopeScaledDepthBiasProperty = renderStateDataMap[RenderStateElementKey.RasterStateSlopeScaledDepthBias];
        if (slopeScaledDepthBiasProperty !== undefined) {
            var _shaderData_getFloat2;
            this.slopeScaledDepthBias = (_shaderData_getFloat2 = shaderData.getFloat(slopeScaledDepthBiasProperty)) != null ? _shaderData_getFloat2 : 0;
        }
    };
    /**
   * @internal
   */ _proto._apply = function _apply(hardwareRenderer, lastRenderState, frontFaceInvert, customStates) {
        this._platformApply(hardwareRenderer, lastRenderState.rasterState, frontFaceInvert, customStates);
    };
    _proto._platformApply = function _platformApply(rhi, lastState, frontFaceInvert, customStates) {
        var gl = rhi.gl;
        var _this = this, cullMode = _this.cullMode, depthBias = _this.depthBias, slopeScaledDepthBias = _this.slopeScaledDepthBias;
        if (customStates) {
            var cullModeState = customStates[RenderStateElementKey.RasterStateCullMode];
            cullModeState !== undefined && (cullMode = cullModeState);
        }
        var cullFaceEnable = cullMode !== CullMode.Off;
        if (cullFaceEnable !== lastState._cullFaceEnable) {
            if (cullFaceEnable) {
                gl.enable(gl.CULL_FACE);
            } else {
                gl.disable(gl.CULL_FACE);
            }
            lastState._cullFaceEnable = cullFaceEnable;
        }
        // apply front face.
        if (cullFaceEnable) {
            if (cullMode !== lastState.cullMode) {
                if (cullMode == CullMode.Back) {
                    gl.cullFace(gl.BACK);
                } else {
                    gl.cullFace(gl.FRONT);
                }
                lastState.cullMode = cullMode;
            }
        }
        if (frontFaceInvert !== lastState._frontFaceInvert) {
            if (frontFaceInvert) {
                gl.frontFace(gl.CW);
            } else {
                gl.frontFace(gl.CCW);
            }
            lastState._frontFaceInvert = frontFaceInvert;
        }
        // apply polygonOffset.
        if (!rhi._enableGlobalDepthBias) {
            if (depthBias !== lastState.depthBias || slopeScaledDepthBias !== lastState.slopeScaledDepthBias) {
                if (depthBias !== 0 || slopeScaledDepthBias !== 0) {
                    gl.enable(gl.POLYGON_OFFSET_FILL);
                    gl.polygonOffset(slopeScaledDepthBias, depthBias);
                } else {
                    gl.disable(gl.POLYGON_OFFSET_FILL);
                }
                lastState.depthBias = depthBias;
                lastState.slopeScaledDepthBias = slopeScaledDepthBias;
            }
        }
    };
    return RasterState;
}();

/**
 * Stencil state.
 */ var StencilState = /*#__PURE__*/ function() {
    function StencilState() {
        /** Whether to enable stencil test. */ this.enabled = false;
        /** Write the reference value of the stencil buffer. */ this.referenceValue = 0;
        /** Specifying a bit-wise mask that is used to AND the reference value and the stored stencil value when the test is done. */ this.mask = 0xff;
        /** Specifying a bit mask to enable or disable writing of individual bits in the stencil planes. */ this.writeMask = 0xff;
        /** The comparison function of the reference value of the front face of the geometry and the current buffer storage value. */ this.compareFunctionFront = CompareFunction.Always;
        /** The comparison function of the reference value of the back of the geometry and the current buffer storage value. */ this.compareFunctionBack = CompareFunction.Always;
        /** specifying the function to use for front face when both the stencil test and the depth test pass. */ this.passOperationFront = StencilOperation.Keep;
        /** specifying the function to use for back face when both the stencil test and the depth test pass. */ this.passOperationBack = StencilOperation.Keep;
        /** specifying the function to use for front face when the stencil test fails. */ this.failOperationFront = StencilOperation.Keep;
        /** specifying the function to use for back face when the stencil test fails. */ this.failOperationBack = StencilOperation.Keep;
        /** specifying the function to use for front face when the stencil test passes, but the depth test fails. */ this.zFailOperationFront = StencilOperation.Keep;
        /** specifying the function to use for back face when the stencil test passes, but the depth test fails. */ this.zFailOperationBack = StencilOperation.Keep;
    }
    var _proto = StencilState.prototype;
    /**
   * @internal
   */ _proto._applyShaderDataValue = function _applyShaderDataValue(renderStateDataMap, shaderData) {
        var enableProperty = renderStateDataMap[RenderStateElementKey.StencilStateEnabled];
        if (enableProperty !== undefined) {
            var enabled = shaderData.getFloat(enableProperty);
            this.enabled = enabled !== undefined ? !!enabled : false;
        }
        var referenceValueProperty = renderStateDataMap[RenderStateElementKey.StencilStateReferenceValue];
        if (referenceValueProperty !== undefined) {
            var _shaderData_getFloat;
            this.referenceValue = (_shaderData_getFloat = shaderData.getFloat(referenceValueProperty)) != null ? _shaderData_getFloat : 0;
        }
        var maskProperty = renderStateDataMap[RenderStateElementKey.StencilStateMask];
        if (maskProperty !== undefined) {
            var _shaderData_getFloat1;
            this.mask = (_shaderData_getFloat1 = shaderData.getFloat(maskProperty)) != null ? _shaderData_getFloat1 : 0xff;
        }
        var writeMaskProperty = renderStateDataMap[RenderStateElementKey.StencilStateWriteMask];
        if (writeMaskProperty !== undefined) {
            var _shaderData_getFloat2;
            this.writeMask = (_shaderData_getFloat2 = shaderData.getFloat(writeMaskProperty)) != null ? _shaderData_getFloat2 : 0xff;
        }
        var compareFunctionFrontProperty = renderStateDataMap[RenderStateElementKey.StencilStateCompareFunctionFront];
        if (compareFunctionFrontProperty !== undefined) {
            var _shaderData_getFloat3;
            this.compareFunctionFront = (_shaderData_getFloat3 = shaderData.getFloat(compareFunctionFrontProperty)) != null ? _shaderData_getFloat3 : CompareFunction.Always;
        }
        var compareFunctionBackProperty = renderStateDataMap[RenderStateElementKey.StencilStateCompareFunctionBack];
        if (compareFunctionBackProperty !== undefined) {
            var _shaderData_getFloat4;
            this.compareFunctionBack = (_shaderData_getFloat4 = shaderData.getFloat(compareFunctionBackProperty)) != null ? _shaderData_getFloat4 : CompareFunction.Always;
        }
        var passOperationFrontProperty = renderStateDataMap[RenderStateElementKey.StencilStatePassOperationFront];
        if (passOperationFrontProperty !== undefined) {
            var _shaderData_getFloat5;
            this.passOperationFront = (_shaderData_getFloat5 = shaderData.getFloat(passOperationFrontProperty)) != null ? _shaderData_getFloat5 : StencilOperation.Keep;
        }
        var passOperationBackProperty = renderStateDataMap[RenderStateElementKey.StencilStatePassOperationBack];
        if (passOperationBackProperty !== undefined) {
            var _shaderData_getFloat6;
            this.passOperationBack = (_shaderData_getFloat6 = shaderData.getFloat(passOperationBackProperty)) != null ? _shaderData_getFloat6 : StencilOperation.Keep;
        }
        var failOperationFrontProperty = renderStateDataMap[RenderStateElementKey.StencilStateFailOperationFront];
        if (failOperationFrontProperty !== undefined) {
            var _shaderData_getFloat7;
            this.failOperationFront = (_shaderData_getFloat7 = shaderData.getFloat(failOperationFrontProperty)) != null ? _shaderData_getFloat7 : StencilOperation.Keep;
        }
        var failOperationBackProperty = renderStateDataMap[RenderStateElementKey.StencilStateFailOperationBack];
        if (failOperationBackProperty !== undefined) {
            var _shaderData_getFloat8;
            this.failOperationBack = (_shaderData_getFloat8 = shaderData.getFloat(failOperationBackProperty)) != null ? _shaderData_getFloat8 : StencilOperation.Keep;
        }
        var zFailOperationFrontProperty = renderStateDataMap[RenderStateElementKey.StencilStateZFailOperationFront];
        if (zFailOperationFrontProperty !== undefined) {
            var _shaderData_getFloat9;
            this.zFailOperationFront = (_shaderData_getFloat9 = shaderData.getFloat(zFailOperationFrontProperty)) != null ? _shaderData_getFloat9 : StencilOperation.Keep;
        }
        var zFailOperationBackProperty = renderStateDataMap[RenderStateElementKey.StencilStateZFailOperationBack];
        if (zFailOperationBackProperty !== undefined) {
            var _shaderData_getFloat10;
            this.zFailOperationBack = (_shaderData_getFloat10 = shaderData.getFloat(zFailOperationBackProperty)) != null ? _shaderData_getFloat10 : StencilOperation.Keep;
        }
    };
    /**
   * @internal
   */ _proto._apply = function _apply(hardwareRenderer, lastRenderState, customStates) {
        this._platformApply(hardwareRenderer, lastRenderState.stencilState, customStates);
    };
    _proto._platformApply = function _platformApply(rhi, lastState, customStates) {
        var gl = rhi.gl;
        var _this = this, enabled = _this.enabled, referenceValue = _this.referenceValue, mask = _this.mask, compareFunctionFront = _this.compareFunctionFront, compareFunctionBack = _this.compareFunctionBack, failOperationFront = _this.failOperationFront, zFailOperationFront = _this.zFailOperationFront, passOperationFront = _this.passOperationFront, failOperationBack = _this.failOperationBack, zFailOperationBack = _this.zFailOperationBack, passOperationBack = _this.passOperationBack, writeMask = _this.writeMask;
        if (customStates) {
            var enabledState = customStates[RenderStateElementKey.StencilStateEnabled];
            enabledState !== undefined && (enabled = enabledState);
            var writeMaskState = customStates[RenderStateElementKey.StencilStateWriteMask];
            writeMaskState !== undefined && (writeMask = writeMaskState);
            var referenceValueState = customStates[RenderStateElementKey.StencilStateReferenceValue];
            referenceValueState !== undefined && (referenceValue = referenceValueState);
            var compareFunctionFrontState = customStates[RenderStateElementKey.StencilStateCompareFunctionFront];
            compareFunctionFrontState !== undefined && (compareFunctionFront = compareFunctionFrontState);
            var compareFunctionBackState = customStates[RenderStateElementKey.StencilStateCompareFunctionBack];
            compareFunctionBackState !== undefined && (compareFunctionBack = compareFunctionBackState);
            var passOperationFrontState = customStates[RenderStateElementKey.StencilStatePassOperationFront];
            passOperationFrontState !== undefined && (passOperationFront = passOperationFrontState);
            var passOperationBackState = customStates[RenderStateElementKey.StencilStatePassOperationBack];
            passOperationBackState !== undefined && (passOperationBack = passOperationBackState);
            var failOperationFrontState = customStates[RenderStateElementKey.StencilStateFailOperationFront];
            failOperationFrontState !== undefined && (failOperationFront = failOperationFrontState);
            var failOperationBackState = customStates[RenderStateElementKey.StencilStateFailOperationBack];
            failOperationBackState !== undefined && (failOperationBack = failOperationBackState);
            var zFailOperationFrontState = customStates[RenderStateElementKey.StencilStateZFailOperationFront];
            zFailOperationFrontState !== undefined && (zFailOperationFront = zFailOperationFrontState);
            var zFailOperationBackState = customStates[RenderStateElementKey.StencilStateZFailOperationBack];
            zFailOperationBackState !== undefined && (zFailOperationBack = zFailOperationBackState);
        }
        if (enabled != lastState.enabled) {
            if (enabled) {
                gl.enable(gl.STENCIL_TEST);
            } else {
                gl.disable(gl.STENCIL_TEST);
            }
            lastState.enabled = enabled;
        }
        if (enabled) {
            // apply stencil func.
            var referenceOrMaskChange = referenceValue !== lastState.referenceValue || mask !== lastState.mask;
            if (referenceOrMaskChange || compareFunctionFront !== lastState.compareFunctionFront) {
                gl.stencilFuncSeparate(gl.FRONT, StencilState._getGLCompareFunction(rhi, compareFunctionFront), referenceValue, mask);
                lastState.compareFunctionFront = compareFunctionFront;
            }
            if (referenceOrMaskChange || compareFunctionBack !== lastState.compareFunctionBack) {
                gl.stencilFuncSeparate(gl.BACK, StencilState._getGLCompareFunction(rhi, compareFunctionBack), referenceValue, mask);
                lastState.compareFunctionBack = compareFunctionBack;
            }
            if (referenceOrMaskChange) {
                lastState.referenceValue = referenceValue;
                lastState.mask = mask;
            }
            // apply stencil operation.
            if (failOperationFront !== lastState.failOperationFront || zFailOperationFront !== lastState.zFailOperationFront || passOperationFront !== lastState.passOperationFront) {
                gl.stencilOpSeparate(gl.FRONT, StencilState._getGLStencilOperation(rhi, failOperationFront), StencilState._getGLStencilOperation(rhi, zFailOperationFront), StencilState._getGLStencilOperation(rhi, passOperationFront));
                lastState.failOperationFront = failOperationFront;
                lastState.zFailOperationFront = zFailOperationFront;
                lastState.passOperationFront = passOperationFront;
            }
            if (failOperationBack !== lastState.failOperationBack || zFailOperationBack !== lastState.zFailOperationBack || passOperationBack !== lastState.passOperationBack) {
                gl.stencilOpSeparate(gl.BACK, StencilState._getGLStencilOperation(rhi, failOperationBack), StencilState._getGLStencilOperation(rhi, zFailOperationBack), StencilState._getGLStencilOperation(rhi, passOperationBack));
                lastState.failOperationBack = failOperationBack;
                lastState.zFailOperationBack = zFailOperationBack;
                lastState.passOperationBack = passOperationBack;
            }
            // apply write mask.
            if (writeMask !== lastState.writeMask) {
                gl.stencilMask(writeMask);
                lastState.writeMask = writeMask;
            }
        }
    };
    StencilState._getGLCompareFunction = function _getGLCompareFunction(rhi, compareFunction) {
        var gl = rhi.gl;
        switch(compareFunction){
            case CompareFunction.Never:
                return gl.NEVER;
            case CompareFunction.Less:
                return gl.LESS;
            case CompareFunction.Equal:
                return gl.EQUAL;
            case CompareFunction.LessEqual:
                return gl.LEQUAL;
            case CompareFunction.Greater:
                return gl.GREATER;
            case CompareFunction.NotEqual:
                return gl.NOTEQUAL;
            case CompareFunction.GreaterEqual:
                return gl.GEQUAL;
            case CompareFunction.Always:
                return gl.ALWAYS;
        }
    };
    StencilState._getGLStencilOperation = function _getGLStencilOperation(rhi, compareFunction) {
        var gl = rhi.gl;
        switch(compareFunction){
            case StencilOperation.Keep:
                return gl.KEEP;
            case StencilOperation.Zero:
                return gl.ZERO;
            case StencilOperation.Replace:
                return gl.REPLACE;
            case StencilOperation.IncrementSaturate:
                return gl.INCR;
            case StencilOperation.DecrementSaturate:
                return gl.DECR;
            case StencilOperation.Invert:
                return gl.INVERT;
            case StencilOperation.IncrementWrap:
                return gl.INCR_WRAP;
            case StencilOperation.DecrementWrap:
                return gl.DECR_WRAP;
        }
    };
    return StencilState;
}();

/**
 * Render state.
 */ var RenderState = /*#__PURE__*/ function() {
    function RenderState() {
        /** Blend state. */ this.blendState = new BlendState();
        /** Depth state. */ this.depthState = new DepthState();
        /** Stencil state. */ this.stencilState = new StencilState();
        /** Raster state. */ this.rasterState = new RasterState();
        /** Render queue type. */ this.renderQueueType = RenderQueueType.Opaque;
    }
    var _proto = RenderState.prototype;
    /**
   * @internal
   */ _proto._applyStates = function _applyStates(engine, frontFaceInvert, renderStateDataMap, shaderData, customRenderStates) {
        // @todo: Should merge when we can delete material render state
        renderStateDataMap && this._applyStatesByShaderData(renderStateDataMap, shaderData);
        var hardwareRenderer = engine._hardwareRenderer;
        var lastRenderState = engine._lastRenderState;
        var context = engine._renderContext;
        this.blendState._apply(hardwareRenderer, lastRenderState, customRenderStates);
        this.depthState._apply(hardwareRenderer, lastRenderState, customRenderStates);
        this.stencilState._apply(hardwareRenderer, lastRenderState, customRenderStates);
        this.rasterState._apply(hardwareRenderer, lastRenderState, context.flipProjection ? !frontFaceInvert : frontFaceInvert, customRenderStates);
    };
    /**
   * @internal
   * @todo Should merge when we can delete material render state
   */ _proto._getRenderQueueByShaderData = function _getRenderQueueByShaderData(renderStateDataMap, shaderData) {
        var renderQueueType = renderStateDataMap[RenderStateElementKey.RenderQueueType];
        if (renderQueueType === undefined) {
            return this.renderQueueType;
        } else {
            var _shaderData_getFloat;
            return (_shaderData_getFloat = shaderData.getFloat(renderQueueType)) != null ? _shaderData_getFloat : RenderQueueType.Opaque;
        }
    };
    _proto._applyStatesByShaderData = function _applyStatesByShaderData(renderStateDataMap, shaderData) {
        this.blendState._applyShaderDataValue(renderStateDataMap, shaderData);
        this.depthState._applyShaderDataValue(renderStateDataMap, shaderData);
        this.stencilState._applyShaderDataValue(renderStateDataMap, shaderData);
        this.rasterState._applyShaderDataValue(renderStateDataMap, shaderData);
    };
    return RenderState;
}();
__decorate$1([
    deepClone
], RenderState.prototype, "blendState", void 0);
__decorate$1([
    deepClone
], RenderState.prototype, "depthState", void 0);
__decorate$1([
    deepClone
], RenderState.prototype, "stencilState", void 0);
__decorate$1([
    deepClone
], RenderState.prototype, "rasterState", void 0);

/**
 * Shader for rendering.
 */ var Shader = /*#__PURE__*/ function() {
    function Shader(name, subShaders) {
        this.name = name;
        this._refCount = 0;
        this._destroyed = false;
        this.name = name;
        this._subShaders = subShaders;
    }
    var _proto = Shader.prototype;
    /**
   * @internal
   * path should follow the specifications of [URL.origin](https://developer.mozilla.org/en-US/docs/Web/API/URL/origin), like: `shaders://root/`
   */ _proto._registerPath = function _registerPath(path) {
        for(var _iterator = _create_for_of_iterator_helper_loose$1(this._subShaders), _step; !(_step = _iterator()).done;){
            var subShader = _step.value;
            for(var _iterator1 = _create_for_of_iterator_helper_loose$1(subShader.passes), _step1; !(_step1 = _iterator1()).done;){
                var shaderPass = _step1.value;
                shaderPass._path = path;
            }
        }
    };
    /**
   * Compile shader variant by macro name list.
   *
   * @remarks
   * Usually a shader contains some macros,any combination of macros is called shader variant.
   *
   * @param engine - Engine to which the shader variant belongs
   * @param macros - Macro name list
   * @returns Is the compiled shader variant valid
   */ _proto.compileVariant = function compileVariant(engine, macros) {
        var compileMacros = Shader._compileMacros;
        compileMacros.clear();
        for(var i = 0, n = macros.length; i < n; i++){
            compileMacros.enable(ShaderMacro.getByName(macros[i]));
        }
        var isValid = false;
        var subShaders = this._subShaders;
        for(var i1 = 0, n1 = subShaders.length; i1 < n1; i1++){
            var passes = subShaders[i1].passes;
            for(var j = 0, m = passes.length; j < m; j++){
                var shaderProgram = passes[j]._getShaderProgram(engine, compileMacros);
                isValid = j === 0 ? shaderProgram.isValid : isValid && shaderProgram.isValid;
            }
        }
        return isValid;
    };
    /**
   * Destroy the shader.
   * @param force - Whether to force the destruction, if it is false, refCount = 0 can be released successfully.
   * @returns Whether the release was successful.
   */ _proto.destroy = function destroy(force) {
        if (force === void 0) force = false;
        if (!force && this._refCount !== 0) {
            return false;
        }
        var subShaders = this._subShaders;
        for(var i = 0, n = subShaders.length; i < n; i++){
            var passes = subShaders[i].passes;
            for(var j = 0, m = passes.length; j < m; j++){
                passes[j]._destroy();
            }
        }
        delete Shader._shaderMap[this.name];
        this._destroyed = true;
        return true;
    };
    /**
   * @internal
   */ _proto._getReferCount = function _getReferCount() {
        return this._refCount;
    };
    /**
   * @internal
   */ _proto._addReferCount = function _addReferCount(value) {
        this._refCount += value;
    };
    Shader.create = function create(nameOrShaderSource, vertexSourceOrShaderPassesOrSubShaders, fragmentSource) {
        var shader;
        var shaderMap = Shader._shaderMap;
        if (!vertexSourceOrShaderPassesOrSubShaders) {
            if (!Shader._shaderLab) {
                throw "ShaderLab has not been set up yet.";
            }
            var shaderContent = Shader._shaderLab._parseShaderContent(nameOrShaderSource);
            if (shaderMap[shaderContent.name]) {
                console.error('Shader named "' + shaderContent.name + '" already exists.');
                return;
            }
            var subShaderList = shaderContent.subShaders.map(function(subShaderContent) {
                var passList = subShaderContent.passes.map(function(passInfo) {
                    if (passInfo.isUsePass) {
                        var _Shader_find_subShaders_find, _Shader_find;
                        // Use pass reference
                        var paths = passInfo.name.split("/");
                        return (_Shader_find = Shader.find(paths[0])) == null ? void 0 : (_Shader_find_subShaders_find = _Shader_find.subShaders.find(function(subShader) {
                            return subShader.name === paths[1];
                        })) == null ? void 0 : _Shader_find_subShaders_find.passes.find(function(pass) {
                            return pass.name === paths[2];
                        });
                    }
                    var shaderPassContent = new ShaderPass(passInfo.name, passInfo.contents, passInfo.vertexEntry, passInfo.fragmentEntry, passInfo.tags);
                    var _passInfo_renderStates = passInfo.renderStates, constantMap = _passInfo_renderStates.constantMap, variableMap = _passInfo_renderStates.variableMap;
                    // Compatible shader lab no render state use material `renderState` to modify render state
                    if (Object.keys(constantMap).length > 0 || Object.keys(variableMap).length > 0) {
                        // Parse const render state
                        var renderState = new RenderState();
                        shaderPassContent._renderState = renderState;
                        for(var k in constantMap){
                            Shader._applyConstRenderStates(renderState, parseInt(k), constantMap[k]);
                        }
                        // Parse variable render state
                        var renderStateDataMap = {};
                        for(var k1 in variableMap){
                            renderStateDataMap[k1] = ShaderProperty.getByName(variableMap[k1]);
                        }
                        shaderPassContent._renderStateDataMap = renderStateDataMap;
                    }
                    return shaderPassContent;
                });
                return new SubShader(subShaderContent.name, passList, subShaderContent.tags);
            });
            shader = new Shader(shaderContent.name, subShaderList);
            shaderMap[shaderContent.name] = shader;
            return shader;
        } else {
            if (shaderMap[nameOrShaderSource]) {
                console.error('Shader named "' + nameOrShaderSource + '" already exists.');
                return;
            }
            if (typeof vertexSourceOrShaderPassesOrSubShaders === "string") {
                var shaderPass = new ShaderPass(vertexSourceOrShaderPassesOrSubShaders, fragmentSource);
                shader = new Shader(nameOrShaderSource, [
                    new SubShader("Default", [
                        shaderPass
                    ])
                ]);
            } else {
                if (vertexSourceOrShaderPassesOrSubShaders.length > 0) {
                    if (vertexSourceOrShaderPassesOrSubShaders[0].constructor === ShaderPass) {
                        shader = new Shader(nameOrShaderSource, [
                            new SubShader("Default", vertexSourceOrShaderPassesOrSubShaders)
                        ]);
                    } else {
                        shader = new Shader(nameOrShaderSource, vertexSourceOrShaderPassesOrSubShaders.slice());
                    }
                } else {
                    throw "SubShader or ShaderPass count must large than 0.";
                }
            }
        }
        shaderMap[nameOrShaderSource] = shader;
        return shader;
    };
    /**
   * Find a shader by name.
   * @param name - Name of the shader
   */ Shader.find = function find(name) {
        return Shader._shaderMap[name];
    };
    /**
   * @internal
   */ Shader._clear = function _clear(engine) {
        var shaderMap = Shader._shaderMap;
        for(var key in shaderMap){
            var shader = shaderMap[key];
            var subShaders = shader._subShaders;
            for(var i = 0, n = subShaders.length; i < n; i++){
                var passes = subShaders[i].passes;
                for(var j = 0, m = passes.length; j < m; j++){
                    var pass = passes[j];
                    var passShaderProgramPools = pass._shaderProgramPools;
                    for(var k = passShaderProgramPools.length - 1; k >= 0; k--){
                        var shaderProgramPool = passShaderProgramPools[k];
                        if (shaderProgramPool.engine !== engine) continue;
                        shaderProgramPool._destroy();
                        passShaderProgramPools.splice(k, 1);
                    }
                }
            }
        }
    };
    Shader._applyConstRenderStates = function _applyConstRenderStates(renderState, key, value) {
        switch(key){
            case RenderStateElementKey.BlendStateEnabled0:
                renderState.blendState.targetBlendState.enabled = value;
                break;
            case RenderStateElementKey.BlendStateColorBlendOperation0:
                renderState.blendState.targetBlendState.colorBlendOperation = value;
                break;
            case RenderStateElementKey.BlendStateAlphaBlendOperation0:
                renderState.blendState.targetBlendState.alphaBlendOperation = value;
                break;
            case RenderStateElementKey.BlendStateSourceColorBlendFactor0:
                renderState.blendState.targetBlendState.sourceColorBlendFactor = value;
                break;
            case RenderStateElementKey.BlendStateDestinationColorBlendFactor0:
                renderState.blendState.targetBlendState.destinationColorBlendFactor = value;
                break;
            case RenderStateElementKey.BlendStateSourceAlphaBlendFactor0:
                renderState.blendState.targetBlendState.sourceAlphaBlendFactor = value;
                break;
            case RenderStateElementKey.BlendStateDestinationAlphaBlendFactor0:
                renderState.blendState.targetBlendState.destinationAlphaBlendFactor = value;
                break;
            case RenderStateElementKey.BlendStateColorWriteMask0:
                renderState.blendState.targetBlendState.colorWriteMask = value;
                break;
            case RenderStateElementKey.DepthStateEnabled:
                renderState.depthState.enabled = value;
                break;
            case RenderStateElementKey.DepthStateWriteEnabled:
                renderState.depthState.writeEnabled = value;
                break;
            case RenderStateElementKey.DepthStateCompareFunction:
                renderState.depthState.compareFunction = value;
                break;
            case RenderStateElementKey.StencilStateEnabled:
                renderState.stencilState.enabled = value;
                break;
            case RenderStateElementKey.StencilStateReferenceValue:
                renderState.stencilState.referenceValue = value;
                break;
            case RenderStateElementKey.StencilStateMask:
                renderState.stencilState.mask = value;
                break;
            case RenderStateElementKey.StencilStateWriteMask:
                renderState.stencilState.writeMask = value;
                break;
            case RenderStateElementKey.StencilStateCompareFunctionFront:
                renderState.stencilState.compareFunctionFront = value;
                break;
            case RenderStateElementKey.StencilStateCompareFunctionBack:
                renderState.stencilState.compareFunctionBack = value;
                break;
            case RenderStateElementKey.StencilStatePassOperationFront:
                renderState.stencilState.passOperationFront = value;
                break;
            case RenderStateElementKey.StencilStatePassOperationBack:
                renderState.stencilState.passOperationBack = value;
                break;
            case RenderStateElementKey.StencilStateFailOperationFront:
                renderState.stencilState.failOperationFront = value;
                break;
            case RenderStateElementKey.StencilStateFailOperationBack:
                renderState.stencilState.failOperationBack = value;
                break;
            case RenderStateElementKey.StencilStateZFailOperationFront:
                renderState.stencilState.zFailOperationFront = value;
                break;
            case RenderStateElementKey.StencilStateZFailOperationBack:
                renderState.stencilState.zFailOperationBack = value;
                break;
            case RenderStateElementKey.RasterStateCullMode:
                renderState.rasterState.cullMode = value;
                break;
            case RenderStateElementKey.RasterStateDepthBias:
                renderState.rasterState.depthBias = value;
                break;
            case RenderStateElementKey.RasterStateSlopeScaledDepthBias:
                renderState.rasterState.slopeScaledDepthBias = value;
                break;
            case RenderStateElementKey.RenderQueueType:
                renderState.renderQueueType = value;
                break;
        }
    };
    Shader.getMacroByName = function getMacroByName(name, value) {
        return ShaderMacro.getByName(name, value);
    };
    /**
   * @deprecated Please use `ShaderProperty.getByName` instead
   *
   * Get shader property by name.
   * @param name - Name of the shader property
   * @returns Shader property
   */ Shader.getPropertyByName = function getPropertyByName(name) {
        return ShaderProperty.getByName(name);
    };
    _create_class$2(Shader, [
        {
            key: "subShaders",
            get: /**
   * Sub shaders of the shader.
   */ function get() {
                return this._subShaders;
            }
        },
        {
            key: "destroyed",
            get: /**
   * Whether it has been destroyed.
   */ function get() {
                return this._destroyed;
            }
        }
    ]);
    return Shader;
}();
/** @internal */ Shader._compileMacros = new ShaderMacroCollection();
Shader._shaderMap = Object.create(null);

/**
 * Shader data collection,Correspondence includes shader properties data and macros data.
 */ var ShaderData = /*#__PURE__*/ function() {
    function ShaderData(group) {
        /** @internal */ this._propertyValueMap = Object.create(null);
        /** @internal */ this._macroCollection = new ShaderMacroCollection();
        this._macroMap = Object.create(null);
        this._refCount = 0;
        this._group = group;
    }
    var _proto = ShaderData.prototype;
    _proto.getFloat = function getFloat(property) {
        return this.getPropertyValue(property);
    };
    _proto.setFloat = function setFloat(property, value) {
        this._setPropertyValue(property, ShaderPropertyType.Float, value);
    };
    _proto.getInt = function getInt(property) {
        return this.getPropertyValue(property);
    };
    _proto.setInt = function setInt(property, value) {
        this._setPropertyValue(property, ShaderPropertyType.Int, value);
    };
    _proto.getFloatArray = function getFloatArray(property) {
        return this.getPropertyValue(property);
    };
    _proto.setFloatArray = function setFloatArray(property, value) {
        this._setPropertyValue(property, ShaderPropertyType.FloatArray, value);
    };
    _proto.getIntArray = function getIntArray(property) {
        return this.getPropertyValue(property);
    };
    _proto.setIntArray = function setIntArray(property, value) {
        this._setPropertyValue(property, ShaderPropertyType.IntArray, value);
    };
    _proto.getVector2 = function getVector2(property) {
        return this.getPropertyValue(property);
    };
    _proto.setVector2 = function setVector2(property, value) {
        this._setPropertyValue(property, ShaderPropertyType.Vector2, value);
    };
    _proto.getVector3 = function getVector3(property) {
        return this.getPropertyValue(property);
    };
    _proto.setVector3 = function setVector3(property, value) {
        this._setPropertyValue(property, ShaderPropertyType.Vector3, value);
    };
    _proto.getVector4 = function getVector4(property) {
        return this.getPropertyValue(property);
    };
    _proto.setVector4 = function setVector4(property, value) {
        this._setPropertyValue(property, ShaderPropertyType.Vector4, value);
    };
    _proto.getMatrix = function getMatrix(property) {
        return this.getPropertyValue(property);
    };
    _proto.setMatrix = function setMatrix(property, value) {
        this._setPropertyValue(property, ShaderPropertyType.Matrix, value);
    };
    _proto.getColor = function getColor(property) {
        return this.getPropertyValue(property);
    };
    _proto.setColor = function setColor(property, value) {
        this._setPropertyValue(property, ShaderPropertyType.Color, value);
    };
    _proto.getTexture = function getTexture(property) {
        return this.getPropertyValue(property);
    };
    _proto.setTexture = function setTexture(property, value) {
        var refCount = this._refCount;
        if (refCount > 0) {
            var lastValue = this.getPropertyValue(property);
            lastValue && lastValue._addReferCount(-refCount);
            value && value._addReferCount(refCount);
        }
        this._setPropertyValue(property, ShaderPropertyType.Texture, value);
    };
    _proto.getTextureArray = function getTextureArray(property) {
        return this.getPropertyValue(property);
    };
    _proto.setTextureArray = function setTextureArray(property, value) {
        var refCount = this._refCount;
        if (refCount > 0) {
            var lastValue = this.getPropertyValue(property);
            if (lastValue) {
                for(var i = 0, n = lastValue.length; i < n; i++){
                    lastValue[i]._addReferCount(-refCount);
                }
            }
            if (value) {
                for(var i1 = 0, n1 = value.length; i1 < n1; i1++){
                    value[i1]._addReferCount(refCount);
                }
            }
        }
        this._setPropertyValue(property, ShaderPropertyType.TextureArray, value);
    };
    /**
   * Get shader property value set on this shaderData.
   * @param property - Shader property
   * @returns Property value
   */ _proto.getPropertyValue = function getPropertyValue(property) {
        if (typeof property === "string") {
            property = ShaderProperty.getByName(property);
        }
        return this._propertyValueMap[property._uniqueId];
    };
    _proto.enableMacro = function enableMacro(macro, value) {
        if (typeof macro === "string") {
            macro = ShaderMacro.getByName(macro, value);
        }
        var nameID = macro._nameId;
        var lastMacro = this._macroMap[nameID];
        if (lastMacro !== macro) {
            var macroCollection = this._macroCollection;
            lastMacro && macroCollection.disable(lastMacro);
            macroCollection.enable(macro);
            this._macroMap[nameID] = macro;
        }
    };
    _proto.disableMacro = function disableMacro(macro) {
        var nameID;
        if (typeof macro === "string") {
            nameID = ShaderMacro._macroNameIdMap[macro];
            if (nameID === undefined) {
                return;
            }
        } else {
            nameID = macro._nameId;
        }
        var currentMacro = this._macroMap[nameID];
        if (currentMacro) {
            this._macroCollection.disable(currentMacro);
            delete this._macroMap[nameID];
        }
    };
    _proto.getMacros = function getMacros(out) {
        if (out) {
            var macroMap = this._macroMap;
            out.length = 0;
            for(var key in macroMap){
                out.push(macroMap[key]);
            }
        } else {
            return Object.values(this._macroMap);
        }
    };
    _proto.getProperties = function getProperties(out) {
        var properties;
        if (out) {
            out.length = 0;
            properties = out;
        } else {
            properties = [];
        }
        var propertyValueMap = this._propertyValueMap;
        var propertyIdMap = ShaderProperty._propertyIdMap;
        for(var key in propertyValueMap){
            properties.push(propertyIdMap[key]);
        }
        if (!out) {
            return properties;
        }
    };
    _proto.clone = function clone() {
        var shaderData = new ShaderData(this._group);
        this.cloneTo(shaderData);
        return shaderData;
    };
    _proto.cloneTo = function cloneTo(target) {
        CloneManager.deepCloneObject(this._macroCollection, target._macroCollection, new Map());
        Object.assign(target._macroMap, this._macroMap);
        var referCount = target._getReferCount();
        var propertyValueMap = this._propertyValueMap;
        var targetPropertyValueMap = target._propertyValueMap;
        var keys = Object.keys(propertyValueMap);
        for(var i = 0, n = keys.length; i < n; i++){
            var k = keys[i];
            var property = propertyValueMap[k];
            if (property != null) {
                if (typeof property === "number") {
                    targetPropertyValueMap[k] = property;
                } else if (_instanceof$3(property, Texture)) {
                    targetPropertyValueMap[k] = property;
                    referCount > 0 && property._addReferCount(referCount);
                } else if (_instanceof$3(property, Array) || _instanceof$3(property, Float32Array) || _instanceof$3(property, Int32Array)) {
                    targetPropertyValueMap[k] = property.slice();
                } else {
                    var targetProperty = targetPropertyValueMap[k];
                    if (targetProperty) {
                        targetProperty.copyFrom(property);
                    } else {
                        targetPropertyValueMap[k] = property.clone();
                    }
                }
            } else {
                targetPropertyValueMap[k] = property;
            }
        }
    };
    /**
   * @internal
   */ _proto._setPropertyValue = function _setPropertyValue(property, type, value) {
        if (typeof property === "string") {
            property = ShaderProperty.getByName(property);
        }
        if (property._group !== this._group) {
            if (property._group === undefined) {
                property._group = this._group;
            } else {
                throw "Shader property " + property.name + " has been used as " + ShaderDataGroup[property._group] + " group.";
            }
        }
        if (property._type !== type) {
            if (property._type === undefined) {
                property._type = type;
            } else {
                throw "Shader property " + property.name + " has been used as " + ShaderPropertyType[property._type] + " type.";
            }
        }
        this._propertyValueMap[property._uniqueId] = value;
    };
    /**
   * @internal
   */ _proto._getReferCount = function _getReferCount() {
        return this._refCount;
    };
    /**
   * @internal
   */ _proto._addReferCount = function _addReferCount(value) {
        this._refCount += value;
        var properties = this._propertyValueMap;
        for(var k in properties){
            var property = properties[k];
            // @todo: Separate array to speed performance.
            if (property && _instanceof$3(property, Texture)) {
                property._addReferCount(value);
            }
        }
    };
    return ShaderData;
}();
__decorate$1([
    ignoreClone
], ShaderData.prototype, "_group", void 0);
__decorate$1([
    ignoreClone
], ShaderData.prototype, "_propertyValueMap", void 0);
__decorate$1([
    ignoreClone
], ShaderData.prototype, "_macroCollection", void 0);
__decorate$1([
    ignoreClone
], ShaderData.prototype, "_macroMap", void 0);
__decorate$1([
    ignoreClone
], ShaderData.prototype, "_refCount", void 0);

/**
 * @internal
 */ var RenderContext = /*#__PURE__*/ function() {
    function RenderContext() {
        this._projectionParams = new Vector4();
        this.flipProjection = false;
        this.rendererUpdateFlag = 0;
    }
    var _proto = RenderContext.prototype;
    _proto.applyVirtualCamera = function applyVirtualCamera(virtualCamera, flipProjection) {
        this.virtualCamera = virtualCamera;
        this.flipProjection = flipProjection;
        var shaderData = this.camera.shaderData;
        var viewMatrix = virtualCamera.viewMatrix, projectionMatrix = virtualCamera.projectionMatrix, viewProjectionMatrix = virtualCamera.viewProjectionMatrix;
        if (flipProjection) {
            Matrix.multiply(RenderContext._flipYMatrix, projectionMatrix, RenderContext._flipYProjectionMatrix);
            Matrix.multiply(RenderContext._flipYProjectionMatrix, viewMatrix, RenderContext._flipYViewProjectionMatrix);
            projectionMatrix = RenderContext._flipYProjectionMatrix;
            viewProjectionMatrix = RenderContext._flipYViewProjectionMatrix;
        }
        this.viewMatrix = viewMatrix;
        this.projectionMatrix = projectionMatrix;
        this.viewProjectionMatrix = viewProjectionMatrix;
        shaderData.setMatrix(RenderContext._viewMatrixProperty, viewMatrix);
        shaderData.setMatrix(RenderContext._projectionMatrixProperty, projectionMatrix);
        shaderData.setMatrix(RenderContext.vpMatrixProperty, viewProjectionMatrix);
        var projectionParams = this._projectionParams;
        projectionParams.set(flipProjection ? -1 : 1, virtualCamera.nearClipPlane, virtualCamera.farClipPlane, 0);
        shaderData.setVector4(RenderContext._cameraProjectionProperty, projectionParams);
    };
    _proto.setRenderTarget = function setRenderTarget(destination, viewport, mipLevel, faceIndex) {
        var engine = this.camera.engine;
        var rhi = engine._hardwareRenderer;
        rhi.activeRenderTarget(destination, viewport, this.flipProjection, mipLevel, faceIndex);
        if (destination) {
            engine._macroCollection.disable(Engine._outputSRGBCorrectMacro);
        } else {
            engine._macroCollection.enable(Engine._outputSRGBCorrectMacro);
        }
    };
    _proto.garbageCollection = function garbageCollection() {
        this.camera = null;
    };
    return RenderContext;
}();
RenderContext.vpMatrixProperty = ShaderProperty.getByName("camera_VPMat");
RenderContext.pipelineStageKey = ShaderTagKey.getByName("pipelineStage");
/** @internal */ RenderContext._flipYMatrix = new Matrix(1, 0, 0, 0, 0, -1);
RenderContext._cameraProjectionProperty = ShaderProperty.getByName("camera_ProjectionParams");
RenderContext._viewMatrixProperty = ShaderProperty.getByName("camera_ViewMat");
RenderContext._projectionMatrixProperty = ShaderProperty.getByName("camera_ProjMat");
RenderContext._flipYProjectionMatrix = new Matrix();
RenderContext._flipYViewProjectionMatrix = new Matrix();
/**
 * @internal
 */ var ContextRendererUpdateFlag = /*#__PURE__*/ function(ContextRendererUpdateFlag) {
    ContextRendererUpdateFlag[ContextRendererUpdateFlag["None"] = 0] = "None";
    ContextRendererUpdateFlag[ContextRendererUpdateFlag["WorldMatrix"] = 1] = "WorldMatrix";
    ContextRendererUpdateFlag[ContextRendererUpdateFlag["viewMatrix"] = 2] = "viewMatrix";
    ContextRendererUpdateFlag[ContextRendererUpdateFlag["ProjectionMatrix"] = 4] = "ProjectionMatrix";
    ContextRendererUpdateFlag[ContextRendererUpdateFlag["WorldViewMatrix"] = 3] = "WorldViewMatrix";
    ContextRendererUpdateFlag[ContextRendererUpdateFlag["viewProjectionMatrix"] = 6] = "viewProjectionMatrix";
    ContextRendererUpdateFlag[ContextRendererUpdateFlag["All"] = 7] = "All";
    return ContextRendererUpdateFlag;
}({});

/**
 * Sky.
 */ var Sky = /*#__PURE__*/ function() {
    function Sky() {}
    var _proto = Sky.prototype;
    /**
   * @internal
   */ _proto.destroy = function destroy() {
        this.mesh = null;
        this.material = null;
    };
    /**
   * @internal
   */ _proto._render = function _render(context) {
        var _this = this, material = _this.material, mesh = _this.mesh;
        if (!material) {
            Logger.warn("The material of sky is not defined.");
            return;
        }
        if (material.destroyed) {
            Logger.warn("The material of sky is destroyed.");
            return;
        }
        if (!mesh) {
            Logger.warn("The mesh of sky is not defined.");
            return;
        }
        if (mesh.destroyed) {
            Logger.warn("The mesh of sky is destroyed.");
            return;
        }
        var _context_camera = context.camera, engine = _context_camera.engine, scene = _context_camera.scene, aspectRatio = _context_camera.aspectRatio, fieldOfView = _context_camera.fieldOfView, viewMatrix = _context_camera.viewMatrix, cameraShaderData = _context_camera.shaderData;
        var sceneData = scene.shaderData;
        var viewProjMatrix = Sky._viewProjMatrix, projectionMatrix = Sky._projectionMatrix;
        var rhi = engine._hardwareRenderer;
        var materialShaderData = material.shaderData, shader = material.shader, renderState = material.renderState;
        // no-scale view matrix
        viewProjMatrix.copyFrom(viewMatrix);
        var e = viewProjMatrix.elements;
        e[12] = e[13] = e[14] = 0;
        // epsilon-infinity projection matrix http://terathon.com/gdc07_lengyel.pdf
        var f = 1.0 / Math.tan(MathUtil.degreeToRadian(fieldOfView) / 2);
        projectionMatrix.elements[0] = f / aspectRatio;
        projectionMatrix.elements[5] = f;
        // view-proj matrix
        Matrix.multiply(projectionMatrix, viewProjMatrix, viewProjMatrix);
        var originViewProjMatrix = cameraShaderData.getMatrix(RenderContext.vpMatrixProperty);
        if (context.flipProjection) {
            Matrix.multiply(RenderContext._flipYMatrix, viewProjMatrix, viewProjMatrix);
        }
        cameraShaderData.setMatrix(RenderContext.vpMatrixProperty, viewProjMatrix);
        var compileMacros = Shader._compileMacros;
        ShaderMacroCollection.unionCollection(context.camera._globalShaderMacro, materialShaderData._macroCollection, compileMacros);
        ShaderMacroCollection.unionCollection(compileMacros, engine._macroCollection, compileMacros);
        var pass = shader.subShaders[0].passes[0];
        var program = pass._getShaderProgram(engine, compileMacros);
        program.bind();
        program.groupingOtherUniformBlock();
        program.uploadAll(program.sceneUniformBlock, sceneData);
        program.uploadAll(program.cameraUniformBlock, cameraShaderData);
        program.uploadAll(program.materialUniformBlock, materialShaderData);
        program.uploadUnGroupTextures();
        renderState._applyStates(engine, false, pass._renderStateDataMap, materialShaderData);
        rhi.drawPrimitive(mesh._primitive, mesh.subMesh, program);
        cameraShaderData.setMatrix(RenderContext.vpMatrixProperty, originViewProjMatrix);
    };
    _create_class$2(Sky, [
        {
            key: "material",
            get: /**
   *  Material of the sky.
   */ function get() {
                return this._material;
            },
            set: function set(value) {
                if (this._material !== value) {
                    var _this__material;
                    value == null ? void 0 : value._addReferCount(1);
                    (_this__material = this._material) == null ? void 0 : _this__material._addReferCount(-1);
                    this._material = value;
                }
            }
        },
        {
            key: "mesh",
            get: /**
   *  Mesh of the sky.
   */ function get() {
                return this._mesh;
            },
            set: function set(value) {
                if (this._mesh !== value) {
                    var _this__mesh;
                    value == null ? void 0 : value._addReferCount(1);
                    (_this__mesh = this._mesh) == null ? void 0 : _this__mesh._addReferCount(-1);
                    this._mesh = value;
                }
            }
        }
    ]);
    return Sky;
}();
Sky._epsilon = 1e-6;
Sky._viewProjMatrix = new Matrix();
Sky._projectionMatrix = new Matrix(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, Sky._epsilon - 1, -1, 0, 0, 0, 0);

/**
 * Background of scene.
 */ var Background = /*#__PURE__*/ function() {
    function Background(_engine) {
        this._engine = _engine;
        this./**
   * Background mode.
   * @defaultValue `BackgroundMode.SolidColor`
   * @remarks If using `BackgroundMode.Sky` mode and material or mesh of the `sky` is not defined, it will downgrade to `BackgroundMode.SolidColor`.
   */ mode = BackgroundMode.SolidColor;
        this.sky = new Sky();
        this./** @internal */ _textureFillMode = BackgroundTextureFillMode.AspectFitHeight;
        this._solidColor = new Color(0.05087608817155679, 0.05087608817155679, 0.05087608817155679, 1.0);
        this._texture = null;
        this._initMesh(_engine);
        this._initMaterial(_engine);
    }
    var _proto = Background.prototype;
    /**
   * @internal
   */ _proto.destroy = function destroy() {
        this.texture = null;
        this._mesh._addReferCount(-1);
        this._mesh = null;
        this._material._addReferCount(-1);
        this._material = null;
        this.sky.destroy();
    };
    /**
   * @internal
   */ _proto._resizeBackgroundTexture = function _resizeBackgroundTexture() {
        var _this = this, texture = _this._texture, mesh = _this._mesh;
        if (!this._texture) {
            return;
        }
        var _this__engine_canvas = this._engine.canvas, width = _this__engine_canvas.width, height = _this__engine_canvas.height;
        var positions = mesh.getPositions();
        switch(this._textureFillMode){
            case BackgroundTextureFillMode.Fill:
                positions[0].set(-1, -1, 1);
                positions[1].set(1, -1, 1);
                positions[2].set(-1, 1, 1);
                positions[3].set(1, 1, 1);
                break;
            case BackgroundTextureFillMode.AspectFitWidth:
                var fitWidthScale = texture.height * width / texture.width / height;
                positions[0].set(-1, -fitWidthScale, 1);
                positions[1].set(1, -fitWidthScale, 1);
                positions[2].set(-1, fitWidthScale, 1);
                positions[3].set(1, fitWidthScale, 1);
                break;
            case BackgroundTextureFillMode.AspectFitHeight:
                var fitHeightScale = texture.width * height / texture.height / width;
                positions[0].set(-fitHeightScale, -1, 1);
                positions[1].set(fitHeightScale, -1, 1);
                positions[2].set(-fitHeightScale, 1, 1);
                positions[3].set(fitHeightScale, 1, 1);
                break;
        }
        mesh.setPositions(positions);
        mesh.uploadData(false);
    };
    _proto._initMesh = function _initMesh(engine) {
        var mesh = this._mesh = this._createPlane(engine);
        engine.resourceManager.addContentRestorer(new (/*#__PURE__*/ function(ContentRestorer) {
            _inherits$2(_class, ContentRestorer);
            function _class() {
                return ContentRestorer.call(this, mesh) || this;
            }
            var _proto = _class.prototype;
            _proto.restoreContent = function restoreContent() {
                mesh.setPositions(mesh.getPositions());
                mesh.setUVs(mesh.getUVs());
                mesh.setIndices(mesh.getIndices());
                mesh.uploadData(false);
            };
            return _class;
        }(ContentRestorer))());
        this._mesh._addReferCount(1);
    };
    _proto._initMaterial = function _initMaterial(engine) {
        var material = this._material = new Material(engine, Shader.find("background-texture"));
        material.renderState.depthState.compareFunction = CompareFunction.LessEqual;
        material._addReferCount(1);
    };
    _proto._createPlane = function _createPlane(engine) {
        var mesh = new ModelMesh(engine);
        var indices = new Uint8Array([
            1,
            2,
            0,
            1,
            3,
            2
        ]);
        var positions = new Array(4);
        var uvs = new Array(4);
        for(var i = 0; i < 4; ++i){
            positions[i] = new Vector3();
            uvs[i] = new Vector2(i % 2, 1 - (i * 0.5 | 0));
        }
        mesh.setPositions(positions);
        mesh.setUVs(uvs);
        mesh.setIndices(indices);
        mesh.uploadData(false);
        mesh.addSubMesh(0, indices.length);
        return mesh;
    };
    _create_class$2(Background, [
        {
            key: "solidColor",
            get: /**
   * Background solid color.
   * @defaultValue `new Color(0.05, 0.05, 0.05, 1.0)`
   * @remarks When `mode` is `BackgroundMode.SolidColor`, the property will take effects.
   */ function get() {
                return this._solidColor;
            },
            set: function set(value) {
                if (value !== this._solidColor) {
                    this._solidColor.copyFrom(value);
                }
            }
        },
        {
            key: "texture",
            get: /**
   * Background texture.
   * @remarks When `mode` is `BackgroundMode.Texture`, the property will take effects.
   */ function get() {
                return this._texture;
            },
            set: function set(value) {
                if (this._texture !== value) {
                    var _this__texture;
                    value == null ? void 0 : value._addReferCount(1);
                    (_this__texture = this._texture) == null ? void 0 : _this__texture._addReferCount(-1);
                    this._texture = value;
                    this._material.shaderData.setTexture("material_BaseTexture", value);
                    this._resizeBackgroundTexture();
                }
            }
        },
        {
            key: "textureFillMode",
            get: /**
   * Background texture fill mode.
   * @remarks When `mode` is `BackgroundMode.Texture`, the property will take effects.
   * @defaultValue `BackgroundTextureFillMode.FitHeight`
   */ function get() {
                return this._textureFillMode;
            },
            set: function set(value) {
                if (value !== this._textureFillMode) {
                    this._textureFillMode = value;
                    this._resizeBackgroundTexture();
                }
            }
        }
    ]);
    return Background;
}();
/** @internal */ Background._premultiplySolidColor = new Color();

var ActiveChangeFlag = /*#__PURE__*/ function(ActiveChangeFlag) {
    ActiveChangeFlag[ActiveChangeFlag["None"] = 0] = "None";
    ActiveChangeFlag[ActiveChangeFlag["Scene"] = 1] = "Scene";
    ActiveChangeFlag[ActiveChangeFlag["Hierarchy"] = 2] = "Hierarchy";
    ActiveChangeFlag[ActiveChangeFlag["All"] = 3] = "All";
    return ActiveChangeFlag;
}({});

/**
 * The base class of the components.
 */ var Component = /*#__PURE__*/ function(EngineObject) {
    _inherits$2(Component, EngineObject);
    function Component(entity) {
        var _this;
        _this = EngineObject.call(this, entity.engine) || this, /** @internal */ _this._awoken = false, _this._phasedActiveInScene = false, _this._phasedActive = false, _this._enabled = true;
        _this._entity = entity;
        return _this;
    }
    var _proto = Component.prototype;
    /**
   * @internal
   */ _proto._onAwake = function _onAwake() {};
    /**
   * @internal
   */ _proto._onEnable = function _onEnable() {};
    /**
   * @internal
   */ _proto._onDisable = function _onDisable() {};
    /**
   * @internal
   */ _proto._onEnableInScene = function _onEnableInScene() {};
    /**
   * @internal
   */ _proto._onDisableInScene = function _onDisableInScene() {};
    /**
   * @internal
   */ _proto._setActive = function _setActive(value, activeChangeFlag) {
        var entity = this._entity;
        // Process active in scene, precautions are the same as below
        if (activeChangeFlag & ActiveChangeFlag.Scene) {
            if (value) {
                if (!this._phasedActiveInScene && entity._isActiveInScene && this._enabled) {
                    this._phasedActiveInScene = true;
                    this._onEnableInScene();
                }
            } else {
                if (this._phasedActiveInScene && !(entity._isActiveInScene && this._enabled)) {
                    this._phasedActiveInScene = false;
                    this._onDisableInScene();
                }
            }
        }
        // Process active in hierarchy
        if (activeChangeFlag & ActiveChangeFlag.Hierarchy) {
            if (value) {
                // Awake condition is un awake && current entity is active in hierarchy
                if (!this._awoken && entity._isActiveInHierarchy) {
                    this._awoken = true;
                    this._onAwake();
                }
                // Developer maybe do `isActive = false` in `onAwake` method
                // Enable condition is phased active state is false && current component is active in hierarchy
                if (!this._phasedActive && entity._isActiveInHierarchy && this._enabled) {
                    this._phasedActive = true;
                    this._onEnable();
                }
            } else {
                // Disable condition is phased active state is true && current component is inActive in hierarchy
                if (this._phasedActive && !(entity._isActiveInHierarchy && this._enabled)) {
                    this._phasedActive = false;
                    this._onDisable();
                }
            }
        }
    };
    _proto._addResourceReferCount = function _addResourceReferCount(resource, count) {
        this._entity._isTemplate || resource._addReferCount(count);
    };
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        EngineObject.prototype._onDestroy.call(this);
        var entity = this._entity;
        entity._removeComponent(this);
        if (this._enabled) {
            entity._isActiveInScene && this._onDisableInScene();
            entity._isActiveInHierarchy && this._onDisable();
        }
    };
    _create_class$2(Component, [
        {
            key: "enabled",
            get: /**
   * Indicates whether the component is enabled.
   */ function get() {
                return this._enabled;
            },
            set: function set(value) {
                if (value !== this._enabled) {
                    this._enabled = value;
                    if (this._entity._isActiveInScene) {
                        if (value) {
                            if (!this._phasedActiveInScene) {
                                this._phasedActiveInScene = true;
                                this._onEnableInScene();
                            }
                        } else {
                            if (this._phasedActiveInScene) {
                                this._phasedActiveInScene = false;
                                this._onDisableInScene();
                            }
                        }
                    }
                    if (this._entity.isActiveInHierarchy) {
                        if (value) {
                            if (!this._phasedActive) {
                                this._phasedActive = true;
                                this._onEnable();
                            }
                        } else {
                            if (this._phasedActive) {
                                this._phasedActive = false;
                                this._onDisable();
                            }
                        }
                    }
                }
            }
        },
        {
            key: "entity",
            get: /**
   * The entity which the component belongs to.
   */ function get() {
                return this._entity;
            }
        },
        {
            key: "scene",
            get: /**
   * The scene which the component's entity belongs to.
   */ function get() {
                return this._entity.scene;
            }
        }
    ]);
    return Component;
}(EngineObject);
__decorate$1([
    ignoreClone
], Component.prototype, "_entity", void 0);
__decorate$1([
    ignoreClone
], Component.prototype, "_awoken", void 0);
__decorate$1([
    ignoreClone
], Component.prototype, "_phasedActiveInScene", void 0);
__decorate$1([
    ignoreClone
], Component.prototype, "_phasedActive", void 0);
__decorate$1([
    assignmentClone
], Component.prototype, "_enabled", void 0);

/**
 * @internal
 * Used for component dependency registration.
 */ var ComponentsDependencies = /*#__PURE__*/ function() {
    function ComponentsDependencies() {}
    /**
   * @internal
   */ ComponentsDependencies._addCheck = function _addCheck(entity, type) {
        while(type !== Component){
            var dependentInfo = ComponentsDependencies._dependenciesMap.get(type);
            if (dependentInfo) {
                var components = dependentInfo.components, mode = dependentInfo.mode;
                for(var i = 0, n = components.length; i < n; i++){
                    var dependentComponent = components[i];
                    if (!entity.getComponent(dependentComponent)) {
                        if (mode === 1) {
                            entity.addComponent(dependentComponent);
                        } else {
                            throw "Should add " + dependentComponent.name + " before adding " + type.name;
                        }
                    }
                }
            }
            type = Object.getPrototypeOf(type);
        }
    };
    /**
   * @internal
   */ ComponentsDependencies._removeCheck = function _removeCheck(entity, type) {
        var components = entity._components;
        var n = components.length;
        while(type !== Component){
            var count = 0;
            for(var i = 0; i < n; i++){
                if (_instanceof$3(components[i], type) && ++count > 1) return;
            }
            var invDependencies = ComponentsDependencies._invDependenciesMap.get(type);
            if (invDependencies) {
                for(var i1 = 0, len = invDependencies.length; i1 < len; i1++){
                    if (entity.getComponent(invDependencies[i1])) {
                        throw "Should remove " + invDependencies[i1].name + " before remove " + type.name;
                    }
                }
            }
            type = Object.getPrototypeOf(type);
        }
    };
    /**
   * @internal
   */ ComponentsDependencies._addDependency = function _addDependency(targetInfo, dependentComponent, map) {
        var components = map.get(targetInfo);
        if (!components) {
            map.set(targetInfo, [
                dependentComponent
            ]);
        } else {
            components.includes(dependentComponent) || components.push(dependentComponent);
        }
    };
    /**
   * @internal
   */ ComponentsDependencies._addInvDependency = function _addInvDependency(currentComponent, dependentComponent) {
        var map = this._invDependenciesMap;
        var components = map.get(currentComponent);
        if (!components) {
            map.set(currentComponent, [
                dependentComponent
            ]);
        } else {
            components.includes(dependentComponent) || components.push(dependentComponent);
        }
    };
    return ComponentsDependencies;
}();
ComponentsDependencies._invDependenciesMap = new Map();
ComponentsDependencies._dependenciesMap = new Map();
function dependentComponents(componentOrComponents, dependentMode) {
    if (dependentMode === void 0) dependentMode = 0;
    var components = Array.isArray(componentOrComponents) ? componentOrComponents : [
        componentOrComponents
    ];
    return function(target) {
        ComponentsDependencies._dependenciesMap.set(target, {
            mode: dependentMode,
            components: components
        });
        components.forEach(function(component) {
            return ComponentsDependencies._addInvDependency(component, target);
        });
    };
}
/**
 * Dependent mode.
 */ var DependentMode = /*#__PURE__*/ function(DependentMode) {
    /** Check only, throw error if dependent components do not exist. */ DependentMode[DependentMode["CheckOnly"] = 0] = "CheckOnly";
    /** Auto add if dependent components do not exist. */ DependentMode[DependentMode["AutoAdd"] = 1] = "AutoAdd";
    return DependentMode;
}({});

/**
 * Layer, used for bit operations.
 */ var Layer = /*#__PURE__*/ function(Layer) {
    /** Layer 0. */ Layer[Layer["Layer0"] = 1] = "Layer0";
    /** Layer 1. */ Layer[Layer["Layer1"] = 2] = "Layer1";
    /** Layer 2. */ Layer[Layer["Layer2"] = 4] = "Layer2";
    /** Layer 3. */ Layer[Layer["Layer3"] = 8] = "Layer3";
    /** Layer 4. */ Layer[Layer["Layer4"] = 16] = "Layer4";
    /** Layer 5. */ Layer[Layer["Layer5"] = 32] = "Layer5";
    /** Layer 6. */ Layer[Layer["Layer6"] = 64] = "Layer6";
    /** Layer 7. */ Layer[Layer["Layer7"] = 128] = "Layer7";
    /** Layer 8. */ Layer[Layer["Layer8"] = 256] = "Layer8";
    /** Layer 9. */ Layer[Layer["Layer9"] = 512] = "Layer9";
    /** Layer 10. */ Layer[Layer["Layer10"] = 1024] = "Layer10";
    /** Layer 11. */ Layer[Layer["Layer11"] = 2048] = "Layer11";
    /** Layer 12. */ Layer[Layer["Layer12"] = 4096] = "Layer12";
    /** Layer 13. */ Layer[Layer["Layer13"] = 8192] = "Layer13";
    /** Layer 14. */ Layer[Layer["Layer14"] = 16384] = "Layer14";
    /** Layer 15. */ Layer[Layer["Layer15"] = 32768] = "Layer15";
    /** Layer 16. */ Layer[Layer["Layer16"] = 65536] = "Layer16";
    /** Layer 17. */ Layer[Layer["Layer17"] = 131072] = "Layer17";
    /** Layer 18. */ Layer[Layer["Layer18"] = 262144] = "Layer18";
    /** Layer 19. */ Layer[Layer["Layer19"] = 524288] = "Layer19";
    /** Layer 20. */ Layer[Layer["Layer20"] = 1048576] = "Layer20";
    /** Layer 21. */ Layer[Layer["Layer21"] = 2097152] = "Layer21";
    /** Layer 22. */ Layer[Layer["Layer22"] = 4194304] = "Layer22";
    /** Layer 23. */ Layer[Layer["Layer23"] = 8388608] = "Layer23";
    /** Layer 24. */ Layer[Layer["Layer24"] = 16777216] = "Layer24";
    /** Layer 25. */ Layer[Layer["Layer25"] = 33554432] = "Layer25";
    /** Layer 26. */ Layer[Layer["Layer26"] = 67108864] = "Layer26";
    /** Layer 27. */ Layer[Layer["Layer27"] = 134217728] = "Layer27";
    /** Layer 28. */ Layer[Layer["Layer28"] = 268435456] = "Layer28";
    /** Layer 29. */ Layer[Layer["Layer29"] = 536870912] = "Layer29";
    /** Layer 30. */ Layer[Layer["Layer30"] = 1073741824] = "Layer30";
    /** Layer 31. */ Layer[Layer["Layer31"] = 2147483648] = "Layer31";
    /** All layers. */ Layer[Layer["Everything"] = 4294967295] = "Everything";
    /** None layer. */ Layer[Layer["Nothing"] = 0] = "Nothing";
    return Layer;
}({});

/**
 * Used to update tags.
 */ var UpdateFlag = /*#__PURE__*/ function() {
    function UpdateFlag() {
        /** @internal */ this._flagManagers = [];
    }
    var _proto = UpdateFlag.prototype;
    /**
   * Clear.
   */ _proto.clearFromManagers = function clearFromManagers() {
        this._removeFromManagers();
        this._flagManagers.length = 0;
    };
    /**
   * Destroy.
   */ _proto.destroy = function destroy() {
        this._removeFromManagers();
        this._flagManagers = null;
    };
    _proto._removeFromManagers = function _removeFromManagers() {
        var flagManagers = this._flagManagers;
        for(var i = 0, n = flagManagers.length; i < n; i++){
            Utils.removeFromArray(flagManagers[i]._updateFlags, this);
        }
    };
    return UpdateFlag;
}();

/**
 * Bool update flag.
 */ var BoolUpdateFlag = /*#__PURE__*/ function(UpdateFlag) {
    _inherits$2(BoolUpdateFlag, UpdateFlag);
    function BoolUpdateFlag() {
        var _this;
        _this = UpdateFlag.apply(this, arguments) || this, /** Bool flag. */ _this.flag = true;
        return _this;
    }
    var _proto = BoolUpdateFlag.prototype;
    /**
   * @inheritdoc
   */ _proto.dispatch = function dispatch() {
        this.flag = true;
    };
    return BoolUpdateFlag;
}(UpdateFlag);

/**
 * Used to implement transformation related functions.
 */ var Transform = /*#__PURE__*/ function(Component) {
    _inherits$2(Transform, Component);
    function Transform(entity) {
        var _this;
        _this = Component.call(this, entity) || this, _this._position = new Vector3(), _this._rotation = new Vector3(), _this._rotationQuaternion = new Quaternion(), _this._scale = new Vector3(1, 1, 1), _this._localUniformScaling = true, _this._worldPosition = new Vector3(), _this._worldRotation = new Vector3(), _this._worldRotationQuaternion = new Quaternion(), _this._worldUniformScaling = true, _this._lossyWorldScale = new Vector3(1, 1, 1), _this._localMatrix = new Matrix(), _this._worldMatrix = new Matrix(), _this._worldForward = null, _this._worldRight = null, _this._worldUp = null, _this._isParentDirty = true, _this._parentTransformCache = null, _this._dirtyFlag = 188;
        _this._onPositionChanged = _this._onPositionChanged.bind(_this);
        _this._onWorldPositionChanged = _this._onWorldPositionChanged.bind(_this);
        _this._onRotationChanged = _this._onRotationChanged.bind(_this);
        _this._onWorldRotationChanged = _this._onWorldRotationChanged.bind(_this);
        _this._onRotationQuaternionChanged = _this._onRotationQuaternionChanged.bind(_this);
        _this._onWorldRotationQuaternionChanged = _this._onWorldRotationQuaternionChanged.bind(_this);
        _this._onScaleChanged = _this._onScaleChanged.bind(_this);
        //@ts-ignore
        _this._position._onValueChanged = _this._onPositionChanged;
        //@ts-ignore
        _this._worldPosition._onValueChanged = _this._onWorldPositionChanged;
        //@ts-ignore
        _this._rotation._onValueChanged = _this._onRotationChanged;
        //@ts-ignore
        _this._worldRotation._onValueChanged = _this._onWorldRotationChanged;
        //@ts-ignore
        _this._rotationQuaternion._onValueChanged = _this._onRotationQuaternionChanged;
        //@ts-ignore
        _this._worldRotationQuaternion._onValueChanged = _this._onWorldRotationQuaternionChanged;
        //@ts-ignore
        _this._scale._onValueChanged = _this._onScaleChanged;
        return _this;
    }
    var _proto = Transform.prototype;
    /**
   * Set local position by X, Y, Z value.
   * @param x - X coordinate
   * @param y - Y coordinate
   * @param z - Z coordinate
   */ _proto.setPosition = function setPosition(x, y, z) {
        this._position.set(x, y, z);
    };
    /**
   * Set local rotation by the X, Y, Z components of the euler angle, unit in degrees.
   * Rotations are performed around the Y axis, the X axis, and the Z axis, in that order.
   * @param x - The angle of rotation around the X axis
   * @param y - The angle of rotation around the Y axis
   * @param z - The angle of rotation around the Z axis
   */ _proto.setRotation = function setRotation(x, y, z) {
        this._rotation.set(x, y, z);
    };
    /**
   * Set local rotation by the X, Y, Z, and W components of the quaternion.
   * @param x - X component of quaternion
   * @param y - Y component of quaternion
   * @param z - Z component of quaternion
   * @param w - W component of quaternion
   */ _proto.setRotationQuaternion = function setRotationQuaternion(x, y, z, w) {
        this._rotationQuaternion.set(x, y, z, w);
    };
    /**
   * Set local scaling by scaling values along X, Y, Z axis.
   * @param x - Scaling along X axis
   * @param y - Scaling along Y axis
   * @param z - Scaling along Z axis
   */ _proto.setScale = function setScale(x, y, z) {
        this._scale.set(x, y, z);
    };
    /**
   * Set world position by X, Y, Z value.
   * @param x - X coordinate
   * @param y - Y coordinate
   * @param z - Z coordinate
   */ _proto.setWorldPosition = function setWorldPosition(x, y, z) {
        this._worldPosition.set(x, y, z);
    };
    /**
   * Set world rotation by the X, Y, Z components of the euler angle, unit in degrees, Yaw/Pitch/Roll sequence.
   * @param x - The angle of rotation around the X axis
   * @param y - The angle of rotation around the Y axis
   * @param z - The angle of rotation around the Z axis
   */ _proto.setWorldRotation = function setWorldRotation(x, y, z) {
        this._worldRotation.set(x, y, z);
    };
    /**
   * Set local rotation by the X, Y, Z, and W components of the quaternion.
   * @param x - X component of quaternion
   * @param y - Y component of quaternion
   * @param z - Z component of quaternion
   * @param w - W component of quaternion
   */ _proto.setWorldRotationQuaternion = function setWorldRotationQuaternion(x, y, z, w) {
        this._worldRotationQuaternion.set(x, y, z, w);
    };
    _proto.translate = function translate(translationOrX, relativeToLocalOrY, z, relativeToLocal) {
        if (typeof translationOrX === "number") {
            var translate = Transform._tempVec30;
            translate.set(translationOrX, relativeToLocalOrY, z);
            this._translate(translate, relativeToLocal);
        } else {
            this._translate(translationOrX, relativeToLocalOrY);
        }
    };
    _proto.rotate = function rotate(rotationOrX, relativeToLocalOrY, z, relativeToLocal) {
        if (typeof rotationOrX === "number") {
            this._rotateXYZ(rotationOrX, relativeToLocalOrY, z, relativeToLocal);
        } else {
            this._rotateXYZ(rotationOrX.x, rotationOrX.y, rotationOrX.z, relativeToLocalOrY);
        }
    };
    /**
   * Rotate around the specified axis according to the specified angle.
   * @param axis - Rotate axis
   * @param angle - Rotate angle in degrees
   * @param relativeToLocal = `true` - Relative to local space
   */ _proto.rotateByAxis = function rotateByAxis(axis, angle, relativeToLocal) {
        if (relativeToLocal === void 0) relativeToLocal = true;
        var rad = angle * MathUtil.degreeToRadFactor;
        Quaternion.rotationAxisAngle(axis, rad, Transform._tempQuat0);
        this._rotateByQuat(Transform._tempQuat0, relativeToLocal);
    };
    /**
   * Rotate and ensure that the world front vector points to the target world position.
   * @param targetPosition - Target world position
   * @param worldUp - Up direction in world space, default is Vector3(0, 1, 0)
   */ _proto.lookAt = function lookAt(targetPosition, worldUp) {
        var zAxis = Transform._tempVec30;
        Vector3.subtract(this.worldPosition, targetPosition, zAxis);
        var axisLen = zAxis.length();
        if (axisLen <= MathUtil.zeroTolerance) {
            // The current position and the target position are almost the same.
            return;
        }
        zAxis.scale(1 / axisLen);
        var xAxis = Transform._tempVec31;
        if (worldUp) {
            Vector3.cross(worldUp, zAxis, xAxis);
        } else {
            xAxis.set(zAxis.z, 0, -zAxis.x);
        }
        axisLen = xAxis.length();
        if (axisLen <= MathUtil.zeroTolerance) {
            // @todo:
            // 1.worldUp is（0,0,0）
            // 2.worldUp is parallel to zAxis
            return;
        }
        xAxis.scale(1 / axisLen);
        var yAxis = Transform._tempVec32;
        Vector3.cross(zAxis, xAxis, yAxis);
        var rotMat = Transform._tempMat41;
        var e = rotMat.elements;
        e[0] = xAxis.x, e[1] = xAxis.y, e[2] = xAxis.z;
        e[4] = yAxis.x, e[5] = yAxis.y, e[6] = yAxis.z;
        e[8] = zAxis.x, e[9] = zAxis.y, e[10] = zAxis.z;
        rotMat.getRotation(this._worldRotationQuaternion);
    };
    /**
   * @internal
   */ _proto._parentChange = function _parentChange() {
        this._isParentDirty = true;
        this._updateAllWorldFlag(444);
    };
    /**
   * @internal
   */ _proto._isFrontFaceInvert = function _isFrontFaceInvert() {
        var scale = this.lossyWorldScale;
        var isInvert = scale.x < 0;
        scale.y < 0 && (isInvert = !isInvert);
        scale.z < 0 && (isInvert = !isInvert);
        return isInvert;
    };
    /**
   * @internal
   */ _proto._copyFrom = function _copyFrom(transform) {
        this._position.copyFrom(transform.position);
        this._rotation.copyFrom(transform.rotation);
        this._scale.copyFrom(transform.scale);
    };
    _proto._onDestroy = function _onDestroy() {
        Component.prototype._onDestroy.call(this);
        //@ts-ignore
        this._worldPosition._onValueChanged = null;
        //@ts-ignore
        this._rotation._onValueChanged = null;
        //@ts-ignore
        this._worldRotation._onValueChanged = null;
        //@ts-ignore
        this._rotationQuaternion._onValueChanged = null;
        //@ts-ignore
        this._worldRotationQuaternion._onValueChanged = null;
        //@ts-ignore
        this._position._onValueChanged = null;
        //@ts-ignore
        this._scale._onValueChanged = null;
    };
    /**
   * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.
   * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.
   * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix or worldRotationQuaternion) to be false.
   */ _proto._updateWorldPositionFlag = function _updateWorldPositionFlag() {
        if (!this._isContainDirtyFlags(132)) {
            this._worldAssociatedChange(132);
            var children = this._entity._children;
            for(var i = 0, n = children.length; i < n; i++){
                var _children_i_transform;
                (_children_i_transform = children[i].transform) == null ? void 0 : _children_i_transform._updateWorldPositionFlag();
            }
        }
    };
    /**
   * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.
   * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.
   * Get worldRotationQuaternion: Will trigger the world rotation (in quaternion) update of itself and all parent entities.
   * Get worldRotation: Will trigger the world rotation(in euler and quaternion) update of itself and world rotation(in quaternion) update of all parent entities.
   * Get worldScale: Will trigger the scaling update of itself and all parent entities.
   * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix or worldRotationQuaternion) to be false.
   */ _proto._updateWorldRotationFlag = function _updateWorldRotationFlag() {
        var parent = this._getParentTransform();
        var parentWorldUniformScaling = parent ? parent._getWorldUniformScaling() : true;
        var flags = parentWorldUniformScaling ? 152 : 184;
        if (!this._isContainDirtyFlags(flags)) {
            this._worldAssociatedChange(flags);
            flags = this._getWorldUniformScaling() ? 156 : 188;
            var children = this._entity._children;
            for(var i = 0, n = children.length; i < n; i++){
                var _children_i_transform;
                (_children_i_transform = children[i].transform) == null ? void 0 : _children_i_transform._updateWorldPositionAndRotationFlag(flags); // Rotation update of parent entity will trigger world position, rotation and scale update of all child entity.
            }
        }
    };
    /**
   * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.
   * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.
   * Get worldRotationQuaternion: Will trigger the world rotation (in quaternion) update of itself and all parent entities.
   * Get worldRotation: Will trigger the world rotation(in euler and quaternion) update of itself and world rotation(in quaternion) update of all parent entities.
   * Get worldScale: Will trigger the scaling update of itself and all parent entities.
   * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix or worldRotationQuaternion) to be false.
   * @param flags - Dirty flag
   */ _proto._updateWorldPositionAndRotationFlag = function _updateWorldPositionAndRotationFlag(flags) {
        if (!this._isContainDirtyFlags(flags)) {
            this._worldAssociatedChange(flags);
            flags = this._getWorldUniformScaling() ? 156 : 188;
            var children = this._entity._children;
            for(var i = 0, n = children.length; i < n; i++){
                var _children_i_transform;
                (_children_i_transform = children[i].transform) == null ? void 0 : _children_i_transform._updateWorldPositionAndRotationFlag(flags);
            }
        }
    };
    /**
   * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.
   * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.
   * Get worldScale: Will trigger the scaling update of itself and all parent entities.
   * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix) to be false.
   * @param flags - Dirty flag
   */ _proto._updateWorldScaleFlag = function _updateWorldScaleFlag(flags) {
        if (!this._isContainDirtyFlags(flags)) {
            this._worldAssociatedChange(flags);
            flags |= 4;
            var children = this._entity._children;
            for(var i = 0, n = children.length; i < n; i++){
                var _children_i_transform;
                (_children_i_transform = children[i].transform) == null ? void 0 : _children_i_transform._updateWorldPositionAndScaleFlag(flags);
            }
        }
    };
    /**
   * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.
   * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.
   * Get worldScale: Will trigger the scaling update of itself and all parent entities.
   * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix) to be false.
   * @param flags - Dirty flag
   */ _proto._updateWorldPositionAndScaleFlag = function _updateWorldPositionAndScaleFlag(flags) {
        if (!this._isContainDirtyFlags(flags)) {
            this._worldAssociatedChange(flags);
            var children = this._entity._children;
            for(var i = 0, n = children.length; i < n; i++){
                var _children_i_transform;
                (_children_i_transform = children[i].transform) == null ? void 0 : _children_i_transform._updateWorldPositionAndScaleFlag(flags);
            }
        }
    };
    /**
   * Update all world transform property dirty flag, the principle is the same as above.
   * @param flags - Dirty flag
   */ _proto._updateAllWorldFlag = function _updateAllWorldFlag(flags) {
        if (!this._isContainDirtyFlags(flags)) {
            this._worldAssociatedChange(flags);
            var children = this._entity._children;
            for(var i = 0, n = children.length; i < n; i++){
                var _children_i_transform;
                (_children_i_transform = children[i].transform) == null ? void 0 : _children_i_transform._updateAllWorldFlag(flags);
            }
        }
    };
    _proto._getParentTransform = function _getParentTransform() {
        if (!this._isParentDirty) {
            return this._parentTransformCache;
        }
        var parentCache = null;
        var parent = this._entity.parent;
        while(parent){
            var transform = parent.transform;
            if (transform) {
                parentCache = transform;
                break;
            } else {
                parent = parent.parent;
            }
        }
        this._parentTransformCache = parentCache;
        this._isParentDirty = false;
        return parentCache;
    };
    _proto._getScaleMatrix = function _getScaleMatrix() {
        var invRotation = Transform._tempQuat0;
        var invRotationMat = Transform._tempMat30;
        var worldRotScaMat = Transform._tempMat31;
        var scaMat = Transform._tempMat32;
        worldRotScaMat.copyFromMatrix(this.worldMatrix);
        Quaternion.invert(this.worldRotationQuaternion, invRotation);
        Matrix3x3.rotationQuaternion(invRotation, invRotationMat);
        Matrix3x3.multiply(invRotationMat, worldRotScaMat, scaMat);
        return scaMat;
    };
    _proto._isContainDirtyFlags = function _isContainDirtyFlags(targetDirtyFlags) {
        return (this._dirtyFlag & targetDirtyFlags) === targetDirtyFlags;
    };
    _proto._isContainDirtyFlag = function _isContainDirtyFlag(type) {
        return (this._dirtyFlag & type) != 0;
    };
    _proto._setDirtyFlagTrue = function _setDirtyFlagTrue(type) {
        this._dirtyFlag |= type;
    };
    _proto._setDirtyFlagFalse = function _setDirtyFlagFalse(type) {
        this._dirtyFlag &= ~type;
    };
    _proto._worldAssociatedChange = function _worldAssociatedChange(type) {
        this._dirtyFlag |= type;
        this._entity._updateFlagManager.dispatch(type);
    };
    _proto._rotateByQuat = function _rotateByQuat(rotateQuat, relativeToLocal) {
        if (relativeToLocal) {
            Quaternion.multiply(this.rotationQuaternion, rotateQuat, this._rotationQuaternion);
        } else {
            Quaternion.multiply(rotateQuat, this.worldRotationQuaternion, this._worldRotationQuaternion);
        }
    };
    _proto._translate = function _translate(translation, relativeToLocal) {
        if (relativeToLocal === void 0) relativeToLocal = true;
        if (relativeToLocal) {
            var _tempVec30 = Transform._tempVec30;
            Vector3.transformByQuat(translation, this.worldRotationQuaternion, _tempVec30);
            this.worldPosition.add(_tempVec30);
        } else {
            this.worldPosition.add(translation);
        }
    };
    _proto._rotateXYZ = function _rotateXYZ(x, y, z, relativeToLocal) {
        if (relativeToLocal === void 0) relativeToLocal = true;
        var radFactor = MathUtil.degreeToRadFactor;
        var rotQuat = Transform._tempQuat0;
        Quaternion.rotationEuler(x * radFactor, y * radFactor, z * radFactor, rotQuat);
        this._rotateByQuat(rotQuat, relativeToLocal);
    };
    _proto._onPositionChanged = function _onPositionChanged() {
        this._setDirtyFlagTrue(64);
        this._updateWorldPositionFlag();
    };
    _proto._onWorldPositionChanged = function _onWorldPositionChanged() {
        var worldPosition = this._worldPosition;
        var parent = this._getParentTransform();
        if (parent) {
            Matrix.invert(parent.worldMatrix, Transform._tempMat41);
            Vector3.transformCoordinate(worldPosition, Transform._tempMat41, this._position);
        } else {
            this._position.copyFrom(worldPosition);
        }
        this._setDirtyFlagFalse(4);
    };
    _proto._onRotationChanged = function _onRotationChanged() {
        this._setDirtyFlagTrue(64 | 2);
        this._setDirtyFlagFalse(1);
        this._updateWorldRotationFlag();
    };
    _proto._onWorldRotationChanged = function _onWorldRotationChanged() {
        var worldRotation = this._worldRotation;
        Quaternion.rotationEuler(MathUtil.degreeToRadian(worldRotation.x), MathUtil.degreeToRadian(worldRotation.y), MathUtil.degreeToRadian(worldRotation.z), this._worldRotationQuaternion);
        this._setDirtyFlagFalse(8);
    };
    _proto._onRotationQuaternionChanged = function _onRotationQuaternionChanged() {
        this._setDirtyFlagTrue(64 | 1);
        this._setDirtyFlagFalse(2);
        this._updateWorldRotationFlag();
    };
    _proto._onWorldRotationQuaternionChanged = function _onWorldRotationQuaternionChanged() {
        var worldRotationQuaternion = this._worldRotationQuaternion;
        var parent = this._getParentTransform();
        if (parent) {
            var invParentQuaternion = Transform._tempQuat0;
            Quaternion.invert(parent.worldRotationQuaternion, invParentQuaternion);
            Quaternion.multiply(invParentQuaternion, worldRotationQuaternion, this._rotationQuaternion);
        } else {
            this._rotationQuaternion.copyFrom(worldRotationQuaternion);
        }
        this._setDirtyFlagFalse(16);
    };
    _proto._onScaleChanged = function _onScaleChanged() {
        var _this__scale = this._scale, x = _this__scale.x, y = _this__scale.y, z = _this__scale.z;
        this._setDirtyFlagTrue(64);
        var localUniformScaling = x == y && y == z;
        if (this._localUniformScaling !== localUniformScaling) {
            this._localUniformScaling = localUniformScaling;
            this._updateWorldScaleFlag(416);
        } else {
            this._updateWorldScaleFlag(160);
        }
    };
    _proto._getWorldUniformScaling = function _getWorldUniformScaling() {
        if (this._isContainDirtyFlag(256)) {
            var localUniformScaling = this._localUniformScaling;
            if (localUniformScaling) {
                var parent = this._getParentTransform();
                this._worldUniformScaling = localUniformScaling && (parent ? parent._getWorldUniformScaling() : true);
            } else {
                this._worldUniformScaling = false;
            }
            this._setDirtyFlagFalse(256);
        }
        return this._worldUniformScaling;
    };
    //--------------------------------------------------------------deprecated----------------------------------------------------------------
    /**
   * @deprecated
   * Listen for changes in the world pose of this `Entity`.
   * @returns Change flag
   */ _proto.registerWorldChangeFlag = function registerWorldChangeFlag() {
        return this.entity._updateFlagManager.createFlag(BoolUpdateFlag);
    };
    _create_class$2(Transform, [
        {
            key: "position",
            get: /**
   * Local position.
   */ function get() {
                return this._position;
            },
            set: function set(value) {
                if (this._position !== value) {
                    this._position.copyFrom(value);
                }
            }
        },
        {
            key: "worldPosition",
            get: /**
   * World position.
   */ function get() {
                var worldPosition = this._worldPosition;
                if (this._isContainDirtyFlag(4)) {
                    //@ts-ignore
                    worldPosition._onValueChanged = null;
                    if (this._getParentTransform()) {
                        this.worldMatrix.getTranslation(worldPosition);
                    } else {
                        worldPosition.copyFrom(this._position);
                    }
                    //@ts-ignore
                    worldPosition._onValueChanged = this._onWorldPositionChanged;
                    this._setDirtyFlagFalse(4);
                }
                return worldPosition;
            },
            set: function set(value) {
                if (this._worldPosition !== value) {
                    this._worldPosition.copyFrom(value);
                }
            }
        },
        {
            key: "rotation",
            get: /**
   * Local rotation, defining the rotation value in degrees.
   * Rotations are performed around the Y axis, the X axis, and the Z axis, in that order.
   */ function get() {
                var rotation = this._rotation;
                if (this._isContainDirtyFlag(1)) {
                    //@ts-ignore
                    rotation._onValueChanged = null;
                    this._rotationQuaternion.toEuler(rotation);
                    rotation.scale(MathUtil.radToDegreeFactor); // radians to degrees
                    //@ts-ignore
                    rotation._onValueChanged = this._onRotationChanged;
                    this._setDirtyFlagFalse(1);
                }
                return rotation;
            },
            set: function set(value) {
                if (this._rotation !== value) {
                    this._rotation.copyFrom(value);
                }
            }
        },
        {
            key: "worldRotation",
            get: /**
   * World rotation, defining the rotation value in degrees.
   * Rotations are performed around the Y axis, the X axis, and the Z axis, in that order.
   */ function get() {
                var worldRotation = this._worldRotation;
                if (this._isContainDirtyFlag(8)) {
                    //@ts-ignore
                    worldRotation._onValueChanged = null;
                    this.worldRotationQuaternion.toEuler(worldRotation);
                    worldRotation.scale(MathUtil.radToDegreeFactor); // Radian to angle
                    //@ts-ignore
                    worldRotation._onValueChanged = this._onWorldRotationChanged;
                    this._setDirtyFlagFalse(8);
                }
                return worldRotation;
            },
            set: function set(value) {
                if (this._worldRotation !== value) {
                    this._worldRotation.copyFrom(value);
                }
            }
        },
        {
            key: "rotationQuaternion",
            get: /**
   * Local rotation, defining the rotation by using a unit quaternion.
   */ function get() {
                var rotationQuaternion = this._rotationQuaternion;
                if (this._isContainDirtyFlag(2)) {
                    //@ts-ignore
                    rotationQuaternion._onValueChanged = null;
                    Quaternion.rotationEuler(MathUtil.degreeToRadian(this._rotation.x), MathUtil.degreeToRadian(this._rotation.y), MathUtil.degreeToRadian(this._rotation.z), rotationQuaternion);
                    //@ts-ignore
                    rotationQuaternion._onValueChanged = this._onRotationQuaternionChanged;
                    this._setDirtyFlagFalse(2);
                }
                return rotationQuaternion;
            },
            set: function set(value) {
                if (this._rotationQuaternion !== value) {
                    if (value.normalized) {
                        this._rotationQuaternion.copyFrom(value);
                    } else {
                        Quaternion.normalize(value, this._rotationQuaternion);
                    }
                } else {
                    value.normalized || value.normalize();
                }
            }
        },
        {
            key: "worldRotationQuaternion",
            get: /**
   * World rotation, defining the rotation by using a unit quaternion.
   */ function get() {
                var worldRotationQuaternion = this._worldRotationQuaternion;
                if (this._isContainDirtyFlag(16)) {
                    //@ts-ignore
                    worldRotationQuaternion._onValueChanged = null;
                    var parent = this._getParentTransform();
                    if (parent != null) {
                        Quaternion.multiply(parent.worldRotationQuaternion, this.rotationQuaternion, worldRotationQuaternion);
                    } else {
                        worldRotationQuaternion.copyFrom(this.rotationQuaternion);
                    }
                    //@ts-ignore
                    worldRotationQuaternion._onValueChanged = this._onWorldRotationQuaternionChanged;
                    this._setDirtyFlagFalse(16);
                }
                return worldRotationQuaternion;
            },
            set: function set(value) {
                if (this._worldRotationQuaternion !== value) {
                    if (value.normalized) {
                        this._worldRotationQuaternion.copyFrom(value);
                    } else {
                        Quaternion.normalize(value, this._worldRotationQuaternion);
                    }
                }
                value.normalized || value.normalize();
            }
        },
        {
            key: "scale",
            get: /**
   * Local scaling.
   */ function get() {
                return this._scale;
            },
            set: function set(value) {
                if (this._scale !== value) {
                    this._scale.copyFrom(value);
                }
            }
        },
        {
            key: "lossyWorldScale",
            get: /**
   * Local lossy scaling.
   * @remarks The value obtained may not be correct under certain conditions(for example, the parent node has non-uniform world scaling,
   * and the child node has a rotation), the scaling will be tilted.
   */ function get() {
                if (this._isContainDirtyFlag(32)) {
                    if (this._getParentTransform()) {
                        // Vector3 cannot be used to correctly represent the scaling. Must use Matrix3x3
                        var scaleMat = this._getScaleMatrix();
                        var e = scaleMat.elements;
                        this._lossyWorldScale.set(e[0], e[4], e[8]);
                    } else {
                        this._lossyWorldScale.copyFrom(this._scale);
                    }
                    this._setDirtyFlagFalse(32);
                }
                return this._lossyWorldScale;
            }
        },
        {
            key: "localMatrix",
            get: /**
   * Local matrix.
   * @remarks Need to re-assign after modification to ensure that the modification takes effect.
   */ function get() {
                if (this._isContainDirtyFlag(64)) {
                    Matrix.affineTransformation(this._scale, this.rotationQuaternion, this._position, this._localMatrix);
                    this._setDirtyFlagFalse(64);
                }
                return this._localMatrix;
            },
            set: function set(value) {
                if (this._localMatrix !== value) {
                    this._localMatrix.copyFrom(value);
                }
                var _this = this, position = _this._position, rotationQuaternion = _this._rotationQuaternion, scale = _this._scale;
                // @ts-ignore
                position._onValueChanged = rotationQuaternion._onValueChanged = scale._onValueChanged = null;
                this._localMatrix.decompose(position, rotationQuaternion, scale);
                // @ts-ignore
                position._onValueChanged = this._onPositionChanged;
                // @ts-ignore
                rotationQuaternion._onValueChanged = this._onRotationQuaternionChanged;
                // @ts-ignore
                scale._onValueChanged = this._onScaleChanged;
                this._setDirtyFlagTrue(1);
                this._setDirtyFlagFalse(64 | 2);
                var localUniformScaling = scale.x === scale.y && scale.y === scale.z;
                if (this._localUniformScaling !== localUniformScaling) {
                    this._localUniformScaling = localUniformScaling;
                    this._updateAllWorldFlag(444);
                } else {
                    this._updateAllWorldFlag(188);
                }
            }
        },
        {
            key: "worldMatrix",
            get: /**
   * World matrix.
   * @remarks Need to re-assign after modification to ensure that the modification takes effect.
   */ function get() {
                if (this._isContainDirtyFlag(128)) {
                    var parent = this._getParentTransform();
                    if (parent) {
                        Matrix.multiply(parent.worldMatrix, this.localMatrix, this._worldMatrix);
                    } else {
                        this._worldMatrix.copyFrom(this.localMatrix);
                    }
                    this._setDirtyFlagFalse(128);
                }
                return this._worldMatrix;
            },
            set: function set(value) {
                if (this._worldMatrix !== value) {
                    this._worldMatrix.copyFrom(value);
                }
                var parent = this._getParentTransform();
                if (parent) {
                    Matrix.invert(parent.worldMatrix, Transform._tempMat42);
                    Matrix.multiply(Transform._tempMat42, value, this._localMatrix);
                } else {
                    this._localMatrix.copyFrom(value);
                }
                this.localMatrix = this._localMatrix;
                this._setDirtyFlagFalse(128);
            }
        },
        {
            key: "worldForward",
            get: /**
   * The forward direction in world space.
   */ function get() {
                var worldForward = this._worldForward || (this._worldForward = new Vector3());
                var e = this.worldMatrix.elements;
                worldForward.set(-e[8], -e[9], -e[10]);
                return worldForward.normalize();
            }
        },
        {
            key: "worldRight",
            get: /**
   * The right direction in world space.
   */ function get() {
                var worldRight = this._worldRight || (this._worldRight = new Vector3());
                var e = this.worldMatrix.elements;
                worldRight.set(e[0], e[1], e[2]);
                return worldRight.normalize();
            }
        },
        {
            key: "worldUp",
            get: /**
   * The up direction in world space.
   */ function get() {
                var worldUp = this._worldUp || (this._worldUp = new Vector3());
                var e = this.worldMatrix.elements;
                worldUp.set(e[4], e[5], e[6]);
                return worldUp.normalize();
            }
        }
    ]);
    return Transform;
}(Component);
Transform._tempQuat0 = new Quaternion();
Transform._tempVec30 = new Vector3();
Transform._tempVec31 = new Vector3();
Transform._tempVec32 = new Vector3();
Transform._tempMat30 = new Matrix3x3();
Transform._tempMat31 = new Matrix3x3();
Transform._tempMat32 = new Matrix3x3();
Transform._tempMat41 = new Matrix();
Transform._tempMat42 = new Matrix();
__decorate$1([
    deepClone
], Transform.prototype, "_position", void 0);
__decorate$1([
    deepClone
], Transform.prototype, "_rotation", void 0);
__decorate$1([
    deepClone
], Transform.prototype, "_rotationQuaternion", void 0);
__decorate$1([
    deepClone
], Transform.prototype, "_scale", void 0);
__decorate$1([
    assignmentClone
], Transform.prototype, "_localUniformScaling", void 0);
__decorate$1([
    deepClone
], Transform.prototype, "_worldPosition", void 0);
__decorate$1([
    deepClone
], Transform.prototype, "_worldRotation", void 0);
__decorate$1([
    deepClone
], Transform.prototype, "_worldRotationQuaternion", void 0);
__decorate$1([
    assignmentClone
], Transform.prototype, "_worldUniformScaling", void 0);
__decorate$1([
    deepClone
], Transform.prototype, "_lossyWorldScale", void 0);
__decorate$1([
    deepClone
], Transform.prototype, "_localMatrix", void 0);
__decorate$1([
    deepClone
], Transform.prototype, "_worldMatrix", void 0);
__decorate$1([
    ignoreClone
], Transform.prototype, "_worldForward", void 0);
__decorate$1([
    ignoreClone
], Transform.prototype, "_worldRight", void 0);
__decorate$1([
    ignoreClone
], Transform.prototype, "_worldUp", void 0);
__decorate$1([
    ignoreClone
], Transform.prototype, "_isParentDirty", void 0);
__decorate$1([
    ignoreClone
], Transform.prototype, "_parentTransformCache", void 0);
__decorate$1([
    ignoreClone
], Transform.prototype, "_onPositionChanged", null);
__decorate$1([
    ignoreClone
], Transform.prototype, "_onWorldPositionChanged", null);
__decorate$1([
    ignoreClone
], Transform.prototype, "_onRotationChanged", null);
__decorate$1([
    ignoreClone
], Transform.prototype, "_onWorldRotationChanged", null);
__decorate$1([
    ignoreClone
], Transform.prototype, "_onRotationQuaternionChanged", null);
__decorate$1([
    ignoreClone
], Transform.prototype, "_onWorldRotationQuaternionChanged", null);
__decorate$1([
    ignoreClone
], Transform.prototype, "_onScaleChanged", null);
/**
 * @internal
 */ var TransformModifyFlags = /*#__PURE__*/ function(TransformModifyFlags) {
    TransformModifyFlags[TransformModifyFlags["LocalEuler"] = 1] = "LocalEuler";
    TransformModifyFlags[TransformModifyFlags["LocalQuat"] = 2] = "LocalQuat";
    TransformModifyFlags[TransformModifyFlags["WorldPosition"] = 4] = "WorldPosition";
    TransformModifyFlags[TransformModifyFlags["WorldEuler"] = 8] = "WorldEuler";
    TransformModifyFlags[TransformModifyFlags["WorldQuat"] = 16] = "WorldQuat";
    TransformModifyFlags[TransformModifyFlags["WorldScale"] = 32] = "WorldScale";
    TransformModifyFlags[TransformModifyFlags["LocalMatrix"] = 64] = "LocalMatrix";
    TransformModifyFlags[TransformModifyFlags["WorldMatrix"] = 128] = "WorldMatrix";
    /** This is an internal flag used to assist in determining the dispatch
   *  of world scaling dirty flags in the case of non-uniform scaling.
   */ TransformModifyFlags[TransformModifyFlags["IsWorldUniformScaling"] = 256] = "IsWorldUniformScaling";
    /** WorldMatrix | WorldPosition */ TransformModifyFlags[TransformModifyFlags["WmWp"] = 132] = "WmWp";
    /** WorldMatrix | WorldEuler | WorldQuat */ TransformModifyFlags[TransformModifyFlags["WmWeWq"] = 152] = "WmWeWq";
    /** WorldMatrix | WorldEuler | WorldQuat | WorldScale*/ TransformModifyFlags[TransformModifyFlags["WmWeWqWs"] = 184] = "WmWeWqWs";
    /** WorldMatrix | WorldPosition | WorldEuler | WorldQuat */ TransformModifyFlags[TransformModifyFlags["WmWpWeWq"] = 156] = "WmWpWeWq";
    /** WorldMatrix | WorldScale */ TransformModifyFlags[TransformModifyFlags["WmWs"] = 160] = "WmWs";
    /** WorldMatrix | WorldScale | WorldUniformScaling */ TransformModifyFlags[TransformModifyFlags["WmWsWus"] = 416] = "WmWsWus";
    /** WorldMatrix | WorldPosition | WorldScale */ TransformModifyFlags[TransformModifyFlags["WmWpWs"] = 164] = "WmWpWs";
    /** WorldMatrix | WorldPosition | WorldEuler | WorldQuat | WorldScale */ TransformModifyFlags[TransformModifyFlags["WmWpWeWqWs"] = 188] = "WmWpWeWqWs";
    /** WorldMatrix | WorldPosition | WorldEuler | WorldQuat | WorldScale | WorldUniformScaling */ TransformModifyFlags[TransformModifyFlags["WmWpWeWqWsWus"] = 444] = "WmWpWeWqWsWus";
    return TransformModifyFlags;
}({});

/**
 * @internal
 */ var VirtualCamera = function VirtualCamera() {
    this.position = new Vector3();
    this.isOrthographic = false;
    this.viewMatrix = new Matrix();
    this.projectionMatrix = new Matrix();
    this.viewProjectionMatrix = new Matrix();
    this.nearClipPlane = 0.1;
    this.farClipPlane = 100;
    /** Only orth mode use. */ this.forward = new Vector3();
};

/**
 * The anti-aliasing mode.
 */ var AntiAliasing = /*#__PURE__*/ function(AntiAliasing) {
    /* Disable anti-aliasing. */ AntiAliasing[AntiAliasing["None"] = 0] = "None";
    /* Fast approximate anti-aliasing, it detects and smooths jagged edges based on luminance contrast in the final rendered image. */ AntiAliasing[AntiAliasing["FXAA"] = 1] = "FXAA";
    return AntiAliasing;
}({});

/**
 * Camera clear flags enumeration.
 */ var CameraClearFlags = /*#__PURE__*/ function(CameraClearFlags) {
    /* Do nothing. */ CameraClearFlags[CameraClearFlags["None"] = 0] = "None";
    /* Clear color with scene background. */ CameraClearFlags[CameraClearFlags["Color"] = 1] = "Color";
    /* Clear depth only. */ CameraClearFlags[CameraClearFlags["Depth"] = 2] = "Depth";
    /* Clear depth only. */ CameraClearFlags[CameraClearFlags["Stencil"] = 4] = "Stencil";
    /* Clear color with scene background and depth. */ CameraClearFlags[CameraClearFlags["ColorDepth"] = 3] = "ColorDepth";
    /* Clear color with scene background and stencil. */ CameraClearFlags[CameraClearFlags["ColorStencil"] = 5] = "ColorStencil";
    /* Clear depth and stencil. */ CameraClearFlags[CameraClearFlags["DepthStencil"] = 6] = "DepthStencil";
    /* Clear color with scene background, depth, and stencil. */ CameraClearFlags[CameraClearFlags["All"] = 7] = "All";
    return CameraClearFlags;
}({});

/**
 * The camera modify flags.
 */ var CameraModifyFlags = /*#__PURE__*/ function(CameraModifyFlags) {
    /** The types of camera projections changes. */ CameraModifyFlags[CameraModifyFlags["ProjectionType"] = 1] = "ProjectionType";
    /** The aspect ratio of the camera changes. */ CameraModifyFlags[CameraModifyFlags["AspectRatio"] = 2] = "AspectRatio";
    /** The field of view of the camera changes. */ CameraModifyFlags[CameraModifyFlags["FieldOfView"] = 4] = "FieldOfView";
    /** The orthographic size of the camera changes. */ CameraModifyFlags[CameraModifyFlags["OrthographicSize"] = 8] = "OrthographicSize";
    /** The camera becomes active in the scene. */ CameraModifyFlags[CameraModifyFlags["EnableInScene"] = 16] = "EnableInScene";
    /** The camera becomes inactive in the scene. */ CameraModifyFlags[CameraModifyFlags["DisableInScene"] = 32] = "DisableInScene";
    return CameraModifyFlags;
}({});

/**
 * @internal
 */ var CameraType$1 = /*#__PURE__*/ function(CameraType) {
    CameraType[CameraType["Normal"] = 0] = "Normal";
    CameraType[CameraType["XRCenterCamera"] = 1] = "XRCenterCamera";
    CameraType[CameraType["XRLeftCamera"] = 2] = "XRLeftCamera";
    CameraType[CameraType["XRRightCamera"] = 4] = "XRRightCamera";
    return CameraType;
}({});

/**
 * Depth texture mode.
 */ var DepthTextureMode = /*#__PURE__*/ function(DepthTextureMode) {
    /* No depth texture. */ DepthTextureMode[DepthTextureMode["None"] = 0] = "None";
    /* Generate depth texture by pre-pass rendering. */ DepthTextureMode[DepthTextureMode["PrePass"] = 1] = "PrePass";
    return DepthTextureMode;
}({});

/**
 * Down sampling.
 */ var Downsampling = /*#__PURE__*/ function(Downsampling) {
    /** No down sampling. */ Downsampling[Downsampling["None"] = 1] = "None";
    /** Half resolution down sampling. */ Downsampling[Downsampling["TwoX"] = 2] = "TwoX";
    /** Quarter resolution down sampling. */ Downsampling[Downsampling["FourX"] = 4] = "FourX";
    return Downsampling;
}({});

/**
 * Multi-sample anti-aliasing samples.
 */ var MSAASamples = /*#__PURE__*/ function(MSAASamples) {
    /** No multi-sample anti-aliasing. */ MSAASamples[MSAASamples["None"] = 1] = "None";
    /** Multi-sample anti-aliasing with 2 samples. */ MSAASamples[MSAASamples["TwoX"] = 2] = "TwoX";
    /** Multi-sample anti-aliasing with 4 samples. */ MSAASamples[MSAASamples["FourX"] = 4] = "FourX";
    /** Multi-sample anti-aliasing with 8 samples. */ MSAASamples[MSAASamples["EightX"] = 8] = "EightX";
    return MSAASamples;
}({});

/**
 * The strategy to use when a shader replacement fails.
 */ var ReplacementFailureStrategy = /*#__PURE__*/ function(ReplacementFailureStrategy) {
    /** Keep the original shader. */ ReplacementFailureStrategy[ReplacementFailureStrategy["KeepOriginalShader"] = 0] = "KeepOriginalShader";
    /** Do not render. */ ReplacementFailureStrategy[ReplacementFailureStrategy["DoNotRender"] = 1] = "DoNotRender";
    return ReplacementFailureStrategy;
}({});

var MathTemp = function MathTemp() {
};
MathTemp.tempVec4 = new Vector4();
MathTemp.tempVec3 = new Vector3();
MathTemp.tempVec2 = new Vector2();
var Camera = /*#__PURE__*/ function(Component) {
    _inherits$2(Camera, Component);
    function Camera(entity) {
        var _this;
        _this = Component.call(this, entity) || this, /** Whether to enable frustum culling, it is enabled by default. */ _this.enableFrustumCulling = true, /**
   * Determining what to clear when rendering by a Camera.
   *
   * @defaultValue `CameraClearFlags.All`
   */ _this.clearFlags = CameraClearFlags.All, /**
   * Culling mask - which layers the camera renders.
   * @remarks Support bit manipulation, corresponding to `Layer`.
   */ _this.cullingMask = Layer.Everything, /**
   * Determines which PostProcess to use.
   */ _this.postProcessMask = Layer.Everything, /**
   * Depth texture mode.
   * If `DepthTextureMode.PrePass` is used, the depth texture can be accessed in the shader using `camera_DepthTexture`.
   *
   * @defaultValue `DepthTextureMode.None`
   */ _this.depthTextureMode = DepthTextureMode.None, /**
   * Opacity texture down sampling.
   *
   * @defaultValue `Downsampling.TwoX`
   */ _this.opaqueTextureDownsampling = Downsampling.TwoX, /**
   * The screen-space anti-aliasing mode applied after the camera renders the final image.
   * Unlike MSAA, it can smooth all pixels, including by shader-generated specular, alpha-cutoff edge.
   *
   * @defaultValue `AntiAliasing.None`
   */ _this.antiAliasing = AntiAliasing.None, /**
   * Determines whether to preserve the alpha channel in the output.
   * When set to true, the alpha channel is always preserved.
   * When set to false, the engine automatically decides whether to preserve it.
   *
   * @remarks
   * Set to true if you need to ensure the alpha channel is preserved, for example, when performing canvas transparent blending.
   *
   * @defaultValue `false`
   */ _this.isAlphaOutputRequired = false, /** @internal */ _this._cameraType = CameraType$1.Normal, /** @internal */ _this._globalShaderMacro = new ShaderMacroCollection(), /** @internal */ _this._frustum = new BoundingFrustum(), /** @internal */ _this._virtualCamera = new VirtualCamera(), /** @internal */ _this._replacementShader = null, /** @internal */ _this._replacementSubShaderTag = null, /** @internal */ _this._replacementFailureStrategy = null, /** @internal */ _this._cameraIndex = -1, _this._priority = 0, _this._shaderData = new ShaderData(ShaderDataGroup.Camera), _this._isCustomViewMatrix = false, _this._isCustomProjectionMatrix = false, _this._fieldOfView = 45, _this._orthographicSize = 10, _this._isProjectionDirty = true, _this._isInvProjMatDirty = true, _this._customAspectRatio = undefined, _this._renderTarget = null, _this._depthBufferParams = new Vector4(), _this._opaqueTextureEnabled = false, _this._enableHDR = false, _this._enablePostProcess = false, _this._viewport = new Vector4(0, 0, 1, 1), _this._pixelViewport = new Rect(0, 0, 0, 0), _this._inverseProjectionMatrix = new Matrix(), _this._invViewProjMat = new Matrix();
        // Includes hardware detection correction
        _this.msaaSamples = MSAASamples.FourX;
        _this._isViewMatrixDirty = entity.registerWorldChangeFlag();
        _this._isInvViewProjDirty = entity.registerWorldChangeFlag();
        _this._frustumChangeFlag = entity.registerWorldChangeFlag();
        _this._renderPipeline = new BasicRenderPipeline(_this);
        _this._addResourceReferCount(_this.shaderData, 1);
        _this._updatePixelViewport();
        _this._onPixelViewportChanged = _this._onPixelViewportChanged.bind(_this);
        //@ts-ignore
        _this._viewport._onValueChanged = _this._onPixelViewportChanged;
        _this.engine.canvas._sizeUpdateFlagManager.addListener(_this._onPixelViewportChanged);
        return _this;
    }
    var _proto = Camera.prototype;
    /**
   * Restore the view matrix to the world matrix of the entity.
   */ _proto.resetViewMatrix = function resetViewMatrix() {
        this._isCustomViewMatrix = false;
        this._viewMatrixChange();
    };
    /**
   * Restore the automatic calculation of projection matrix through fieldOfView, nearClipPlane and farClipPlane.
   */ _proto.resetProjectionMatrix = function resetProjectionMatrix() {
        this._isCustomProjectionMatrix = false;
        this._projectionMatrixChange();
    };
    /**
   * Restore the automatic calculation of the aspect ratio through the viewport aspect ratio.
   */ _proto.resetAspectRatio = function resetAspectRatio() {
        this._customAspectRatio = undefined;
        this._projectionMatrixChange();
        this._dispatchModify(CameraModifyFlags.AspectRatio);
    };
    /**
   * Transform a point from world space to viewport space.
   * @param point - Point in world space
   * @param out - Point in viewport space, X and Y are the camera viewport space coordinates, Z is in world space units from the plane that camera forward is normal to
   * @returns Point in viewport space
   */ _proto.worldToViewportPoint = function worldToViewportPoint(point, out) {
        var cameraPoint = MathTemp.tempVec3;
        var viewportPoint = MathTemp.tempVec4;
        Vector3.transformCoordinate(point, this.viewMatrix, cameraPoint);
        Vector3.transformToVec4(cameraPoint, this.projectionMatrix, viewportPoint);
        var w = viewportPoint.w;
        out.set((viewportPoint.x / w + 1.0) * 0.5, (1.0 - viewportPoint.y / w) * 0.5, -cameraPoint.z);
        return out;
    };
    /**
   * Transform a point from viewport space to world space.
   * @param point - Point in viewport space, X and Y are the camera viewport space coordinates, Z is in world space units from the plane that camera forward is normal to
   * @param out - Point in world space
   * @returns Point in world space
   */ _proto.viewportToWorldPoint = function viewportToWorldPoint(point, out) {
        var _this = this, nearClipPlane = _this.nearClipPlane, farClipPlane = _this.farClipPlane;
        var nf = 1 / (nearClipPlane - farClipPlane);
        var z;
        if (this.isOrthographic) {
            z = -point.z * 2 * nf;
            z += (farClipPlane + nearClipPlane) * nf;
        } else {
            var pointZ = point.z;
            z = -pointZ * (nearClipPlane + farClipPlane) * nf;
            z += 2 * nearClipPlane * farClipPlane * nf;
            z = z / pointZ;
        }
        this._innerViewportToWorldPoint(point.x, point.y, (z + 1.0) / 2.0, this._getInvViewProjMat(), out);
        return out;
    };
    /**
   * Generate a ray by a point in viewport.
   * @param point - Point in viewport space, X and Y are the camera viewport space coordinates
   * @param out - Ray
   * @returns Ray
   */ _proto.viewportPointToRay = function viewportPointToRay(point, out) {
        var invViewProjMat = this._getInvViewProjMat();
        // Use the intersection of the near clipping plane as the origin point.
        var origin = this._innerViewportToWorldPoint(point.x, point.y, 0.0, invViewProjMat, out.origin);
        // Use the intersection of the far clipping plane as the origin point.
        var direction = this._innerViewportToWorldPoint(point.x, point.y, 1 - MathUtil.zeroTolerance, invViewProjMat, out.direction);
        Vector3.subtract(direction, origin, direction);
        direction.normalize();
        return out;
    };
    /**
   * Transform the X and Y coordinates of a point from screen space to viewport space
   * @param point - Point in screen space
   * @param out - Point in viewport space
   * @returns Point in viewport space
   */ _proto.screenToViewportPoint = function screenToViewportPoint(point, out) {
        var canvas = this.engine.canvas;
        var viewport = this.viewport;
        out.x = (point.x / canvas.width - viewport.x) / viewport.z;
        out.y = (point.y / canvas.height - viewport.y) / viewport.w;
        point.z !== undefined && (out.z = point.z);
        return out;
    };
    /**
   * Transform the X and Y coordinates of a point from viewport space to screen space.
   * @param point - Point in viewport space
   * @param out - Point in screen space
   * @returns Point in screen space
   */ _proto.viewportToScreenPoint = function viewportToScreenPoint(point, out) {
        var canvas = this.engine.canvas;
        var viewport = this.viewport;
        out.x = (viewport.x + point.x * viewport.z) * canvas.width;
        out.y = (viewport.y + point.y * viewport.w) * canvas.height;
        point.z !== undefined && (out.z = point.z);
        return out;
    };
    /**
   * Transform a point from world space to screen space.
   *
   * @remarks
   * Screen space is defined in pixels, the left-top of the screen is (0,0), the right-top is (canvasPixelWidth,canvasPixelHeight).
   *
   * @param point - Point in world space
   * @param out - The result will be stored
   * @returns X and Y are the coordinates of the point in screen space, Z is the distance from the camera in world space
   */ _proto.worldToScreenPoint = function worldToScreenPoint(point, out) {
        this.worldToViewportPoint(point, out);
        return this.viewportToScreenPoint(out, out);
    };
    /**
   * Transform a point from screen space to world space.
   *
   * @param point - Screen space point, the top-left of the screen is (0,0), the right-bottom is (pixelWidth,pixelHeight), The z position is in world units from the camera
   * @param out - Point in world space
   * @returns Point in world space
   */ _proto.screenToWorldPoint = function screenToWorldPoint(point, out) {
        this.screenToViewportPoint(point, out);
        return this.viewportToWorldPoint(out, out);
    };
    /**
   * Generate a ray by a point in screen.
   * @param point - Point in screen space, the top-left of the screen is (0,0), the right-bottom is (pixelWidth,pixelHeight)
   * @param out - Ray
   * @returns Ray
   */ _proto.screenPointToRay = function screenPointToRay(point, out) {
        var viewportPoint = MathTemp.tempVec2;
        this.screenToViewportPoint(point, viewportPoint);
        return this.viewportPointToRay(viewportPoint, out);
    };
    /**
   * Manually call the rendering of the camera.
   * @param cubeFace - Cube rendering surface collection
   * @param mipLevel - Set mip level the data want to write, only take effect in webgl2.0
   */ _proto.render = function render(cubeFace, mipLevel) {
        if (mipLevel === void 0) mipLevel = 0;
        var engine = this._engine;
        var context = engine._renderContext;
        var virtualCamera = this._virtualCamera;
        var transform = this._entity.transform;
        Matrix.multiply(this.projectionMatrix, this.viewMatrix, virtualCamera.viewProjectionMatrix);
        virtualCamera.position.copyFrom(transform.worldPosition);
        if (virtualCamera.isOrthographic) {
            virtualCamera.forward.copyFrom(transform.worldForward);
        }
        context.camera = this;
        context.virtualCamera = virtualCamera;
        context.replacementShader = this._replacementShader;
        context.replacementTag = this._replacementSubShaderTag;
        context.replacementFailureStrategy = this._replacementFailureStrategy;
        // compute cull frustum.
        if (this.enableFrustumCulling && this._frustumChangeFlag.flag) {
            this._frustum.calculateFromMatrix(virtualCamera.viewProjectionMatrix);
            this._frustumChangeFlag.flag = false;
        }
        this._updateShaderData();
        // union scene and camera macro.
        ShaderMacroCollection.unionCollection(this.scene.shaderData._macroCollection, this.shaderData._macroCollection, this._globalShaderMacro);
        if (mipLevel > 0 && !engine._hardwareRenderer.isWebGL2) {
            mipLevel = 0;
            Logger.error("mipLevel only take effect in WebGL2.0");
        }
        var ignoreClearFlags;
        if (this._cameraType !== CameraType$1.Normal && !this._renderTarget && !this._isIndependentCanvasEnabled()) {
            ignoreClearFlags = engine.xrManager._getCameraIgnoreClearFlags(this._cameraType);
        }
        this._renderPipeline.render(context, cubeFace, mipLevel, ignoreClearFlags);
        engine._renderCount++;
        context.camera = null;
    };
    _proto.setReplacementShader = function setReplacementShader(shader, replacementTag, failureStrategy) {
        if (failureStrategy === void 0) failureStrategy = ReplacementFailureStrategy.KeepOriginalShader;
        this._replacementShader = shader;
        this._replacementSubShaderTag = typeof replacementTag === "string" ? ShaderTagKey.getByName(replacementTag) : replacementTag;
        this._replacementFailureStrategy = failureStrategy;
    };
    /**
   * Reset and clear the replacement shader.
   */ _proto.resetReplacementShader = function resetReplacementShader() {
        this._replacementShader = null;
        this._replacementSubShaderTag = null;
        this._replacementFailureStrategy = null;
    };
    /**
   * @inheritdoc
   */ _proto._onEnableInScene = function _onEnableInScene() {
        this.scene._componentsManager.addCamera(this);
        this._dispatchModify(CameraModifyFlags.EnableInScene);
    };
    /**
   * @inheritdoc
   */ _proto._onDisableInScene = function _onDisableInScene() {
        this.scene._componentsManager.removeCamera(this);
        this._dispatchModify(CameraModifyFlags.DisableInScene);
    };
    /**
   * @internal
   * Whether independent canvas is enabled.
   */ _proto._isIndependentCanvasEnabled = function _isIndependentCanvasEnabled() {
        // Uber pass need internal RT
        if (this.enablePostProcess && this.scene.postProcessManager._isValid()) {
            return true;
        }
        // Final pass should sRGB conversion and FXAA
        if (this._needFinalPass()) {
            return true;
        }
        var renderTarget = this._renderTarget;
        // Need HDR and opaque texture
        if (this.enableHDR || this.opaqueTextureEnabled) {
            if (renderTarget) {
                // If camera is HDR and format is same with renderTarget can reuse renderTarget if renderTarget is same HDR format
                // If camera is LDR and opaqueTextureEnabled is true, can reuse renderTarget if renderTarget is LDR format(Only R8G8B8A8)
                return this._getInternalColorTextureFormat() !== renderTarget.getColorTexture(0).format;
            } else {
                return true;
            }
        }
        return false;
    };
    /**
   * @internal
   */ _proto._getInternalColorTextureFormat = function _getInternalColorTextureFormat() {
        return this._enableHDR ? this.engine._hardwareRenderer.isWebGL2 && !this.isAlphaOutputRequired ? TextureFormat.R11G11B10_UFloat : TextureFormat.R16G16B16A16 : TextureFormat.R8G8B8A8;
    };
    /**
   * @internal
   */ _proto._needFinalPass = function _needFinalPass() {
        // FXAA or sRGB conversion when camera render to screen
        return this.antiAliasing === AntiAliasing.FXAA || !this._renderTarget;
    };
    /**
   * @internal
   */ _proto._getTargetColorTextureFormat = function _getTargetColorTextureFormat() {
        var renderTarget = this._renderTarget;
        return renderTarget ? renderTarget.getColorTexture(0).format : TextureFormat.R8G8B8A8;
    };
    /**
   * @internal
   */ _proto._isTargetFormatHDR = function _isTargetFormatHDR() {
        var format = this._getTargetColorTextureFormat();
        return format === TextureFormat.R16G16B16A16 || format === TextureFormat.R32G32B32A32 || format === TextureFormat.R11G11B10_UFloat;
    };
    /**
   * @internal
   */ _proto._registerModifyListener = function _registerModifyListener(onChange) {
        (this._updateFlagManager || (this._updateFlagManager = new UpdateFlagManager())).addListener(onChange);
    };
    /**
   * @internal
   */ _proto._unRegisterModifyListener = function _unRegisterModifyListener(onChange) {
        var _this__updateFlagManager;
        (_this__updateFlagManager = this._updateFlagManager) == null ? void 0 : _this__updateFlagManager.removeListener(onChange);
    };
    /**
   * @internal
   * @inheritdoc
   */ _proto._onDestroy = function _onDestroy() {
        var _this__renderPipeline;
        Component.prototype._onDestroy.call(this);
        (_this__renderPipeline = this._renderPipeline) == null ? void 0 : _this__renderPipeline.destroy();
        this._isInvViewProjDirty.destroy();
        this._isViewMatrixDirty.destroy();
        this._addResourceReferCount(this.shaderData, -1);
        //@ts-ignore
        this._viewport._onValueChanged = null;
        this.engine.canvas._sizeUpdateFlagManager.removeListener(this._onPixelViewportChanged);
        this._globalShaderMacro = null;
        this._frustum = null;
        this._renderPipeline = null;
        this._virtualCamera = null;
        this._shaderData = null;
        this._frustumChangeFlag = null;
        this._isViewMatrixDirty = null;
        this._isInvViewProjDirty = null;
        this._viewport = null;
        this._inverseProjectionMatrix = null;
        this._invViewProjMat = null;
    };
    _proto._updatePixelViewport = function _updatePixelViewport() {
        var width, height;
        var renderTarget = this._renderTarget;
        if (renderTarget) {
            width = renderTarget.width;
            height = renderTarget.height;
        } else {
            var canvas = this.engine.canvas;
            width = canvas.width;
            height = canvas.height;
        }
        var viewport = this._viewport;
        this._pixelViewport.set(viewport.x * width, viewport.y * height, viewport.z * width, viewport.w * height);
        !this._customAspectRatio && this._dispatchModify(CameraModifyFlags.AspectRatio);
    };
    _proto._viewMatrixChange = function _viewMatrixChange() {
        this._isViewMatrixDirty.flag = true;
        this._isInvViewProjDirty.flag = true;
        this._frustumChangeFlag.flag = true;
    };
    _proto._projectionMatrixChange = function _projectionMatrixChange() {
        this._isProjectionDirty = true;
        this._isInvProjMatDirty = true;
        this._isInvViewProjDirty.flag = true;
        this._frustumChangeFlag.flag = true;
    };
    _proto._innerViewportToWorldPoint = function _innerViewportToWorldPoint(x, y, z, invViewProjMat, out) {
        // Depth is a normalized value, 0 is nearPlane, 1 is farClipPlane.
        // Transform to clipping space matrix
        var clipPoint = MathTemp.tempVec3;
        clipPoint.set(x * 2 - 1, 1 - y * 2, z * 2 - 1);
        Vector3.transformCoordinate(clipPoint, invViewProjMat, out);
        return out;
    };
    _proto._updateShaderData = function _updateShaderData() {
        var shaderData = this.shaderData;
        var transform = this._entity.transform;
        shaderData.setMatrix(Camera._inverseViewMatrixProperty, transform.worldMatrix);
        shaderData.setVector3(Camera._cameraPositionProperty, transform.worldPosition);
        shaderData.setVector3(Camera._cameraForwardProperty, transform.worldForward);
        shaderData.setVector3(Camera._cameraUpProperty, transform.worldUp);
        var depthBufferParams = this._depthBufferParams;
        var farDivideNear = this.farClipPlane / this.nearClipPlane;
        depthBufferParams.set(1.0 - farDivideNear, farDivideNear, 0, 0);
        shaderData.setVector4(Camera._cameraDepthBufferParamsProperty, depthBufferParams);
    };
    /**
   * The inverse matrix of view projection matrix.
   */ _proto._getInvViewProjMat = function _getInvViewProjMat() {
        if (this._isInvViewProjDirty.flag) {
            this._isInvViewProjDirty.flag = false;
            Matrix.multiply(this._entity.transform.worldMatrix, this._getInverseProjectionMatrix(), this._invViewProjMat);
        }
        return this._invViewProjMat;
    };
    /**
   * The inverse of the projection matrix.
   */ _proto._getInverseProjectionMatrix = function _getInverseProjectionMatrix() {
        if (this._isInvProjMatDirty) {
            this._isInvProjMatDirty = false;
            Matrix.invert(this.projectionMatrix, this._inverseProjectionMatrix);
        }
        return this._inverseProjectionMatrix;
    };
    _proto._onPixelViewportChanged = function _onPixelViewportChanged() {
        this._updatePixelViewport();
        var _this__customAspectRatio;
        (_this__customAspectRatio = this._customAspectRatio) != null ? _this__customAspectRatio : this._projectionMatrixChange();
    };
    _proto._dispatchModify = function _dispatchModify(flag) {
        var _this__updateFlagManager;
        (_this__updateFlagManager = this._updateFlagManager) == null ? void 0 : _this__updateFlagManager.dispatch(flag);
    };
    _create_class$2(Camera, [
        {
            key: "opaqueTextureEnabled",
            get: /**
   * Whether to enable opaque texture.
   * If enabled, the opaque texture can be accessed in the shader using `camera_OpaqueTexture`.
   *
   * @defaultValue `false`
   */ function get() {
                return this._opaqueTextureEnabled;
            },
            set: function set(value) {
                this._opaqueTextureEnabled = value;
            }
        },
        {
            key: "shaderData",
            get: /**
   * Shader data.
   */ function get() {
                return this._shaderData;
            }
        },
        {
            key: "nearClipPlane",
            get: /**
   * Near clip plane - the closest point to the camera when rendering occurs.
   */ function get() {
                return this._virtualCamera.nearClipPlane;
            },
            set: function set(value) {
                this._virtualCamera.nearClipPlane = value;
                this._projectionMatrixChange();
            }
        },
        {
            key: "farClipPlane",
            get: /**
   * Far clip plane - the furthest point to the camera when rendering occurs.
   */ function get() {
                return this._virtualCamera.farClipPlane;
            },
            set: function set(value) {
                this._virtualCamera.farClipPlane = value;
                this._projectionMatrixChange();
            }
        },
        {
            key: "fieldOfView",
            get: /**
   * The camera's view angle. activating when camera use perspective projection.
   */ function get() {
                return this._fieldOfView;
            },
            set: function set(value) {
                if (this._fieldOfView !== value) {
                    this._fieldOfView = value;
                    this._projectionMatrixChange();
                    this._dispatchModify(CameraModifyFlags.FieldOfView);
                }
            }
        },
        {
            key: "aspectRatio",
            get: /**
   * Aspect ratio. The default is automatically calculated by the viewport's aspect ratio. If it is manually set,
   * the manual value will be kept. Call resetAspectRatio() to restore it.
   */ function get() {
                var pixelViewport = this.pixelViewport;
                var _this__customAspectRatio;
                return (_this__customAspectRatio = this._customAspectRatio) != null ? _this__customAspectRatio : pixelViewport.width / pixelViewport.height;
            },
            set: function set(value) {
                this._customAspectRatio = value;
                this._projectionMatrixChange();
                this._dispatchModify(CameraModifyFlags.AspectRatio);
            }
        },
        {
            key: "viewport",
            get: /**
   * The viewport of the camera in normalized coordinates on the screen.
   * In normalized screen coordinates, the upper-left corner is (0, 0), and the lower-right corner is (1.0, 1.0).
   * @remarks Re-assignment is required after modification to ensure that the modification takes effect.
   */ function get() {
                return this._viewport;
            },
            set: function set(value) {
                if (value !== this._viewport) {
                    this._viewport.copyFrom(value);
                }
            }
        },
        {
            key: "pixelViewport",
            get: /**
   * The viewport of the camera in pixel coordinates on the screen.
   * In pixel screen coordinates, the upper-left corner is (0, 0), and the lower-right corner is (1.0, 1.0).
   */ function get() {
                return this._pixelViewport;
            }
        },
        {
            key: "priority",
            get: /**
   * Rendering priority, higher priority will be rendered on top of a camera with lower priority.
   */ function get() {
                return this._priority;
            },
            set: function set(value) {
                if (this._priority !== value) {
                    if (this._phasedActiveInScene) {
                        this.scene._componentsManager._cameraNeedSorting = true;
                    }
                    this._priority = value;
                }
            }
        },
        {
            key: "isOrthographic",
            get: /**
   * Whether it is orthogonal, the default is false. True will use orthographic projection, false will use perspective projection.
   */ function get() {
                return this._virtualCamera.isOrthographic;
            },
            set: function set(value) {
                var _this = this, virtualCamera = _this._virtualCamera;
                if (virtualCamera.isOrthographic !== value) {
                    virtualCamera.isOrthographic = value;
                    this._projectionMatrixChange();
                    if (value) {
                        this.shaderData.enableMacro("CAMERA_ORTHOGRAPHIC");
                    } else {
                        this.shaderData.disableMacro("CAMERA_ORTHOGRAPHIC");
                    }
                    this._dispatchModify(CameraModifyFlags.ProjectionType);
                }
            }
        },
        {
            key: "orthographicSize",
            get: /**
   * Half the size of the camera in orthographic mode.
   */ function get() {
                return this._orthographicSize;
            },
            set: function set(value) {
                if (this._orthographicSize !== value) {
                    this._orthographicSize = value;
                    this._projectionMatrixChange();
                    this._dispatchModify(CameraModifyFlags.OrthographicSize);
                }
            }
        },
        {
            key: "viewMatrix",
            get: /**
   * View matrix.
   */ function get() {
                var viewMatrix = this._virtualCamera.viewMatrix;
                if (!this._isViewMatrixDirty.flag || this._isCustomViewMatrix) {
                    return viewMatrix;
                }
                this._isViewMatrixDirty.flag = false;
                // Ignore scale
                var transform = this._entity.transform;
                Matrix.rotationTranslation(transform.worldRotationQuaternion, transform.worldPosition, viewMatrix);
                viewMatrix.invert();
                return viewMatrix;
            },
            set: function set(value) {
                this._virtualCamera.viewMatrix.copyFrom(value);
                this._isCustomViewMatrix = true;
                this._viewMatrixChange();
            }
        },
        {
            key: "projectionMatrix",
            get: /**
   * The projection matrix is ​​calculated by the relevant parameters of the camera by default.
   * If it is manually set, the manual value will be maintained. Call resetProjectionMatrix() to restore it.
   */ function get() {
                var virtualCamera = this._virtualCamera;
                var projectionMatrix = virtualCamera.projectionMatrix;
                if (!this._isProjectionDirty || this._isCustomProjectionMatrix) {
                    return projectionMatrix;
                }
                this._isProjectionDirty = false;
                var aspectRatio = this.aspectRatio;
                if (!virtualCamera.isOrthographic) {
                    Matrix.perspective(MathUtil.degreeToRadian(this._fieldOfView), aspectRatio, this.nearClipPlane, this.farClipPlane, projectionMatrix);
                } else {
                    var width = this._orthographicSize * aspectRatio;
                    var height = this._orthographicSize;
                    Matrix.ortho(-width, width, -height, height, this.nearClipPlane, this.farClipPlane, projectionMatrix);
                }
                return projectionMatrix;
            },
            set: function set(value) {
                this._virtualCamera.projectionMatrix.copyFrom(value);
                this._isCustomProjectionMatrix = true;
                this._projectionMatrixChange();
            }
        },
        {
            key: "enableHDR",
            get: /**
   * Whether to enable HDR.
   * @defaultValue `false`
   */ function get() {
                return this._enableHDR;
            },
            set: function set(value) {
                if (this.enableHDR !== value) {
                    var rhi = this.engine._hardwareRenderer;
                    var supportHDR = rhi.isWebGL2 || rhi.canIUse(GLCapabilityType.textureHalfFloat);
                    if (value && !supportHDR) {
                        Logger.warn("Can't enable HDR in this device.");
                        return;
                    }
                    this._enableHDR = value;
                }
            }
        },
        {
            key: "enablePostProcess",
            get: /**
   * Whether to enable post process.
   * @defaultValue `false`
   */ function get() {
                return this._enablePostProcess;
            },
            set: function set(value) {
                if (this._enablePostProcess !== value) {
                    this._enablePostProcess = value;
                }
            }
        },
        {
            key: "renderTarget",
            get: /**
   * RenderTarget. After setting, it will be rendered to the renderTarget. If it is empty, it will be rendered to the main canvas.
   */ function get() {
                return this._renderTarget;
            },
            set: function set(value) {
                if (this._renderTarget !== value) {
                    this._renderTarget && this._addResourceReferCount(this._renderTarget, -1);
                    value && this._addResourceReferCount(value, 1);
                    this._renderTarget = value;
                    this._onPixelViewportChanged();
                }
            }
        },
        {
            key: "msaaSamples",
            get: /**
   * The number of samples used for hardware multisample anti-aliasing (MSAA) to smooth geometry edges during rasterization.
   * Higher sample counts (e.g., 2x, 4x, 8x) produce smoother edges.
   *
   * @defaultValue `MSAASamples.FourX`
   */ function get() {
                return this._msaaSamples;
            },
            set: function set(value) {
                if (this._msaaSamples !== value) {
                    var maxMSAASamples = this._engine._hardwareRenderer.capability.maxAntiAliasing;
                    if (value > maxMSAASamples) {
                        Logger.warn("MSAA samples exceeds the limit and is automatically downgraded to:" + maxMSAASamples);
                        this._msaaSamples = maxMSAASamples;
                    } else {
                        this._msaaSamples = value;
                    }
                }
            }
        }
    ]);
    return Camera;
}(Component);
/** @internal */ Camera._cameraDepthTextureProperty = ShaderProperty.getByName("camera_DepthTexture");
/** @internal */ Camera._cameraOpaqueTextureProperty = ShaderProperty.getByName("camera_OpaqueTexture");
Camera._inverseViewMatrixProperty = ShaderProperty.getByName("camera_ViewInvMat");
Camera._cameraPositionProperty = ShaderProperty.getByName("camera_Position");
Camera._cameraForwardProperty = ShaderProperty.getByName("camera_Forward");
Camera._cameraUpProperty = ShaderProperty.getByName("camera_Up");
Camera._cameraDepthBufferParamsProperty = ShaderProperty.getByName("camera_DepthBufferParams");
__decorate$1([
    deepClone
], Camera.prototype, "_frustum", void 0);
__decorate$1([
    ignoreClone
], Camera.prototype, "_renderPipeline", void 0);
__decorate$1([
    ignoreClone
], Camera.prototype, "_virtualCamera", void 0);
__decorate$1([
    ignoreClone
], Camera.prototype, "_cameraIndex", void 0);
__decorate$1([
    ignoreClone
], Camera.prototype, "_updateFlagManager", void 0);
__decorate$1([
    ignoreClone
], Camera.prototype, "_frustumChangeFlag", void 0);
__decorate$1([
    ignoreClone
], Camera.prototype, "_isViewMatrixDirty", void 0);
__decorate$1([
    ignoreClone
], Camera.prototype, "_isInvViewProjDirty", void 0);
__decorate$1([
    deepClone
], Camera.prototype, "_viewport", void 0);
__decorate$1([
    deepClone
], Camera.prototype, "_pixelViewport", void 0);
__decorate$1([
    deepClone
], Camera.prototype, "_inverseProjectionMatrix", void 0);
__decorate$1([
    deepClone
], Camera.prototype, "_invViewProjMat", void 0);
__decorate$1([
    ignoreClone
], Camera.prototype, "_onPixelViewportChanged", null);
Camera = __decorate$1([
    dependentComponents(Transform, DependentMode.CheckOnly)
], Camera);

var blitVs = "#define GLSLIFY 1\nattribute vec4 POSITION_UV;\nvarying vec2 v_uv;\n\nvoid main() {\t\n\tgl_Position = vec4(POSITION_UV.xy, 0.0, 1.0);\t\n\tv_uv = POSITION_UV.zw;\n}"; // eslint-disable-line

/**
 * Represents a parameter of a post process effect.
 * @remarks
 * The parameter will be mixed to a final value and be used in post process manager.
 */ var PostProcessEffectParameter = /*#__PURE__*/ function() {
    function PostProcessEffectParameter(value, needLerp) {
        if (needLerp === void 0) needLerp = false;
        /**
   * Whether the parameter is enabled.
   */ this.enabled = true;
        this._needLerp = false;
        this._needLerp = needLerp;
        this._value = value;
    }
    var _proto = PostProcessEffectParameter.prototype;
    /**
   * @internal
   */ _proto._lerp = function _lerp(to, factor) {
        if (factor > 0) {
            this.value = to;
        }
    };
    _create_class$2(PostProcessEffectParameter, [
        {
            key: "value",
            get: /**
   * The value of the parameter.
   */ function get() {
                return this._value;
            },
            set: function set(value) {
                this._value = value;
            }
        }
    ]);
    return PostProcessEffectParameter;
}();
/**
 * Represents a float parameter of a post process effect.
 */ var PostProcessEffectFloatParameter = /*#__PURE__*/ function(PostProcessEffectParameter) {
    _inherits$2(PostProcessEffectFloatParameter, PostProcessEffectParameter);
    function PostProcessEffectFloatParameter(value, min, max, needLerp) {
        if (min === void 0) min = Number.NEGATIVE_INFINITY;
        if (max === void 0) max = Number.POSITIVE_INFINITY;
        if (needLerp === void 0) needLerp = true;
        var _this;
        _this = PostProcessEffectParameter.call(this, value, needLerp) || this, _this.min = min, _this.max = max;
        _this.value = value;
        return _this;
    }
    var _proto = PostProcessEffectFloatParameter.prototype;
    _proto._lerp = function _lerp(to, factor) {
        if (this._needLerp) {
            this.value = MathUtil.lerp(this.value, to, factor);
        } else {
            PostProcessEffectParameter.prototype._lerp.call(this, to, factor);
        }
    };
    _create_class$2(PostProcessEffectFloatParameter, [
        {
            key: "value",
            get: function get() {
                return this._value;
            },
            set: function set(v) {
                this._value = MathUtil.clamp(v, this.min, this.max);
            }
        }
    ]);
    return PostProcessEffectFloatParameter;
}(PostProcessEffectParameter);
/**
 * Represents a boolean parameter of a post process effect.
 */ var PostProcessEffectBoolParameter = /*#__PURE__*/ function(PostProcessEffectParameter) {
    _inherits$2(PostProcessEffectBoolParameter, PostProcessEffectParameter);
    function PostProcessEffectBoolParameter(value) {
        return PostProcessEffectParameter.call(this, value, false) || this;
    }
    return PostProcessEffectBoolParameter;
}(PostProcessEffectParameter);
/**
 * Represents a texture parameter of a post process effect.
 */ var PostProcessEffectTextureParameter = /*#__PURE__*/ function(PostProcessEffectParameter) {
    _inherits$2(PostProcessEffectTextureParameter, PostProcessEffectParameter);
    function PostProcessEffectTextureParameter(value) {
        return PostProcessEffectParameter.call(this, value, false) || this;
    }
    return PostProcessEffectTextureParameter;
}(PostProcessEffectParameter);
/**
 * Represents a color parameter of a post process effect.
 */ var PostProcessEffectColorParameter = /*#__PURE__*/ function(PostProcessEffectParameter) {
    _inherits$2(PostProcessEffectColorParameter, PostProcessEffectParameter);
    function PostProcessEffectColorParameter(value, needLerp) {
        if (needLerp === void 0) needLerp = true;
        return PostProcessEffectParameter.call(this, value, needLerp) || this;
    }
    var _proto = PostProcessEffectColorParameter.prototype;
    _proto._lerp = function _lerp(to, factor) {
        if (this._needLerp) {
            Color.lerp(this.value, to, factor, this.value);
        } else {
            PostProcessEffectParameter.prototype._lerp.call(this, to, factor);
        }
    };
    return PostProcessEffectColorParameter;
}(PostProcessEffectParameter);
/**
 * Represents a vector2 parameter of a post process effect.
 */ var PostProcessEffectVector2Parameter = /*#__PURE__*/ function(PostProcessEffectParameter) {
    _inherits$2(PostProcessEffectVector2Parameter, PostProcessEffectParameter);
    function PostProcessEffectVector2Parameter(value, needLerp) {
        if (needLerp === void 0) needLerp = true;
        return PostProcessEffectParameter.call(this, value, needLerp) || this;
    }
    var _proto = PostProcessEffectVector2Parameter.prototype;
    _proto._lerp = function _lerp(to, factor) {
        if (this._needLerp) {
            Vector2.lerp(this.value, to, factor, this.value);
        } else {
            PostProcessEffectParameter.prototype._lerp.call(this, to, factor);
        }
    };
    return PostProcessEffectVector2Parameter;
}(PostProcessEffectParameter);
/**
 * Represents a vector3 parameter of a post process effect.
 */ var PostProcessEffectVector3Parameter = /*#__PURE__*/ function(PostProcessEffectParameter) {
    _inherits$2(PostProcessEffectVector3Parameter, PostProcessEffectParameter);
    function PostProcessEffectVector3Parameter(value, needLerp) {
        if (needLerp === void 0) needLerp = true;
        return PostProcessEffectParameter.call(this, value, needLerp) || this;
    }
    var _proto = PostProcessEffectVector3Parameter.prototype;
    _proto._lerp = function _lerp(to, factor) {
        if (this._needLerp) {
            Vector3.lerp(this.value, to, factor, this.value);
        } else {
            PostProcessEffectParameter.prototype._lerp.call(this, to, factor);
        }
    };
    return PostProcessEffectVector3Parameter;
}(PostProcessEffectParameter);
/**
 * Represents a vector4 parameter of a post process effect.
 */ var PostProcessEffectVector4Parameter = /*#__PURE__*/ function(PostProcessEffectParameter) {
    _inherits$2(PostProcessEffectVector4Parameter, PostProcessEffectParameter);
    function PostProcessEffectVector4Parameter(value, needLerp) {
        if (needLerp === void 0) needLerp = true;
        return PostProcessEffectParameter.call(this, value, needLerp) || this;
    }
    var _proto = PostProcessEffectVector4Parameter.prototype;
    _proto._lerp = function _lerp(to, factor) {
        if (this._needLerp) {
            Vector4.lerp(this.value, to, factor, this.value);
        } else {
            PostProcessEffectParameter.prototype._lerp.call(this, to, factor);
        }
    };
    return PostProcessEffectVector4Parameter;
}(PostProcessEffectParameter);
/**
 * Represents a enum parameter of a post process effect.
 */ var PostProcessEffectEnumParameter = /*#__PURE__*/ function(PostProcessEffectParameter) {
    _inherits$2(PostProcessEffectEnumParameter, PostProcessEffectParameter);
    function PostProcessEffectEnumParameter(enumType, value) {
        var _this;
        _this = PostProcessEffectParameter.call(this, value, false) || this, _this.enumType = enumType;
        return _this;
    }
    return PostProcessEffectEnumParameter;
}(PostProcessEffectParameter);

/**
 * The base class for post process effect.
 */ var PostProcessEffect = /*#__PURE__*/ function() {
    function PostProcessEffect() {
        this._enabled = true;
        this._parameters = [];
        this._parameterInitialized = false;
    }
    var _proto = PostProcessEffect.prototype;
    /**
   * Whether the post process effect is valid.
   * @remarks
   * This method can be overridden to control the effect's real validity.
   */ _proto.isValid = function isValid() {
        return this._enabled;
    };
    /**
   * @internal
   */ _proto._lerp = function _lerp(to, factor) {
        var parameters = this._getParameters();
        var toParameters = to._getParameters();
        for(var i = 0, n = parameters.length; i < n; i++){
            var toParameter = toParameters[i];
            if (toParameter.enabled) {
                parameters[i]._lerp(toParameter.value, factor);
            }
        }
    };
    /**
   * Get all parameters of the post process effect.
   * @remarks
   * Only get the parameters that are initialized in the constructor.
   * It will don't take effect if you add a new parameter after the post process effect is created, such as `effect.** = new PostProcessEffectParameter(1)`
   */ _proto._getParameters = function _getParameters() {
        if (!this._parameterInitialized) {
            this._parameterInitialized = true;
            for(var key in this){
                var value = this[key];
                if (_instanceof$3(value, PostProcessEffectParameter)) {
                    this._parameters.push(value);
                }
            }
        }
        return this._parameters;
    };
    _create_class$2(PostProcessEffect, [
        {
            key: "enabled",
            get: /**
   * Indicates whether the post process effect is enabled.
   */ function get() {
                return this._enabled;
            },
            set: function set(value) {
                if (value === this._enabled) {
                    return;
                }
                this._enabled = value;
            }
        }
    ]);
    return PostProcessEffect;
}();

var fragBlurH = "#define GLSLIFY 1\n#include <PostCommon>\n\nvarying vec2 v_uv;\nuniform sampler2D renderer_BlitTexture;\nuniform vec4 renderer_texelSize;    // x: 1/width, y: 1/height, z: width, w: height\n\nvoid main(){\n\tvec2 texelSize = renderer_texelSize.xy * 2.0;\n\n    // 9-tap gaussian blur on the downsampled source\n    mediump vec4 c0 = texture2DSRGB(renderer_BlitTexture, v_uv - vec2(texelSize.x * 4.0, 0.0));\n    mediump vec4 c1 = texture2DSRGB(renderer_BlitTexture, v_uv - vec2(texelSize.x * 3.0, 0.0));\n    mediump vec4 c2 = texture2DSRGB(renderer_BlitTexture, v_uv - vec2(texelSize.x * 2.0, 0.0));\n    mediump vec4 c3 = texture2DSRGB(renderer_BlitTexture, v_uv - vec2(texelSize.x * 1.0, 0.0));\n    mediump vec4 c4 = texture2DSRGB(renderer_BlitTexture, v_uv);\n    mediump vec4 c5 = texture2DSRGB(renderer_BlitTexture, v_uv + vec2(texelSize.x * 1.0, 0.0));\n    mediump vec4 c6 = texture2DSRGB(renderer_BlitTexture, v_uv + vec2(texelSize.x * 2.0, 0.0));\n    mediump vec4 c7 = texture2DSRGB(renderer_BlitTexture, v_uv + vec2(texelSize.x * 3.0, 0.0));\n    mediump vec4 c8 = texture2DSRGB(renderer_BlitTexture, v_uv + vec2(texelSize.x * 4.0, 0.0));\n\n    gl_FragColor = c0 * 0.01621622 + c1 * 0.05405405 + c2 * 0.12162162 + c3 * 0.19459459\n                + c4 * 0.22702703\n                + c5 * 0.19459459 + c6 * 0.12162162 + c7 * 0.05405405 + c8 * 0.01621622;\n}"; // eslint-disable-line

var fragBlurV = "#define GLSLIFY 1\n#include <PostCommon>\n\nvarying vec2 v_uv;\nuniform sampler2D renderer_BlitTexture;\nuniform vec4 renderer_texelSize;    // x: 1/width, y: 1/height, z: width, w: height\n\nvoid main(){\n    vec2 texelSize = renderer_texelSize.xy;\n\n    // Optimized bilinear 5-tap gaussian on the same-sized source (9-tap equivalent)\n    mediump vec4 c0 = texture2DSRGB(renderer_BlitTexture, v_uv - vec2(0.0, texelSize.y * 3.23076923));\n    mediump vec4 c1 = texture2DSRGB(renderer_BlitTexture, v_uv - vec2(0.0, texelSize.y * 1.38461538));\n    mediump vec4 c2 = texture2DSRGB(renderer_BlitTexture, v_uv);\n    mediump vec4 c3 = texture2DSRGB(renderer_BlitTexture, v_uv + vec2(0.0, texelSize.y * 1.38461538));\n    mediump vec4 c4 = texture2DSRGB(renderer_BlitTexture, v_uv + vec2(0.0, texelSize.y * 3.23076923));\n\n    gl_FragColor = c0 * 0.07027027 + c1 * 0.31621622\n                        + c2 * 0.22702703\n                        + c3 * 0.31621622 + c4 * 0.07027027;\n}"; // eslint-disable-line

var fragPrefilter = "#define GLSLIFY 1\n#include <PostCommon>\n\nvarying vec2 v_uv;\nuniform sampler2D renderer_BlitTexture;\nuniform vec4 material_BloomParams;  // x: threshold (linear), y: threshold knee, z: scatter\nuniform vec4 renderer_texelSize;    // x: 1/width, y: 1/height, z: width, w: height\n\nvoid main(){\n\t#ifdef BLOOM_HQ\n      vec2 texelSize = renderer_texelSize.xy;\n      mediump vec4 A = texture2DSRGB(renderer_BlitTexture, v_uv + texelSize * vec2(-1.0, -1.0));\n      mediump vec4 B = texture2DSRGB(renderer_BlitTexture, v_uv + texelSize * vec2(0.0, -1.0));\n      mediump vec4 C = texture2DSRGB(renderer_BlitTexture, v_uv + texelSize * vec2(1.0, -1.0));\n      mediump vec4 D = texture2DSRGB(renderer_BlitTexture, v_uv + texelSize * vec2(-0.5, -0.5));\n      mediump vec4 E = texture2DSRGB(renderer_BlitTexture, v_uv + texelSize * vec2(0.5, -0.5));\n      mediump vec4 F = texture2DSRGB(renderer_BlitTexture, v_uv + texelSize * vec2(-1.0, 0.0));\n      mediump vec4 G = texture2DSRGB(renderer_BlitTexture, v_uv);\n      mediump vec4 H = texture2DSRGB(renderer_BlitTexture, v_uv + texelSize * vec2(1.0, 0.0));\n      mediump vec4 I = texture2DSRGB(renderer_BlitTexture, v_uv + texelSize * vec2(-0.5, 0.5));\n      mediump vec4 J = texture2DSRGB(renderer_BlitTexture, v_uv + texelSize * vec2(0.5, 0.5));\n      mediump vec4 K = texture2DSRGB(renderer_BlitTexture, v_uv + texelSize * vec2(-1.0, 1.0));\n      mediump vec4 L = texture2DSRGB(renderer_BlitTexture, v_uv + texelSize * vec2(0.0, 1.0));\n      mediump vec4 M = texture2DSRGB(renderer_BlitTexture, v_uv + texelSize * vec2(1.0, 1.0));\n\n      mediump vec2 scale = vec2(0.5, 0.125);\n      mediump vec2 div = (1.0 / 4.0) * scale;\n\n      mediump vec4 samplerColor = (D + E + I + J) * div.x;\n      samplerColor += (A + B + G + F) * div.y;\n      samplerColor += (B + C + H + G) * div.y;\n      samplerColor += (F + G + L + K) * div.y;\n      samplerColor += (G + H + M + L) * div.y;\n    #else\n      mediump vec4 samplerColor = texture2DSRGB(renderer_BlitTexture, v_uv);\n    #endif\n\n    mediump vec3 color = samplerColor.rgb;\n\n    // User controlled clamp to limit crazy high broken spec\n    color = min(color, HALF_MAX);\n\n    // Thresholding\n    mediump float brightness = max3(color);\n    float threshold = material_BloomParams.x;\n    float thresholdKnee = material_BloomParams.y;\n    mediump float softness = clamp(brightness - threshold + thresholdKnee, 0.0, 2.0 * thresholdKnee);\n    softness = (softness * softness) / (4.0 * thresholdKnee + 1e-4);\n    mediump float multiplier = max(brightness - threshold, softness) / max(brightness, 1e-4);\n    color *= multiplier;\n\n    // Clamp colors to positive once in prefilter. Encode can have a sqrt, and sqrt(-x) == NaN. Up/Downsample passes would then spread the NaN.\n    color = max(color, 0.0);\n\n    // Bloom is addtive blend mode, we should set alpha 0 to avoid browser background color dark when canvas alpha and premultiplyAlpha is true\n    gl_FragColor = vec4(color, 0.0);\n}\n"; // eslint-disable-line

var fragUpsample = "#define GLSLIFY 1\n#include <PostCommon>\n#include <Filtering>\n\nvarying vec2 v_uv;\nuniform sampler2D renderer_BlitTexture;\nuniform sampler2D material_lowMipTexture;\nuniform vec4 material_BloomParams;        // x: threshold (linear), y: threshold knee, z: scatter\nuniform vec4 material_lowMipTexelSize;    // x: 1/width, y: 1/height, z: width, w: height\n\nvoid main(){\n    mediump vec4 highMip = texture2DSRGB(renderer_BlitTexture, v_uv);\n\n    #ifdef BLOOM_HQ\n      mediump vec4 lowMip = sampleTexture2DBicubic(material_lowMipTexture, v_uv, material_lowMipTexelSize);\n    #else\n      mediump vec4 lowMip = texture2DSRGB(material_lowMipTexture, v_uv);\n    #endif\n    \n    gl_FragColor = mix(highMip, lowMip, material_BloomParams.z);\n}"; // eslint-disable-line

/**
 * This controls the size of the bloom texture.
 */ var BloomDownScaleMode = /*#__PURE__*/ function(BloomDownScaleMode) {
    /** Use this to select half size as the starting resolution. */ BloomDownScaleMode[BloomDownScaleMode["Half"] = 0] = "Half";
    /** Use this to select quarter size as the starting resolution. */ BloomDownScaleMode[BloomDownScaleMode["Quarter"] = 1] = "Quarter";
    return BloomDownScaleMode;
}({});
var BloomEffect = /*#__PURE__*/ function(PostProcessEffect) {
    _inherits$2(BloomEffect, PostProcessEffect);
    function BloomEffect() {
        var _this;
        _this = PostProcessEffect.apply(this, arguments) || this, /**
   * Controls whether to use bicubic sampling instead of bilinear sampling for the upSampling passes.
   * @remarks This is slightly more expensive but helps getting smoother visuals.
   */ _this.highQualityFiltering = new PostProcessEffectBoolParameter(false), /**
   * Controls the starting resolution that this effect begins processing.
   */ _this.downScale = new PostProcessEffectEnumParameter(BloomDownScaleMode, 0), /**
   * Specifies a Texture to add smudges or dust to the bloom effect.
   */ _this.dirtTexture = new PostProcessEffectTextureParameter(null), /**
   * Set the level of brightness to filter out pixels under this level.
   * @remarks This value is expressed in linear.
   */ _this.threshold = new PostProcessEffectFloatParameter(0.8, 0), /**
   * Controls the radius of the bloom effect.
   */ _this.scatter = new PostProcessEffectFloatParameter(0.7, 0, 1), /**
   * Controls the strength of the bloom effect.
   */ _this.intensity = new PostProcessEffectFloatParameter(0, 0), /**
   * Controls the strength of the lens dirt.
   */ _this.dirtIntensity = new PostProcessEffectFloatParameter(0, 0), /**
   * Specifies the tint of the bloom effect.
   */ _this.tint = new PostProcessEffectColorParameter(new Color(1, 1, 1, 1));
        return _this;
    }
    var _proto = BloomEffect.prototype;
    /** @inheritdoc */ _proto.isValid = function isValid() {
        return this.enabled && this.intensity.value > 0;
    };
    return BloomEffect;
}(PostProcessEffect);
BloomEffect.SHADER_NAME = "PostProcessEffect Bloom";
// Bloom shader properties
/** @internal */ BloomEffect._maxIterations = 6;
/** @internal */ BloomEffect._hqMacro = ShaderMacro.getByName("BLOOM_HQ");
/** @internal */ BloomEffect._dirtMacro = ShaderMacro.getByName("BLOOM_DIRT");
/** @internal */ BloomEffect._bloomParams = ShaderProperty.getByName("material_BloomParams") // x: threshold (linear), y: threshold knee, z: scatter
;
/** @internal */ BloomEffect._lowMipTextureProp = ShaderProperty.getByName("material_lowMipTexture");
/** @internal */ BloomEffect._lowMipTexelSizeProp = ShaderProperty.getByName("material_lowMipTexelSize") // x: 1/width, y: 1/height, z: width, w: height
;
// Uber shader properties
/** @internal */ BloomEffect._enableMacro = ShaderMacro.getByName("ENABLE_EFFECT_BLOOM");
/** @internal */ BloomEffect._bloomTextureProp = ShaderProperty.getByName("material_BloomTexture");
/** @internal */ BloomEffect._dirtTextureProp = ShaderProperty.getByName("material_BloomDirtTexture");
/** @internal */ BloomEffect._tintProp = ShaderProperty.getByName("material_BloomTint");
/** @internal */ BloomEffect._bloomIntensityParams = ShaderProperty.getByName("material_BloomIntensityParams") // x: bloom intensity, y: dirt intensity
;
/** @internal */ BloomEffect._dirtTilingOffsetProp = ShaderProperty.getByName("material_BloomDirtTilingOffset");
Shader.create(BloomEffect.SHADER_NAME, [
    new ShaderPass("Bloom Prefilter", blitVs, fragPrefilter),
    new ShaderPass("Bloom Blur Horizontal", blitVs, fragBlurH),
    new ShaderPass("Bloom Blur Vertical", blitVs, fragBlurV),
    new ShaderPass("Bloom Upsample", blitVs, fragUpsample)
]);

/**
 * Options to select a tonemapping algorithm to use.
 */ var TonemappingMode = /*#__PURE__*/ function(TonemappingMode) {
    /**
   * Neutral tonemapper.
   * @remarks Use this option if you only want range-remapping with minimal impact on color hue and saturation.
   */ TonemappingMode[TonemappingMode["Neutral"] = 0] = "Neutral";
    /**
   * ACES Filmic reference tonemapper (custom approximation).
   * @remarks
   * Use this option to apply a close approximation of the reference ACES tonemapper for a more filmic look.
   * It is more contrasted than Neutral and has an effect on actual color hue and saturation.
   */ TonemappingMode[TonemappingMode["ACES"] = 1] = "ACES";
    return TonemappingMode;
}({});
var TonemappingEffect = /*#__PURE__*/ function(PostProcessEffect) {
    _inherits$2(TonemappingEffect, PostProcessEffect);
    function TonemappingEffect() {
        var _this;
        _this = PostProcessEffect.apply(this, arguments) || this, /**
   * Use this to select a tonemapping algorithm to use.
   */ _this.mode = new PostProcessEffectEnumParameter(TonemappingMode, 0);
        return _this;
    }
    return TonemappingEffect;
}(PostProcessEffect);
/** @internal */ TonemappingEffect._enableMacro = ShaderMacro.getByName("ENABLE_EFFECT_TONEMAPPING");

/**
 * Post Process component can be used for global or local post-processing.
 */ var PostProcess = /*#__PURE__*/ function(Component) {
    _inherits$2(PostProcess, Component);
    function PostProcess() {
        var _this;
        _this = Component.apply(this, arguments) || this, /**
   * The layer to which the PostProcess belongs.
   */ _this.layer = Layer.Layer0, /**
   * The outer distance to start blending from, only takes effect when the `isGlobal` is false.
   */ _this.blendDistance = 0, /** @internal */ _this._effects = [], _this._priority = 0, _this._isGlobal = true;
        return _this;
    }
    var _proto = PostProcess.prototype;
    /**
   * Get the PostProcessEffect by type.
   * @param type - The type of PostProcessEffect
   * @returns The PostProcessEffect found
   */ _proto.getEffect = function getEffect(type) {
        var effects = this._effects;
        var length = effects.length;
        for(var i = 0; i < length; i++){
            var effect = effects[i];
            if (_instanceof$3(effect, type)) {
                return effect;
            }
        }
    };
    /**
   * Add a PostProcessEffect to the PostProcess.
   * @remarks Only one effect of the same type can be added to the PostProcess.
   * @param type - The type of PostProcessEffect
   * @returns The PostProcessEffect added
   */ _proto.addEffect = function addEffect(type) {
        if (this.getEffect(type)) {
            Logger.error('effect "' + type.name + '" already exists in the PostProcess.');
            return;
        }
        var effect = new type();
        this._effects.push(effect);
        return effect;
    };
    /**
   * Remove a PostProcessEffect from the PostProcess.
   * @param type - The type of PostProcessEffect
   * @returns The PostProcessEffect removed
   */ _proto.removeEffect = function removeEffect(type) {
        var effects = this._effects;
        var length = effects.length;
        for(var i = 0; i < length; i++){
            var effect = effects[i];
            if (_instanceof$3(effect, type)) {
                effects.splice(i, 1);
                return effect;
            }
        }
    };
    /**
   * @inheritdoc
   */ _proto._onEnableInScene = function _onEnableInScene() {
        this.scene.postProcessManager._addPostProcess(this);
    };
    /**
   * @inheritdoc
   */ _proto._onDisableInScene = function _onDisableInScene() {
        this.scene.postProcessManager._removePostProcess(this);
    };
    /**
   * @inheritdoc
   */ _proto._onDestroy = function _onDestroy() {
        Component.prototype._onDestroy.call(this);
        this._effects.length = 0;
    };
    _create_class$2(PostProcess, [
        {
            key: "isGlobal",
            get: /**
   * Whether the PostProcess is global.
   * @remarks
   * Specifies whether to apply the PostProcess to the entire Scene or in Colliders.
   * Only support local PostProcess in physics enabled Scenes.
   */ function get() {
                return this._isGlobal;
            },
            set: function set(value) {
                if (value !== this._isGlobal) {
                    if (!value && !this.engine._physicsInitialized) {
                        Logger.warn("Only support local PostProcess in physics enabled Scenes.");
                        return;
                    }
                    this._isGlobal = value;
                }
            }
        },
        {
            key: "priority",
            get: /**
   * A value which determines which PostProcess is being used when PostProcess have an equal amount of influence on the Scene.
   * @remarks
   * PostProcess with a higher priority will override lower ones.
   */ function get() {
                return this._priority;
            },
            set: function set(value) {
                this._priority = value;
                if (this.scene) {
                    this.scene.postProcessManager._postProcessNeedSorting = true;
                }
            }
        }
    ]);
    return PostProcess;
}(Component);
__decorate$1([
    deepClone
], PostProcess.prototype, "_effects", void 0);

/**
 * @internal
 */ var PipelineUtils = /*#__PURE__*/ function() {
    function PipelineUtils() {}
    /**
   * Recreate texture if needed.
   * @param engine - Engine
   * @param currentTexture - Current texture
   * @param width - Need texture width
   * @param height - Need texture height
   * @param format - Need texture format
   * @param mipmap - Need texture mipmap
   * @param isSRGBColorSpace - Whether to use sRGB color space
   * @param textureWrapMode - Texture wrap mode
   * @param textureFilterMode - Texture filter mode
   * @returns Texture
   */ PipelineUtils.recreateTextureIfNeeded = function recreateTextureIfNeeded(engine, currentTexture, width, height, format, mipmap, isSRGBColorSpace, textureWrapMode, textureFilterMode) {
        if (currentTexture) {
            if (currentTexture.width !== width || currentTexture.height !== height || currentTexture.format !== format || currentTexture.isSRGBColorSpace !== isSRGBColorSpace || currentTexture.mipmapCount > 1 !== mipmap) {
                currentTexture.destroy(true);
                currentTexture = new Texture2D(engine, width, height, format, mipmap, isSRGBColorSpace);
                currentTexture.isGCIgnored = true;
            }
        } else {
            currentTexture = new Texture2D(engine, width, height, format, mipmap, isSRGBColorSpace);
            currentTexture.isGCIgnored = true;
        }
        currentTexture.wrapModeU = currentTexture.wrapModeV = textureWrapMode;
        currentTexture.filterMode = textureFilterMode;
        return currentTexture;
    };
    /**
   * Recreate render target if needed.
   * @param engine - Engine
   * @param currentRenderTarget - Current render target
   * @param width - Need render target width
   * @param height - Need render target height
   * @param colorFormat - Need render target color format
   * @param depthFormat - Need render target depth format
   * @param mipmap - Need render target mipmap
   * @param isSRGBColorSpace - Whether to use sRGB color space
   * @param antiAliasing - Need render target anti aliasing
   * @param textureWrapMode - Texture wrap mode
   * @param textureFilterMode - Texture filter mode
   * @returns Render target
   */ PipelineUtils.recreateRenderTargetIfNeeded = function recreateRenderTargetIfNeeded(engine, currentRenderTarget, width, height, colorFormat, depthFormat, needDepthTexture, mipmap, isSRGBColorSpace, antiAliasing, textureWrapMode, textureFilterMode) {
        var currentColorTexture = currentRenderTarget == null ? void 0 : currentRenderTarget.getColorTexture(0);
        var colorTexture = colorFormat ? PipelineUtils.recreateTextureIfNeeded(engine, currentColorTexture, width, height, colorFormat, mipmap, isSRGBColorSpace, textureWrapMode, textureFilterMode) : null;
        if (needDepthTexture) {
            var currentDepthTexture = currentRenderTarget == null ? void 0 : currentRenderTarget.depthTexture;
            var _$needDepthTexture = depthFormat ? PipelineUtils.recreateTextureIfNeeded(engine, currentDepthTexture, width, height, depthFormat, mipmap, isSRGBColorSpace, textureWrapMode, textureFilterMode) : null;
            if (currentColorTexture !== colorTexture || currentDepthTexture !== _$needDepthTexture) {
                currentRenderTarget == null ? void 0 : currentRenderTarget.destroy(true);
                currentRenderTarget = new RenderTarget(engine, width, height, colorTexture, _$needDepthTexture, antiAliasing);
                currentRenderTarget.isGCIgnored = true;
            }
        } else {
            if (currentColorTexture !== colorTexture || (currentRenderTarget == null ? void 0 : currentRenderTarget._depthFormat) !== depthFormat || currentRenderTarget.antiAliasing !== antiAliasing) {
                currentRenderTarget == null ? void 0 : currentRenderTarget.destroy(true);
                currentRenderTarget = new RenderTarget(engine, width, height, colorTexture, depthFormat, antiAliasing);
                currentRenderTarget.isGCIgnored = true;
            }
        }
        return currentRenderTarget;
    };
    return PipelineUtils;
}();
PipelineUtils.defaultViewport = new Vector4(0, 0, 1, 1);

/**
 * @internal
 */ var ColliderShapeChangeFlag = /*#__PURE__*/ function(ColliderShapeChangeFlag) {
    ColliderShapeChangeFlag[ColliderShapeChangeFlag["Property"] = 1] = "Property";
    ColliderShapeChangeFlag[ColliderShapeChangeFlag["Count"] = 2] = "Count";
    ColliderShapeChangeFlag[ColliderShapeChangeFlag["Both"] = 3] = "Both";
    return ColliderShapeChangeFlag;
}({});

var Collider = /*#__PURE__*/ function(Component) {
    _inherits$2(Collider, Component);
    function Collider(entity) {
        var _this;
        _this = Component.call(this, entity) || this, /** @internal */ _this._index = -1, _this._shapes = [], _this._collisionLayerIndex = 0;
        _this._updateFlag = entity.registerWorldChangeFlag();
        return _this;
    }
    var _proto = Collider.prototype;
    /**
   * Add collider shape on this collider.
   * @param shape - Collider shape
   */ _proto.addShape = function addShape(shape) {
        var oldCollider = shape._collider;
        if (oldCollider !== this) {
            if (oldCollider) {
                oldCollider.removeShape(shape);
            }
            this._shapes.push(shape);
            this._addNativeShape(shape);
            this._handleShapesChanged(ColliderShapeChangeFlag.Count);
        }
    };
    /**
   * Remove a collider shape.
   * @param shape - The collider shape.
   */ _proto.removeShape = function removeShape(shape) {
        var index = this._shapes.indexOf(shape);
        if (index !== -1) {
            this._shapes.splice(index, 1);
            this._removeNativeShape(shape);
            this._handleShapesChanged(ColliderShapeChangeFlag.Count);
        }
    };
    /**
   * Remove all shape attached.
   */ _proto.clearShapes = function clearShapes() {
        var shapes = this._shapes;
        for(var i = 0, n = shapes.length; i < n; i++){
            this._removeNativeShape(shapes[i]);
        }
        shapes.length = 0;
        this._handleShapesChanged(ColliderShapeChangeFlag.Count);
    };
    /**
   * @internal
   */ _proto._onUpdate = function _onUpdate() {
        if (this._updateFlag.flag) {
            var transform = this.entity.transform;
            this._nativeCollider.setWorldTransform(transform.worldPosition, transform.worldRotationQuaternion);
            var worldScale = transform.lossyWorldScale;
            for(var i = 0, n = this.shapes.length; i < n; i++){
                this.shapes[i]._nativeShape.setWorldScale(worldScale);
            }
            this._updateFlag.flag = false;
        }
    };
    /**
   * @internal
   */ _proto._onLateUpdate = function _onLateUpdate() {};
    /**
   * @internal
   */ _proto._onEnableInScene = function _onEnableInScene() {
        this.scene.physics._addCollider(this);
    };
    /**
   * @internal
   */ _proto._onDisableInScene = function _onDisableInScene() {
        this.scene.physics._removeCollider(this);
    };
    /**
   * @internal
   */ _proto._cloneTo = function _cloneTo(target) {
        target._syncNative();
    };
    /**
   * @internal
   */ _proto._handleShapesChanged = function _handleShapesChanged(changeType) {
        if (changeType & ColliderShapeChangeFlag.Count) {
            this._setCollisionLayer();
        }
    };
    _proto._syncNative = function _syncNative() {
        for(var i = 0, n = this.shapes.length; i < n; i++){
            this._addNativeShape(this.shapes[i]);
        }
        this._setCollisionLayer();
    };
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        Component.prototype._onDestroy.call(this);
        var shapes = this._shapes;
        for(var i = 0, n = shapes.length; i < n; i++){
            var shape = shapes[i];
            this._removeNativeShape(shape);
            shape._destroy();
        }
        shapes.length = 0;
        this._nativeCollider.destroy();
    };
    _proto._addNativeShape = function _addNativeShape(shape) {
        shape._collider = this;
        this._nativeCollider.addShape(shape._nativeShape);
    };
    _proto._removeNativeShape = function _removeNativeShape(shape) {
        shape._collider = null;
        this._nativeCollider.removeShape(shape._nativeShape);
    };
    _proto._setCollisionLayer = function _setCollisionLayer() {
        this._nativeCollider.setCollisionLayer(this._collisionLayerIndex);
    };
    _create_class$2(Collider, [
        {
            key: "shapes",
            get: /**
   * The shapes of this collider.
   */ function get() {
                return this._shapes;
            }
        },
        {
            key: "collisionLayer",
            get: /**
   * The collision layer of this collider, only support single layer.
   *
   * @defaultValue `Layer.Layer0`
   */ function get() {
                return 1 << this._collisionLayerIndex;
            },
            set: function set(value) {
                // Check if value is a single layer (power of 2)
                var index = Math.log2(value);
                if (!Number.isInteger(index)) {
                    throw new Error("Collision layer must be a single layer (Layer.Layer0 to Layer.Layer31)");
                }
                this._collisionLayerIndex = index;
                this._nativeCollider.setCollisionLayer(index);
            }
        }
    ]);
    return Collider;
}(Component);
__decorate$1([
    ignoreClone
], Collider.prototype, "_index", void 0);
__decorate$1([
    ignoreClone
], Collider.prototype, "_nativeCollider", void 0);
__decorate$1([
    ignoreClone
], Collider.prototype, "_updateFlag", void 0);
__decorate$1([
    deepClone
], Collider.prototype, "_shapes", void 0);
Collider = __decorate$1([
    dependentComponents(Transform, DependentMode.CheckOnly)
], Collider);

/**
 * The up axis of the collider shape.
 */ var ControllerNonWalkableMode = /*#__PURE__*/ function(ControllerNonWalkableMode) {
    /** Stops character from climbing up non-walkable slopes, but doesn't move it otherwise. */ ControllerNonWalkableMode[ControllerNonWalkableMode["PreventClimbing"] = 0] = "PreventClimbing";
    /** Stops character from climbing up non-walkable slopes, and forces it to slide down those slopes. */ ControllerNonWalkableMode[ControllerNonWalkableMode["PreventClimbingAndForceSliding"] = 1] = "PreventClimbingAndForceSliding";
    return ControllerNonWalkableMode;
}({});

/**
 * The character controllers.
 */ var CharacterController = /*#__PURE__*/ function(Collider) {
    _inherits$2(CharacterController, Collider);
    function CharacterController(entity) {
        var _this;
        _this = Collider.call(this, entity) || this, _this._stepOffset = 0.5, _this._nonWalkableMode = ControllerNonWalkableMode.PreventClimbing, _this._upDirection = new Vector3(0, 1, 0), _this._slopeLimit = 45;
        _this._nativeCollider = Engine._nativePhysics.createCharacterController();
        _this._setUpDirection = _this._setUpDirection.bind(_this);
        //@ts-ignore
        _this._upDirection._onValueChanged = _this._setUpDirection;
        // Sync world position to physical space
        _this._nativeCollider.setWorldPosition(_this.entity.transform.worldPosition);
        return _this;
    }
    var _proto = CharacterController.prototype;
    /**
   * Moves the character using a "collide-and-slide" algorithm.
   * @param disp - Displacement vector
   * @param minDist - The minimum travelled distance to consider.
   * @param elapsedTime - Time elapsed since last call
   * @return flags - The ControllerCollisionFlag
   */ _proto.move = function move(disp, minDist, elapsedTime) {
        var flags = this._nativeCollider.move(disp, minDist, elapsedTime);
        this._syncWorldPositionFromPhysicalSpace();
        return flags;
    };
    /**
   * Add collider shape on this controller.
   * @param shape - Collider shape
   */ _proto.addShape = function addShape(shape) {
        if (this._shapes.length > 0) {
            throw "only allow single shape on controller!";
        }
        Collider.prototype.addShape.call(this, shape);
        this._updateFlag.flag = true;
    };
    /**
   * @internal
   */ _proto._onUpdate = function _onUpdate() {
        if (this._updateFlag.flag) {
            var transform = this.entity.transform;
            var shapes = this.shapes;
            this._nativeCollider.setWorldPosition(transform.worldPosition);
            var worldScale = transform.lossyWorldScale;
            for(var i = 0, n = shapes.length; i < n; i++){
                shapes[i]._nativeShape.setWorldScale(worldScale);
            }
            this._updateFlag.flag = false;
        }
    };
    /**
   * @internal
   */ _proto._onLateUpdate = function _onLateUpdate() {
        this._syncWorldPositionFromPhysicalSpace();
        this._updateFlag.flag = false;
    };
    /**
   * @internal
   */ _proto._onEnableInScene = function _onEnableInScene() {
        this.scene.physics._addCharacterController(this);
    };
    /**
   * @internal
   */ _proto._onDisableInScene = function _onDisableInScene() {
        this.scene.physics._removeCharacterController(this);
    };
    _proto._syncNative = function _syncNative() {
        Collider.prototype._syncNative.call(this);
        this._nativeCollider.setStepOffset(this._stepOffset);
        this._nativeCollider.setNonWalkableMode(this._nonWalkableMode);
        this._nativeCollider.setUpDirection(this._upDirection);
        this._nativeCollider.setSlopeLimit(this._slopeLimit);
    };
    _proto._syncWorldPositionFromPhysicalSpace = function _syncWorldPositionFromPhysicalSpace() {
        this._nativeCollider.getWorldPosition(this.entity.transform.worldPosition);
    };
    _proto._setUpDirection = function _setUpDirection() {
        this._nativeCollider.setUpDirection(this._upDirection);
    };
    _create_class$2(CharacterController, [
        {
            key: "stepOffset",
            get: /**
   * The step offset for the controller, the value must be greater than or equal to 0.
   * @remarks Character can overcome obstacle less than the height(stepOffset + contractOffset of the shape).
   */ function get() {
                return this._stepOffset;
            },
            set: function set(value) {
                value = Math.max(0, value);
                if (this._stepOffset !== value) {
                    this._stepOffset = value;
                    this._nativeCollider.setStepOffset(value);
                }
            }
        },
        {
            key: "nonWalkableMode",
            get: /**
   * The value of the non-walkable mode.
   */ function get() {
                return this._nonWalkableMode;
            },
            set: function set(value) {
                if (this._nonWalkableMode !== value) {
                    this._nonWalkableMode = value;
                    this._nativeCollider.setNonWalkableMode(value);
                }
            }
        },
        {
            key: "upDirection",
            get: /**
   * The up direction for the controller.
   */ function get() {
                return this._upDirection;
            },
            set: function set(value) {
                if (this._upDirection !== value) {
                    this._upDirection.copyFrom(value);
                }
            }
        },
        {
            key: "slopeLimit",
            get: /**
   * The slope limit in degrees for the controller, the value is the cosine value of the maximum slope angle.
   * @defaultValue 45 degrees
   */ function get() {
                return this._slopeLimit;
            },
            set: function set(value) {
                if (this._slopeLimit !== value) {
                    this._slopeLimit = value;
                    this._nativeCollider.setSlopeLimit(value);
                }
            }
        }
    ]);
    return CharacterController;
}(Collider);
__decorate$1([
    deepClone
], CharacterController.prototype, "_upDirection", void 0);
__decorate$1([
    ignoreClone
], CharacterController.prototype, "_setUpDirection", null);

/**
 * A dynamic collider can act with self-defined movement or physical force.
 */ var DynamicCollider = /*#__PURE__*/ function(Collider) {
    _inherits$2(DynamicCollider, Collider);
    function DynamicCollider(entity) {
        var _this;
        _this = Collider.call(this, entity) || this, _this._linearDamping = 0, _this._angularDamping = 0.05, _this._linearVelocity = new Vector3(), _this._angularVelocity = new Vector3(), _this._mass = 1.0, _this._centerOfMass = new Vector3(), _this._inertiaTensor = new Vector3(1, 1, 1), _this._maxAngularVelocity = 18000 / Math.PI, _this._maxDepenetrationVelocity = 1.0000000331813535e32, _this._solverIterations = 4, _this._useGravity = true, _this._isKinematic = false, _this._constraints = 0, _this._collisionDetectionMode = 0, _this._sleepThreshold = 5e-3, _this._automaticCenterOfMass = true, _this._automaticInertiaTensor = true;
        var transform = _this.entity.transform;
        _this._nativeCollider = Engine._nativePhysics.createDynamicCollider(transform.worldPosition, transform.worldRotationQuaternion);
        _this._setLinearVelocity = _this._setLinearVelocity.bind(_this);
        _this._setAngularVelocity = _this._setAngularVelocity.bind(_this);
        _this._handleCenterOfMassChanged = _this._handleCenterOfMassChanged.bind(_this);
        _this._handleInertiaTensorChanged = _this._handleInertiaTensorChanged.bind(_this);
        //@ts-ignore
        _this._linearVelocity._onValueChanged = _this._setLinearVelocity;
        //@ts-ignore
        _this._angularVelocity._onValueChanged = _this._setAngularVelocity;
        //@ts-ignore
        _this._centerOfMass._onValueChanged = _this._handleCenterOfMassChanged;
        //@ts-ignore
        _this._inertiaTensor._onValueChanged = _this._handleInertiaTensorChanged;
        return _this;
    }
    var _proto = DynamicCollider.prototype;
    /**
   * Apply a force to the DynamicCollider.
   * @param force - The force make the collider move
   */ _proto.applyForce = function applyForce(force) {
        this._phasedActiveInScene && this._nativeCollider.addForce(force);
    };
    /**
   * Apply a torque to the DynamicCollider.
   * @param torque - The force make the collider rotate
   */ _proto.applyTorque = function applyTorque(torque) {
        this._phasedActiveInScene && this._nativeCollider.addTorque(torque);
    };
    _proto.move = function move(positionOrRotation, rotation) {
        this._phasedActiveInScene && this._nativeCollider.move(positionOrRotation, rotation);
    };
    /**
   * Forces a collider to sleep at least one frame.
   */ _proto.sleep = function sleep() {
        this._nativeCollider.sleep();
    };
    /**
   * Returns whether the collider is sleeping.
   * @returns True if the collider is sleeping, false otherwise.
   */ _proto.isSleeping = function isSleeping() {
        return this._nativeCollider.isSleeping();
    };
    /**
   * Forces a collider to wake up.
   */ _proto.wakeUp = function wakeUp() {
        this._nativeCollider.wakeUp();
    };
    /**
   * @internal
   */ _proto._onLateUpdate = function _onLateUpdate() {
        var transform = this.entity.transform;
        var worldPosition = transform.worldPosition, worldRotationQuaternion = transform.worldRotationQuaternion;
        var outPosition = DynamicCollider._tempVector3;
        var outRotation = DynamicCollider._tempQuat;
        this._nativeCollider.getWorldTransform(outPosition, outRotation);
        // To resolve the issue where onValueChanged is triggered even though the values are equal
        if (!Vector3.equals(outPosition, worldPosition)) {
            worldPosition.copyFrom(outPosition);
        }
        if (!Quaternion.equals(outRotation, worldRotationQuaternion)) {
            worldRotationQuaternion.copyFrom(outRotation);
        }
        this._updateFlag.flag = false;
    };
    /**
   * @internal
   */ _proto._cloneTo = function _cloneTo(target) {
        target._linearVelocity.copyFrom(this.linearVelocity);
        target._angularVelocity.copyFrom(this.angularVelocity);
        target._centerOfMass.copyFrom(this.centerOfMass);
        target._inertiaTensor.copyFrom(this.inertiaTensor);
        Collider.prototype._cloneTo.call(this, target);
    };
    /**
   * @internal
   */ _proto._handleShapesChanged = function _handleShapesChanged(changeType) {
        Collider.prototype._handleShapesChanged.call(this, changeType);
        if (this._automaticCenterOfMass || this._automaticInertiaTensor) {
            this._setMassAndUpdateInertia();
        }
    };
    _proto._syncNative = function _syncNative() {
        Collider.prototype._syncNative.call(this);
        this._nativeCollider.setLinearDamping(this._linearDamping);
        this._nativeCollider.setAngularDamping(this._angularDamping);
        this._nativeCollider.setLinearVelocity(this._linearVelocity);
        this._nativeCollider.setAngularVelocity(this._angularVelocity);
        if (this._automaticCenterOfMass || this._automaticInertiaTensor) {
            this._setMassAndUpdateInertia();
        } else {
            this._nativeCollider.setMass(this._mass);
            this._nativeCollider.setCenterOfMass(this._centerOfMass);
            this._nativeCollider.setInertiaTensor(this._inertiaTensor);
        }
        this._nativeCollider.setMaxAngularVelocity(this._maxAngularVelocity);
        this._nativeCollider.setMaxDepenetrationVelocity(this._maxDepenetrationVelocity);
        this._nativeCollider.setSleepThreshold(this._sleepThreshold);
        this._nativeCollider.setSolverIterations(this._solverIterations);
        this._nativeCollider.setUseGravity(this._useGravity);
        this._nativeCollider.setIsKinematic(this._isKinematic);
        this._nativeCollider.setConstraints(this._constraints);
        this._nativeCollider.setCollisionDetectionMode(this._collisionDetectionMode);
    };
    _proto._setMassAndUpdateInertia = function _setMassAndUpdateInertia() {
        this._nativeCollider.setMassAndUpdateInertia(this._mass);
        this._automaticCenterOfMass || this._nativeCollider.setCenterOfMass(this._centerOfMass);
        this._automaticInertiaTensor || this._nativeCollider.setInertiaTensor(this._inertiaTensor);
    };
    _proto._setLinearVelocity = function _setLinearVelocity() {
        this._nativeCollider.setLinearVelocity(this._linearVelocity);
    };
    _proto._setAngularVelocity = function _setAngularVelocity() {
        this._nativeCollider.setAngularVelocity(this._angularVelocity);
    };
    _proto._handleCenterOfMassChanged = function _handleCenterOfMassChanged() {
        if (this._automaticCenterOfMass) {
            console.warn("The center of mass is automatically calculated, please set automaticCenterOfMass to false if you want to set it manually.");
        } else {
            this._nativeCollider.setCenterOfMass(this._centerOfMass);
        }
    };
    _proto._handleInertiaTensorChanged = function _handleInertiaTensorChanged() {
        if (this._automaticInertiaTensor) {
            console.warn("The inertia tensor is automatically calculated, please set automaticInertiaTensor to false if you want to set it manually.");
        } else {
            this._nativeCollider.setInertiaTensor(this._inertiaTensor);
        }
    };
    _create_class$2(DynamicCollider, [
        {
            key: "linearDamping",
            get: /**
   * The linear damping of the dynamic collider.
   */ function get() {
                return this._linearDamping;
            },
            set: function set(value) {
                if (this._linearDamping !== value) {
                    this._linearDamping = value;
                    this._nativeCollider.setLinearDamping(value);
                }
            }
        },
        {
            key: "angularDamping",
            get: /**
   * The angular damping of the dynamic collider.
   */ function get() {
                return this._angularDamping;
            },
            set: function set(value) {
                if (this._angularDamping !== value) {
                    this._angularDamping = value;
                    this._nativeCollider.setAngularDamping(value);
                }
            }
        },
        {
            key: "linearVelocity",
            get: /**
   * The linear velocity vector of the dynamic collider measured in world unit per second.
   */ function get() {
                //@ts-ignore
                this._linearVelocity._onValueChanged = null;
                this._nativeCollider.getLinearVelocity(this._linearVelocity);
                //@ts-ignore
                this._linearVelocity._onValueChanged = this._setLinearVelocity;
                return this._linearVelocity;
            },
            set: function set(value) {
                if (this._linearVelocity !== value) {
                    this._linearVelocity.copyFrom(value);
                }
            }
        },
        {
            key: "angularVelocity",
            get: /**
   * The angular velocity vector of the dynamic collider measured in degrees per second.
   */ function get() {
                //@ts-ignore
                this._angularVelocity._onValueChanged = null;
                this._nativeCollider.getAngularVelocity(this._angularVelocity);
                //@ts-ignore
                this._angularVelocity._onValueChanged = this._setAngularVelocity;
                return this._angularVelocity;
            },
            set: function set(value) {
                if (this._angularVelocity !== value) {
                    this._angularVelocity.copyFrom(value);
                }
            }
        },
        {
            key: "mass",
            get: /**
   * The mass of the dynamic collider.
   */ function get() {
                return this._mass;
            },
            set: function set(value) {
                if (this._mass !== value) {
                    this._mass = value;
                    if (this._automaticInertiaTensor || this._automaticCenterOfMass) {
                        this._setMassAndUpdateInertia();
                    } else {
                        this._nativeCollider.setMass(value);
                    }
                }
            }
        },
        {
            key: "automaticCenterOfMass",
            get: /**
   * Whether or not to calculate the center of mass automatically, if true, the center of mass will be calculated based on the associated shapes.
   * @remarks Affected by the position, rotation of the shapes.
   */ function get() {
                return this._automaticCenterOfMass;
            },
            set: function set(value) {
                if (this._automaticCenterOfMass !== value) {
                    this._automaticCenterOfMass = value;
                    if (value) {
                        this._setMassAndUpdateInertia();
                    }
                }
            }
        },
        {
            key: "centerOfMass",
            get: /**
   * The center of mass relative to the transform's origin.
   * @remarks The center of mass is automatically calculated, if you want to set it manually, please set automaticCenterOfMass to false.
   */ function get() {
                // @ts-ignore
                this._centerOfMass._onValueChanged = null;
                this._nativeCollider.getCenterOfMass(this._centerOfMass);
                // @ts-ignore
                this._centerOfMass._onValueChanged = this._handleCenterOfMassChanged;
                return this._centerOfMass;
            },
            set: function set(value) {
                if (this._centerOfMass !== value) {
                    this._centerOfMass.copyFrom(value);
                }
            }
        },
        {
            key: "automaticInertiaTensor",
            get: /**
   * Whether or not to calculate the inertia tensor automatically, if true, the inertia tensor will be calculated based on the associated shapes and mass.
   * @remarks Affected by the position, rotation of the shapes and the mass of the collider.
   */ function get() {
                return this._automaticInertiaTensor;
            },
            set: function set(value) {
                if (this._automaticInertiaTensor !== value) {
                    this._automaticInertiaTensor = value;
                    if (value) {
                        this._setMassAndUpdateInertia();
                    }
                }
            }
        },
        {
            key: "inertiaTensor",
            get: /**
   * The diagonal inertia tensor of mass relative to the center of mass.
   * @remarks The inertia tensor is automatically calculated, if you want to set it manually, please set automaticInertiaTensor to false.
   */ function get() {
                // @ts-ignore
                this._inertiaTensor._onValueChanged = null;
                this._nativeCollider.getInertiaTensor(this._inertiaTensor);
                // @ts-ignore
                this._inertiaTensor._onValueChanged = this._handleInertiaTensorChanged;
                return this._inertiaTensor;
            },
            set: function set(value) {
                if (this._inertiaTensor !== value) {
                    this._inertiaTensor.copyFrom(value);
                }
            }
        },
        {
            key: "maxAngularVelocity",
            get: /**
   * The maximum angular velocity of the collider measured in degrees per second.
   */ function get() {
                return this._maxAngularVelocity;
            },
            set: function set(value) {
                if (this._maxAngularVelocity !== value) {
                    this._maxAngularVelocity = value;
                    this._nativeCollider.setMaxAngularVelocity(value);
                }
            }
        },
        {
            key: "maxDepenetrationVelocity",
            get: /**
   * Maximum velocity of a collider when moving out of penetrating state.
   */ function get() {
                return this._maxDepenetrationVelocity;
            },
            set: function set(value) {
                if (this._maxDepenetrationVelocity !== value) {
                    this._maxDepenetrationVelocity = value;
                    this._nativeCollider.setMaxDepenetrationVelocity(value);
                }
            }
        },
        {
            key: "sleepThreshold",
            get: /**
   * The mass-normalized energy threshold, below which objects start going to sleep.
   */ function get() {
                return this._sleepThreshold;
            },
            set: function set(value) {
                if (value !== this._sleepThreshold) {
                    this._sleepThreshold = value;
                    this._nativeCollider.setSleepThreshold(value);
                }
            }
        },
        {
            key: "solverIterations",
            get: /**
   * The solverIterations determines how accurately collider joints and collision contacts are resolved.
   */ function get() {
                return this._solverIterations;
            },
            set: function set(value) {
                if (this._solverIterations !== value) {
                    this._solverIterations = value;
                    this._nativeCollider.setSolverIterations(value);
                }
            }
        },
        {
            key: "useGravity",
            get: /**
   * Controls whether gravity affects the dynamic collider.
   */ function get() {
                return this._useGravity;
            },
            set: function set(value) {
                if (this._useGravity !== value) {
                    this._useGravity = value;
                    this._nativeCollider.setUseGravity(value);
                }
            }
        },
        {
            key: "isKinematic",
            get: /**
   * Controls whether physics affects the dynamic collider.
   */ function get() {
                return this._isKinematic;
            },
            set: function set(value) {
                if (this._isKinematic !== value) {
                    this._isKinematic = value;
                    this._nativeCollider.setIsKinematic(value);
                }
            }
        },
        {
            key: "constraints",
            get: /**
   * The particular rigid dynamic lock flag.
   */ function get() {
                return this._constraints;
            },
            set: function set(value) {
                if (this._constraints !== value) {
                    this._constraints = value;
                    this._nativeCollider.setConstraints(value);
                }
            }
        },
        {
            key: "collisionDetectionMode",
            get: /**
   * The colliders' collision detection mode.
   */ function get() {
                return this._collisionDetectionMode;
            },
            set: function set(value) {
                if (this._collisionDetectionMode !== value) {
                    this._collisionDetectionMode = value;
                    this._nativeCollider.setCollisionDetectionMode(value);
                }
            }
        }
    ]);
    return DynamicCollider;
}(Collider);
DynamicCollider._tempVector3 = new Vector3();
DynamicCollider._tempQuat = new Quaternion();
__decorate$1([
    ignoreClone
], DynamicCollider.prototype, "_linearVelocity", void 0);
__decorate$1([
    ignoreClone
], DynamicCollider.prototype, "_angularVelocity", void 0);
__decorate$1([
    ignoreClone
], DynamicCollider.prototype, "_centerOfMass", void 0);
__decorate$1([
    ignoreClone
], DynamicCollider.prototype, "_inertiaTensor", void 0);
__decorate$1([
    ignoreClone
], DynamicCollider.prototype, "_setLinearVelocity", null);
__decorate$1([
    ignoreClone
], DynamicCollider.prototype, "_setAngularVelocity", null);
__decorate$1([
    ignoreClone
], DynamicCollider.prototype, "_handleCenterOfMassChanged", null);
__decorate$1([
    ignoreClone
], DynamicCollider.prototype, "_handleInertiaTensorChanged", null);
/**
 * The collision detection mode constants.
 */ var CollisionDetectionMode = /*#__PURE__*/ function(CollisionDetectionMode) {
    /** Continuous collision detection is off for this dynamic collider. */ CollisionDetectionMode[CollisionDetectionMode["Discrete"] = 0] = "Discrete";
    /** Continuous collision detection is on for colliding with static mesh geometry. */ CollisionDetectionMode[CollisionDetectionMode["Continuous"] = 1] = "Continuous";
    /** Continuous collision detection is on for colliding with static and dynamic geometry. */ CollisionDetectionMode[CollisionDetectionMode["ContinuousDynamic"] = 2] = "ContinuousDynamic";
    /** Speculative continuous collision detection is on for static and dynamic geometries */ CollisionDetectionMode[CollisionDetectionMode["ContinuousSpeculative"] = 3] = "ContinuousSpeculative";
    return CollisionDetectionMode;
}({});
/**
 * Use these flags to constrain motion of dynamic collider.
 */ var DynamicColliderConstraints = /*#__PURE__*/ function(DynamicColliderConstraints) {
    /** Not Freeze. */ DynamicColliderConstraints[DynamicColliderConstraints["None"] = 0] = "None";
    /** Freeze motion along the X-axis. */ DynamicColliderConstraints[DynamicColliderConstraints["FreezePositionX"] = 1] = "FreezePositionX";
    /** Freeze motion along the Y-axis. */ DynamicColliderConstraints[DynamicColliderConstraints["FreezePositionY"] = 2] = "FreezePositionY";
    /** Freeze motion along the Z-axis. */ DynamicColliderConstraints[DynamicColliderConstraints["FreezePositionZ"] = 4] = "FreezePositionZ";
    /** Freeze rotation along the X-axis. */ DynamicColliderConstraints[DynamicColliderConstraints["FreezeRotationX"] = 8] = "FreezeRotationX";
    /** Freeze rotation along the Y-axis. */ DynamicColliderConstraints[DynamicColliderConstraints["FreezeRotationY"] = 16] = "FreezeRotationY";
    /** Freeze rotation along the Z-axis. */ DynamicColliderConstraints[DynamicColliderConstraints["FreezeRotationZ"] = 32] = "FreezeRotationZ";
    return DynamicColliderConstraints;
}({});

/**
 * Structure used to get information back from a raycast or a sweep.
 */ var HitResult = function HitResult() {
    /** The entity that was hit. */ this.entity = null;
    /** The distance from the ray's origin to the impact point. */ this.distance = 0;
    /** The impact point in world space where the ray hit the collider. */ this.point = new Vector3();
    /** The normal of the surface the ray hit. */ this.normal = new Vector3();
    /** The shape of the collider that was hit. */ this.shape = null;
};

/**
 * Describes how physics materials of the colliding objects are combined.
 */ var PhysicsMaterialCombineMode = /*#__PURE__*/ function(PhysicsMaterialCombineMode) {
    /** Averages the friction/bounce of the two colliding materials. */ PhysicsMaterialCombineMode[PhysicsMaterialCombineMode["Average"] = 0] = "Average";
    /** Uses the smaller friction/bounce of the two colliding materials. */ PhysicsMaterialCombineMode[PhysicsMaterialCombineMode["Minimum"] = 1] = "Minimum";
    /** Multiplies the friction/bounce of the two colliding materials. */ PhysicsMaterialCombineMode[PhysicsMaterialCombineMode["Multiply"] = 2] = "Multiply";
    /** Uses the larger friction/bounce of the two colliding materials. */ PhysicsMaterialCombineMode[PhysicsMaterialCombineMode["Maximum"] = 3] = "Maximum";
    return PhysicsMaterialCombineMode;
}({});

/**
 * Material class to represent a set of surface properties.
 */ var PhysicsMaterial = /*#__PURE__*/ function() {
    function PhysicsMaterial() {
        this._bounciness = 0;
        this._dynamicFriction = 0.6;
        this._staticFriction = 0.6;
        this._bounceCombine = PhysicsMaterialCombineMode.Average;
        this._frictionCombine = PhysicsMaterialCombineMode.Average;
        this._nativeMaterial = Engine._nativePhysics.createPhysicsMaterial(this._staticFriction, this._dynamicFriction, this._bounciness, this._bounceCombine, this._frictionCombine);
    }
    var _proto = PhysicsMaterial.prototype;
    /**
   * Destroy the material when the material is no be used by any shape.
   */ _proto.destroy = function destroy() {
        !this._destroyed && this._nativeMaterial.destroy();
        this._destroyed = true;
    };
    _create_class$2(PhysicsMaterial, [
        {
            key: "bounciness",
            get: /**
   * The coefficient of bounciness, ranging from 0 to 1.
   */ function get() {
                return this._bounciness;
            },
            set: function set(value) {
                if (this._bounciness !== value) {
                    this._bounciness = value;
                    this._nativeMaterial.setBounciness(value);
                }
            }
        },
        {
            key: "dynamicFriction",
            get: /**
   * The DynamicFriction value.
   */ function get() {
                return this._dynamicFriction;
            },
            set: function set(value) {
                if (this._dynamicFriction !== value) {
                    this._dynamicFriction = value;
                    this._nativeMaterial.setDynamicFriction(value);
                }
            }
        },
        {
            key: "staticFriction",
            get: /**
   * The coefficient of static friction.
   */ function get() {
                return this._staticFriction;
            },
            set: function set(value) {
                if (this._staticFriction !== value) {
                    this._staticFriction = value;
                    this._nativeMaterial.setStaticFriction(value);
                }
            }
        },
        {
            key: "bounceCombine",
            get: /**
   * The restitution combine mode.
   */ function get() {
                return this._bounceCombine;
            },
            set: function set(value) {
                if (this._bounceCombine !== value) {
                    this._bounceCombine = value;
                    this._nativeMaterial.setBounceCombine(value);
                }
            }
        },
        {
            key: "frictionCombine",
            get: /**
   * The friction combine mode.
   */ function get() {
                return this._frictionCombine;
            },
            set: function set(value) {
                if (this._frictionCombine !== value) {
                    this._frictionCombine = value;
                    this._nativeMaterial.setFrictionCombine(value);
                }
            }
        }
    ]);
    return PhysicsMaterial;
}();

/**
 * Describes a contact point where the collision occurs.
 */ var ContactPoint = function ContactPoint() {
    /** The position of the contact point between the shapes, in world space. */ this.position = new Vector3();
    /** The normal of the contacting surfaces at the contact point. The normal direction points from the other shape to the self shape. */ this.normal = new Vector3();
    /** The impulse applied at the contact point, in world space. Divide by the simulation time step to get a force value. */ this.impulse = new Vector3();
};

/**
 * Collision information between two shapes when they collide.
 */ var Collision = /*#__PURE__*/ function() {
    function Collision() {}
    var _proto = Collision.prototype;
    /**
   * Get contact points.
   * @param outContacts - The result of contact points
   * @returns The actual count of contact points
   *
   * @remarks To optimize performance, the engine does not modify the length of the array you pass.
   * You need to obtain the actual number of contact points from the function's return value.
   */ _proto.getContacts = function getContacts(outContacts) {
        var nativeCollision = this._nativeCollision;
        var smallerShapeId = Math.min(nativeCollision.shape0Id, nativeCollision.shape1Id);
        var factor = this.shape.id === smallerShapeId ? 1 : -1;
        var nativeContactPoints = nativeCollision.getContacts();
        var length = nativeContactPoints.size();
        for(var i = 0; i < length; i++){
            var _outContacts, _i;
            var nativeContractPoint = nativeContactPoints.get(i);
            var contact = (_outContacts = outContacts)[_i = i] || (_outContacts[_i] = new ContactPoint());
            contact.position.copyFrom(nativeContractPoint.position);
            contact.normal.copyFrom(nativeContractPoint.normal).scale(factor);
            contact.impulse.copyFrom(nativeContractPoint.impulse).scale(factor);
            contact.separation = nativeContractPoint.separation;
        }
        return length;
    };
    _create_class$2(Collision, [
        {
            key: "contactCount",
            get: /**
   * Count of contact points.
   */ function get() {
                return this._nativeCollision.contactCount;
            }
        }
    ]);
    return Collision;
}();

/**
 * A physics scene is a collection of colliders and constraints which can interact.
 */ var PhysicsScene = /*#__PURE__*/ function() {
    function PhysicsScene(scene) {
        this._restTime = 0;
        this._fixedTimeStep = 1 / 60;
        this._colliders = new DisorderedArray();
        this._gravity = new Vector3(0, -9.81, 0);
        this._onContactEnter = function(nativeCollision) {
            var physicalObjectsMap = Engine._physicalObjectsMap;
            var shape0Id = nativeCollision.shape0Id, shape1Id = nativeCollision.shape1Id;
            var shape1 = physicalObjectsMap[shape0Id];
            var shape2 = physicalObjectsMap[shape1Id];
            var collision = PhysicsScene._collision;
            collision._nativeCollision = nativeCollision;
            shape1.collider.entity._scripts.forEach(function(element) {
                collision.shape = shape2;
                element.onCollisionEnter(collision);
            }, function(element, index) {
                element._entityScriptsIndex = index;
            });
            shape2.collider.entity._scripts.forEach(function(element) {
                collision.shape = shape1;
                element.onCollisionEnter(collision);
            }, function(element, index) {
                element._entityScriptsIndex = index;
            });
        };
        this._onContactExit = function(nativeCollision) {
            var physicalObjectsMap = Engine._physicalObjectsMap;
            var shape0Id = nativeCollision.shape0Id, shape1Id = nativeCollision.shape1Id;
            var shape1 = physicalObjectsMap[shape0Id];
            var shape2 = physicalObjectsMap[shape1Id];
            var collision = PhysicsScene._collision;
            collision._nativeCollision = nativeCollision;
            shape1.collider.entity._scripts.forEach(function(element) {
                collision.shape = shape2;
                element.onCollisionExit(collision);
            }, function(element, index) {
                element._entityScriptsIndex = index;
            });
            shape2.collider.entity._scripts.forEach(function(element) {
                collision.shape = shape1;
                element.onCollisionExit(collision);
            }, function(element, index) {
                element._entityScriptsIndex = index;
            });
        };
        this._onContactStay = function(nativeCollision) {
            var physicalObjectsMap = Engine._physicalObjectsMap;
            var shape0Id = nativeCollision.shape0Id, shape1Id = nativeCollision.shape1Id;
            var shape1 = physicalObjectsMap[shape0Id];
            var shape2 = physicalObjectsMap[shape1Id];
            var collision = PhysicsScene._collision;
            collision._nativeCollision = nativeCollision;
            shape1.collider.entity._scripts.forEach(function(element) {
                collision.shape = shape2;
                element.onCollisionStay(collision);
            }, function(element, index) {
                element._entityScriptsIndex = index;
            });
            shape2.collider.entity._scripts.forEach(function(element) {
                collision.shape = shape1;
                element.onCollisionStay(collision);
            }, function(element, index) {
                element._entityScriptsIndex = index;
            });
        };
        this._onTriggerEnter = function(obj1, obj2) {
            var physicalObjectsMap = Engine._physicalObjectsMap;
            var shape1 = physicalObjectsMap[obj1];
            var shape2 = physicalObjectsMap[obj2];
            shape1.collider.entity._scripts.forEach(function(element) {
                element.onTriggerEnter(shape2);
            }, function(element, index) {
                element._entityScriptsIndex = index;
            });
            shape2.collider.entity._scripts.forEach(function(element) {
                element.onTriggerEnter(shape1);
            }, function(element, index) {
                element._entityScriptsIndex = index;
            });
        };
        this._onTriggerExit = function(obj1, obj2) {
            var physicalObjectsMap = Engine._physicalObjectsMap;
            var shape1 = physicalObjectsMap[obj1];
            var shape2 = physicalObjectsMap[obj2];
            shape1.collider.entity._scripts.forEach(function(element) {
                element.onTriggerExit(shape2);
            }, function(element, index) {
                element._entityScriptsIndex = index;
            });
            shape2.collider.entity._scripts.forEach(function(element) {
                element.onTriggerExit(shape1);
            }, function(element, index) {
                element._entityScriptsIndex = index;
            });
        };
        this._onTriggerStay = function(obj1, obj2) {
            var physicalObjectsMap = Engine._physicalObjectsMap;
            var shape1 = physicalObjectsMap[obj1];
            var shape2 = physicalObjectsMap[obj2];
            shape1.collider.entity._scripts.forEach(function(element) {
                element.onTriggerStay(shape2);
            }, function(element, index) {
                element._entityScriptsIndex = index;
            });
            shape2.collider.entity._scripts.forEach(function(element) {
                element.onTriggerStay(shape1);
            }, function(element, index) {
                element._entityScriptsIndex = index;
            });
        };
        this._scene = scene;
        this._setGravity = this._setGravity.bind(this);
        //@ts-ignore
        this._gravity._onValueChanged = this._setGravity;
        var engine = scene.engine;
        if (engine._physicsInitialized) {
            this._nativePhysicsScene = Engine._nativePhysics.createPhysicsScene(engine._nativePhysicsManager, this._onContactEnter, this._onContactExit, this._onContactStay, this._onTriggerEnter, this._onTriggerExit, this._onTriggerStay);
        }
    }
    var _proto = PhysicsScene.prototype;
    /**
   * Get whether two colliders can collide with each other.
   * @param layer1 - The first collision layer
   * @param layer2 - The second collision layer
   * @returns Whether the colliders should collide
   */ _proto.getColliderLayerCollision = function getColliderLayerCollision(layer1, layer2) {
        var index1 = Math.log2(layer1);
        var index2 = Math.log2(layer2);
        if (!Number.isInteger(index1) || !Number.isInteger(index1)) {
            throw new Error("Collision layer must be a single layer (Layer.Layer0 to Layer.Layer31)");
        }
        return Engine._nativePhysics.getColliderLayerCollision(index1, index2);
    };
    /**
   * Set whether two colliders can collide with each other.
   * @param layer1 - The first collision layer
   * @param layer2 - The second collision layer
   * @param isCollide - Whether the colliders should collide
   */ _proto.setColliderLayerCollision = function setColliderLayerCollision(layer1, layer2, isCollide) {
        var index1 = Math.log2(layer1);
        var index2 = Math.log2(layer2);
        if (!Number.isInteger(index1) || !Number.isInteger(index1)) {
            throw new Error("Collision layer must be a single layer (Layer.Layer0 to Layer.Layer31)");
        }
        Engine._nativePhysics.setColliderLayerCollision(index1, index2, isCollide);
    };
    _proto.raycast = function raycast(ray, distanceOrResult, layerMaskOrResult, outHitResult) {
        var hitResult;
        var distance = Number.MAX_VALUE;
        if (typeof distanceOrResult === "number") {
            distance = distanceOrResult;
        } else if (distanceOrResult != undefined) {
            hitResult = distanceOrResult;
        }
        var layerMask = Layer.Everything;
        if (typeof layerMaskOrResult === "number") {
            layerMask = layerMaskOrResult;
        } else if (layerMaskOrResult != undefined) {
            hitResult = layerMaskOrResult;
        }
        if (outHitResult) {
            hitResult = outHitResult;
        }
        var onRaycast = function(obj) {
            var shape = Engine._physicalObjectsMap[obj];
            if (!shape) {
                return false;
            }
            return shape.collider.entity.layer & layerMask && shape.isSceneQuery;
        };
        var outIDX;
        var outDistance;
        var outPosition;
        var outNormal;
        if (hitResult != undefined) {
            var result = this._nativePhysicsScene.raycast(ray, distance, onRaycast, function(idx, distance, position, normal) {
                outIDX = idx;
                outDistance = distance;
                outPosition = position;
                outNormal = normal;
            });
            if (result) {
                var hitShape = Engine._physicalObjectsMap[outIDX];
                hitResult.entity = hitShape._collider.entity;
                hitResult.shape = hitShape;
                hitResult.distance = outDistance;
                hitResult.point.copyFrom(outPosition);
                hitResult.normal.copyFrom(outNormal);
                return true;
            } else {
                hitResult.entity = null;
                hitResult.shape = null;
                hitResult.distance = 0;
                hitResult.point.set(0, 0, 0);
                hitResult.normal.set(0, 0, 0);
                return false;
            }
        } else {
            return this._nativePhysicsScene.raycast(ray, distance, onRaycast);
        }
    };
    /**
   * Call on every frame to update pose of objects.
   * @internal
   */ _proto._update = function _update(deltaTime) {
        var _this = this, fixedTimeStep = _this._fixedTimeStep, nativePhysicsManager = _this._nativePhysicsScene;
        var componentsManager = this._scene._componentsManager;
        var simulateTime = this._restTime + deltaTime;
        var step = Math.floor(simulateTime / fixedTimeStep);
        this._restTime = simulateTime - step * fixedTimeStep;
        for(var i = 0; i < step; i++){
            componentsManager.callScriptOnPhysicsUpdate();
            this._callColliderOnUpdate();
            nativePhysicsManager.update(fixedTimeStep);
            this._callColliderOnLateUpdate();
        }
    };
    /**
   * Add collider into the manager.
   * @param collider - StaticCollider or DynamicCollider.
   * @internal
   */ _proto._addCollider = function _addCollider(collider) {
        if (collider._index === -1) {
            collider._index = this._colliders.length;
            this._colliders.add(collider);
        }
        this._nativePhysicsScene.addCollider(collider._nativeCollider);
    };
    /**
   * Add character controller into the manager.
   * @param controller - Character Controller.
   * @internal
   */ _proto._addCharacterController = function _addCharacterController(controller) {
        if (controller._index === -1) {
            controller._index = this._colliders.length;
            this._colliders.add(controller);
        }
        this._nativePhysicsScene.addCharacterController(controller._nativeCollider);
    };
    /**
   * Remove collider.
   * @param collider - StaticCollider or DynamicCollider.
   * @internal
   */ _proto._removeCollider = function _removeCollider(collider) {
        var replaced = this._colliders.deleteByIndex(collider._index);
        replaced && (replaced._index = collider._index);
        collider._index = -1;
        this._nativePhysicsScene.removeCollider(collider._nativeCollider);
    };
    /**
   * Remove collider.
   * @param controller - Character Controller.
   * @internal
   */ _proto._removeCharacterController = function _removeCharacterController(controller) {
        var replaced = this._colliders.deleteByIndex(controller._index);
        replaced && (replaced._index = controller._index);
        controller._index = -1;
        this._nativePhysicsScene.removeCharacterController(controller._nativeCollider);
    };
    /**
   * @internal
   */ _proto._callColliderOnUpdate = function _callColliderOnUpdate() {
        var elements = this._colliders._elements;
        for(var i = this._colliders.length - 1; i >= 0; --i){
            elements[i]._onUpdate();
        }
    };
    /**
   * @internal
   */ _proto._callColliderOnLateUpdate = function _callColliderOnLateUpdate() {
        var elements = this._colliders._elements;
        for(var i = this._colliders.length - 1; i >= 0; --i){
            elements[i]._onLateUpdate();
        }
    };
    /**
   * @internal
   */ _proto._gc = function _gc() {
        this._colliders.garbageCollection();
    };
    /**
   * @internal
   */ _proto._destroy = function _destroy() {
        var _this__nativePhysicsScene;
        (_this__nativePhysicsScene = this._nativePhysicsScene) == null ? void 0 : _this__nativePhysicsScene.destroy();
    };
    _proto._setGravity = function _setGravity() {
        this._nativePhysicsScene.setGravity(this._gravity);
    };
    _create_class$2(PhysicsScene, [
        {
            key: "gravity",
            get: /**
   * The gravity of physics scene.
   */ function get() {
                return this._gravity;
            },
            set: function set(value) {
                var gravity = this._gravity;
                if (gravity !== value) {
                    gravity.copyFrom(value);
                }
            }
        },
        {
            key: "fixedTimeStep",
            get: /**
   * The fixed time step in seconds at which physics are performed.
   */ function get() {
                return this._fixedTimeStep;
            },
            set: function set(value) {
                this._fixedTimeStep = Math.max(value, MathUtil.zeroTolerance);
            }
        }
    ]);
    return PhysicsScene;
}();
PhysicsScene._collision = new Collision();

/**
 * A static collider component that will not move.
 * @remarks Mostly used for object which always stays at the same place and never moves around.
 */ var StaticCollider = /*#__PURE__*/ function(Collider) {
    _inherits$2(StaticCollider, Collider);
    function StaticCollider(entity) {
        var _this;
        _this = Collider.call(this, entity) || this;
        var transform = _this.entity.transform;
        _this._nativeCollider = Engine._nativePhysics.createStaticCollider(transform.worldPosition, transform.worldRotationQuaternion);
        return _this;
    }
    return StaticCollider;
}(Collider);

/**
 * The up axis of the collider shape.
 */ var ColliderShapeUpAxis = /*#__PURE__*/ function(ColliderShapeUpAxis) {
    /** Up axis is X. */ ColliderShapeUpAxis[ColliderShapeUpAxis["X"] = 0] = "X";
    /** Up axis is Y. */ ColliderShapeUpAxis[ColliderShapeUpAxis["Y"] = 1] = "Y";
    /** Up axis is Z. */ ColliderShapeUpAxis[ColliderShapeUpAxis["Z"] = 2] = "Z";
    return ColliderShapeUpAxis;
}({});

/**
 * The up axis of the collider shape.
 */ var ControllerCollisionFlag = /*#__PURE__*/ function(ControllerCollisionFlag) {
    /** Character is colliding to the sides. */ ControllerCollisionFlag[ControllerCollisionFlag["Sides"] = 1] = "Sides";
    /** Character has collision above. */ ControllerCollisionFlag[ControllerCollisionFlag["Up"] = 2] = "Up";
    /** Character has collision below. */ ControllerCollisionFlag[ControllerCollisionFlag["Down"] = 4] = "Down";
    return ControllerCollisionFlag;
}({});

var Joint = /*#__PURE__*/ function(Component) {
    _inherits$2(Joint, Component);
    function Joint(entity) {
        var _this;
        _this = Component.call(this, entity) || this, _this._colliderInfo = new JointColliderInfo(), _this._connectedColliderInfo = new JointColliderInfo(), _this._force = Infinity, _this._torque = Infinity, _this._automaticConnectedAnchor = true;
        //@ts-ignore
        _this._colliderInfo.anchor._onValueChanged = _this._updateActualAnchor.bind(_this, 1);
        _this._handleConnectedAnchorChanged = _this._handleConnectedAnchorChanged.bind(_this);
        //@ts-ignore
        _this._connectedColliderInfo.anchor._onValueChanged = _this._handleConnectedAnchorChanged.bind(_this);
        _this._onSelfTransformChanged = _this._onSelfTransformChanged.bind(_this);
        _this._onConnectedTransformChanged = _this._onConnectedTransformChanged.bind(_this);
        // @ts-ignore
        entity._updateFlagManager.addListener(_this._onSelfTransformChanged);
        return _this;
    }
    var _proto = Joint.prototype;
    /**
   * @internal
   */ _proto._onEnableInScene = function _onEnableInScene() {
        this._createJoint();
        this._syncNative();
        this._updateRotation();
    };
    /**
   * @internal
   */ _proto._onDisableInScene = function _onDisableInScene() {
        this._nativeJoint.destroy();
        this._nativeJoint = null;
    };
    _proto._syncNative = function _syncNative() {
        if (this._nativeJoint) {
            var _this__connectedColliderInfo_collider;
            this._nativeJoint.setConnectedCollider(((_this__connectedColliderInfo_collider = this._connectedColliderInfo.collider) == null ? void 0 : _this__connectedColliderInfo_collider._nativeCollider) || null);
            this._updateActualAnchor(1);
            if (this._automaticConnectedAnchor) {
                this._calculateConnectedAnchor();
            } else {
                this._updateActualAnchor(2);
            }
            this._nativeJoint.setConnectedMassScale(this._connectedColliderInfo.massScale);
            this._nativeJoint.setConnectedInertiaScale(this._connectedColliderInfo.inertiaScale);
            this._nativeJoint.setMassScale(this._colliderInfo.massScale);
            this._nativeJoint.setInertiaScale(this._colliderInfo.inertiaScale);
            this._nativeJoint.setBreakForce(this._force);
            this._nativeJoint.setBreakTorque(this._torque);
        }
    };
    _proto._calculateConnectedAnchor = function _calculateConnectedAnchor() {
        var colliderInfo = this._colliderInfo;
        var connectedColliderInfo = this._connectedColliderInfo;
        var connectedAnchor = connectedColliderInfo.anchor;
        var connectedActualAnchor = connectedColliderInfo.actualAnchor;
        var connectedCollider = connectedColliderInfo.collider;
        // @ts-ignore
        connectedAnchor._onValueChanged = null;
        if (connectedCollider) {
            var tempVector3 = Joint._tempVector3;
            var tempMatrix = Joint._tempMatrix;
            Vector3.transformCoordinate(colliderInfo.anchor, this.entity.transform.worldMatrix, tempVector3);
            Matrix.invert(connectedCollider.entity.transform.worldMatrix, tempMatrix);
            Vector3.transformCoordinate(tempVector3, tempMatrix, connectedAnchor);
        } else {
            Vector3.transformCoordinate(colliderInfo.anchor, this.entity.transform.worldMatrix, connectedActualAnchor);
            connectedAnchor.copyFrom(connectedActualAnchor);
        }
        // @ts-ignore
        connectedAnchor._onValueChanged = this._handleConnectedAnchorChanged;
        this._updateActualAnchor(2);
    };
    _proto._handleConnectedAnchorChanged = function _handleConnectedAnchorChanged() {
        if (this._automaticConnectedAnchor) {
            console.warn("Cannot set connectedAnchor when automaticConnectedAnchor is true.");
        } else {
            this._updateActualAnchor(2);
        }
    };
    _proto._onSelfTransformChanged = function _onSelfTransformChanged(type) {
        if (type & TransformModifyFlags.WorldScale) {
            this._updateActualAnchor(1);
        }
    };
    _proto._onConnectedTransformChanged = function _onConnectedTransformChanged(type) {
        if (type & TransformModifyFlags.WorldScale) {
            this._updateActualAnchor(2);
        }
    };
    _proto._updateRotation = function _updateRotation() {
        var _this__nativeJoint;
        var quat = Joint._tempQuat;
        var connectedColliderInfo = this._connectedColliderInfo;
        var connectedCollider = connectedColliderInfo.collider;
        if (connectedCollider) {
            Quaternion.invert(connectedCollider.entity.transform.worldRotationQuaternion, quat);
        }
        Quaternion.multiply(quat, this.entity.transform.worldRotationQuaternion, quat);
        (_this__nativeJoint = this._nativeJoint) == null ? void 0 : _this__nativeJoint.setRotation(quat);
    };
    _proto._updateActualAnchor = function _updateActualAnchor(flag) {
        if (flag & 1) {
            var _this__nativeJoint;
            var worldScale = this.entity.transform.lossyWorldScale;
            var selfColliderInfo = this._colliderInfo;
            Vector3.multiply(selfColliderInfo.anchor, worldScale, selfColliderInfo.actualAnchor);
            (_this__nativeJoint = this._nativeJoint) == null ? void 0 : _this__nativeJoint.setAnchor(selfColliderInfo.actualAnchor);
        }
        if (flag & 2) {
            var _this__nativeJoint1;
            var connectedColliderInfo = this._connectedColliderInfo;
            var connectedCollider = connectedColliderInfo.collider;
            if (connectedCollider) {
                var worldScale1 = connectedCollider.entity.transform.lossyWorldScale;
                Vector3.multiply(connectedColliderInfo.anchor, worldScale1, connectedColliderInfo.actualAnchor);
            } else {
                connectedColliderInfo.actualAnchor.copyFrom(connectedColliderInfo.anchor);
            }
            (_this__nativeJoint1 = this._nativeJoint) == null ? void 0 : _this__nativeJoint1.setConnectedAnchor(connectedColliderInfo.actualAnchor);
        }
    };
    _create_class$2(Joint, [
        {
            key: "connectedCollider",
            get: /**
   * The connected collider.
   */ function get() {
                return this._connectedColliderInfo.collider;
            },
            set: function set(value) {
                var preCollider = this._connectedColliderInfo.collider;
                if (preCollider !== value) {
                    var _this__nativeJoint;
                    preCollider == null ? void 0 : preCollider.entity._updateFlagManager.removeListener(this._onConnectedTransformChanged);
                    value == null ? void 0 : value.entity._updateFlagManager.addListener(this._onConnectedTransformChanged);
                    this._connectedColliderInfo.collider = value;
                    (_this__nativeJoint = this._nativeJoint) == null ? void 0 : _this__nativeJoint.setConnectedCollider(value == null ? void 0 : value._nativeCollider);
                    this._updateRotation();
                    if (this._automaticConnectedAnchor) {
                        this._calculateConnectedAnchor();
                    } else {
                        this._updateActualAnchor(2);
                    }
                }
            }
        },
        {
            key: "anchor",
            get: /**
   * The anchor position.
   */ function get() {
                return this._colliderInfo.anchor;
            },
            set: function set(value) {
                var anchor = this._colliderInfo.anchor;
                if (value !== anchor) {
                    anchor.copyFrom(value);
                    this._updateActualAnchor(1);
                    this._automaticConnectedAnchor && this._calculateConnectedAnchor();
                }
            }
        },
        {
            key: "connectedAnchor",
            get: /**
   * The connected anchor position.
   * @remarks If connectedCollider is set, this anchor is relative offset, or the anchor is world position.
   * The connectedAnchor is automatically calculated, if you want to set it manually, please set automaticConnectedAnchor to false
   */ function get() {
                return this._connectedColliderInfo.anchor;
            },
            set: function set(value) {
                var connectedAnchor = this._connectedColliderInfo.anchor;
                if (value !== connectedAnchor) {
                    connectedAnchor.copyFrom(value);
                }
            }
        },
        {
            key: "automaticConnectedAnchor",
            get: /**
   * Whether or not to calculate the connectedAnchor automatically, if true, the connectedAnchor will be calculated automatically to match the global position of the anchor property.
   */ function get() {
                return this._automaticConnectedAnchor;
            },
            set: function set(value) {
                this._automaticConnectedAnchor = value;
                value && this._calculateConnectedAnchor();
            }
        },
        {
            key: "connectedMassScale",
            get: /**
   *  The scale to apply to the mass of collider 0 for resolving this constraint.
   */ function get() {
                return this._connectedColliderInfo.massScale;
            },
            set: function set(value) {
                if (value !== this._connectedColliderInfo.massScale) {
                    var _this__nativeJoint;
                    this._connectedColliderInfo.massScale = value;
                    (_this__nativeJoint = this._nativeJoint) == null ? void 0 : _this__nativeJoint.setConnectedMassScale(value);
                }
            }
        },
        {
            key: "massScale",
            get: /**
   * The scale to apply to the mass of collider 1 for resolving this constraint.
   */ function get() {
                return this._colliderInfo.massScale;
            },
            set: function set(value) {
                if (value !== this._colliderInfo.massScale) {
                    var _this__nativeJoint;
                    this._colliderInfo.massScale = value;
                    (_this__nativeJoint = this._nativeJoint) == null ? void 0 : _this__nativeJoint.setMassScale(value);
                }
            }
        },
        {
            key: "connectedInertiaScale",
            get: /**
   * The scale to apply to the inertia of collider0 for resolving this constraint.
   */ function get() {
                return this._connectedColliderInfo.inertiaScale;
            },
            set: function set(value) {
                if (value !== this._connectedColliderInfo.inertiaScale) {
                    var _this__nativeJoint;
                    this._connectedColliderInfo.inertiaScale = value;
                    (_this__nativeJoint = this._nativeJoint) == null ? void 0 : _this__nativeJoint.setConnectedInertiaScale(value);
                }
            }
        },
        {
            key: "inertiaScale",
            get: /**
   * The scale to apply to the inertia of collider1 for resolving this constraint.
   */ function get() {
                return this._colliderInfo.inertiaScale;
            },
            set: function set(value) {
                if (value !== this._colliderInfo.inertiaScale) {
                    var _this__nativeJoint;
                    this._colliderInfo.inertiaScale = value;
                    (_this__nativeJoint = this._nativeJoint) == null ? void 0 : _this__nativeJoint.setInertiaScale(value);
                }
            }
        },
        {
            key: "breakForce",
            get: /**
   * The maximum force the joint can apply before breaking.
   */ function get() {
                return this._force;
            },
            set: function set(value) {
                if (value !== this._force) {
                    var _this__nativeJoint;
                    this._force = value;
                    (_this__nativeJoint = this._nativeJoint) == null ? void 0 : _this__nativeJoint.setBreakForce(value);
                }
            }
        },
        {
            key: "breakTorque",
            get: /**
   * The maximum torque the joint can apply before breaking.
   */ function get() {
                return this._torque;
            },
            set: function set(value) {
                if (value !== this._torque) {
                    var _this__nativeJoint;
                    this._torque = value;
                    (_this__nativeJoint = this._nativeJoint) == null ? void 0 : _this__nativeJoint.setBreakTorque(value);
                }
            }
        }
    ]);
    return Joint;
}(Component);
Joint._tempVector3 = new Vector3();
Joint._tempQuat = new Quaternion();
Joint._tempMatrix = new Matrix();
__decorate$1([
    deepClone
], Joint.prototype, "_colliderInfo", void 0);
__decorate$1([
    deepClone
], Joint.prototype, "_connectedColliderInfo", void 0);
__decorate$1([
    ignoreClone
], Joint.prototype, "_nativeJoint", void 0);
__decorate$1([
    ignoreClone
], Joint.prototype, "_handleConnectedAnchorChanged", null);
__decorate$1([
    ignoreClone
], Joint.prototype, "_onSelfTransformChanged", null);
__decorate$1([
    ignoreClone
], Joint.prototype, "_onConnectedTransformChanged", null);
Joint = __decorate$1([
    dependentComponents(DynamicCollider, DependentMode.AutoAdd)
], Joint);
/**
 * @internal
 */ var JointColliderInfo = function JointColliderInfo() {
    this.collider = null;
    this.anchor = new Vector3();
    this.actualAnchor = new Vector3();
    this.massScale = 1;
    this.inertiaScale = 1;
};
__decorate$1([
    deepClone
], JointColliderInfo.prototype, "anchor", void 0);
__decorate$1([
    deepClone
], JointColliderInfo.prototype, "actualAnchor", void 0);

/*
 * A fixed joint permits no relative movement between two colliders. ie the colliders are glued together.
 */ var FixedJoint = /*#__PURE__*/ function(Joint) {
    _inherits$2(FixedJoint, Joint);
    function FixedJoint() {
        return Joint.apply(this, arguments) || this;
    }
    var _proto = FixedJoint.prototype;
    _proto._createJoint = function _createJoint() {
        var colliderInfo = this._colliderInfo;
        colliderInfo.collider = this.entity.getComponent(Collider);
        this._nativeJoint = Engine._nativePhysics.createFixedJoint(colliderInfo.collider._nativeCollider);
    };
    return FixedJoint;
}(Joint);

/**
 * Flags specific to the Hinge Joint.
 * @internal
 */ var HingeJointFlag = /*#__PURE__*/ function(HingeJointFlag) {
    /** None. */ HingeJointFlag[HingeJointFlag["None"] = 0] = "None";
    /** Enable the limit. */ HingeJointFlag[HingeJointFlag["LimitEnabled"] = 1] = "LimitEnabled";
    /** Enable the drive. */ HingeJointFlag[HingeJointFlag["DriveEnabled"] = 2] = "DriveEnabled";
    /** If the existing velocity is beyond the drive velocity, do not add force. */ HingeJointFlag[HingeJointFlag["DriveFreeSpin"] = 4] = "DriveFreeSpin";
    return HingeJointFlag;
}({});

/**
 * A joint which behaves in a similar way to a hinge or axle.
 */ var HingeJoint = /*#__PURE__*/ function(Joint) {
    _inherits$2(HingeJoint, Joint);
    function HingeJoint(entity) {
        var _this;
        _this = Joint.call(this, entity) || this, _this._axis = new Vector3(1, 0, 0), _this._hingeFlags = HingeJointFlag.None, _this._useSpring = false, _this._angle = 0, _this._velocity = 0;
        _this._onMotorChanged = _this._onMotorChanged.bind(_this);
        _this._onLimitsChanged = _this._onLimitsChanged.bind(_this);
        _this._onAxisChanged = _this._onAxisChanged.bind(_this);
        //@ts-ignore
        _this._axis._onValueChanged = _this._onAxisChanged;
        return _this;
    }
    var _proto = HingeJoint.prototype;
    /**
   * @internal
   */ _proto._onDisableInScene = function _onDisableInScene() {
        var nativeJoint = this._nativeJoint;
        this._angle = nativeJoint.getAngle();
        this._velocity = nativeJoint.getVelocity();
        Joint.prototype._onDisableInScene.call(this);
    };
    _proto._createJoint = function _createJoint() {
        var colliderInfo = this._colliderInfo;
        colliderInfo.collider = this.entity.getComponent(Collider);
        this._nativeJoint = Engine._nativePhysics.createHingeJoint(colliderInfo.collider._nativeCollider);
    };
    _proto._syncNative = function _syncNative() {
        Joint.prototype._syncNative.call(this);
        var motor = this._jointMotor;
        this._nativeJoint.setAxis(this._axis);
        this._nativeJoint.setHingeJointFlag(HingeJointFlag.LimitEnabled, this.useLimits);
        this._nativeJoint.setHingeJointFlag(HingeJointFlag.DriveEnabled, this.useMotor);
        if (motor) {
            this._nativeJoint.setDriveVelocity(motor.targetVelocity);
            this._nativeJoint.setDriveForceLimit(motor.forceLimit);
            this._nativeJoint.setDriveGearRatio(motor.gearRatio);
            this._nativeJoint.setHingeJointFlag(HingeJointFlag.DriveFreeSpin, motor.freeSpin);
        }
    };
    _proto._onMotorChanged = function _onMotorChanged() {
        var motor = this._jointMotor;
        if (this._nativeJoint) {
            this._nativeJoint.setDriveVelocity(motor.targetVelocity);
            this._nativeJoint.setDriveForceLimit(motor.forceLimit);
            this._nativeJoint.setDriveGearRatio(motor.gearRatio);
            this._nativeJoint.setHingeJointFlag(HingeJointFlag.DriveFreeSpin, motor.freeSpin);
        }
    };
    _proto._onLimitsChanged = function _onLimitsChanged() {
        var limits = this._limits;
        if (limits && this._nativeJoint) {
            if (this.useSpring) {
                this._nativeJoint.setSoftLimit(limits.min, limits.max, limits.stiffness, limits.damping);
            } else {
                this._nativeJoint.setHardLimit(limits.min, limits.max, limits.contactDistance);
            }
        }
    };
    _proto._onAxisChanged = function _onAxisChanged() {
        var _this__nativeJoint;
        //@ts-ignore
        this._axis._onValueChanged = null;
        this._axis.normalize();
        (_this__nativeJoint = this._nativeJoint) == null ? void 0 : _this__nativeJoint.setAxis(this._axis);
        //@ts-ignore
        this._axis._onValueChanged = this._onAxisChanged;
    };
    _create_class$2(HingeJoint, [
        {
            key: "axis",
            get: /**
   * The Direction of the axis around which the hingeJoint.
   */ function get() {
                return this._axis;
            },
            set: function set(value) {
                var axis = this._axis;
                if (value !== axis) {
                    axis.copyFrom(value);
                }
            }
        },
        {
            key: "angle",
            get: /**
   * The current angle in degrees of the joint relative to its rest position.
   */ function get() {
                var nativeJoint = this._nativeJoint;
                if (nativeJoint) {
                    this._angle = nativeJoint.getAngle();
                }
                return this._angle;
            }
        },
        {
            key: "velocity",
            get: /**
   * The angular velocity of the joint in degrees per second.
   */ function get() {
                var nativeJoint = this._nativeJoint;
                if (nativeJoint) {
                    this._velocity = nativeJoint.getVelocity();
                }
                return this._velocity;
            }
        },
        {
            key: "useLimits",
            get: /**
   * Enables the joint's limits. Disabled by default.
   */ function get() {
                return (this._hingeFlags & HingeJointFlag.LimitEnabled) == HingeJointFlag.LimitEnabled;
            },
            set: function set(value) {
                if (value !== this.useLimits) {
                    var _this__nativeJoint;
                    value ? this._hingeFlags |= HingeJointFlag.LimitEnabled : this._hingeFlags &= ~HingeJointFlag.LimitEnabled;
                    (_this__nativeJoint = this._nativeJoint) == null ? void 0 : _this__nativeJoint.setHingeJointFlag(HingeJointFlag.LimitEnabled, value);
                }
            }
        },
        {
            key: "useMotor",
            get: /**
   * Enables the joint's motor. Disabled by default.
   */ function get() {
                return (this._hingeFlags & HingeJointFlag.DriveEnabled) == HingeJointFlag.DriveEnabled;
            },
            set: function set(value) {
                if (value !== this.useMotor) {
                    var _this__nativeJoint;
                    value ? this._hingeFlags |= HingeJointFlag.DriveEnabled : this._hingeFlags &= ~HingeJointFlag.DriveEnabled;
                    (_this__nativeJoint = this._nativeJoint) == null ? void 0 : _this__nativeJoint.setHingeJointFlag(HingeJointFlag.DriveEnabled, value);
                }
            }
        },
        {
            key: "useSpring",
            get: /**
   * Enables the joint's spring. Disabled by default.
   */ function get() {
                return this._useSpring;
            },
            set: function set(value) {
                if (this._useSpring !== value) {
                    this._useSpring = value;
                    this._onLimitsChanged();
                }
            }
        },
        {
            key: "motor",
            get: /**
   * The motor will apply a force up to a maximum force to achieve the target velocity in degrees per second.
   */ function get() {
                return this._jointMotor;
            },
            set: function set(value) {
                if (this._jointMotor !== value) {
                    var _this__jointMotor;
                    (_this__jointMotor = this._jointMotor) == null ? void 0 : _this__jointMotor._updateFlagManager.removeListener(this._onMotorChanged);
                    this._jointMotor = value;
                    value == null ? void 0 : value._updateFlagManager.addListener(this._onMotorChanged);
                    this._onMotorChanged();
                }
            }
        },
        {
            key: "limits",
            get: /**
   * Limit of angular rotation (in degrees) on the hinge joint.
   */ function get() {
                return this._limits;
            },
            set: function set(value) {
                if (this._limits !== value) {
                    var _this__limits;
                    (_this__limits = this._limits) == null ? void 0 : _this__limits._updateFlagManager.removeListener(this._onLimitsChanged);
                    this._limits = value;
                    value == null ? void 0 : value._updateFlagManager.addListener(this._onLimitsChanged);
                    this._onLimitsChanged();
                }
            }
        }
    ]);
    return HingeJoint;
}(Joint);
__decorate$1([
    deepClone
], HingeJoint.prototype, "_axis", void 0);
__decorate$1([
    deepClone
], HingeJoint.prototype, "_jointMotor", void 0);
__decorate$1([
    deepClone
], HingeJoint.prototype, "_limits", void 0);
__decorate$1([
    ignoreClone
], HingeJoint.prototype, "_onMotorChanged", null);
__decorate$1([
    ignoreClone
], HingeJoint.prototype, "_onLimitsChanged", null);
__decorate$1([
    ignoreClone
], HingeJoint.prototype, "_onAxisChanged", null);

/**
 * A joint that maintains an upper or lower bound (or both) on the distance between two points on different objects.
 */ var SpringJoint = /*#__PURE__*/ function(Joint) {
    _inherits$2(SpringJoint, Joint);
    function SpringJoint() {
        var _this;
        _this = Joint.apply(this, arguments) || this, _this._minDistance = 0, _this._maxDistance = 0, _this._tolerance = 0.25, _this._stiffness = 0, _this._damping = 0;
        return _this;
    }
    var _proto = SpringJoint.prototype;
    _proto._createJoint = function _createJoint() {
        var colliderInfo = this._colliderInfo;
        colliderInfo.collider = this.entity.getComponent(Collider);
        this._nativeJoint = Engine._nativePhysics.createSpringJoint(colliderInfo.collider._nativeCollider);
    };
    _proto._syncNative = function _syncNative() {
        Joint.prototype._syncNative.call(this);
        this._nativeJoint.setMinDistance(this._minDistance);
        this._nativeJoint.setMaxDistance(this._maxDistance);
        this._nativeJoint.setTolerance(this._tolerance);
        this._nativeJoint.setStiffness(this._stiffness);
        this._nativeJoint.setDamping(this._damping);
    };
    _create_class$2(SpringJoint, [
        {
            key: "minDistance",
            get: /**
   * The minimum distance.
   */ function get() {
                return this._minDistance;
            },
            set: function set(value) {
                if (this._minDistance !== value) {
                    var _this__nativeJoint;
                    this._minDistance = value;
                    (_this__nativeJoint = this._nativeJoint) == null ? void 0 : _this__nativeJoint.setMinDistance(value);
                }
            }
        },
        {
            key: "maxDistance",
            get: /**
   * The maximum distance.
   */ function get() {
                return this._maxDistance;
            },
            set: function set(value) {
                if (this._maxDistance !== value) {
                    var _this__nativeJoint;
                    this._maxDistance = value;
                    (_this__nativeJoint = this._nativeJoint) == null ? void 0 : _this__nativeJoint.setMaxDistance(value);
                }
            }
        },
        {
            key: "tolerance",
            get: /**
   * The distance beyond the allowed range at which the joint becomes active.
   */ function get() {
                return this._tolerance;
            },
            set: function set(value) {
                if (this._tolerance !== value) {
                    var _this__nativeJoint;
                    this._tolerance = value;
                    (_this__nativeJoint = this._nativeJoint) == null ? void 0 : _this__nativeJoint.setTolerance(value);
                }
            }
        },
        {
            key: "stiffness",
            get: /**
   * The spring strength of the joint.
   */ function get() {
                return this._stiffness;
            },
            set: function set(value) {
                if (this._stiffness !== value) {
                    var _this__nativeJoint;
                    this._stiffness = value;
                    (_this__nativeJoint = this._nativeJoint) == null ? void 0 : _this__nativeJoint.setStiffness(value);
                }
            }
        },
        {
            key: "damping",
            get: /**
   * The degree of damping of the joint spring of the joint.
   */ function get() {
                return this._damping;
            },
            set: function set(value) {
                if (this._damping !== value) {
                    var _this__nativeJoint;
                    this._damping = value;
                    (_this__nativeJoint = this._nativeJoint) == null ? void 0 : _this__nativeJoint.setDamping(value);
                }
            }
        }
    ]);
    return SpringJoint;
}(Joint);

/**
 * JointLimits is used to limit the joints angle.
 */ var JointLimits = /*#__PURE__*/ function() {
    function JointLimits() {
        this./** @internal */ _updateFlagManager = new UpdateFlagManager();
        this._max = 0;
        this._min = 0;
        this._contactDistance = -1;
        this._stiffness = 0;
        this._damping = 0;
    }
    _create_class$2(JointLimits, [
        {
            key: "max",
            get: /**
   * The upper angular limit (in degrees) of the joint.
   */ function get() {
                return this._max;
            },
            set: function set(value) {
                if (this._max !== value) {
                    if (value < this._min) {
                        this._min = value;
                    }
                    this._max = value;
                    this._updateFlagManager.dispatch();
                }
            }
        },
        {
            key: "min",
            get: /**
   * The lower angular limit (in degrees) of the joint.
   */ function get() {
                return this._min;
            },
            set: function set(value) {
                if (this._min !== value) {
                    if (value > this._max) {
                        this._max = value;
                    }
                    this._min = value;
                    this._updateFlagManager.dispatch();
                }
            }
        },
        {
            key: "contactDistance",
            get: /**
   * Distance inside the limit value at which the limit will be considered to be active by the solver.
   * Default is the lesser of 0.1 radians, and 0.49 * (upperLimit - lowerLimit)
   */ function get() {
                if (this._contactDistance === -1) {
                    return Math.min(0.1, 0.49 * (this._max - this._min));
                }
                return this._contactDistance;
            },
            set: function set(value) {
                if (this._contactDistance !== value) {
                    this._contactDistance = value;
                    this._updateFlagManager.dispatch();
                }
            }
        },
        {
            key: "stiffness",
            get: /**
   * The spring forces used to reach the target position.
   */ function get() {
                return this._stiffness;
            },
            set: function set(value) {
                if (this._stiffness !== value) {
                    this._stiffness = value;
                    this._updateFlagManager.dispatch();
                }
            }
        },
        {
            key: "damping",
            get: /**
   * The damper force uses to dampen the spring.
   */ function get() {
                return this._damping;
            },
            set: function set(value) {
                if (this._damping !== value) {
                    this._damping = value;
                    this._updateFlagManager.dispatch();
                }
            }
        }
    ]);
    return JointLimits;
}();
__decorate$1([
    deepClone
], JointLimits.prototype, "_updateFlagManager", void 0);

/**
 * The JointMotor is used to motorize a joint.
 */ var JointMotor = /*#__PURE__*/ function() {
    function JointMotor() {
        this./** @internal */ _updateFlagManager = new UpdateFlagManager();
        this._targetVelocity = 0;
        this._forceLimit = Number.MAX_VALUE;
        this._gearRatio = 1.0;
        this._freeSpin = false;
    }
    _create_class$2(JointMotor, [
        {
            key: "targetVelocity",
            get: /**
   * The motor will apply a force up to force to achieve targetVelocity.
   */ function get() {
                return this._targetVelocity;
            },
            set: function set(value) {
                if (this._targetVelocity !== value) {
                    this._targetVelocity = value;
                    this._updateFlagManager.dispatch();
                }
            }
        },
        {
            key: "forceLimit",
            get: /**
   * The force limit.
   */ function get() {
                return this._forceLimit;
            },
            set: function set(value) {
                if (this._forceLimit !== value) {
                    this._forceLimit = value;
                    this._updateFlagManager.dispatch();
                }
            }
        },
        {
            key: "gearRatio",
            get: /**
   * Gear ration for the motor
   */ function get() {
                return this._gearRatio;
            },
            set: function set(value) {
                if (this._gearRatio !== value) {
                    this._gearRatio = value;
                    this._updateFlagManager.dispatch();
                }
            }
        },
        {
            key: "freeSpin",
            get: /**
   * If freeSpin is enabled the motor will only accelerate but never slow down.
   */ function get() {
                return this._freeSpin;
            },
            set: function set(value) {
                if (this._freeSpin !== value) {
                    this._freeSpin = value;
                    this._updateFlagManager.dispatch();
                }
            }
        }
    ]);
    return JointMotor;
}();
__decorate$1([
    deepClone
], JointMotor.prototype, "_updateFlagManager", void 0);

/**
 * Abstract class for collider shapes.
 */ var ColliderShape = /*#__PURE__*/ function() {
    function ColliderShape() {
        this._isTrigger = false;
        this._rotation = new Vector3();
        this._position = new Vector3();
        this._contactOffset = 0.02;
        /**
   * @internal
   * @beta
   * Whether raycast can select it.
   */ this.isSceneQuery = true;
        this._material = new PhysicsMaterial();
        this._id = ColliderShape._idGenerator++;
        this._setRotation = this._setRotation.bind(this);
        this._setPosition = this._setPosition.bind(this);
        //@ts-ignore
        this._rotation._onValueChanged = this._setRotation;
        //@ts-ignore
        this._position._onValueChanged = this._setPosition;
        Engine._physicalObjectsMap[this._id] = this;
    }
    var _proto = ColliderShape.prototype;
    /**
   * Get the distance and the closest point on the shape from a point.
   * @param point - Location in world space you want to find the closest point to
   * @param outClosestPoint - The closest point on the shape in world space
   * @returns The distance between the point and the shape
   */ _proto.getClosestPoint = function getClosestPoint(point, outClosestPoint) {
        var collider = this._collider;
        if (collider.enabled === false || collider.entity._isActiveInHierarchy === false) {
            console.warn("The collider is not active in scene.");
            return -1;
        }
        var res = this._nativeShape.pointDistance(point);
        var distance = res.w;
        if (distance > 0) {
            outClosestPoint.set(res.x, res.y, res.z);
        } else {
            outClosestPoint.copyFrom(point);
        }
        return Math.sqrt(distance);
    };
    /**
   * @internal
   */ _proto._cloneTo = function _cloneTo(target) {
        target._syncNative();
    };
    /**
   * @internal
   */ _proto._destroy = function _destroy() {
        this._nativeShape.destroy();
        this._nativeShape = null;
        delete Engine._physicalObjectsMap[this._id];
    };
    _proto._syncNative = function _syncNative() {
        var _this__collider;
        this._nativeShape.setPosition(this._position);
        this._nativeShape.setRotation(this._rotation);
        this._nativeShape.setContactOffset(this._contactOffset);
        this._nativeShape.setIsTrigger(this._isTrigger);
        this._nativeShape.setMaterial(this._material._nativeMaterial);
        (_this__collider = this._collider) == null ? void 0 : _this__collider._handleShapesChanged(ColliderShapeChangeFlag.Property);
    };
    _proto._setPosition = function _setPosition() {
        var _this__collider;
        this._nativeShape.setPosition(this._position);
        (_this__collider = this._collider) == null ? void 0 : _this__collider._handleShapesChanged(ColliderShapeChangeFlag.Property);
    };
    _proto._setRotation = function _setRotation() {
        var _this__collider;
        this._nativeShape.setRotation(this._rotation);
        (_this__collider = this._collider) == null ? void 0 : _this__collider._handleShapesChanged(ColliderShapeChangeFlag.Property);
    };
    _create_class$2(ColliderShape, [
        {
            key: "collider",
            get: /**
   * Collider owner of this shape.
   */ function get() {
                return this._collider;
            }
        },
        {
            key: "id",
            get: /**
   * Unique id for this shape.
   */ function get() {
                return this._id;
            }
        },
        {
            key: "contactOffset",
            get: /**
   * Contact offset for this shape, the value must be greater than or equal to 0.
   * @defaultValue 0.02
   */ function get() {
                return this._contactOffset;
            },
            set: function set(value) {
                value = Math.max(0, value);
                if (this._contactOffset !== value) {
                    this._contactOffset = value;
                    this._nativeShape.setContactOffset(value);
                }
            }
        },
        {
            key: "material",
            get: /**
   * Physical material, material can't be null.
   */ function get() {
                return this._material;
            },
            set: function set(value) {
                if (!value) {
                    throw new Error("The physics material of the shape can't be null.");
                }
                if (this._material !== value) {
                    this._material = value;
                    this._nativeShape.setMaterial(value._nativeMaterial);
                }
            }
        },
        {
            key: "rotation",
            get: /**
   * The local rotation of this ColliderShape, in degrees.
   */ function get() {
                return this._rotation;
            },
            set: function set(value) {
                if (this._rotation != value) {
                    this._rotation.copyFrom(value);
                }
            }
        },
        {
            key: "position",
            get: /**
   * The local position of this ColliderShape.
   */ function get() {
                return this._position;
            },
            set: function set(value) {
                if (this._position !== value) {
                    this._position.copyFrom(value);
                }
            }
        },
        {
            key: "isTrigger",
            get: /**
   * True for TriggerShape, false for SimulationShape.
   */ function get() {
                return this._isTrigger;
            },
            set: function set(value) {
                if (this._isTrigger !== value) {
                    this._isTrigger = value;
                    this._nativeShape.setIsTrigger(value);
                }
            }
        }
    ]);
    return ColliderShape;
}();
ColliderShape._idGenerator = 0;
__decorate$1([
    ignoreClone
], ColliderShape.prototype, "_collider", void 0);
__decorate$1([
    ignoreClone
], ColliderShape.prototype, "_nativeShape", void 0);
__decorate$1([
    ignoreClone
], ColliderShape.prototype, "_id", void 0);
__decorate$1([
    deepClone
], ColliderShape.prototype, "_rotation", void 0);
__decorate$1([
    deepClone
], ColliderShape.prototype, "_position", void 0);
__decorate$1([
    ignoreClone
], ColliderShape.prototype, "_setPosition", null);
__decorate$1([
    ignoreClone
], ColliderShape.prototype, "_setRotation", null);

/**
 * Physical collider shape for box.
 */ var BoxColliderShape = /*#__PURE__*/ function(ColliderShape) {
    _inherits$2(BoxColliderShape, ColliderShape);
    function BoxColliderShape() {
        var _this;
        _this = ColliderShape.call(this) || this, _this._size = new Vector3(1, 1, 1);
        _this._nativeShape = Engine._nativePhysics.createBoxColliderShape(_this._id, _this._size, _this._material._nativeMaterial);
        //@ts-ignore
        _this._size._onValueChanged = _this._setSize.bind(_this);
        return _this;
    }
    var _proto = BoxColliderShape.prototype;
    _proto._syncNative = function _syncNative() {
        ColliderShape.prototype._syncNative.call(this);
        this._setSize();
    };
    _proto._setSize = function _setSize() {
        this._nativeShape.setSize(this._size);
    };
    _create_class$2(BoxColliderShape, [
        {
            key: "size",
            get: /**
   * Size of box shape.
   */ function get() {
                return this._size;
            },
            set: function set(value) {
                if (this._size !== value) {
                    this._size.copyFrom(value);
                }
            }
        }
    ]);
    return BoxColliderShape;
}(ColliderShape);
__decorate$1([
    deepClone
], BoxColliderShape.prototype, "_size", void 0);
__decorate$1([
    ignoreClone
], BoxColliderShape.prototype, "_setSize", null);

/**
 * Physical collider shape for sphere.
 */ var SphereColliderShape = /*#__PURE__*/ function(ColliderShape) {
    _inherits$2(SphereColliderShape, ColliderShape);
    function SphereColliderShape() {
        var _this;
        _this = ColliderShape.call(this) || this, _this._radius = 1;
        _this._nativeShape = Engine._nativePhysics.createSphereColliderShape(_this._id, _this._radius, _this._material._nativeMaterial);
        return _this;
    }
    var _proto = SphereColliderShape.prototype;
    _proto._syncNative = function _syncNative() {
        ColliderShape.prototype._syncNative.call(this);
        this._nativeShape.setRadius(this._radius);
    };
    _create_class$2(SphereColliderShape, [
        {
            key: "radius",
            get: /**
   * Radius of sphere shape.
   */ function get() {
                return this._radius;
            },
            set: function set(value) {
                if (this._radius !== value) {
                    this._radius = value;
                    this._nativeShape.setRadius(value);
                }
            }
        }
    ]);
    return SphereColliderShape;
}(ColliderShape);

/**
 * Physical collider shape plane.
 */ var PlaneColliderShape = /*#__PURE__*/ function(ColliderShape) {
    _inherits$2(PlaneColliderShape, ColliderShape);
    function PlaneColliderShape() {
        var _this;
        _this = ColliderShape.call(this) || this;
        _this._nativeShape = Engine._nativePhysics.createPlaneColliderShape(_this._id, _this._material._nativeMaterial);
        return _this;
    }
    var _proto = PlaneColliderShape.prototype;
    _proto.getClosestPoint = function getClosestPoint(point, closestPoint) {
        console.error("PlaneColliderShape is not support getClosestPoint");
        return -1;
    };
    return PlaneColliderShape;
}(ColliderShape);

/**
 * Physical collider shape for capsule.
 */ var CapsuleColliderShape = /*#__PURE__*/ function(ColliderShape) {
    _inherits$2(CapsuleColliderShape, ColliderShape);
    function CapsuleColliderShape() {
        var _this;
        _this = ColliderShape.call(this) || this, _this._radius = 1, _this._height = 2, _this._upAxis = ColliderShapeUpAxis.Y;
        _this._nativeShape = Engine._nativePhysics.createCapsuleColliderShape(_this._id, _this._radius, _this._height, _this._material._nativeMaterial);
        return _this;
    }
    var _proto = CapsuleColliderShape.prototype;
    _proto._syncNative = function _syncNative() {
        ColliderShape.prototype._syncNative.call(this);
        this._nativeShape.setRadius(this._radius);
        this._nativeShape.setHeight(this._height);
        this._nativeShape.setUpAxis(this._upAxis);
    };
    _create_class$2(CapsuleColliderShape, [
        {
            key: "radius",
            get: /**
   * Radius of capsule.
   */ function get() {
                return this._radius;
            },
            set: function set(value) {
                if (this._radius !== value) {
                    this._radius = value;
                    this._nativeShape.setRadius(value);
                }
            }
        },
        {
            key: "height",
            get: /**
   * Height of capsule.
   */ function get() {
                return this._height;
            },
            set: function set(value) {
                if (this._height !== value) {
                    this._height = value;
                    this._nativeShape.setHeight(value);
                }
            }
        },
        {
            key: "upAxis",
            get: /**
   * Up axis of capsule.
   */ function get() {
                return this._upAxis;
            },
            set: function set(value) {
                if (this._upAxis !== value) {
                    this._upAxis = value;
                    this._nativeShape.setUpAxis(value);
                }
            }
        }
    ]);
    return CapsuleColliderShape;
}(ColliderShape);

/**
 * A global manager of the PostProcess.
 */ var PostProcessManager = /*#__PURE__*/ function() {
    function PostProcessManager(scene) {
        this.scene = scene;
        this./** @internal */ _postProcessNeedSorting = false;
        this./** @internal */ _postProcessPassNeedSorting = false;
        this._activePostProcesses = [];
        this._blendEffectMap = new Map();
        this._defaultEffectMap = new Map();
        this._remainActivePassCount = 0;
    }
    var _proto = PostProcessManager.prototype;
    /**
   * @internal
   * Whether has any valid post process pass.
   */ _proto._isValid = function _isValid() {
        var scene = this.scene;
        var engine = scene.engine;
        var activePasses = engine._getActivePostProcessPasses();
        return activePasses.some(function(pass) {
            return pass.isValid(scene.postProcessManager);
        });
    };
    /**
   * @internal
   */ _proto._update = function _update(camera) {
        // Start by resetting post process effect instance to default values
        this._resetDefaultValue();
        // Sort post process
        this._sortActivePostProcess();
        var activePostProcesses = this._activePostProcesses;
        for(var i = 0, n = activePostProcesses.length; i < n; i++){
            var postProcess = activePostProcesses[i];
            if (!(camera.postProcessMask & postProcess.layer)) {
                continue;
            }
            var isGlobal = postProcess.isGlobal;
            var interpFactor = 1; // Global default value
            if (!isGlobal) {
                var currentColliders = PostProcessManager._tempColliders;
                var cameraPosition = camera.entity.transform.worldPosition;
                var blendDistance = postProcess.blendDistance;
                var hasColliderShape = false;
                // Find closest distance to current postProcess, 0 means it's inside it
                var closestDistance = Number.POSITIVE_INFINITY;
                postProcess.entity.getComponents(Collider, currentColliders);
                for(var i1 = 0; i1 < currentColliders.length; i1++){
                    var collider = currentColliders[i1];
                    if (!collider.enabled) {
                        continue;
                    }
                    var shapes = collider.shapes;
                    for(var j = 0; j < shapes.length; j++){
                        var currentShape = shapes[j];
                        hasColliderShape = true;
                        var distance = currentShape.getClosestPoint(cameraPosition, PostProcessManager._tempVector3);
                        if (distance < closestDistance) {
                            closestDistance = distance;
                        }
                    }
                }
                if (!hasColliderShape) {
                    Logger.warn('No collider shape found in the entity:"' + postProcess.entity.name + '", the local mode of post process will not take effect.');
                    continue;
                }
                // Post process has no influence, ignore it
                if (closestDistance > blendDistance) {
                    continue;
                }
                if (blendDistance > 0) {
                    interpFactor = 1 - closestDistance / blendDistance;
                }
            }
            var effects = postProcess._effects;
            for(var j1 = 0; j1 < effects.length; j1++){
                var effect = effects[j1];
                if (!effect.enabled) {
                    continue;
                }
                var PostConstructor = effect.constructor;
                var blendEffect = this._blendEffectMap.get(PostConstructor);
                if (!blendEffect) {
                    blendEffect = new PostConstructor();
                    this._blendEffectMap.set(PostConstructor, blendEffect);
                }
                blendEffect._lerp(effect, interpFactor);
                blendEffect.enabled = true;
            }
        }
    };
    /**
   * @internal
   */ _proto._addPostProcess = function _addPostProcess(postProcess) {
        this._activePostProcesses.push(postProcess);
        this._postProcessNeedSorting = true;
    };
    /**
   * @internal
   */ _proto._removePostProcess = function _removePostProcess(postProcess) {
        var index = this._activePostProcesses.indexOf(postProcess);
        if (index >= 0) {
            this._activePostProcesses.splice(index, 1);
            this._postProcessNeedSorting = true;
        }
    };
    /**
   * Get the blend effect by type.
   * @remarks
   * The blend effect is a post process effect that is used to blend all result of the effects by the type.
   * @param type - The type of PostProcessEffect
   * @returns The PostProcessEffect instance found
   */ _proto.getBlendEffect = function getBlendEffect(type) {
        return this._blendEffectMap.get(type);
    };
    /**
   * @internal
   */ _proto._render = function _render(camera, srcRenderTarget, destRenderTarget) {
        var engine = this.scene.engine;
        this._srcRenderTarget = srcRenderTarget;
        this._destRenderTarget = destRenderTarget;
        // Should blit to resolve the MSAA
        srcRenderTarget._blitRenderTarget();
        var activePasses = engine._getActivePostProcessPasses();
        this._remainActivePassCount = activePasses.length;
        this._initSwapRenderTarget(camera);
        for(var i = 0, n = activePasses.length; i < n; i++){
            var pass = activePasses[i];
            pass.onRender(camera, this._getCurrentSourceTexture(), this._currentDestRenderTarget);
            this._remainActivePassCount--;
            this._swapRT();
        }
    };
    /**
   * @internal
   */ _proto._releaseSwapRenderTarget = function _releaseSwapRenderTarget() {
        var swapRenderTarget = this._swapRenderTarget;
        if (swapRenderTarget) {
            var _swapRenderTarget_getColorTexture;
            (_swapRenderTarget_getColorTexture = swapRenderTarget.getColorTexture(0)) == null ? void 0 : _swapRenderTarget_getColorTexture.destroy(true);
            swapRenderTarget.destroy(true);
            this._swapRenderTarget = null;
        }
    };
    /**
   * @internal
   */ _proto._releaseOutputRenderTarget = function _releaseOutputRenderTarget() {
        var outputRenderTarget = this._outputRenderTarget;
        if (outputRenderTarget) {
            var _outputRenderTarget_getColorTexture;
            (_outputRenderTarget_getColorTexture = outputRenderTarget.getColorTexture(0)) == null ? void 0 : _outputRenderTarget_getColorTexture.destroy(true);
            outputRenderTarget.destroy(true);
            this._outputRenderTarget = null;
        }
    };
    /**
   * @internal
   */ _proto._getOutputRenderTarget = function _getOutputRenderTarget(camera) {
        var pixelViewport = camera.pixelViewport;
        this._outputRenderTarget = PipelineUtils.recreateRenderTargetIfNeeded(camera.engine, this._outputRenderTarget, pixelViewport.width, pixelViewport.height, camera._getTargetColorTextureFormat(), null, false, false, !camera._isTargetFormatHDR(), 1, TextureWrapMode$1.Clamp, TextureFilterMode.Bilinear);
        return this._outputRenderTarget;
    };
    _proto._sortActivePostProcess = function _sortActivePostProcess() {
        if (this._postProcessNeedSorting) {
            var postProcesses = this._activePostProcesses;
            if (postProcesses.length) {
                postProcesses.sort(function(a, b) {
                    return a.priority - b.priority;
                });
            }
            this._postProcessNeedSorting = false;
        }
    };
    _proto._resetDefaultValue = function _resetDefaultValue() {
        var _this = this;
        this._blendEffectMap.forEach(function(blendEffect, typeofBlendEffect) {
            var defaultEffect = _this._defaultEffectMap.get(typeofBlendEffect);
            if (!defaultEffect) {
                defaultEffect = new typeofBlendEffect();
                _this._defaultEffectMap.set(typeofBlendEffect, defaultEffect);
            }
            // Reset effectInstance's value by defaultEffect
            blendEffect._lerp(defaultEffect, 1);
            blendEffect.enabled = false;
        });
    };
    _proto._initSwapRenderTarget = function _initSwapRenderTarget(camera) {
        if (this._remainActivePassCount > 1) {
            var viewport = camera.pixelViewport;
            var swapRenderTarget = PipelineUtils.recreateRenderTargetIfNeeded(this.scene.engine, this._swapRenderTarget, viewport.width, viewport.height, camera._getInternalColorTextureFormat(), TextureFormat.Depth24Stencil8, false, false, !camera.enableHDR, 1, TextureWrapMode$1.Clamp, TextureFilterMode.Bilinear);
            this._swapRenderTarget = swapRenderTarget;
            this._currentDestRenderTarget = this._swapRenderTarget;
        } else {
            this._currentDestRenderTarget = this._destRenderTarget;
        }
        this._currentSourceRenderTarget = this._srcRenderTarget;
    };
    _proto._swapRT = function _swapRT() {
        var currentSourceRenderTarget = this._currentSourceRenderTarget;
        var currentDestRenderTarget = this._currentDestRenderTarget;
        this._currentSourceRenderTarget = currentDestRenderTarget;
        if (this._remainActivePassCount > 1) {
            this._currentDestRenderTarget = currentSourceRenderTarget;
        } else {
            this._currentDestRenderTarget = this._destRenderTarget;
        }
    };
    _proto._getCurrentSourceTexture = function _getCurrentSourceTexture() {
        return this._currentSourceRenderTarget.getColorTexture(0);
    };
    return PostProcessManager;
}();
PostProcessManager._tempColliders = [];
PostProcessManager._tempVector3 = new Vector3();

/**
 * Controls when the post process pass executes.
 */ var PostProcessPassEvent = /*#__PURE__*/ function(PostProcessPassEvent) {
    /** Before the uber pass. */ PostProcessPassEvent[PostProcessPassEvent["BeforeUber"] = 0] = "BeforeUber";
    /** After the uber pass. */ PostProcessPassEvent[PostProcessPassEvent["AfterUber"] = 100] = "AfterUber";
    return PostProcessPassEvent;
}({});
/**
 * Post process pass.
 */ var PostProcessPass = /*#__PURE__*/ function(EngineObject) {
    _inherits$2(PostProcessPass, EngineObject);
    function PostProcessPass() {
        var _this;
        _this = EngineObject.apply(this, arguments) || this, _this._event = 100, _this._isActive = true;
        return _this;
    }
    var _proto = PostProcessPass.prototype;
    /**
   * Whether the post process pass is valid in current post process manager.
   * @remarks
   * This method can be overridden to control the pass's real validity.
   * @param postProcessManager - The post process manager
   */ _proto.isValid = function isValid(postProcessManager) {
        return this._isActive;
    };
    /**
   * @inheritdoc
   */ _proto._onDestroy = function _onDestroy() {
        EngineObject.prototype._onDestroy.call(this);
        this.engine._removePostProcessPass(this);
    };
    _create_class$2(PostProcessPass, [
        {
            key: "event",
            get: /**
   * When the post process pass is rendered.
   * @remarks
   * Users can also inject pass events in a specific point by doing PostProcessPassEvent + offset.
   */ function get() {
                return this._event;
            },
            set: function set(value) {
                if (value !== this._event) {
                    this._event = value;
                    if (this._isActive) {
                        this.engine._postProcessPassNeedRefresh = true;
                    }
                }
            }
        },
        {
            key: "isActive",
            get: /**
   * Whether the post process pass is active.
   */ function get() {
                return this._isActive;
            },
            set: function set(value) {
                if (value !== this._isActive) {
                    this._isActive = value;
                    this.engine._postProcessPassNeedRefresh = true;
                }
            }
        }
    ]);
    return PostProcessPass;
}(EngineObject);

/**
 * Alpha blend mode.
 */ var BlendMode = /*#__PURE__*/ function(BlendMode) {
    /** SRC ALPHA * SRC + (1 - SRC ALPHA) * DEST */ BlendMode[BlendMode["Normal"] = 0] = "Normal";
    /** SRC ALPHA * SRC + ONE * DEST */ BlendMode[BlendMode["Additive"] = 1] = "Additive";
    return BlendMode;
}({});

/**
 * Set which face for render.
 */ var RenderFace = /*#__PURE__*/ function(RenderFace) {
    /** Render front face. */ RenderFace[RenderFace["Front"] = 0] = "Front";
    /** Render back face. */ RenderFace[RenderFace["Back"] = 1] = "Back";
    /** Render double face. */ RenderFace[RenderFace["Double"] = 2] = "Double";
    return RenderFace;
}({});

/**
 * Material.
 */ var Material = /*#__PURE__*/ function(ReferResource) {
    _inherits$2(Material, ReferResource);
    function Material(engine, shader) {
        var _this;
        _this = ReferResource.call(this, engine) || this, /** @internal */ _this._renderStates = [] // todo: later will as a part of shaderData when shader effect frame is OK, that is more powerful and flexible.
        , _this._shaderData = new ShaderData(ShaderDataGroup.Material);
        _this.shader = shader;
        _this.name = shader.name;
        return _this;
    }
    var _proto = Material.prototype;
    /**
   * Clone and return the instance.
   */ _proto.clone = function clone() {
        var dest = new Material(this._engine, this.shader);
        this._cloneToAndModifyName(dest);
        return dest;
    };
    /**
   * Clone to the target material.
   * @param target - target material
   */ _proto.cloneTo = function cloneTo(target) {
        target.shader = this.shader;
        this.shaderData.cloneTo(target.shaderData);
        CloneManager.deepCloneObject(this.renderStates, target.renderStates, new Map());
    };
    _proto._addReferCount = function _addReferCount(value) {
        if (this._destroyed) return;
        ReferResource.prototype._addReferCount.call(this, value);
        this.shaderData._addReferCount(value);
        this._shader._addReferCount(value);
    };
    _proto._cloneToAndModifyName = function _cloneToAndModifyName(target) {
        this.cloneTo(target);
        target.name = this.name + "(Clone)";
    };
    /**
   * @override
   */ _proto._onDestroy = function _onDestroy() {
        ReferResource.prototype._onDestroy.call(this);
        this._shader = null;
        this._shaderData = null;
        this._renderStates.length = 0;
        this._renderStates = null;
    };
    _create_class$2(Material, [
        {
            key: "shaderData",
            get: /**
   *  Shader data.
   */ function get() {
                return this._shaderData;
            }
        },
        {
            key: "shader",
            get: /**
   * Shader used by the material.
   */ function get() {
                return this._shader;
            },
            set: function set(value) {
                var refCount = this._getReferCount();
                if (refCount > 0) {
                    var _this__shader;
                    (_this__shader = this._shader) == null ? void 0 : _this__shader._addReferCount(-refCount);
                    value._addReferCount(refCount);
                }
                this._shader = value;
                var renderStates = this._renderStates;
                var lastStatesCount = renderStates.length;
                var maxPassCount = 0;
                var subShaders = value.subShaders;
                for(var i = 0; i < subShaders.length; i++){
                    maxPassCount = Math.max(subShaders[i].passes.length, maxPassCount);
                }
                if (lastStatesCount < maxPassCount) {
                    for(var i1 = lastStatesCount; i1 < maxPassCount; i1++){
                        renderStates.push(new RenderState());
                    }
                } else {
                    renderStates.length = maxPassCount;
                }
            }
        },
        {
            key: "renderState",
            get: /**
   * First Render state.
   */ function get() {
                return this._renderStates[0];
            }
        },
        {
            key: "renderStates",
            get: /**
   * Render states.
   */ function get() {
                return this._renderStates;
            }
        }
    ]);
    return Material;
}(ReferResource);

var BaseMaterial = /*#__PURE__*/ function(Material) {
    _inherits$2(BaseMaterial, Material);
    function BaseMaterial(engine, shader) {
        var _this;
        _this = Material.call(this, engine, shader) || this, _this._renderFace = RenderFace.Front, _this._isTransparent = false, _this._blendMode = BlendMode.Normal;
        var shaderData = _this.shaderData;
        shaderData.setFloat(BaseMaterial._alphaCutoffProp, 0);
        shaderData.setFloat(BaseMaterial._shadowCasterRenderQueueProp, RenderQueueType.Opaque);
        return _this;
    }
    var _proto = BaseMaterial.prototype;
    /**
   * Set if is transparent of the shader pass render state.
   * @param passIndex - Shader pass index
   * @param isTransparent - If is transparent
   */ _proto.setIsTransparent = function setIsTransparent(passIndex, isTransparent) {
        var renderStates = this.renderStates;
        if (renderStates.length < passIndex) {
            throw "Pass should less than pass count.";
        }
        var renderState = renderStates[passIndex];
        var shaderData = this.shaderData;
        if (isTransparent) {
            renderState.blendState.targetBlendState.enabled = true;
            renderState.depthState.writeEnabled = false;
            renderState.renderQueueType = RenderQueueType.Transparent;
            shaderData.enableMacro(BaseMaterial._transparentMacro);
        } else {
            renderState.blendState.targetBlendState.enabled = false;
            renderState.depthState.writeEnabled = true;
            renderState.renderQueueType = shaderData.getFloat(BaseMaterial._alphaCutoffProp) ? RenderQueueType.AlphaTest : RenderQueueType.Opaque;
            shaderData.disableMacro(BaseMaterial._transparentMacro);
        }
    };
    /**
   * Set the blend mode of shader pass render state.
   * @param passIndex - Shader pass index
   * @param blendMode - Blend mode
   */ _proto.setBlendMode = function setBlendMode(passIndex, blendMode) {
        var renderStates = this.renderStates;
        if (renderStates.length < passIndex) {
            throw "Pass should less than pass count.";
        }
        var _renderStates_passIndex_blendState = renderStates[passIndex].blendState, target = _renderStates_passIndex_blendState.targetBlendState;
        switch(blendMode){
            case BlendMode.Normal:
                target.sourceColorBlendFactor = BlendFactor.SourceAlpha;
                target.destinationColorBlendFactor = BlendFactor.OneMinusSourceAlpha;
                target.sourceAlphaBlendFactor = BlendFactor.One;
                target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
                target.colorBlendOperation = target.alphaBlendOperation = BlendOperation.Add;
                break;
            case BlendMode.Additive:
                target.sourceColorBlendFactor = BlendFactor.SourceAlpha;
                target.destinationColorBlendFactor = BlendFactor.One;
                target.sourceAlphaBlendFactor = BlendFactor.Zero;
                target.destinationAlphaBlendFactor = BlendFactor.One;
                target.colorBlendOperation = target.alphaBlendOperation = BlendOperation.Add;
                break;
        }
    };
    /**
   * Set the render face of shader pass render state.
   * @param passIndex - Shader pass index
   * @param renderFace - Render face
   */ _proto.setRenderFace = function setRenderFace(passIndex, renderFace) {
        var renderStates = this.renderStates;
        if (renderStates.length < passIndex) {
            throw "Pass should less than pass count.";
        }
        switch(renderFace){
            case RenderFace.Front:
                renderStates[passIndex].rasterState.cullMode = CullMode.Back;
                break;
            case RenderFace.Back:
                renderStates[passIndex].rasterState.cullMode = CullMode.Front;
                break;
            case RenderFace.Double:
                renderStates[passIndex].rasterState.cullMode = CullMode.Off;
                break;
        }
    };
    /**
   * Clone and return the instance.
   */ _proto.clone = function clone() {
        var dest = new BaseMaterial(this._engine, this.shader);
        this._cloneToAndModifyName(dest);
        return dest;
    };
    /**
   * Clone to the target material.
   * @param target - target material
   */ _proto.cloneTo = function cloneTo(target) {
        Material.prototype.cloneTo.call(this, target);
        target._renderFace = this._renderFace;
        target._isTransparent = this._isTransparent;
        target._blendMode = this._blendMode;
    };
    _proto._seIsTransparent = function _seIsTransparent(value) {
        if (value !== this._isTransparent) {
            this.setIsTransparent(0, value);
            var shaderData = this.shaderData;
            if (value) {
                // Use alpha test queue to simulate transparent shadow
                shaderData.setFloat(BaseMaterial._shadowCasterRenderQueueProp, RenderQueueType.AlphaTest);
            } else {
                var alphaCutoff = shaderData.getFloat(BaseMaterial._alphaCutoffProp);
                if (alphaCutoff) {
                    shaderData.setFloat(BaseMaterial._shadowCasterRenderQueueProp, RenderQueueType.AlphaTest);
                } else {
                    shaderData.setFloat(BaseMaterial._shadowCasterRenderQueueProp, RenderQueueType.Opaque);
                }
            }
            this._isTransparent = value;
        }
    };
    _proto._setAlphaCutoff = function _setAlphaCutoff(value) {
        var shaderData = this.shaderData;
        if (shaderData.getFloat(BaseMaterial._alphaCutoffProp) !== value) {
            if (value) {
                shaderData.enableMacro(BaseMaterial._alphaCutoffMacro);
                shaderData.setFloat(BaseMaterial._shadowCasterRenderQueueProp, RenderQueueType.AlphaTest);
            } else {
                shaderData.disableMacro(BaseMaterial._alphaCutoffMacro);
                if (this._isTransparent) {
                    shaderData.setFloat(BaseMaterial._shadowCasterRenderQueueProp, RenderQueueType.AlphaTest);
                } else {
                    shaderData.setFloat(BaseMaterial._shadowCasterRenderQueueProp, RenderQueueType.Opaque);
                }
            }
            var renderStates = this.renderStates;
            for(var i = 0, n = renderStates.length; i < n; i++){
                var renderState = renderStates[i];
                if (value > 0) {
                    renderState.renderQueueType = renderState.blendState.targetBlendState.enabled ? RenderQueueType.Transparent : RenderQueueType.AlphaTest;
                } else {
                    renderState.renderQueueType = renderState.blendState.targetBlendState.enabled ? RenderQueueType.Transparent : RenderQueueType.Opaque;
                }
            }
            shaderData.setFloat(BaseMaterial._alphaCutoffProp, value);
        }
    };
    _create_class$2(BaseMaterial, [
        {
            key: "shader",
            get: /**
   * Shader used by the material.
   */ function get() {
                return this._shader;
            },
            set: function set(value) {
                var refCount = this._getReferCount();
                if (refCount > 0) {
                    var _this__shader;
                    (_this__shader = this._shader) == null ? void 0 : _this__shader._addReferCount(-refCount);
                    value._addReferCount(refCount);
                }
                this._shader = value;
                var renderStates = this._renderStates;
                var lastStatesCount = renderStates.length;
                var maxPassCount = 0;
                var subShaders = value.subShaders;
                for(var i = 0; i < subShaders.length; i++){
                    maxPassCount = Math.max(subShaders[i].passes.length, maxPassCount);
                }
                if (lastStatesCount < maxPassCount) {
                    for(var i1 = lastStatesCount; i1 < maxPassCount; i1++){
                        renderStates.push(new RenderState());
                        this.setBlendMode(i1, BlendMode.Normal);
                    }
                } else {
                    renderStates.length = maxPassCount;
                }
            }
        },
        {
            key: "isTransparent",
            get: /**
   * Whether transparent of first shader pass render state.
   */ function get() {
                return this._isTransparent;
            },
            set: function set(value) {
                this._seIsTransparent(value);
            }
        },
        {
            key: "blendMode",
            get: /**
   * Blend mode of first shader pass render state.
   * @remarks Only take effect when `isTransparent` is `true`.
   */ function get() {
                return this._blendMode;
            },
            set: function set(value) {
                if (value !== this._blendMode) {
                    this.setBlendMode(0, value);
                    this._blendMode = value;
                }
            }
        },
        {
            key: "alphaCutoff",
            get: /**
   * Alpha cutoff value.
   * @remarks
   * Fragments with alpha channel lower than cutoff value will be discarded.
   * `0` means no fragment will be discarded.
   */ function get() {
                return this.shaderData.getFloat(BaseMaterial._alphaCutoffProp);
            },
            set: function set(value) {
                this._setAlphaCutoff(value);
            }
        },
        {
            key: "renderFace",
            get: /**
   * Face for render of first shader pass render state.
   */ function get() {
                return this._renderFace;
            },
            set: function set(value) {
                if (value !== this._renderFace) {
                    this.setRenderFace(0, value);
                    this._renderFace = value;
                }
            }
        }
    ]);
    return BaseMaterial;
}(Material);
/** @internal */ BaseMaterial._shadowCasterRenderQueueProp = ShaderProperty.getByName("material_ShadowCasterRenderQueue");
BaseMaterial._baseTextureMacro = ShaderMacro.getByName("MATERIAL_HAS_BASETEXTURE");
BaseMaterial._normalTextureMacro = ShaderMacro.getByName("MATERIAL_HAS_NORMALTEXTURE");
BaseMaterial._emissiveTextureMacro = ShaderMacro.getByName("MATERIAL_HAS_EMISSIVETEXTURE");
BaseMaterial._transparentMacro = ShaderMacro.getByName("MATERIAL_IS_TRANSPARENT");
BaseMaterial._baseColorProp = ShaderProperty.getByName("material_BaseColor");
BaseMaterial._baseTextureProp = ShaderProperty.getByName("material_BaseTexture");
BaseMaterial._tilingOffsetProp = ShaderProperty.getByName("material_TilingOffset");
BaseMaterial._normalTextureProp = ShaderProperty.getByName("material_NormalTexture");
BaseMaterial._normalIntensityProp = ShaderProperty.getByName("material_NormalIntensity");
BaseMaterial._emissiveColorProp = ShaderProperty.getByName("material_EmissiveColor");
BaseMaterial._emissiveTextureProp = ShaderProperty.getByName("material_EmissiveTexture");
BaseMaterial._alphaCutoffProp = ShaderProperty.getByName("material_AlphaCutoff");
BaseMaterial._alphaCutoffMacro = ShaderMacro.getByName("MATERIAL_IS_ALPHA_CUTOFF");

/**
 * Blinn-phong Material.
 */ var BlinnPhongMaterial = /*#__PURE__*/ function(BaseMaterial) {
    _inherits$2(BlinnPhongMaterial, BaseMaterial);
    function BlinnPhongMaterial(engine) {
        var _this;
        _this = BaseMaterial.call(this, engine, Shader.find("blinn-phong")) || this;
        var shaderData = _this.shaderData;
        shaderData.enableMacro("MATERIAL_NEED_WORLD_POS");
        shaderData.enableMacro("MATERIAL_NEED_TILING_OFFSET");
        shaderData.setColor(BlinnPhongMaterial._baseColorProp, new Color(1, 1, 1, 1));
        shaderData.setColor(BlinnPhongMaterial._specularColorProp, new Color(1, 1, 1, 1));
        shaderData.setColor(BlinnPhongMaterial._emissiveColorProp, new Color(0, 0, 0, 1));
        shaderData.setVector4(BlinnPhongMaterial._tilingOffsetProp, new Vector4(1, 1, 0, 0));
        shaderData.setFloat(BlinnPhongMaterial._shininessProp, 16);
        shaderData.setFloat(BlinnPhongMaterial._normalIntensityProp, 1);
        return _this;
    }
    var _proto = BlinnPhongMaterial.prototype;
    _proto.clone = function clone() {
        var dest = new BlinnPhongMaterial(this._engine);
        this._cloneToAndModifyName(dest);
        return dest;
    };
    _create_class$2(BlinnPhongMaterial, [
        {
            key: "baseColor",
            get: /**
   * Base color.
   */ function get() {
                return this.shaderData.getColor(BlinnPhongMaterial._baseColorProp);
            },
            set: function set(value) {
                var baseColor = this.shaderData.getColor(BlinnPhongMaterial._baseColorProp);
                if (value !== baseColor) {
                    baseColor.copyFrom(value);
                }
            }
        },
        {
            key: "baseTexture",
            get: /**
   * Base texture.
   */ function get() {
                return this.shaderData.getTexture(BlinnPhongMaterial._baseTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(BlinnPhongMaterial._baseTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro(BlinnPhongMaterial._baseTextureMacro);
                } else {
                    this.shaderData.disableMacro(BlinnPhongMaterial._baseTextureMacro);
                }
            }
        },
        {
            key: "specularColor",
            get: /**
   * Specular color.
   */ function get() {
                return this.shaderData.getColor(BlinnPhongMaterial._specularColorProp);
            },
            set: function set(value) {
                var specularColor = this.shaderData.getColor(BlinnPhongMaterial._specularColorProp);
                if (value !== specularColor) {
                    specularColor.copyFrom(value);
                }
            }
        },
        {
            key: "specularTexture",
            get: /**
   * Specular texture.
   */ function get() {
                return this.shaderData.getTexture(BlinnPhongMaterial._specularTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(BlinnPhongMaterial._specularTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro("MATERIAL_HAS_SPECULAR_TEXTURE");
                } else {
                    this.shaderData.disableMacro("MATERIAL_HAS_SPECULAR_TEXTURE");
                }
            }
        },
        {
            key: "emissiveColor",
            get: /**
   * Emissive color.
   */ function get() {
                return this.shaderData.getColor(BlinnPhongMaterial._emissiveColorProp);
            },
            set: function set(value) {
                var emissiveColor = this.shaderData.getColor(BlinnPhongMaterial._emissiveColorProp);
                if (value !== emissiveColor) {
                    emissiveColor.copyFrom(value);
                }
            }
        },
        {
            key: "emissiveTexture",
            get: /**
   * Emissive texture.
   */ function get() {
                return this.shaderData.getTexture(BlinnPhongMaterial._emissiveTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(BlinnPhongMaterial._emissiveTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro(BlinnPhongMaterial._emissiveTextureMacro);
                } else {
                    this.shaderData.disableMacro(BlinnPhongMaterial._emissiveTextureMacro);
                }
            }
        },
        {
            key: "normalTexture",
            get: /**
   * Normal texture.
   */ function get() {
                return this.shaderData.getTexture(BlinnPhongMaterial._normalTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(BlinnPhongMaterial._normalTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro(BlinnPhongMaterial._normalTextureMacro);
                } else {
                    this.shaderData.disableMacro(BlinnPhongMaterial._normalTextureMacro);
                }
            }
        },
        {
            key: "normalIntensity",
            get: /**
   * Normal texture intensity.
   */ function get() {
                return this.shaderData.getFloat(BlinnPhongMaterial._normalIntensityProp);
            },
            set: function set(value) {
                this.shaderData.setFloat(BlinnPhongMaterial._normalIntensityProp, value);
            }
        },
        {
            key: "shininess",
            get: /**
   * Set the specular reflection coefficient, the larger the value, the more convergent the specular reflection effect.
   */ function get() {
                return this.shaderData.getFloat(BlinnPhongMaterial._shininessProp);
            },
            set: function set(value) {
                this.shaderData.setFloat(BlinnPhongMaterial._shininessProp, Math.max(value, 1e-4));
            }
        },
        {
            key: "tilingOffset",
            get: /**
   * Tiling and offset of main textures.
   */ function get() {
                return this.shaderData.getVector4(BlinnPhongMaterial._tilingOffsetProp);
            },
            set: function set(value) {
                var tilingOffset = this.shaderData.getVector4(BlinnPhongMaterial._tilingOffsetProp);
                if (value !== tilingOffset) {
                    tilingOffset.copyFrom(value);
                }
            }
        }
    ]);
    return BlinnPhongMaterial;
}(BaseMaterial);
BlinnPhongMaterial._specularColorProp = ShaderProperty.getByName("material_SpecularColor");
BlinnPhongMaterial._shininessProp = ShaderProperty.getByName("material_Shininess");
BlinnPhongMaterial._specularTextureProp = ShaderProperty.getByName("material_SpecularTexture");

/**
 * Texture UV coordinate.
 */ var TextureCoordinate = /*#__PURE__*/ function(TextureCoordinate) {
    TextureCoordinate[TextureCoordinate["UV0"] = 0] = "UV0";
    TextureCoordinate[TextureCoordinate["UV1"] = 1] = "UV1";
    TextureCoordinate[TextureCoordinate["UV2"] = 2] = "UV2";
    TextureCoordinate[TextureCoordinate["UV3"] = 3] = "UV3";
    TextureCoordinate[TextureCoordinate["UV4"] = 4] = "UV4";
    TextureCoordinate[TextureCoordinate["UV5"] = 5] = "UV5";
    TextureCoordinate[TextureCoordinate["UV6"] = 6] = "UV6";
    TextureCoordinate[TextureCoordinate["UV7"] = 7] = "UV7";
    return TextureCoordinate;
}({});

/**
 * PBR (Physically-Based Rendering) Material.
 */ var PBRBaseMaterial = /*#__PURE__*/ function(BaseMaterial) {
    _inherits$2(PBRBaseMaterial, BaseMaterial);
    function PBRBaseMaterial(engine, shader) {
        var _this;
        _this = BaseMaterial.call(this, engine, shader) || this;
        var shaderData = _this.shaderData;
        shaderData.enableMacro("MATERIAL_NEED_WORLD_POS");
        shaderData.enableMacro("MATERIAL_NEED_TILING_OFFSET");
        shaderData.setColor(PBRBaseMaterial._baseColorProp, new Color(1, 1, 1, 1));
        shaderData.setColor(PBRBaseMaterial._emissiveColorProp, new Color(0, 0, 0, 1));
        shaderData.setVector4(PBRBaseMaterial._tilingOffsetProp, new Vector4(1, 1, 0, 0));
        shaderData.setFloat(PBRBaseMaterial._normalIntensityProp, 1);
        shaderData.setFloat(PBRBaseMaterial._occlusionTextureIntensityProp, 1);
        shaderData.setFloat(PBRBaseMaterial._occlusionTextureCoordProp, TextureCoordinate.UV0);
        shaderData.setFloat(PBRBaseMaterial._clearCoatProp, 0);
        shaderData.setFloat(PBRBaseMaterial._clearCoatRoughnessProp, 0);
        return _this;
    }
    _create_class$2(PBRBaseMaterial, [
        {
            key: "baseColor",
            get: /**
   * Base color.
   */ function get() {
                return this.shaderData.getColor(PBRBaseMaterial._baseColorProp);
            },
            set: function set(value) {
                var baseColor = this.shaderData.getColor(PBRBaseMaterial._baseColorProp);
                if (value !== baseColor) {
                    baseColor.copyFrom(value);
                }
            }
        },
        {
            key: "baseTexture",
            get: /**
   * Base texture.
   */ function get() {
                return this.shaderData.getTexture(PBRBaseMaterial._baseTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(PBRBaseMaterial._baseTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro(PBRBaseMaterial._baseTextureMacro);
                } else {
                    this.shaderData.disableMacro(PBRBaseMaterial._baseTextureMacro);
                }
            }
        },
        {
            key: "normalTexture",
            get: /**
   * Normal texture.
   */ function get() {
                return this.shaderData.getTexture(PBRBaseMaterial._normalTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(PBRBaseMaterial._normalTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro(PBRBaseMaterial._normalTextureMacro);
                } else {
                    this.shaderData.disableMacro(PBRBaseMaterial._normalTextureMacro);
                }
            }
        },
        {
            key: "normalTextureIntensity",
            get: /**
   * Normal texture intensity.
   */ function get() {
                return this.shaderData.getFloat(PBRBaseMaterial._normalIntensityProp);
            },
            set: function set(value) {
                this.shaderData.setFloat(PBRBaseMaterial._normalIntensityProp, value);
            }
        },
        {
            key: "emissiveColor",
            get: /**
   * Emissive color.
   */ function get() {
                return this.shaderData.getColor(PBRBaseMaterial._emissiveColorProp);
            },
            set: function set(value) {
                var emissiveColor = this.shaderData.getColor(PBRBaseMaterial._emissiveColorProp);
                if (value !== emissiveColor) {
                    emissiveColor.copyFrom(value);
                }
            }
        },
        {
            key: "emissiveTexture",
            get: /**
   * Emissive texture.
   */ function get() {
                return this.shaderData.getTexture(PBRBaseMaterial._emissiveTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(PBRBaseMaterial._emissiveTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro(PBRBaseMaterial._emissiveTextureMacro);
                } else {
                    this.shaderData.disableMacro(PBRBaseMaterial._emissiveTextureMacro);
                }
            }
        },
        {
            key: "occlusionTexture",
            get: /**
   * Occlusion texture.
   */ function get() {
                return this.shaderData.getTexture(PBRBaseMaterial._occlusionTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(PBRBaseMaterial._occlusionTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro("MATERIAL_HAS_OCCLUSION_TEXTURE");
                } else {
                    this.shaderData.disableMacro("MATERIAL_HAS_OCCLUSION_TEXTURE");
                }
            }
        },
        {
            key: "occlusionTextureIntensity",
            get: /**
   * Occlusion texture intensity.
   */ function get() {
                return this.shaderData.getFloat(PBRBaseMaterial._occlusionTextureIntensityProp);
            },
            set: function set(value) {
                this.shaderData.setFloat(PBRBaseMaterial._occlusionTextureIntensityProp, value);
            }
        },
        {
            key: "occlusionTextureCoord",
            get: /**
   * Occlusion texture uv coordinate.
   * @remarks Must be UV0 or UV1.
   */ function get() {
                return this.shaderData.getFloat(PBRBaseMaterial._occlusionTextureCoordProp);
            },
            set: function set(value) {
                if (value > TextureCoordinate.UV1) {
                    Logger.warn("Occlusion texture uv coordinate must be UV0 or UV1.");
                }
                this.shaderData.setFloat(PBRBaseMaterial._occlusionTextureCoordProp, value);
            }
        },
        {
            key: "tilingOffset",
            get: /**
   * Tiling and offset of main textures.
   */ function get() {
                return this.shaderData.getVector4(PBRBaseMaterial._tilingOffsetProp);
            },
            set: function set(value) {
                var tilingOffset = this.shaderData.getVector4(PBRBaseMaterial._tilingOffsetProp);
                if (value !== tilingOffset) {
                    tilingOffset.copyFrom(value);
                }
            }
        },
        {
            key: "clearCoat",
            get: /**
   * The clearCoat layer intensity, default 0.
   */ function get() {
                return this.shaderData.getFloat(PBRBaseMaterial._clearCoatProp);
            },
            set: function set(value) {
                if (!!this.shaderData.getFloat(PBRBaseMaterial._clearCoatProp) !== !!value) {
                    if (value === 0) {
                        this.shaderData.disableMacro("MATERIAL_ENABLE_CLEAR_COAT");
                    } else {
                        this.shaderData.enableMacro("MATERIAL_ENABLE_CLEAR_COAT");
                    }
                }
                this.shaderData.setFloat(PBRBaseMaterial._clearCoatProp, value);
            }
        },
        {
            key: "clearCoatTexture",
            get: /**
   * The clearCoat layer intensity texture.
   */ function get() {
                return this.shaderData.getTexture(PBRBaseMaterial._clearCoatTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(PBRBaseMaterial._clearCoatTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro("MATERIAL_HAS_CLEAR_COAT_TEXTURE");
                } else {
                    this.shaderData.disableMacro("MATERIAL_HAS_CLEAR_COAT_TEXTURE");
                }
            }
        },
        {
            key: "clearCoatRoughness",
            get: /**
   * The clearCoat layer roughness, default 0.
   */ function get() {
                return this.shaderData.getFloat(PBRBaseMaterial._clearCoatRoughnessProp);
            },
            set: function set(value) {
                this.shaderData.setFloat(PBRBaseMaterial._clearCoatRoughnessProp, value);
            }
        },
        {
            key: "clearCoatRoughnessTexture",
            get: /**
   * The clearCoat layer roughness texture.
   */ function get() {
                return this.shaderData.getTexture(PBRBaseMaterial._clearCoatRoughnessTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(PBRBaseMaterial._clearCoatRoughnessTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro("MATERIAL_HAS_CLEAR_COAT_ROUGHNESS_TEXTURE");
                } else {
                    this.shaderData.disableMacro("MATERIAL_HAS_CLEAR_COAT_ROUGHNESS_TEXTURE");
                }
            }
        },
        {
            key: "clearCoatNormalTexture",
            get: /**
   * The clearCoat normal map texture.
   */ function get() {
                return this.shaderData.getTexture(PBRBaseMaterial._clearCoatNormalTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(PBRBaseMaterial._clearCoatNormalTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro("MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE");
                } else {
                    this.shaderData.disableMacro("MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE");
                }
            }
        }
    ]);
    return PBRBaseMaterial;
}(BaseMaterial);
PBRBaseMaterial._occlusionTextureIntensityProp = ShaderProperty.getByName("material_OcclusionIntensity");
PBRBaseMaterial._occlusionTextureCoordProp = ShaderProperty.getByName("material_OcclusionTextureCoord");
PBRBaseMaterial._occlusionTextureProp = ShaderProperty.getByName("material_OcclusionTexture");
PBRBaseMaterial._clearCoatProp = ShaderProperty.getByName("material_ClearCoat");
PBRBaseMaterial._clearCoatTextureProp = ShaderProperty.getByName("material_ClearCoatTexture");
PBRBaseMaterial._clearCoatRoughnessProp = ShaderProperty.getByName("material_ClearCoatRoughness");
PBRBaseMaterial._clearCoatRoughnessTextureProp = ShaderProperty.getByName("material_ClearCoatRoughnessTexture");
PBRBaseMaterial._clearCoatNormalTextureProp = ShaderProperty.getByName("material_ClearCoatNormalTexture");

/**
 * Refraction mode.
 */ var RefractionMode = /*#__PURE__*/ function(RefractionMode) {
    /** Use the sphere refraction model when light passes through the surface. */ RefractionMode[RefractionMode["Sphere"] = 0] = "Sphere";
    /** Use the planar refraction model when light passes through the surface. */ RefractionMode[RefractionMode["Planar"] = 1] = "Planar";
    return RefractionMode;
}({});

/**
 * PBR (Metallic-Roughness Workflow) Material.
 */ var PBRMaterial = /*#__PURE__*/ function(PBRBaseMaterial) {
    _inherits$2(PBRMaterial, PBRBaseMaterial);
    function PBRMaterial(engine) {
        var _this;
        _this = PBRBaseMaterial.call(this, engine, Shader.find("pbr")) || this, _this._anisotropyRotation = 0, _this._iridescenceRange = new Vector2(100, 400), _this._sheenEnabled = false;
        var shaderData = _this.shaderData;
        shaderData.setFloat(PBRMaterial._metallicProp, 1);
        shaderData.setFloat(PBRMaterial._roughnessProp, 1);
        shaderData.setFloat(PBRMaterial._iorProp, 1.5);
        shaderData.setVector3(PBRMaterial._anisotropyInfoProp, new Vector3(1, 0, 0));
        shaderData.setVector4(PBRMaterial._iridescenceInfoProp, new Vector4(0, 1.3, 100, 400));
        var sheenColor = new Color(0, 0, 0);
        shaderData.setColor(PBRMaterial._sheenColorProp, sheenColor);
        _this.refractionMode = RefractionMode.Planar;
        shaderData.setFloat(PBRMaterial._transmissionProp, 0);
        shaderData.setFloat(PBRMaterial._thicknessProp, 0);
        shaderData.setFloat(PBRMaterial._attenuationDistanceProp, Infinity);
        var attenuationColor = new Color(1, 1, 1);
        shaderData.setColor(PBRMaterial._attenuationColorProp, attenuationColor);
        // @ts-ignore
        _this._iridescenceRange._onValueChanged = _this._onIridescenceRangeChanged.bind(_this);
        // @ts-ignore
        sheenColor._onValueChanged = _this._onSheenColorChanged.bind(_this);
        return _this;
    }
    var _proto = PBRMaterial.prototype;
    /**
   * @inheritdoc
   */ _proto.clone = function clone() {
        var dest = new PBRMaterial(this._engine);
        this._cloneToAndModifyName(dest);
        return dest;
    };
    _proto._onIridescenceRangeChanged = function _onIridescenceRangeChanged() {
        var iridescenceInfo = this.shaderData.getVector4(PBRMaterial._iridescenceInfoProp);
        iridescenceInfo.z = this._iridescenceRange.x;
        iridescenceInfo.w = this._iridescenceRange.y;
    };
    _proto._onSheenColorChanged = function _onSheenColorChanged() {
        var sheenColor = this.sheenColor;
        var enableSheen = sheenColor.r + sheenColor.g + sheenColor.b > 0;
        if (enableSheen !== this._sheenEnabled) {
            this._sheenEnabled = enableSheen;
            if (enableSheen) {
                this.shaderData.enableMacro("MATERIAL_ENABLE_SHEEN");
            } else {
                this.shaderData.disableMacro("MATERIAL_ENABLE_SHEEN");
            }
        }
    };
    _create_class$2(PBRMaterial, [
        {
            key: "ior",
            get: /**
   * Index Of Refraction.
   * @defaultValue `1.5`
   */ function get() {
                return this.shaderData.getFloat(PBRMaterial._iorProp);
            },
            set: function set(v) {
                this.shaderData.setFloat(PBRMaterial._iorProp, Math.max(v, 0));
            }
        },
        {
            key: "metallic",
            get: /**
   * Metallic.
   * @defaultValue `1.0`
   */ function get() {
                return this.shaderData.getFloat(PBRMaterial._metallicProp);
            },
            set: function set(value) {
                this.shaderData.setFloat(PBRMaterial._metallicProp, value);
            }
        },
        {
            key: "roughness",
            get: /**
   * Roughness. default 1.0.
   * @defaultValue `1.0`
   */ function get() {
                return this.shaderData.getFloat(PBRMaterial._roughnessProp);
            },
            set: function set(value) {
                this.shaderData.setFloat(PBRMaterial._roughnessProp, value);
            }
        },
        {
            key: "roughnessMetallicTexture",
            get: /**
   * Roughness metallic texture.
   * @remarks G channel is roughness, B channel is metallic
   */ function get() {
                return this.shaderData.getTexture(PBRMaterial._roughnessMetallicTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(PBRMaterial._roughnessMetallicTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro("MATERIAL_HAS_ROUGHNESS_METALLIC_TEXTURE");
                } else {
                    this.shaderData.disableMacro("MATERIAL_HAS_ROUGHNESS_METALLIC_TEXTURE");
                }
            }
        },
        {
            key: "anisotropy",
            get: /**
   * The strength of anisotropy, when anisotropyTexture is present, this value is multiplied by the blue channel.
   * @defaultValue `0`
   */ function get() {
                return this.shaderData.getVector3(PBRMaterial._anisotropyInfoProp).z;
            },
            set: function set(value) {
                var anisotropyInfo = this.shaderData.getVector3(PBRMaterial._anisotropyInfoProp);
                if (!!anisotropyInfo.z !== !!value) {
                    if (value === 0) {
                        this.shaderData.disableMacro("MATERIAL_ENABLE_ANISOTROPY");
                    } else {
                        this.shaderData.enableMacro("MATERIAL_ENABLE_ANISOTROPY");
                    }
                }
                anisotropyInfo.z = value;
            }
        },
        {
            key: "anisotropyRotation",
            get: /**
   * The rotation of the anisotropy in tangent, bitangent space, value in degrees.
   * @defaultValue `0`
   */ function get() {
                return this._anisotropyRotation;
            },
            set: function set(value) {
                if (this._anisotropyRotation !== value) {
                    this._anisotropyRotation = value;
                    var anisotropyInfo = this.shaderData.getVector3(PBRMaterial._anisotropyInfoProp);
                    var rad = MathUtil.degreeToRadFactor * value;
                    anisotropyInfo.x = Math.cos(rad);
                    anisotropyInfo.y = Math.sin(rad);
                }
            }
        },
        {
            key: "anisotropyTexture",
            get: /**
   * The anisotropy texture.
   * @remarks
   * Red and green channels represent the anisotropy direction in [-1, 1] tangent, bitangent space, to be rotated by anisotropyRotation.
   * The blue channel contains strength as [0, 1] to be multiplied by anisotropy.
   */ function get() {
                return this.shaderData.getTexture(PBRMaterial._anisotropyTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(PBRMaterial._anisotropyTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro("MATERIAL_HAS_ANISOTROPY_TEXTURE");
                } else {
                    this.shaderData.disableMacro("MATERIAL_HAS_ANISOTROPY_TEXTURE");
                }
            }
        },
        {
            key: "iridescence",
            get: /**
   * The iridescence intensity factor, from 0.0 to 1.0.
   * @defaultValue `0.0`
   */ function get() {
                return this.shaderData.getVector4(PBRMaterial._iridescenceInfoProp).x;
            },
            set: function set(value) {
                value = Math.max(0, Math.min(1, value));
                var iridescenceInfo = this.shaderData.getVector4(PBRMaterial._iridescenceInfoProp);
                if (!!iridescenceInfo.x !== !!value) {
                    if (value === 0) {
                        this.shaderData.disableMacro("MATERIAL_ENABLE_IRIDESCENCE");
                    } else {
                        this.shaderData.enableMacro("MATERIAL_ENABLE_IRIDESCENCE");
                    }
                }
                iridescenceInfo.x = value;
            }
        },
        {
            key: "iridescenceTexture",
            get: /**
   * The iridescence intensity texture, sampling red channel, and multiply 'iridescence'.
   */ function get() {
                return this.shaderData.getTexture(PBRMaterial._iridescenceTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(PBRMaterial._iridescenceTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro("MATERIAL_HAS_IRIDESCENCE_TEXTURE");
                } else {
                    this.shaderData.disableMacro("MATERIAL_HAS_IRIDESCENCE_TEXTURE");
                }
            }
        },
        {
            key: "iridescenceIOR",
            get: /**
   * The index of refraction of the dielectric thin-film layer, greater than or equal to 1.0.
   * @defaultValue `1.3`
   */ function get() {
                return this.shaderData.getVector4(PBRMaterial._iridescenceInfoProp).y;
            },
            set: function set(value) {
                var iridescenceInfo = this.shaderData.getVector4(PBRMaterial._iridescenceInfoProp);
                iridescenceInfo.y = Math.max(value, 1.0);
            }
        },
        {
            key: "iridescenceThicknessRange",
            get: /**
   * The range of iridescence thickness, x is minimum, y is maximum.
   *  @defaultValue `[100, 400]`
   */ function get() {
                return this._iridescenceRange;
            },
            set: function set(value) {
                if (this._iridescenceRange !== value) {
                    this._iridescenceRange.copyFrom(value);
                }
            }
        },
        {
            key: "iridescenceThicknessTexture",
            get: /**
   * The thickness texture of the thin-film layer, sampling green channel.
   * @remarks
   * If iridescenceThicknessTexture is defined, iridescence thickness between the 'iridescenceThicknessRange'.
   * If iridescenceThicknessTexture is not defined, iridescence thickness will use only 'iridescenceThicknessRange.y'.
   */ function get() {
                return this.shaderData.getTexture(PBRMaterial._iridescenceThicknessTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(PBRMaterial._iridescenceThicknessTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro("MATERIAL_HAS_IRIDESCENCE_THICKNESS_TEXTURE");
                } else {
                    this.shaderData.disableMacro("MATERIAL_HAS_IRIDESCENCE_THICKNESS_TEXTURE");
                }
            }
        },
        {
            key: "sheenColor",
            get: /**
   * Sheen color.
   * @defaultValue `[0,0,0]`
   */ function get() {
                return this.shaderData.getColor(PBRMaterial._sheenColorProp);
            },
            set: function set(value) {
                var sheenColor = this.shaderData.getColor(PBRMaterial._sheenColorProp);
                if (value !== sheenColor) {
                    sheenColor.copyFrom(value);
                }
            }
        },
        {
            key: "sheenRoughness",
            get: /**
   * Sheen roughness, from 0.0 to 1.0.
   * @defaultValue `0.0`
   */ function get() {
                return this.shaderData.getFloat(PBRMaterial._sheenRoughnessProp);
            },
            set: function set(value) {
                value = Math.max(0, Math.min(1, value));
                this.shaderData.setFloat(PBRMaterial._sheenRoughnessProp, value);
            }
        },
        {
            key: "sheenColorTexture",
            get: /**
   * Sheen color texture, multiply ‘sheenColor’.
   */ function get() {
                return this.shaderData.getTexture(PBRMaterial._sheenTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(PBRMaterial._sheenTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro("MATERIAL_HAS_SHEEN_TEXTURE");
                } else {
                    this.shaderData.disableMacro("MATERIAL_HAS_SHEEN_TEXTURE");
                }
            }
        },
        {
            key: "sheenRoughnessTexture",
            get: /**
   * Sheen roughness texture.
   * @remarks Use alpha channel, and multiply 'sheenRoughness'.
   */ function get() {
                return this.shaderData.getTexture(PBRMaterial._sheenRoughnessTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(PBRMaterial._sheenRoughnessTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro("MATERIAL_HAS_SHEEN_ROUGHNESS_TEXTURE");
                } else {
                    this.shaderData.disableMacro("MATERIAL_HAS_SHEEN_ROUGHNESS_TEXTURE");
                }
            }
        },
        {
            key: "refractionMode",
            get: /**
   * Refraction switch.
   * @remarks Use refractionMode to set the refraction shape.
   */ function get() {
                return this._refractionMode;
            },
            set: function set(value) {
                if (value !== this._refractionMode) {
                    this._refractionMode = value;
                    this.shaderData.enableMacro("REFRACTION_MODE", value.toString());
                }
            }
        },
        {
            key: "isTransparent",
            get: /**
   * @inheritdoc
   */ function get() {
                return this._isTransparent;
            },
            set: function set(value) {
                this._seIsTransparent(value);
                if (this.transmission > 0) {
                    // If transmission enabled, always use transparent queue to ensure get correct opaque texture
                    this.renderState.renderQueueType = RenderQueueType.Transparent;
                }
            }
        },
        {
            key: "alphaCutoff",
            get: /**
   * @inheritdoc
   */ function get() {
                return this.shaderData.getFloat(BaseMaterial._alphaCutoffProp);
            },
            set: function set(value) {
                this._setAlphaCutoff(value);
                if (this.transmission > 0) {
                    // If transmission enabled, always use transparent queue to ensure get correct opaque texture
                    this.renderState.renderQueueType = RenderQueueType.Transparent;
                }
            }
        },
        {
            key: "transmission",
            get: /**
   * Transmission factor.
   * @defaultValue `0.0`
   */ function get() {
                return this.shaderData.getFloat(PBRMaterial._transmissionProp);
            },
            set: function set(value) {
                value = MathUtil.clamp(value, 0, 1);
                if (!!this.shaderData.getFloat(PBRMaterial._transmissionProp) !== !!value) {
                    if (value > 0) {
                        this.shaderData.enableMacro(PBRMaterial._transmissionMacro);
                        this.renderState.renderQueueType = RenderQueueType.Transparent;
                    } else {
                        this.shaderData.disableMacro(PBRMaterial._transmissionMacro);
                    }
                }
                this.shaderData.setFloat(PBRMaterial._transmissionProp, value);
            }
        },
        {
            key: "transmissionTexture",
            get: /**
   * Transmission texture.
   * @remarks Use red channel, and multiply 'transmission'.
   */ function get() {
                return this.shaderData.getTexture(PBRMaterial._transmissionTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(PBRMaterial._transmissionTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro(PBRMaterial._transmissionTextureMacro);
                } else {
                    this.shaderData.disableMacro(PBRMaterial._transmissionTextureMacro);
                }
            }
        },
        {
            key: "attenuationColor",
            get: /**
   * Attenuation color.
   * @defaultValue `[1,1,1]`
   */ function get() {
                return this.shaderData.getColor(PBRMaterial._attenuationColorProp);
            },
            set: function set(value) {
                var attenuationColor = this.shaderData.getColor(PBRMaterial._attenuationColorProp);
                if (value !== attenuationColor) {
                    attenuationColor.copyFrom(value);
                }
            }
        },
        {
            key: "attenuationDistance",
            get: /**
   * Attenuation distance, greater than 0.0.
   * @defaultValue `infinity`
   */ function get() {
                return this.shaderData.getFloat(PBRMaterial._attenuationDistanceProp);
            },
            set: function set(value) {
                value = Math.max(0, value);
                this.shaderData.setFloat(PBRMaterial._attenuationDistanceProp, value);
            }
        },
        {
            key: "thickness",
            get: /**
   * Thickness, greater than or equal to 0.0.
   * @defaultValue `0.0`
   */ function get() {
                return this.shaderData.getFloat(PBRMaterial._thicknessProp);
            },
            set: function set(value) {
                value = Math.max(0, value);
                if (!!this.shaderData.getFloat(PBRMaterial._thicknessProp) !== !!value) {
                    if (value > 0) {
                        this.shaderData.enableMacro(PBRMaterial._thicknessMacro);
                    } else {
                        this.shaderData.disableMacro(PBRMaterial._thicknessMacro);
                    }
                }
                this.shaderData.setFloat(PBRMaterial._thicknessProp, value);
            }
        },
        {
            key: "thicknessTexture",
            get: /**
   * Thickness texture.
   * @remarks Use green channel, and multiply 'thickness', range is 0.0 to 1.0.
   */ function get() {
                return this.shaderData.getTexture(PBRMaterial._thicknessTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(PBRMaterial._thicknessTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro(PBRMaterial._thicknessTextureMacro);
                } else {
                    this.shaderData.disableMacro(PBRMaterial._thicknessTextureMacro);
                }
            }
        }
    ]);
    return PBRMaterial;
}(PBRBaseMaterial);
PBRMaterial._metallicProp = ShaderProperty.getByName("material_Metal");
PBRMaterial._roughnessProp = ShaderProperty.getByName("material_Roughness");
PBRMaterial._roughnessMetallicTextureProp = ShaderProperty.getByName("material_RoughnessMetallicTexture");
PBRMaterial._iorProp = ShaderProperty.getByName("material_IOR");
PBRMaterial._anisotropyInfoProp = ShaderProperty.getByName("material_AnisotropyInfo");
PBRMaterial._anisotropyTextureProp = ShaderProperty.getByName("material_AnisotropyTexture");
PBRMaterial._iridescenceInfoProp = ShaderProperty.getByName("material_IridescenceInfo");
PBRMaterial._iridescenceThicknessTextureProp = ShaderProperty.getByName("material_IridescenceThicknessTexture");
PBRMaterial._iridescenceTextureProp = ShaderProperty.getByName("material_IridescenceTexture");
PBRMaterial._sheenColorProp = ShaderProperty.getByName("material_SheenColor");
PBRMaterial._sheenRoughnessProp = ShaderProperty.getByName("material_SheenRoughness");
PBRMaterial._sheenTextureProp = ShaderProperty.getByName("material_SheenTexture");
PBRMaterial._sheenRoughnessTextureProp = ShaderProperty.getByName("material_SheenRoughnessTexture");
PBRMaterial._transmissionMacro = ShaderMacro.getByName("MATERIAL_ENABLE_TRANSMISSION");
PBRMaterial._thicknessMacro = ShaderMacro.getByName("MATERIAL_HAS_THICKNESS");
PBRMaterial._thicknessTextureMacro = ShaderMacro.getByName("MATERIAL_HAS_THICKNESS_TEXTURE");
PBRMaterial._transmissionTextureMacro = ShaderMacro.getByName("MATERIAL_HAS_TRANSMISSION_TEXTURE");
PBRMaterial._transmissionProp = ShaderProperty.getByName("material_Transmission");
PBRMaterial._transmissionTextureProp = ShaderProperty.getByName("material_TransmissionTexture");
PBRMaterial._attenuationColorProp = ShaderProperty.getByName("material_AttenuationColor");
PBRMaterial._attenuationDistanceProp = ShaderProperty.getByName("material_AttenuationDistance");
PBRMaterial._thicknessProp = ShaderProperty.getByName("material_Thickness");
PBRMaterial._thicknessTextureProp = ShaderProperty.getByName("material_ThicknessTexture");

/**
 * PBR (Specular-Glossiness Workflow) Material.
 */ var PBRSpecularMaterial = /*#__PURE__*/ function(PBRBaseMaterial) {
    _inherits$2(PBRSpecularMaterial, PBRBaseMaterial);
    function PBRSpecularMaterial(engine) {
        var _this;
        _this = PBRBaseMaterial.call(this, engine, Shader.find("pbr-specular")) || this;
        _this.shaderData.setColor(PBRSpecularMaterial._specularColorProp, new Color(1, 1, 1, 1));
        _this.shaderData.setFloat(PBRSpecularMaterial._glossinessProp, 1.0);
        return _this;
    }
    var _proto = PBRSpecularMaterial.prototype;
    /**
   * @inheritdoc
   */ _proto.clone = function clone() {
        var dest = new PBRSpecularMaterial(this._engine);
        this._cloneToAndModifyName(dest);
        return dest;
    };
    _create_class$2(PBRSpecularMaterial, [
        {
            key: "specularColor",
            get: /**
   * Specular color.
   */ function get() {
                return this.shaderData.getColor(PBRSpecularMaterial._specularColorProp);
            },
            set: function set(value) {
                var specularColor = this.shaderData.getColor(PBRSpecularMaterial._specularColorProp);
                if (value !== specularColor) {
                    specularColor.copyFrom(value);
                }
            }
        },
        {
            key: "glossiness",
            get: /**
   * Glossiness.
   */ function get() {
                return this.shaderData.getFloat(PBRSpecularMaterial._glossinessProp);
            },
            set: function set(value) {
                this.shaderData.setFloat(PBRSpecularMaterial._glossinessProp, value);
            }
        },
        {
            key: "specularGlossinessTexture",
            get: /**
   * Specular glossiness texture.
   * @remarks RGB is specular, A is glossiness
   */ function get() {
                return this.shaderData.getTexture(PBRSpecularMaterial._specularGlossinessTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(PBRSpecularMaterial._specularGlossinessTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro(PBRSpecularMaterial._specularGlossinessTextureMacro);
                } else {
                    this.shaderData.disableMacro(PBRSpecularMaterial._specularGlossinessTextureMacro);
                }
            }
        }
    ]);
    return PBRSpecularMaterial;
}(PBRBaseMaterial);
PBRSpecularMaterial._specularColorProp = ShaderProperty.getByName("material_PBRSpecularColor");
PBRSpecularMaterial._glossinessProp = ShaderProperty.getByName("material_Glossiness");
PBRSpecularMaterial._specularGlossinessTextureProp = ShaderProperty.getByName("material_SpecularGlossinessTexture");
PBRSpecularMaterial._specularGlossinessTextureMacro = ShaderMacro.getByName("MATERIAL_HAS_SPECULAR_GLOSSINESS_TEXTURE");

/**
 * Unlit Material.
 */ var UnlitMaterial = /*#__PURE__*/ function(BaseMaterial) {
    _inherits$2(UnlitMaterial, BaseMaterial);
    function UnlitMaterial(engine) {
        var _this;
        _this = BaseMaterial.call(this, engine, Shader.find("unlit")) || this;
        var shaderData = _this.shaderData;
        shaderData.enableMacro("MATERIAL_OMIT_NORMAL");
        shaderData.enableMacro("MATERIAL_NEED_TILING_OFFSET");
        shaderData.setColor(UnlitMaterial._baseColorProp, new Color(1, 1, 1, 1));
        shaderData.setVector4(UnlitMaterial._tilingOffsetProp, new Vector4(1, 1, 0, 0));
        return _this;
    }
    var _proto = UnlitMaterial.prototype;
    /**
   * @inheritdoc
   */ _proto.clone = function clone() {
        var dest = new UnlitMaterial(this._engine);
        this._cloneToAndModifyName(dest);
        return dest;
    };
    _create_class$2(UnlitMaterial, [
        {
            key: "baseColor",
            get: /**
   * Base color.
   */ function get() {
                return this.shaderData.getColor(UnlitMaterial._baseColorProp);
            },
            set: function set(value) {
                var baseColor = this.shaderData.getColor(UnlitMaterial._baseColorProp);
                if (value !== baseColor) {
                    baseColor.copyFrom(value);
                }
            }
        },
        {
            key: "baseTexture",
            get: /**
   * Base texture.
   */ function get() {
                return this.shaderData.getTexture(UnlitMaterial._baseTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(UnlitMaterial._baseTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro(UnlitMaterial._baseTextureMacro);
                } else {
                    this.shaderData.disableMacro(UnlitMaterial._baseTextureMacro);
                }
            }
        },
        {
            key: "tilingOffset",
            get: /**
   * Tiling and offset of main textures.
   */ function get() {
                return this.shaderData.getVector4(UnlitMaterial._tilingOffsetProp);
            },
            set: function set(value) {
                var tilingOffset = this.shaderData.getVector4(UnlitMaterial._tilingOffsetProp);
                if (value !== tilingOffset) {
                    tilingOffset.copyFrom(value);
                }
            }
        }
    ]);
    return UnlitMaterial;
}(BaseMaterial);

/**
 * A helper class to blit texture to destination render target.
 */ var Blitter = /*#__PURE__*/ function() {
    function Blitter() {}
    /**
   * Blit texture to destination render target using a triangle.
   * @param engine - Engine
   * @param source - Source texture
   * @param destination - Destination render target
   * @param mipLevel - Mip level to blit
   * @param viewport - Viewport
   * @param material - The material to use when blit
   * @param passIndex - Pass index to use of the provided material
   * @param sourceScaleOffset - Source scale and offset
   */ Blitter.blitTexture = function blitTexture(engine, source, destination, mipLevel, viewport, material, passIndex, sourceScaleOffset) {
        if (mipLevel === void 0) mipLevel = 0;
        if (viewport === void 0) viewport = PipelineUtils.defaultViewport;
        if (material === void 0) material = null;
        if (passIndex === void 0) passIndex = 0;
        var basicResources = engine._basicResources;
        var blitMesh = destination ? basicResources.flipYBlitMesh : basicResources.blitMesh;
        var blitMaterial = material || basicResources.blitMaterial;
        var rhi = engine._hardwareRenderer;
        var context = engine._renderContext;
        var camera = context.camera;
        // We not use projection matrix when blit, but we must modify flipProjection to make front face correct
        context.flipProjection = !!destination;
        context.setRenderTarget(destination, viewport, 0);
        var rendererShaderData = Blitter._rendererShaderData;
        rendererShaderData.setTexture(Blitter._blitTextureProperty, source);
        rendererShaderData.setFloat(Blitter._blitMipLevelProperty, mipLevel);
        Blitter._texelSize.set(1 / source.width, 1 / source.height, source.width, source.height);
        rendererShaderData.setVector4(Blitter._blitTexelSizeProperty, Blitter._texelSize);
        rendererShaderData.setVector4(Blitter._sourceScaleOffsetProperty, sourceScaleOffset != null ? sourceScaleOffset : Blitter._defaultScaleOffset);
        var pass = blitMaterial.shader.subShaders[0].passes[passIndex];
        var compileMacros = Shader._compileMacros;
        ShaderMacroCollection.unionCollection(camera._globalShaderMacro, blitMaterial.shaderData._macroCollection, compileMacros);
        ShaderMacroCollection.unionCollection(compileMacros, engine._macroCollection, compileMacros);
        var program = pass._getShaderProgram(engine, compileMacros);
        program.bind();
        program.groupingOtherUniformBlock();
        program.uploadAll(program.sceneUniformBlock, camera.scene.shaderData);
        program.uploadAll(program.cameraUniformBlock, camera.shaderData);
        program.uploadAll(program.rendererUniformBlock, rendererShaderData);
        program.uploadAll(program.materialUniformBlock, blitMaterial.shaderData);
        program.uploadUnGroupTextures();
        (pass._renderState || blitMaterial.renderState)._applyStates(engine, false, pass._renderStateDataMap, blitMaterial.shaderData);
        rhi.drawPrimitive(blitMesh._primitive, blitMesh.subMesh, program);
        rendererShaderData.setTexture(Blitter._blitTextureProperty, null);
    };
    return Blitter;
}();
Blitter._blitTextureProperty = ShaderProperty.getByName("renderer_BlitTexture");
Blitter._blitMipLevelProperty = ShaderProperty.getByName("renderer_BlitMipLevel");
Blitter._blitTexelSizeProperty = ShaderProperty.getByName("renderer_texelSize") // x: 1/width, y: 1/height, z: width, w: height
;
Blitter._sourceScaleOffsetProperty = ShaderProperty.getByName("renderer_SourceScaleOffset");
Blitter._rendererShaderData = new ShaderData(ShaderDataGroup.Renderer);
Blitter._texelSize = new Vector4();
Blitter._defaultScaleOffset = new Vector4(1, 1, 0, 0);

var Filtering = "#define GLSLIFY 1\n#ifndef FILTERING\n#define FILTERING\n\nvec2 bSpline3MiddleLeft(vec2 x){\n    return 0.16666667 + x * (0.5 + x * (0.5 - x * 0.5));\n}\n\nvec2 bSpline3MiddleRight(vec2 x){\n      return 0.66666667 + x * (-1.0 + 0.5 * x) * x;\n}\n\nvec2 bSpline3Rightmost(vec2 x){\n      return 0.16666667 + x * (-0.5 + x * (0.5 - x * 0.16666667));\n}\n\n// Compute weights & offsets for 4x bilinear taps for the bicubic B-Spline filter.\n// The fractional coordinate should be in the [0, 1] range (centered on 0.5).\n// Inspired by: http://vec3.ca/bicubic-filtering-in-fewer-taps/\nvoid bicubicFilter(vec2 fracCoord, out vec2 weights[2], out vec2 offsets[2]){\n      vec2 r  = bSpline3Rightmost(fracCoord);\n      vec2 mr = bSpline3MiddleRight(fracCoord);\n      vec2 ml = bSpline3MiddleLeft(fracCoord);\n      vec2 l  = 1.0 - mr - ml - r;\n\n      weights[0] = r + mr;\n      weights[1] = ml + l;\n      offsets[0] = -1.0 + mr / weights[0];\n      offsets[1] =  1.0 + l / weights[1];\n}\n\n// texSize: (1/width, 1/height, width, height)\nvec4 sampleTexture2DBicubic(sampler2D tex, vec2 coord, vec4 texSize){\n\tvec2 xy = coord * texSize.zw + 0.5;\n    vec2 ic = floor(xy);\n    vec2 fc = fract(xy);\n\n    vec2 weights[2], offsets[2];\n    bicubicFilter(fc, weights, offsets);\n\n    return weights[0].y * (weights[0].x * texture2DSRGB(tex, (ic + vec2(offsets[0].x, offsets[0].y) - 0.5) * texSize.xy)  +\n                        \tweights[1].x * texture2DSRGB(tex, (ic + vec2(offsets[1].x, offsets[0].y) - 0.5) * texSize.xy)) +\n            weights[1].y * (weights[0].x * texture2DSRGB(tex, (ic + vec2(offsets[0].x, offsets[1].y) - 0.5) * texSize.xy)  +\n                            weights[1].x * texture2DSRGB(tex, (ic + vec2(offsets[1].x, offsets[1].y) - 0.5) * texSize.xy));\n}\n\n#endif"; // eslint-disable-line

var PostCommon = "#define GLSLIFY 1\n#ifndef POST_COMMON\n#define POST_COMMON\n\n#include <common>\n#define FLT_MIN  1.175494351e-38 // Minimum normalized positive floating-point number\n#define HALF_MIN 6.103515625e-5  // 2^-14, the same value for 10, 11 and 16-bit: https://www.khronos.org/opengl/wiki/Small_Float_Formats\n#define HALF_MAX 65504.0 // (2 - 2^-10) * 2^15\n\nfloat min3(vec3 val) { return min(min(val.x, val.y), val.z); }\nfloat max3(vec3 val) { return max(max(val.x, val.y), val.z); }\n\nconst float INVERT_LOG10 = 0.43429448190325176;\n\nfloat log10(float x){\n    return log(x) * INVERT_LOG10;\n}\n\n#endif"; // eslint-disable-line

var ACESTonemapping = "#define GLSLIFY 1\n#include <ColorTransform>\n#include <RRT>\n#include <ODT>\n\nvec3 ACESTonemap(vec3 color){\n    vec3 aces = sRGB_2_AP0 * color;\n    \n    // --- Glow module --- //\n    mediump float saturation = rgb_2_saturation(aces);\n    mediump float ycIn = rgb_2_yc(aces);\n    mediump float s = sigmoid_shaper((saturation - 0.4) / 0.2);\n    float addedGlow = 1.0 + glow_fwd(ycIn, RRT_GLOW_GAIN * s, RRT_GLOW_MID);\n    aces *= addedGlow;\n\n    // --- Red modifier --- //\n    mediump float hue = rgb_2_hue(vec3(aces));\n    mediump float centeredHue = center_hue(hue, RRT_RED_HUE);\n    float hueWeight = smoothstep(0.0, 1.0, 1.0 - abs(2.0 * centeredHue / RRT_RED_WIDTH));\n    hueWeight *= hueWeight;\n\n    aces.r += hueWeight * saturation * (RRT_RED_PIVOT - aces.r) * (1.0 - RRT_RED_SCALE);\n\n    // --- ACES to RGB rendering space --- //\n    vec3 acescg = max(AP0_2_AP1_MAT * aces, 0.0);\n\n    // --- Global desaturation --- //\n    acescg = mix(vec3(dot(acescg, AP1_RGB2Y)), acescg, RRT_SAT_FACTOR);\n\n    // Apply RRT and ODT\n    // https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n    const float a = 0.0245786;\n    const float b = 0.000090537;\n    const float c = 0.983729;\n    const float d = 0.4329510;\n    const float e = 0.238081;\n\n    // To reduce the likelyhood of extremely large values, we avoid using the x^2 term and therefore\n    // divide numerator and denominator by it. This will lead to the constant factors of the\n    // quadratic in the numerator and denominator to be divided by x; we add a tiny epsilon to avoid divide by 0.\n    vec3 rcpAcesCG = 1.0 / (acescg + FLT_MIN);\n    mediump vec3 rgbPost = (acescg + a - b * rcpAcesCG) /\n    (acescg * c + d + e * rcpAcesCG);\n\n    // Apply gamma adjustment to compensate for dim surround\n    vec3 linearCV = darkSurround_to_dimSurround(rgbPost);\n\n    // Apply desaturation to compensate for luminance difference\n    linearCV = mix(vec3(dot(linearCV, AP1_RGB2Y)), linearCV, ODT_SAT_FACTOR);\n\n    // Convert to display primary encoding\n    // Rendering space RGB to XYZ\n    vec3 XYZ = AP1_2_XYZ_MAT * linearCV;\n\n    // Apply CAT from ACES white point to assumed observer adapted white point\n    XYZ = D60_2_D65_CAT * XYZ;\n\n    // CIE XYZ to display primaries\n    linearCV = XYZ_2_REC709_MAT * XYZ;\n\n    return linearCV;\n\n}"; // eslint-disable-line

var ColorTransform = "#define GLSLIFY 1\n#ifndef COLOR_TRANSFORM\n#define COLOR_TRANSFORM\n\n// Precomputed matrices (pre-transposed)\n// See https://github.com/ampas/aces-dev/blob/master/transforms/ctl/README-MATRIX.md\n  \n  const mediump mat3 sRGB_2_AP0 = mat3(\n    0.4397010, 0.0897923, 0.0175440,\n    0.3829780, 0.8134230, 0.1115440,\n    0.1773350, 0.0967616, 0.8707040\n  );\n\n  const mediump mat3 AP1_2_AP0_MAT = mat3(\n    vec3(0.6954522414, 0.0447945634, -0.0055258826),\n    vec3(0.1406786965, 0.8596711185, 0.0040252103),\n    vec3(0.1638690622, 0.0955343182, 1.0015006723)\n  );\n\n  const mediump mat3 AP0_2_AP1_MAT = mat3(\n\tvec3(1.4514393161, -0.0765537734, 0.0083161484),\n    vec3(-0.2365107469, 1.1762296998, -0.0060324498),\n    vec3(-0.2149285693, -0.0996759264, 0.9977163014)\n  );\n\n  const mediump mat3 AP1_2_XYZ_MAT = mat3(\n    vec3(0.6624541811, 0.2722287168, -0.0055746495),\n    vec3(0.1340042065, 0.6740817658, 0.0040607335),\n    vec3(0.1561876870, 0.0536895174, 1.0103391003)\n  );\n\n  const mediump mat3 XYZ_2_AP1_MAT = mat3(\n    vec3(1.6410233797, -0.6636628587, 0.0117218943),\n    vec3(-0.3248032942, 1.6153315917, -0.0082844420),\n    vec3(-0.2364246952, 0.0167563477, 0.9883948585)\n  );\n\n  const mediump mat3 D60_2_D65_CAT = mat3(\n    vec3(0.987224, -0.00759836, 0.00307257),\n    vec3(-0.00611327, 1.00186, -0.00509595),\n    vec3(0.0159533, 0.00533002, 1.08168)\n  );\n\n  const mediump mat3 XYZ_2_REC709_MAT = mat3(\n    vec3(3.2409699419, -0.9692436363, 0.0556300797),\n    vec3(-1.5373831776, 1.8759675015, -0.2039769589),\n    vec3(-0.498610760, 0.0415550574, 1.0569715142)\n  );\n\n  const mediump vec3 AP1_RGB2Y = vec3(0.2722287168, 0.6740817658, 0.0536895174);\n\n  mediump float rgb_2_saturation(mediump vec3 rgb){\n    const mediump float TINY = 1e-4;\n    mediump float mi = min3(rgb);\n    mediump float ma = max3(rgb);\n    return (max(ma, TINY) - max(mi, TINY)) / max(ma, 1e-2);\n  }\n\n  mediump float rgb_2_yc(mediump vec3 rgb){\n    const mediump float ycRadiusWeight = 1.75;\n\n    // Converts RGB to a luminance proxy, here called YC\n    // YC is ~ Y + K * Chroma\n    // Constant YC is a cone-shaped surface in RGB space, with the tip on the\n    // neutral axis, towards white.\n    // YC is normalized: RGB 1 1 1 maps to YC = 1\n    //\n    // ycRadiusWeight defaults to 1.75, although can be overridden in function\n    // call to rgb_2_yc\n    // ycRadiusWeight = 1 -> YC for pure cyan, magenta, yellow == YC for neutral\n    // of same value\n    // ycRadiusWeight = 2 -> YC for pure red, green, blue  == YC for  neutral of\n    // same value.\n\n    mediump float r = rgb.x;\n    mediump float g = rgb.y;\n    mediump float b = rgb.z;\n    mediump float k = b * (b - g) + g * (g - r) + r * (r - b);\n    k = max(k, 0.0); // Clamp to avoid precision issue causing k < 0, making sqrt(k) undefined\n    float chroma = k == 0.0 ? 0.0 : sqrt(k); // Avoid NaN\n\n    return (b + g + r + ycRadiusWeight * chroma) / 3.0;\n  }\n\n  mediump float rgb_2_hue(mediump vec3 rgb){\n    // Returns a geometric hue angle in degrees (0-360) based on RGB values.\n    // For neutral colors, hue is undefined and the function will return a quiet NaN value.\n    mediump float hue;\n    if (rgb.x == rgb.y && rgb.y == rgb.z){\n      hue = 0.0; // RGB triplets where RGB are equal have an undefined hue\n    } else{\n      hue = (180.0 / PI) * atan(sqrt(3.0) * (rgb.y - rgb.z), 2.0 * rgb.x - rgb.y - rgb.z);\n    }\n\n    if (hue < 0.0){\n      hue = hue + 360.0;\n    } \n\n    return hue;\n  }\n\n  mediump float center_hue(mediump float hue, mediump float centerH){\n    mediump float hueCentered = hue - centerH;\n    if (hueCentered < -180.0){\n      hueCentered = hueCentered + 360.0;\n    } else if (hueCentered > 180.0){\n      hueCentered = hueCentered - 360.0;\n    } \n\n    return hueCentered;\n  }\n\n#endif"; // eslint-disable-line

var ODT = "#define GLSLIFY 1\n#include <Tonescale>\n\n// Output Device Transform - RGB computer monitor\n\nconst float CINEMA_WHITE = 48.0;\nconst float CINEMA_BLACK = 0.02; // CINEMA_WHITE / 2400.0;\nconst float ODT_SAT_FACTOR = 0.93;\n\nmediump vec3 Y_2_linCV(mediump vec3 Y, mediump float Ymax, mediump float Ymin){\n    return (Y - Ymin) / (Ymax - Ymin);\n}\n\nmediump vec3 XYZ_2_xyY(mediump vec3 XYZ){\n    mediump float divisor = max(dot(XYZ, vec3(1.0)), 1e-4);\n    return vec3(XYZ.xy / divisor, XYZ.y);\n}\n\nmediump vec3 xyY_2_XYZ(mediump vec3 xyY){\n    mediump float m = xyY.z / max(xyY.y, 1e-4);\n    mediump vec3 XYZ = vec3(xyY.xz, (1.0 - xyY.x - xyY.y));\n    XYZ.xz *= m;\n    return XYZ;\n}\n\nconst mediump float DIM_SURROUND_GAMMA = 0.9811;\n\nmediump vec3 darkSurround_to_dimSurround(mediump vec3 linearCV){\n    // Extra conversions to float3/vec3 are required to avoid floating-point precision issues on some platforms.\n\n    mediump vec3 XYZ = AP1_2_XYZ_MAT * linearCV;\n    mediump vec3 xyY = XYZ_2_xyY(XYZ);\n    xyY.z = clamp(xyY.z, 0.0, HALF_MAX);\n    xyY.z = pow(xyY.z, DIM_SURROUND_GAMMA);\n    XYZ = xyY_2_XYZ(xyY);\n\n    return XYZ_2_AP1_MAT * XYZ;\n}\n\n//\n// Summary :\n//  This transform is intended for mapping OCES onto a desktop computer monitor\n//  typical of those used in motion picture visual effects production. These\n//  monitors may occasionally be referred to as \"sRGB\" displays, however, the\n//  monitor for which this transform is designed does not exactly match the\n//  specifications in IEC 61966-2-1:1999.\n//\n//  The assumed observer adapted white is D65, and the viewing environment is\n//  that of a dim surround.\n//\n//  The monitor specified is intended to be more typical of those found in\n//  visual effects production.\n//\n// Device Primaries :\n//  Primaries are those specified in Rec. ITU-R BT.709\n//  CIE 1931 chromaticities:  x         y         Y\n//              Red:          0.64      0.33\n//              Green:        0.3       0.6\n//              Blue:         0.15      0.06\n//              White:        0.3127    0.329     100 cd/m^2\n//\n// Display EOTF :\n//  The reference electro-optical transfer function specified in\n//  IEC 61966-2-1:1999.\n//\n// Signal Range:\n//    This transform outputs full range code values.\n//\n// Assumed observer adapted white point:\n//         CIE 1931 chromaticities:    x            y\n//                                     0.3127       0.329\n//\n\n// Viewing Environment:\n//   This ODT has a compensation for viewing environment variables more typical\n//   of those associated with video mastering.\n//\nmediump vec3 ODT_RGBmonitor_100nits_dim(mediump vec3 oces){\n    // The metal compiler does not optimize structure access\n    // const SegmentedSplineParams_c9 ODT_48nits = SegmentedSplineParams_c9(\n    //     // coefsLow[10]\n    //     float[10]( -1.6989700043, -1.6989700043, -1.4779000000, -1.2291000000, -0.8648000000, -0.4480000000, 0.0051800000, 0.4511080334, 0.9113744414, 0.9113744414),\n    //     // coefsHigh[10]\n    //     float[10]( 0.5154386965, 0.8470437783, 1.1358000000, 1.3802000000, 1.5197000000, 1.5985000000, 1.6467000000, 1.6746091357, 1.6878733390, 1.6878733390 ),\n    //     vec2(segmented_spline_c5_fwd(0.18*pow(2.,-6.5)),  0.02),    // minPoint\n    //     vec2(segmented_spline_c5_fwd(0.18),                4.8),    // midPoint\n    //     vec2(segmented_spline_c5_fwd(0.18*pow(2.,6.5)),   48.0),    // maxPoint\n    //     0.0,  // slopeLow\n    //     0.04  // slopeHigh\n    // );\n\n    // OCES to RGB rendering space\n    mediump vec3 rgbPre = AP0_2_AP1_MAT * oces;\n\n    // Apply the tonescale independently in rendering-space RGB\n    mediump vec3 rgbPost;\n\n    // rgbPost.r = segmented_spline_c9_fwd(rgbPre.r, ODT_48nits);\n    // rgbPost.g = segmented_spline_c9_fwd(rgbPre.g, ODT_48nits);\n    // rgbPost.b = segmented_spline_c9_fwd(rgbPre.b, ODT_48nits);\n\n    rgbPost.r = segmented_spline_c9_fwd(rgbPre.r);\n    rgbPost.g = segmented_spline_c9_fwd(rgbPre.g);\n    rgbPost.b = segmented_spline_c9_fwd(rgbPre.b);\n\n    // Scale luminance to linear code value\n    mediump vec3 linearCV = Y_2_linCV(rgbPost, CINEMA_WHITE, CINEMA_BLACK);\n\n     // Apply gamma adjustment to compensate for dim surround\n    linearCV = darkSurround_to_dimSurround(linearCV);\n\n    // Apply desaturation to compensate for luminance difference\n    linearCV = mix(vec3(dot(linearCV, AP1_RGB2Y)), linearCV, ODT_SAT_FACTOR);\n\n    // Convert to display primary encoding\n    // Rendering space RGB to XYZ\n    mediump vec3 XYZ = AP1_2_XYZ_MAT * linearCV;\n\n    // Apply CAT from ACES white point to assumed observer adapted white point\n    XYZ = D60_2_D65_CAT * XYZ;\n\n    // CIE XYZ to display primaries\n    linearCV = XYZ_2_REC709_MAT * XYZ;\n\n    // Handle out-of-gamut values\n    // Clip values < 0 or > 1 (i.e. projecting outside the display primaries)\n    linearCV = clamp(linearCV, vec3(0), vec3(1));\n\n    // Unity already draws to a sRGB target\n    return linearCV;\n}"; // eslint-disable-line

var RRT = "#define GLSLIFY 1\n#include <Tonescale>\n\n// Reference Rendering Transform (RRT)\n\n// Sigmoid function in the range 0 to 1 spanning -2 to +2.\nmediump float sigmoid_shaper(mediump float x){\n    mediump float t = max(1.0 - abs(x / 2.0), 0.0);\n    mediump float y = 1.0 + sign(x) * (1.0 - t * t);\n\n    return y * 0.5;\n}\n\nmediump float glow_fwd(mediump float ycIn, mediump float glowGainIn, mediump float glowMid){\n    mediump float glowGainOut;\n\n    if (ycIn <= 2.0 / 3.0 * glowMid){\n        glowGainOut = glowGainIn;\n    } else if (ycIn >= 2.0 * glowMid){\n        glowGainOut = 0.0;\n    } else{\n        glowGainOut = glowGainIn * (glowMid / ycIn - 1.0 / 2.0);\n    }\n\n    return glowGainOut;\n}\n\n// \"Glow\" module constants\nconst mediump float RRT_GLOW_GAIN = 0.05;\nconst mediump float RRT_GLOW_MID = 0.08;\n\n// Red modifier constants\nconst mediump float RRT_RED_SCALE = 0.82;\nconst mediump float RRT_RED_PIVOT = 0.03;\nconst mediump float RRT_RED_HUE = 0.0;\nconst mediump float RRT_RED_WIDTH = 135.0;\n\n// Desaturation contants\nconst mediump float RRT_SAT_FACTOR = 0.96;\n\n// ACES to OCES\nmediump vec3 RRT(mediump vec3 aces){\n    // --- Glow module --- //\n    mediump float saturation = rgb_2_saturation(aces);\n    mediump float ycIn = rgb_2_yc(aces);\n    mediump float s = sigmoid_shaper((saturation - 0.4) / 0.2);\n    mediump float addedGlow = 1.0 + glow_fwd(ycIn, RRT_GLOW_GAIN * s, RRT_GLOW_MID);\n    aces *= addedGlow;\n\n    // --- Red modifier --- //\n    mediump float hue = rgb_2_hue(aces);\n    mediump float centeredHue = center_hue(hue, RRT_RED_HUE);\n\n    mediump float hueWeight = smoothstep(0.0, 1.0, 1.0 - abs(2.0 * centeredHue / RRT_RED_WIDTH));\n    hueWeight *= hueWeight;\n\n    aces.r += hueWeight * saturation * (RRT_RED_PIVOT - aces.r) * (1.0 - RRT_RED_SCALE);\n\n    // --- ACES to RGB rendering space --- //\n    aces = clamp(aces, 0.0, HALF_MAX);  // avoids saturated negative colors from becoming positive in the matrix\n    mediump vec3 rgbPre = AP0_2_AP1_MAT * aces;\n    rgbPre = clamp(rgbPre, 0.0, HALF_MAX);\n\n    // --- Global desaturation --- //\n    rgbPre = mix(vec3(dot(rgbPre, AP1_RGB2Y)), rgbPre, RRT_SAT_FACTOR);\n\n    // --- Apply the tonescale independently in rendering-space RGB --- //\n    mediump vec3 rgbPost;\n    rgbPost.x = segmented_spline_c5_fwd(rgbPre.x);\n    rgbPost.y = segmented_spline_c5_fwd(rgbPre.y);\n    rgbPost.z = segmented_spline_c5_fwd(rgbPre.z);\n\n    // --- RGB rendering space to OCES --- //\n    mediump vec3 outputVal = AP1_2_AP0_MAT * rgbPost;\n\n    return outputVal;\n}"; // eslint-disable-line

var Tonescale = "#define GLSLIFY 1\n #ifndef TONE_SCALE\n #define TONE_SCALE\n \n const mediump mat3 M = mat3(\n    vec3(0.5, -1.0, 0.5),\n    vec3(-1.0, 1.0, 0.5),\n    vec3(0.5, 0.0, 0.0)\n  );\n\n  mediump float segmented_spline_c5_fwd(mediump float x){\n    #ifdef GRAPHICS_API_WEBGL2\n      const mediump float coefsLow[6] = float[6](-4.0000000000, -4.0000000000, -3.1573765773, -0.4852499958, 1.8477324706, 1.8477324706); // coefs for B-spline between minPoint and midPoint (units of log luminance)\n      const mediump float coefsHigh[6] = float[6](-0.7185482425, 2.0810307172, 3.6681241237, 4.0000000000, 4.0000000000, 4.0000000000);   // coefs for B-spline between midPoint and maxPoint (units of log luminance)\n    #else\n      const mediump float coefsLow_0 = -4.0000000000;\n      const mediump float coefsLow_1 = -4.0000000000;\n      const mediump float coefsLow_2 = -3.1573765773;\n      const mediump float coefsLow_3 = -0.4852499958;\n      const mediump float coefsLow_4 = 1.8477324706;\n      const mediump float coefsLow_5 = 1.8477324706;\n\n      const mediump float coefsHigh_0 = -0.7185482425;\n      const mediump float coefsHigh_1 = 2.0810307172;\n      const mediump float coefsHigh_2 = 3.6681241237;\n      const mediump float coefsHigh_3 = 4.0000000000;\n      const mediump float coefsHigh_4 = 4.0000000000;\n      const mediump float coefsHigh_5 = 4.0000000000;\n    #endif\n\n    // const vec2 minPoint = vec2(0.18 * exp2(-15.0), 0.0001); // {luminance, luminance} linear extension below this\n    const mediump vec2 minPoint = vec2(0.0000054931640625, 0.0001); // {luminance, luminance} linear extension below this\n    const mediump vec2 midPoint = vec2(0.18, 0.48); // {luminance, luminance}\n    // const vec2 maxPoint = vec2(0.18 * exp2(18.0), 10000.0); // {luminance, luminance} linear extension above this\n    const mediump vec2 maxPoint = vec2(47185.92, 10000.0); // {luminance, luminance} linear extension above this\n    const mediump float slopeLow = 0.0; // log-log slope of low linear extension\n    const mediump float slopeHigh = 0.0; // log-log slope of high linear extension\n\n    const int N_KNOTS_LOW = 4;\n    const int N_KNOTS_HIGH = 4;\n\n    // Check for negatives or zero before taking the log. If negative or zero,\n    // set to ACESMIN.1\n    mediump float logx = log10(max(x, HALF_MIN));\n    mediump float logy;\n\n    if (logx <= log10(minPoint.x)){\n        logy = logx * slopeLow + (log10(minPoint.y) - slopeLow * log10(minPoint.x));\n    } else if ((logx > log10(minPoint.x)) && (logx < log10(midPoint.x))){\n        mediump float knot_coord = float(N_KNOTS_LOW - 1) * (logx - log10(minPoint.x)) / (log10(midPoint.x) - log10(minPoint.x));\n        int j = int(knot_coord);\n        mediump float t = knot_coord - float(j);\n\n        mediump vec3 cf;\n        #ifdef GRAPHICS_API_WEBGL2\n          cf = vec3(coefsLow[j], coefsLow[j + 1], coefsLow[j + 2]);\n        #else\n          if (j <= 0) {\n            cf = vec3(coefsLow_0, coefsLow_1, coefsLow_2);\n          } else if (j == 1) {\n            cf = vec3(coefsLow_1, coefsLow_2, coefsLow_3);\n          } else if (j == 2) {\n            cf = vec3(coefsLow_2, coefsLow_3, coefsLow_4);\n          } else { // if (j == 3)\n            cf = vec3(coefsLow_3, coefsLow_4, coefsLow_5);\n          }\n        #endif\n\n        mediump vec3 monomials = vec3(t * t, t, 1.0);\n        logy = dot(monomials, M * cf);\n    } else if ((logx >= log10(midPoint.x)) && (logx < log10(maxPoint.x))){\n        mediump float knot_coord = float(N_KNOTS_HIGH - 1) * (logx - log10(midPoint.x)) / (log10(maxPoint.x) - log10(midPoint.x));\n        int j = int(knot_coord);\n        mediump float t = knot_coord - float(j);\n\n        mediump vec3 cf;\n        #ifdef GRAPHICS_API_WEBGL2\n          cf = vec3(coefsHigh[j], coefsHigh[j + 1], coefsHigh[j + 2]);\n        #else\n          if (j <= 0) {\n            cf = vec3(coefsHigh_0, coefsHigh_1, coefsHigh_2);\n          } else if (j == 1) {\n            cf = vec3(coefsHigh_1, coefsHigh_2, coefsHigh_3);\n          } else if (j == 2) {\n            cf = vec3(coefsHigh_2, coefsHigh_3, coefsHigh_4);\n          } else { // if (j == 3)\n            cf = vec3(coefsHigh_3, coefsHigh_4, coefsHigh_5);\n          }\n        #endif\n\n        mediump vec3 monomials = vec3(t * t, t, 1.0);\n        logy = dot(monomials, M * cf);\n    } else {\n        logy = logx * slopeHigh + (log10(maxPoint.y) - slopeHigh * log10(maxPoint.x));\n    }\n\n    return pow(10.0, logy);\n  }\n\n  // The metal compiler does not optimize structure access\n  // struct SegmentedSplineParams_c9{\n  //   float coefsLow[10];    // coefs for B-spline between minPoint and midPoint (units of log luminance)\n  //   float coefsHigh[10];   // coefs for B-spline between midPoint and maxPoint (units of log luminance)\n  //   mediump vec2 minPoint; // {luminance, luminance} linear extension below this\n  //   mediump vec2 midPoint; // {luminance, luminance}\n  //   mediump vec2 maxPoint; // {luminance, luminance} linear extension above this\n  //   float slopeLow;       // log-log slope of low linear extension\n  //   float slopeHigh;      // log-log slope of high linear extension\n  // };\n\n  mediump float segmented_spline_c9_fwd(mediump float x){\n      // ODT_48nits\n      #ifdef GRAPHICS_API_WEBGL2\n        const mediump float coefsLow[10] = float[10](-1.6989700043, -1.6989700043, -1.4779000000, -1.2291000000, -0.8648000000, -0.4480000000, 0.0051800000, 0.4511080334, 0.9113744414, 0.9113744414);\n        const mediump float coefsHigh[10] = float[10](0.5154386965, 0.8470437783, 1.1358000000, 1.3802000000, 1.5197000000, 1.5985000000, 1.6467000000, 1.6746091357, 1.6878733390, 1.6878733390);\n      #else\n        const mediump float coefsLow_0 = -1.6989700043;\n        const mediump float coefsLow_1 = -1.6989700043;\n        const mediump float coefsLow_2 = -1.4779000000;\n        const mediump float coefsLow_3 = -1.2291000000;\n        const mediump float coefsLow_4 = -0.8648000000;\n        const mediump float coefsLow_5 = -0.4480000000;\n        const mediump float coefsLow_6 = 0.0051800000;\n        const mediump float coefsLow_7 = 0.4511080334;\n        const mediump float coefsLow_8 = 0.9113744414;\n        const mediump float coefsLow_9 = 0.9113744414;\n\n        const mediump float coefsHigh_0 = 0.5154386965;\n        const mediump float coefsHigh_1 = 0.8470437783;\n        const mediump float coefsHigh_2 = 1.1358000000;\n        const mediump float coefsHigh_3 = 1.3802000000;\n        const mediump float coefsHigh_4 = 1.5197000000;\n        const mediump float coefsHigh_5 = 1.5985000000;\n        const mediump float coefsHigh_6 = 1.6467000000;\n        const mediump float coefsHigh_7 = 1.6746091357;\n        const mediump float coefsHigh_8 = 1.6878733390;\n        const mediump float coefsHigh_9 = 1.6878733390;\n      #endif\n\n      // mediump vec2 minPoint = vec2(segmented_spline_c5_fwd(0.18 * pow(2.0, -6.5)), 0.02);\n      // mediump vec2 midPoint = vec2(segmented_spline_c5_fwd(0.18), 4.8);\n      // mediump vec2 maxPoint = vec2(segmented_spline_c5_fwd(0.18 * pow(2., 6.5)), 48.0);\n\n      const mediump vec2 minPoint = vec2(0.0028799, 0.02);\n      const mediump vec2 midPoint = vec2(4.799999, 4.8);\n      const mediump vec2 maxPoint = vec2(1005.719, 48.0);\n\n      const mediump float slopeLow = 0.0;\n      const mediump float slopeHigh = 0.04;\n\n      const int N_KNOTS_LOW = 8;\n      const int N_KNOTS_HIGH = 8;\n\n      // Check for negatives or zero before taking the log. If negative or zero,\n      // set to OCESMIN.\n      mediump float logx = log10(max(x, 1e-4));\n      mediump float logy;\n\n      if (logx <= log10(minPoint.x)) {\n          logy = logx * slopeLow + (log10(minPoint.y) - slopeLow * log10(minPoint.x));\n      } else if ((logx > log10(minPoint.x)) && (logx < log10(midPoint.x))) {\n          mediump float knot_coord = float(N_KNOTS_LOW - 1) * (logx - log10(minPoint.x)) / (log10(midPoint.x) - log10(minPoint.x));\n          int j = int(knot_coord);\n          mediump float t = knot_coord - float(j);\n\n          mediump vec3 cf;\n          #ifdef GRAPHICS_API_WEBGL2\n            cf = vec3(coefsLow[j], coefsLow[j + 1], coefsLow[j + 2]);\n          #else\n            if (j <= 0) {\n                cf = vec3(coefsLow_0, coefsLow_1, coefsLow_2);\n            } else if (j == 1) {\n                cf = vec3(coefsLow_1, coefsLow_2, coefsLow_3);\n            } else if (j == 2) {\n                cf = vec3(coefsLow_2, coefsLow_3, coefsLow_4);\n            } else if (j == 3) {\n                cf = vec3(coefsLow_3, coefsLow_4, coefsLow_5);\n            } else if (j == 4) {\n                cf = vec3(coefsLow_4, coefsLow_5, coefsLow_6);\n            } else if (j == 5) {\n                cf = vec3(coefsLow_5, coefsLow_6, coefsLow_7);\n            } else if (j == 6) {\n                cf = vec3(coefsLow_6, coefsLow_7, coefsLow_8);\n            } else { // if (j == 7)\n                cf = vec3(coefsLow_7, coefsLow_8, coefsLow_9);\n            }\n          #endif\n\n          mediump vec3 monomials = vec3(t * t, t, 1.0);\n          logy = dot(monomials, M * cf);\n      } else if ((logx >= log10(midPoint.x)) && (logx < log10(maxPoint.x))) {\n          mediump float knot_coord = float(N_KNOTS_HIGH - 1) * (logx - log10(midPoint.x)) / (log10(maxPoint.x) - log10(midPoint.x));\n          int j = int(knot_coord);\n          mediump float t = knot_coord - float(j);\n\n          mediump vec3 cf;\n          #ifdef GRAPHICS_API_WEBGL2\n            cf = vec3(coefsHigh[j], coefsHigh[j + 1], coefsHigh[j + 2]);\n          #else\n            if (j <= 0) {\n                cf = vec3(coefsHigh_0, coefsHigh_1, coefsHigh_2);\n            } else if (j == 1) {\n                cf = vec3(coefsHigh_1, coefsHigh_2, coefsHigh_3);\n            } else if (j == 2) {\n                cf = vec3(coefsHigh_2, coefsHigh_3, coefsHigh_4);\n            } else if (j == 3) {\n                cf = vec3(coefsHigh_3, coefsHigh_4, coefsHigh_5);\n            } else if (j == 4) {\n                cf = vec3(coefsHigh_4, coefsHigh_5, coefsHigh_6);\n            } else if (j == 5) {\n                cf = vec3(coefsHigh_5, coefsHigh_6, coefsHigh_7);\n            } else if (j == 6) {\n                cf = vec3(coefsHigh_6, coefsHigh_7, coefsHigh_8);\n            } else { // if (j == 7)\n                cf = vec3(coefsHigh_7, coefsHigh_8, coefsHigh_9);\n            }\n          #endif\n\n          mediump vec3 monomials = vec3(t * t, t, 1.0);\n          logy = dot(monomials, M * cf);\n      } else {\n          logy = logx * slopeHigh + (log10(maxPoint.y) - slopeHigh * log10(maxPoint.x));\n      }\n\n      return pow(10.0, logy);\n  }\n\n#endif"; // eslint-disable-line

var NeutralTonemapping = "#define GLSLIFY 1\n// Neutral tonemapping (Hable/Hejl/Frostbite)\n// Input is linear RGB\n// More accuracy to avoid NaN on extremely high values.\nvec3 neutralCurve(vec3 x, float a, float b, float c, float d, float e, float f){\n      return vec3(((x * (a * x + c * b) + d * e) / (x * (a * x + b) + d * f)) - e / f);\n}\n\n#define TONEMAPPING_CLAMP_MAX 435.18712 //(-b + sqrt(b * b - 4 * a * (HALF_MAX - d * f))) / (2 * a * whiteScale)\n//Extremely high values cause NaN output when using fp16, we clamp to avoid the performace hit of switching to fp32\n//The overflow happens in (x * (a * x + b) + d * f) of the NeutralCurve, highest value that avoids fp16 precision errors is ~571.56873\n//Since whiteScale is constant (~1.31338) max input is ~435.18712\n\nvec3 neutralTonemap(vec3 color){\n  const float a = 0.2;\n  const float b = 0.29;\n  const float c = 0.24;\n  const float d = 0.272;\n  const float e = 0.02;\n  const float f = 0.3;\n  // const float whiteLevel = 5.3;\n  // const float whiteClip = 1.0;\n\n  #ifndef GL_FRAGMENT_PRECISION_HIGH\n    color = min(color, TONEMAPPING_CLAMP_MAX);\n  #endif\n\n  // 1.0 / neutralCurve(whiteLevel, a, b, c, d, e, f);\n  const float whiteScale = 1.31338; \n  color = neutralCurve(color * whiteScale, a, b, c, d, e, f);\n  color *= whiteScale;\n\n  // Post-curve white point adjustment\n  // color /= whiteClip;\n\n  return color;\n}"; // eslint-disable-line

var UberPost = "#define GLSLIFY 1\n#include <PostCommon>\n#include <Filtering>\n#include <NeutralTonemapping>\n#include <ACESTonemapping>\n\nvarying vec2 v_uv;\nuniform sampler2D renderer_BlitTexture;\nuniform vec4 renderer_texelSize;    // x: 1/width, y: 1/height, z: width, w: height\n#ifdef ENABLE_EFFECT_BLOOM\n\tuniform sampler2D material_BloomTexture;\n\tuniform sampler2D material_BloomDirtTexture;\n\tuniform vec4 material_BloomTint;\n\tuniform vec4 material_BloomDirtTilingOffset;\n\tuniform vec4 material_BloomIntensityParams; // x: bloom intensity, y: dirt intensity\n#endif\n\nvoid main(){\n\tmediump vec4 color = texture2DSRGB(renderer_BlitTexture, v_uv);\n\n\t#ifdef ENABLE_EFFECT_BLOOM\n    \t#ifdef BLOOM_HQ\n    \t  mediump vec4 bloom = sampleTexture2DBicubic(material_BloomTexture, v_uv, renderer_texelSize);\n    \t#else\n    \t  mediump vec4 bloom = texture2DSRGB(material_BloomTexture, v_uv);\n    \t#endif\n\n    \tbloom *= material_BloomIntensityParams.x;\n    \tcolor += bloom * material_BloomTint;\n\n    \t#ifdef BLOOM_DIRT\n    \t  mediump vec4 dirt = texture2DSRGB(material_BloomDirtTexture, v_uv * material_BloomDirtTilingOffset.xy + material_BloomDirtTilingOffset.zw);\n    \t  dirt *= material_BloomIntensityParams.y;\n    \t  // Additive bloom (artist friendly)\n    \t  color += dirt * bloom;\n    \t#endif\n\t#endif\n\n\t#ifdef ENABLE_EFFECT_TONEMAPPING\n\t\t#if TONEMAPPING_MODE == 0\n      \t\tcolor.rgb = neutralTonemap(color.rgb);\n    \t#elif TONEMAPPING_MODE == 1\n      \t\tcolor.rgb = ACESTonemap(color.rgb);\n    \t#endif\n\n    \tcolor.rgb = clamp(color.rgb, vec3(0), vec3(1));\n\t#endif\n\n    gl_FragColor = color;\n}"; // eslint-disable-line

var PostProcessUberPass = /*#__PURE__*/ function(PostProcessPass) {
    _inherits$2(PostProcessUberPass, PostProcessPass);
    function PostProcessUberPass(engine) {
        var _this;
        _this = PostProcessPass.call(this, engine) || this, _this._mipDownRT = [], _this._mipUpRT = [];
        _this.event = PostProcessPassEvent.AfterUber - 1;
        // Uber Material
        var uberMaterial = new Material(engine, Shader.find(PostProcessUberPass.UBER_SHADER_NAME));
        var uberDepthState = uberMaterial.renderState.depthState;
        uberDepthState.enabled = false;
        uberDepthState.writeEnabled = false;
        _this._uberMaterial = uberMaterial;
        // Bloom Material
        var bloomMaterial = new Material(engine, Shader.find(BloomEffect.SHADER_NAME));
        var bloomDepthState = bloomMaterial.renderState.depthState;
        bloomDepthState.enabled = false;
        bloomDepthState.writeEnabled = false;
        _this._bloomMaterial = bloomMaterial;
        // ShaderData initialization
        var bloomShaderData = bloomMaterial.shaderData;
        var uberShaderData = uberMaterial.shaderData;
        bloomShaderData.setVector4(BloomEffect._bloomParams, new Vector4());
        bloomShaderData.setVector4(BloomEffect._lowMipTexelSizeProp, new Vector4());
        uberShaderData.setVector4(BloomEffect._bloomIntensityParams, new Vector4());
        uberShaderData.setVector4(BloomEffect._dirtTilingOffsetProp, new Vector4());
        uberShaderData.setColor(BloomEffect._tintProp, new Color());
        return _this;
    }
    var _proto = PostProcessUberPass.prototype;
    /** @inheritdoc */ _proto.isValid = function isValid(postProcessManager) {
        if (!this.isActive) {
            return false;
        }
        var bloomBlend = postProcessManager.getBlendEffect(BloomEffect);
        var tonemappingBlend = postProcessManager.getBlendEffect(TonemappingEffect);
        return (bloomBlend == null ? void 0 : bloomBlend.isValid()) || (tonemappingBlend == null ? void 0 : tonemappingBlend.isValid());
    };
    /**
   * @inheritdoc
   */ _proto.onRender = function onRender(camera, srcTexture, destTarget) {
        var postProcessManager = camera.scene.postProcessManager;
        var uberShaderData = this._uberMaterial.shaderData;
        var bloomBlend = postProcessManager.getBlendEffect(BloomEffect);
        var tonemappingBlend = postProcessManager.getBlendEffect(TonemappingEffect);
        if (bloomBlend == null ? void 0 : bloomBlend.isValid()) {
            this._setupBloom(bloomBlend, camera, srcTexture);
            uberShaderData.enableMacro(BloomEffect._enableMacro);
        } else {
            uberShaderData.disableMacro(BloomEffect._enableMacro);
            this._releaseBloomRenderTargets();
        }
        if (tonemappingBlend == null ? void 0 : tonemappingBlend.isValid()) {
            uberShaderData.enableMacro("TONEMAPPING_MODE", tonemappingBlend.mode.value.toString());
            uberShaderData.enableMacro(TonemappingEffect._enableMacro);
        } else {
            uberShaderData.disableMacro(TonemappingEffect._enableMacro);
        }
        Blitter.blitTexture(camera.engine, srcTexture, destTarget, 0, camera.viewport, this._uberMaterial, undefined);
    };
    /**
   * @inheritdoc
   */ _proto._onDestroy = function _onDestroy() {
        PostProcessPass.prototype._onDestroy.call(this);
        this._releaseBloomRenderTargets();
        this._uberMaterial.destroy();
        this._bloomMaterial.destroy();
    };
    _proto._setupBloom = function _setupBloom(bloomBlend, camera, srcTexture) {
        var engine = camera.engine;
        var bloomMaterial = this._bloomMaterial;
        var bloomShaderData = bloomMaterial.shaderData;
        var uberMaterial = this._uberMaterial;
        var uberShaderData = uberMaterial.shaderData;
        var downScale = bloomBlend.downScale, threshold = bloomBlend.threshold, scatter = bloomBlend.scatter, intensity = bloomBlend.intensity, tint = bloomBlend.tint, highQualityFiltering = bloomBlend.highQualityFiltering, dirtTexture = bloomBlend.dirtTexture, dirtIntensity = bloomBlend.dirtIntensity;
        // Update shaderData
        var thresholdLinear = threshold.value;
        var thresholdKnee = thresholdLinear * 0.5; // Hardcoded soft knee
        var bloomParams = bloomShaderData.getVector4(BloomEffect._bloomParams);
        var scatterLerp = MathUtil.lerp(0.05, 0.95, scatter.value);
        bloomParams.x = thresholdLinear;
        bloomParams.y = thresholdKnee;
        bloomParams.z = scatterLerp;
        var bloomIntensityParams = uberShaderData.getVector4(BloomEffect._bloomIntensityParams);
        bloomIntensityParams.x = intensity.value;
        bloomIntensityParams.y = dirtIntensity.value;
        var tintParam = uberShaderData.getColor(BloomEffect._tintProp);
        tintParam.copyFrom(tint.value);
        if (highQualityFiltering.value) {
            bloomShaderData.enableMacro(BloomEffect._hqMacro);
            uberShaderData.enableMacro(BloomEffect._hqMacro);
        } else {
            bloomShaderData.disableMacro(BloomEffect._hqMacro);
            uberShaderData.disableMacro(BloomEffect._hqMacro);
        }
        uberShaderData.setTexture(BloomEffect._dirtTextureProp, dirtTexture.value);
        if (dirtTexture) {
            uberShaderData.enableMacro(BloomEffect._dirtMacro);
        } else {
            uberShaderData.disableMacro(BloomEffect._dirtMacro);
        }
        // Determine the iteration count
        var downRes = downScale.value === BloomDownScaleMode.Half ? 1 : 2;
        var pixelViewport = camera.pixelViewport;
        var tw = pixelViewport.width >> downRes;
        var th = pixelViewport.height >> downRes;
        var maxSize = Math.max(tw, th);
        var iterations = Math.floor(Math.log2(maxSize) - 1);
        var mipCount = Math.min(Math.max(iterations, 1), BloomEffect._maxIterations);
        // Prefilter
        var internalColorTextureFormat = camera._getInternalColorTextureFormat();
        var mipWidth = tw, mipHeight = th;
        for(var i = 0; i < mipCount; i++){
            this._mipUpRT[i] = PipelineUtils.recreateRenderTargetIfNeeded(engine, this._mipUpRT[i], mipWidth, mipHeight, internalColorTextureFormat, null, false, false, !camera.enableHDR, 1, TextureWrapMode$1.Clamp, TextureFilterMode.Bilinear);
            this._mipDownRT[i] = PipelineUtils.recreateRenderTargetIfNeeded(engine, this._mipDownRT[i], mipWidth, mipHeight, internalColorTextureFormat, null, false, false, !camera.enableHDR, 1, TextureWrapMode$1.Clamp, TextureFilterMode.Bilinear);
            mipWidth = Math.max(1, Math.floor(mipWidth / 2));
            mipHeight = Math.max(1, Math.floor(mipHeight / 2));
        }
        Blitter.blitTexture(engine, srcTexture, this._mipDownRT[0], undefined, undefined, bloomMaterial, 0);
        // Down sample - gaussian pyramid
        var lastDown = this._mipDownRT[0];
        for(var i1 = 1; i1 < mipCount; i1++){
            // Classic two pass gaussian blur - use mipUp as a temporary target
            // First pass does 2x downsampling + 9-tap gaussian
            // Second pass does 9-tap gaussian using a 5-tap filter + bilinear filtering
            Blitter.blitTexture(engine, lastDown.getColorTexture(0), this._mipUpRT[i1], undefined, undefined, bloomMaterial, 1);
            Blitter.blitTexture(engine, this._mipUpRT[i1].getColorTexture(0), this._mipDownRT[i1], undefined, undefined, bloomMaterial, 2);
            lastDown = this._mipDownRT[i1];
        }
        // Up sample (bilinear by default, HQ filtering does bicubic instead
        for(var i2 = mipCount - 2; i2 >= 0; i2--){
            var lowMip = i2 == mipCount - 2 ? this._mipDownRT[i2 + 1] : this._mipUpRT[i2 + 1];
            var highMip = this._mipDownRT[i2];
            var dst = this._mipUpRT[i2];
            bloomShaderData.setTexture(BloomEffect._lowMipTextureProp, lowMip.getColorTexture(0));
            if (highQualityFiltering) {
                var texelSizeLow = bloomShaderData.getVector4(BloomEffect._lowMipTexelSizeProp);
                texelSizeLow.set(1 / lowMip.width, 1 / lowMip.height, lowMip.width, lowMip.height);
            }
            Blitter.blitTexture(engine, highMip.getColorTexture(0), dst, undefined, undefined, bloomMaterial, 3);
        }
        // Setup bloom on uber
        if (dirtTexture.value) {
            var dirtTilingOffset = uberShaderData.getVector4(BloomEffect._dirtTilingOffsetProp);
            var dirtRatio = dirtTexture.value.width / dirtTexture.value.height;
            var screenRatio = camera.aspectRatio;
            if (dirtRatio > screenRatio) {
                dirtTilingOffset.set(screenRatio / dirtRatio, 1, (1 - dirtTilingOffset.x) * 0.5, 0);
            } else if (dirtRatio < screenRatio) {
                dirtTilingOffset.set(1, dirtRatio / screenRatio, 0, (1 - dirtTilingOffset.y) * 0.5);
            } else {
                dirtTilingOffset.set(1, 1, 0, 0);
            }
        }
        uberShaderData.setTexture(BloomEffect._bloomTextureProp, this._mipUpRT[0].getColorTexture(0));
    };
    _proto._releaseBloomRenderTargets = function _releaseBloomRenderTargets() {
        var length = this._mipDownRT.length;
        for(var i = 0; i < length; i++){
            var downRT = this._mipDownRT[i];
            var upRT = this._mipUpRT[i];
            if (downRT) {
                downRT.getColorTexture(0).destroy(true);
                downRT.destroy(true);
            }
            if (upRT) {
                upRT.getColorTexture(0).destroy(true);
                upRT.destroy(true);
            }
        }
        this._mipDownRT.length = 0;
        this._mipUpRT.length = 0;
    };
    return PostProcessUberPass;
}(PostProcessPass);
PostProcessUberPass.UBER_SHADER_NAME = "UberPost";
Object.assign(ShaderLib, {
    PostCommon: PostCommon,
    Filtering: Filtering,
    ODT: ODT,
    RRT: RRT,
    Tonescale: Tonescale,
    ColorTransform: ColorTransform,
    NeutralTonemapping: NeutralTonemapping,
    ACESTonemapping: ACESTonemapping
});
Shader.create(PostProcessUberPass.UBER_SHADER_NAME, blitVs, UberPost);

/**
 * PipelinePass is a base class for all pipeline passes.
 */ var PipelinePass = function PipelinePass(engine) {
    this.engine = engine;
};

var FinalAntiAliasingFS = "#define GLSLIFY 1\n#define FXAA_PC 1\n#define FXAA_QUALITY_PRESET 12\n#define FXAA_GREEN_AS_LUMA 0\n#if defined(GRAPHICS_API_WEBGL2)\n    #define FXAA_GLSL_130 1\n#elif defined(GRAPHICS_API_WEBGL1)\n    #define FXAA_GLSL_120 1\n#endif\n\n#include <common>\n#include <FXAA3_11>\n\nconst FxaaFloat FXAA_SUBPIXEL_BLEND_AMOUNT = 0.75;\nconst FxaaFloat FXAA_RELATIVE_CONTRAST_THRESHOLD = 0.166;\nconst FxaaFloat FXAA_ABSOLUTE_CONTRAST_THRESHOLD = 0.0833;\n\nvarying vec2 v_uv;\nuniform sampler2D renderer_BlitTexture;\nuniform vec4 renderer_texelSize;    // x: 1/width, y: 1/height, z: width, w: height\n\nvec4 applyFXAA(vec4 color, vec2 positionNDC, vec4 sourceSize, sampler2D blitTexture)\n{\n    return FxaaPixelShader(\n    positionNDC,\n    color,\n    blitTexture,\n    sourceSize.xy,\n    FXAA_SUBPIXEL_BLEND_AMOUNT,\n    FXAA_RELATIVE_CONTRAST_THRESHOLD,\n    FXAA_ABSOLUTE_CONTRAST_THRESHOLD\n    );\n}\n\nvoid main(){\n\tmediump vec4 color = texture2D(renderer_BlitTexture, v_uv);\n\n    color = applyFXAA(color, v_uv, renderer_texelSize, renderer_BlitTexture);\n\n    // We have convert the color to sRGB space in sRGB pass\n    // So we need to convert it back to linear space when output to render target.\n    #ifndef ENGINE_OUTPUT_SRGB_CORRECT\n        color.rgb /= color.a;\n        color = sRGBToLinear(color);\n        color.rgb *= color.a;\n    #endif\n\n    gl_FragColor = color;\n}"; // eslint-disable-line

var SRGBFS = "#define GLSLIFY 1\n#include <common>\nvarying vec2 v_uv;\nuniform sampler2D renderer_BlitTexture;\n\nvoid main(){\n\tmediump vec4 color = texture2DSRGB(renderer_BlitTexture, v_uv);\n\n    // This is final output, maybe has alpha\n    // If we use premultiplied color to convert to sRGB. Since we ignored the background color, the greater the transparency, the greater the final composite color\n    // But the actual transparent canvas can be composited with any color of the browser background\n\n    // So we assume non-transparent SRGB conversion. Then use the Alpha value and the background canvas to do SRGB blending \n    // Although it is non-linear blending, it is more scientific\n    color.rgb = color.rgb / color.a;\n    color = linearToSRGB(color);\n    gl_FragColor = vec4(color.rgb * color.a, color.a);\n}\n"; // eslint-disable-line

var FXAA3_11 = "#define GLSLIFY 1\n//----------------------------------------------------------------------------------\n//  This file was obatined from: https://github.com/hghdev/NVIDIAGameWorks-GraphicsSamples/blob/master/samples/es3-kepler/FXAA/FXAA3_11.h\n//  NVIDIA paper: https://www.iryoku.com/aacourse/downloads/09-FXAA-3.11-in-15-Slides.pdf\n//  Modifications to this file done by Galacean:\n//  * Deleted HLSL-related macros\n//  * Deleted the macros and function except for 'FXAA_PC == 1' \n//  * Deleted the useless parameters in 'FxaaPixelShader' \n//  * Webgl does not compile the double underline, so we remove the double underline for macros\n//  * Changed the 'FXAA_GREEN_AS_LUMA == 0' code-path to compute luminance since we don't precompute luminance into the alpha channel\n//  * Change the alpha value of the `ret` finally returned by the function from brightness to transparency when `FXAA_DISCARD == 1` code path\n//----------------------------------------------------------------------------------\n\n//----------------------------------------------------------------------------------\n// File:        es3-kepler\\FXAA/FXAA3_11.h\n// SDK Version: v3.00\n// Email:       gameworks@nvidia.com\n// Site:        http://developer.nvidia.com/\n//\n// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n//  * Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//  * Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n//  * Neither the name of NVIDIA CORPORATION nor the names of its\n//    contributors may be used to endorse or promote products derived\n//    from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//----------------------------------------------------------------------------------\n/*============================================================================\n\n\n                    NVIDIA FXAA 3.11 by TIMOTHY LOTTES\n\n------------------------------------------------------------------------------\n                           INTEGRATION CHECKLIST\n------------------------------------------------------------------------------\n(1.)\nIn the shader source, setup defines for the desired configuration.\nWhen providing multiple shaders (for different presets),\nsimply setup the defines differently in multiple files.\nExample,\n\n  #define FXAA_PC 1\n  #define FXAA_HLSL_5 1\n  #define FXAA_QUALITY_PRESET 12\n\nOr,\n\n  #define FXAA_360 1\n\nOr,\n\n  #define FXAA_PS3 1\n\nEtc.\n\n(2.)\nThen include this file,\n\n  #include \"Fxaa3_11.h\"\n\n(3.)\nThen call the FXAA pixel shader from within your desired shader.\nLook at the FXAA Quality FxaaPixelShader() for docs on inputs.\nAs for FXAA 3.11 all inputs for all shaders are the same\nto enable easy porting between platforms.\n\n  return FxaaPixelShader(...);\n\n(4.)\nInsure pass prior to FXAA outputs RGBL (see next section).\nOr use,\n\n  #define FXAA_GREEN_AS_LUMA 1\n\n(5.)\nSetup engine to provide the following constants\nwhich are used in the FxaaPixelShader() inputs,\n\n  FxaaFloat2 fxaaQualityRcpFrame,\n  FxaaFloat4 fxaaConsoleRcpFrameOpt,\n  FxaaFloat4 fxaaConsoleRcpFrameOpt2,\n  FxaaFloat4 fxaaConsole360RcpFrameOpt2,\n  FxaaFloat fxaaQualitySubpix,\n  FxaaFloat fxaaQualityEdgeThreshold,\n  FxaaFloat fxaaQualityEdgeThresholdMin,\n  FxaaFloat fxaaConsoleEdgeSharpness,\n  FxaaFloat fxaaConsoleEdgeThreshold,\n  FxaaFloat fxaaConsoleEdgeThresholdMin,\n  FxaaFloat4 fxaaConsole360ConstDir\n\nLook at the FXAA Quality FxaaPixelShader() for docs on inputs.\n\n(6.)\nHave FXAA vertex shader run as a full screen triangle,\nand output \"pos\" and \"fxaaConsolePosPos\"\nsuch that inputs in the pixel shader provide,\n\n  // {xy} = center of pixel\n  FxaaFloat2 pos,\n\n  // {xy_} = upper left of pixel\n  // {_zw} = lower right of pixel\n  FxaaFloat4 fxaaConsolePosPos,\n\n(7.)\nInsure the texture sampler(s) used by FXAA are set to bilinear filtering.\n\n\n------------------------------------------------------------------------------\n                    INTEGRATION - RGBL AND COLORSPACE\n------------------------------------------------------------------------------\nFXAA3 requires RGBL as input unless the following is set,\n\n  #define FXAA_GREEN_AS_LUMA 1\n\nIn which case the engine uses green in place of luma,\nand requires RGB input is in a non-linear colorspace.\n\nRGB should be LDR (low dynamic range).\nSpecifically do FXAA after tonemapping.\n\nRGB data as returned by a texture fetch can be non-linear,\nor linear when FXAA_GREEN_AS_LUMA is not set.\nNote an \"sRGB format\" texture counts as linear,\nbecause the result of a texture fetch is linear data.\nRegular \"RGBA8\" textures in the sRGB colorspace are non-linear.\n\nIf FXAA_GREEN_AS_LUMA is not set,\nluma must be stored in the alpha channel prior to running FXAA.\nThis luma should be in a perceptual space (could be gamma 2.0).\nExample pass before FXAA where output is gamma 2.0 encoded,\n\n  color.rgb = ToneMap(color.rgb); // linear color output\n  color.rgb = sqrt(color.rgb);    // gamma 2.0 color output\n  return color;\n\nTo use FXAA,\n\n  color.rgb = ToneMap(color.rgb);  // linear color output\n  color.rgb = sqrt(color.rgb);     // gamma 2.0 color output\n  color.a = dot(color.rgb, FxaaFloat3(0.299, 0.587, 0.114)); // compute luma\n  return color;\n\nAnother example where output is linear encoded,\nsay for instance writing to an sRGB formated render target,\nwhere the render target does the conversion back to sRGB after blending,\n\n  color.rgb = ToneMap(color.rgb); // linear color output\n  return color;\n\nTo use FXAA,\n\n  color.rgb = ToneMap(color.rgb); // linear color output\n  color.a = sqrt(dot(color.rgb, FxaaFloat3(0.299, 0.587, 0.114))); // compute luma\n  return color;\n\nGetting luma correct is required for the algorithm to work correctly.\n\n\n------------------------------------------------------------------------------\n                          BEING LINEARLY CORRECT?\n------------------------------------------------------------------------------\nApplying FXAA to a framebuffer with linear RGB color will look worse.\nThis is very counter intuitive, but happends to be true in this case.\nThe reason is because dithering artifacts will be more visiable\nin a linear colorspace.\n\n\n------------------------------------------------------------------------------\n                             COMPLEX INTEGRATION\n------------------------------------------------------------------------------\nQ. What if the engine is blending into RGB before wanting to run FXAA?\n\nA. In the last opaque pass prior to FXAA,\n   have the pass write out luma into alpha.\n   Then blend into RGB only.\n   FXAA should be able to run ok\n   assuming the blending pass did not any add aliasing.\n   This should be the common case for particles and common blending passes.\n\nA. Or use FXAA_GREEN_AS_LUMA.\n\n============================================================================*/\n\n/*============================================================================\n\n                             INTEGRATION KNOBS\n\n============================================================================*/\n/*==========================================================================*/\n#ifndef FXAA_PC\n    //\n    // FXAA Quality\n    // The high quality PC algorithm.\n    //\n    #define FXAA_PC 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_GLSL_120\n    #define FXAA_GLSL_120 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_GLSL_130\n    #define FXAA_GLSL_130 0\n#endif\n/*--------------------------------------------------------------------------*/\n/*==========================================================================*/\n#ifndef FXAA_GREEN_AS_LUMA\n    //\n    // For those using non-linear color,\n    // and either not able to get luma in alpha, or not wanting to,\n    // this enables FXAA to run using green as a proxy for luma.\n    // So with this enabled, no need to pack luma in alpha.\n    //\n    // This will turn off AA on anything which lacks some amount of green.\n    // Pure red and blue or combination of only R and B, will get no AA.\n    //\n    // Might want to lower the settings for both,\n    //    fxaaConsoleEdgeThresholdMin\n    //    fxaaQualityEdgeThresholdMin\n    // In order to insure AA does not get turned off on colors \n    // which contain a minor amount of green.\n    //\n    // 1 = On.\n    // 0 = Off.\n    //\n    #define FXAA_GREEN_AS_LUMA 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_EARLY_EXIT\n    //\n    // Controls algorithm's early exit path.\n    // On PS3 turning this ON adds 2 cycles to the shader.\n    // On 360 turning this OFF adds 10ths of a millisecond to the shader.\n    // Turning this off on console will result in a more blurry image.\n    // So this defaults to on.\n    //\n    // 1 = On.\n    // 0 = Off.\n    //\n    #define FXAA_EARLY_EXIT 1\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_DISCARD\n    //\n    // Only valid for PC OpenGL currently.\n    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.\n    //\n    // 1 = Use discard on pixels which don't need AA.\n    //     For APIs which enable concurrent TEX+ROP from same surface.\n    // 0 = Return unchanged color on pixels which don't need AA.\n    //\n    #define FXAA_DISCARD 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_FAST_PIXEL_OFFSET\n    //\n    // Used for GLSL 120 only.\n    //\n    // 1 = GL API supports fast pixel offsets\n    // 0 = do not use fast pixel offsets\n    //\n    #ifdef GL_EXT_gpu_shader4\n        #define FXAA_FAST_PIXEL_OFFSET 1\n    #endif\n    #ifdef GL_NV_gpu_shader5\n        #define FXAA_FAST_PIXEL_OFFSET 1\n    #endif\n    #ifdef gpu_shader5\n        #define FXAA_FAST_PIXEL_OFFSET 1\n    #endif\n    #ifndef FXAA_FAST_PIXEL_OFFSET\n        #define FXAA_FAST_PIXEL_OFFSET 0\n    #endif\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_GATHER4_ALPHA\n    //\n    // 1 = API supports gather4 on alpha channel.\n    // 0 = API does not support gather4 on alpha channel.\n    //\n    #ifdef gpu_shader5\n        #define FXAA_GATHER4_ALPHA 1\n    #endif\n    #ifdef GL_NV_gpu_shader5\n        #define FXAA_GATHER4_ALPHA 1\n    #endif\n    #ifndef FXAA_GATHER4_ALPHA\n        #define FXAA_GATHER4_ALPHA 0\n    #endif\n#endif\n\n/*============================================================================\n                        FXAA QUALITY - TUNING KNOBS\n------------------------------------------------------------------------------\nNOTE the other tuning knobs are now in the shader function inputs!\n============================================================================*/\n#ifndef FXAA_QUALITY_PRESET\n    //\n    // Choose the quality preset.\n    // This needs to be compiled into the shader as it affects code.\n    // Best option to include multiple presets is to \n    // in each shader define the preset, then include this file.\n    // \n    // OPTIONS\n    // -----------------------------------------------------------------------\n    // 10 to 15 - default medium dither (10=fastest, 15=highest quality)\n    // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)\n    // 39       - no dither, very expensive \n    //\n    // NOTES\n    // -----------------------------------------------------------------------\n    // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)\n    // 13 = about same speed as FXAA 3.9 and better than 12\n    // 23 = closest to FXAA 3.9 visually and performance wise\n    //  _ = the lowest digit is directly related to performance\n    // _  = the highest digit is directly related to style\n    // \n    #define FXAA_QUALITY_PRESET 12\n#endif\n\n/*============================================================================\n\n                           FXAA QUALITY - PRESETS\n\n============================================================================*/\n\n/*============================================================================\n                     FXAA QUALITY - MEDIUM DITHER PRESETS\n============================================================================*/\n#if (FXAA_QUALITY_PRESET == 10)\n    #define FXAA_QUALITY_PS 3\n    #define FXAA_QUALITY_P0 1.5\n    #define FXAA_QUALITY_P1 3.0\n    #define FXAA_QUALITY_P2 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 11)\n    #define FXAA_QUALITY_PS 4\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 3.0\n    #define FXAA_QUALITY_P3 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 12)\n    #define FXAA_QUALITY_PS 5\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 4.0\n    #define FXAA_QUALITY_P4 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 13)\n    #define FXAA_QUALITY_PS 6\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 4.0\n    #define FXAA_QUALITY_P5 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 14)\n    #define FXAA_QUALITY_PS 7\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 4.0\n    #define FXAA_QUALITY_P6 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 15)\n    #define FXAA_QUALITY_PS 8\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 4.0\n    #define FXAA_QUALITY_P7 12.0\n#endif\n\n/*============================================================================\n                     FXAA QUALITY - LOW DITHER PRESETS\n============================================================================*/\n#if (FXAA_QUALITY_PRESET == 20)\n    #define FXAA_QUALITY_PS 3\n    #define FXAA_QUALITY_P0 1.5\n    #define FXAA_QUALITY_P1 2.0\n    #define FXAA_QUALITY_P2 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 21)\n    #define FXAA_QUALITY_PS 4\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 22)\n    #define FXAA_QUALITY_PS 5\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 23)\n    #define FXAA_QUALITY_PS 6\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 24)\n    #define FXAA_QUALITY_PS 7\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 3.0\n    #define FXAA_QUALITY_P6 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 25)\n    #define FXAA_QUALITY_PS 8\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 4.0\n    #define FXAA_QUALITY_P7 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 26)\n    #define FXAA_QUALITY_PS 9\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 4.0\n    #define FXAA_QUALITY_P8 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 27)\n    #define FXAA_QUALITY_PS 10\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 4.0\n    #define FXAA_QUALITY_P9 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 28)\n    #define FXAA_QUALITY_PS 11\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 4.0\n    #define FXAA_QUALITY_P10 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 29)\n    #define FXAA_QUALITY_PS 12\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 2.0\n    #define FXAA_QUALITY_P10 4.0\n    #define FXAA_QUALITY_P11 8.0\n#endif\n\n/*============================================================================\n                     FXAA QUALITY - EXTREME QUALITY\n============================================================================*/\n#if (FXAA_QUALITY_PRESET == 39)\n    #define FXAA_QUALITY_PS 12\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.0\n    #define FXAA_QUALITY_P2 1.0\n    #define FXAA_QUALITY_P3 1.0\n    #define FXAA_QUALITY_P4 1.0\n    #define FXAA_QUALITY_P5 1.5\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 2.0\n    #define FXAA_QUALITY_P10 4.0\n    #define FXAA_QUALITY_P11 8.0\n#endif\n\n/*============================================================================\n\n                                API PORTING\n\n============================================================================*/\n#if (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)\n    #define FxaaBool bool\n    #define FxaaDiscard discard\n    #define FxaaFloat float\n    #define FxaaFloat2 vec2\n    #define FxaaFloat3 vec3\n    #define FxaaFloat4 vec4\n    #define FxaaHalf float\n    #define FxaaHalf2 vec2\n    #define FxaaHalf3 vec3\n    #define FxaaHalf4 vec4\n    #define FxaaInt2 ivec2\n    #define FxaaSat(x) clamp(x, 0.0, 1.0)\n    #define FxaaTex sampler2D\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_GLSL_120 == 1)\n    // Requires,\n    //  #version 120\n    // And at least,\n    //  #extension GL_EXT_gpu_shader4 : enable\n    //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)\n    #define FxaaTexTop(t, p) texture2DLodEXT(t, p, 0.0)\n    #if (FXAA_FAST_PIXEL_OFFSET == 1)\n        #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\n    #else\n        #define FxaaTexOff(t, p, o, r) texture2DLodEXT(t, p + (o * r), 0.0)\n    #endif\n    #if (FXAA_GATHER4_ALPHA == 1)\n        // use #extension gpu_shader5 : enable\n        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n    #endif\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_GLSL_130 == 1)\n    // Requires \"#version 130\" or better\n    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)\n    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\n    #if (FXAA_GATHER4_ALPHA == 1)\n        // use #extension gpu_shader5 : enable\n        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n    #endif\n#endif\n/*--------------------------------------------------------------------------*/\n\n/*============================================================================\n                   GREEN AS LUMA OPTION SUPPORT FUNCTION\n============================================================================*/\n#if (FXAA_GREEN_AS_LUMA == 0)\n    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return dot(rgba.xyz, FxaaFloat3(0.299, 0.587, 0.114));}\n#else\n   FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\n#endif    \n\n/*============================================================================\n\n                             FXAA3 QUALITY - PC\n\n============================================================================*/\n#if (FXAA_PC == 1)\n/*--------------------------------------------------------------------------*/\nFxaaFloat4 FxaaPixelShader(\n    // Use noperspective interpolation here (turn off perspective interpolation).\n    // {xy} = center of pixel\n    FxaaFloat2 pos,\n    //\n    // Reuse the center sample as it's already available\n    // {rgb_} = the color of the center pixel (alpha won't be used)\n    FxaaFloat4 rgbyM,\n    //\n    // Input color texture.\n    // {rgb_} = color in linear or perceptual color space\n    // if (FXAA_GREEN_AS_LUMA == 0)\n    //     {__a} = luma in perceptual color space (not linear)\n    FxaaTex tex,\n    //\n    // Only used on FXAA Quality.\n    // This must be from a constant/uniform.\n    // {x_} = 1.0/screenWidthInPixels\n    // {_y} = 1.0/screenHeightInPixels\n    FxaaFloat2 fxaaQualityRcpFrame,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITY_SUBPIX define.\n    // It is here now to allow easier tuning.\n    // Choose the amount of sub-pixel aliasing removal.\n    // This can effect sharpness.\n    //   1.00 - upper limit (softer)\n    //   0.75 - default amount of filtering\n    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n    //   0.25 - almost off\n    //   0.00 - completely off\n    FxaaFloat fxaaQualitySubpix,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\n    // It is here now to allow easier tuning.\n    // The minimum amount of local contrast required to apply algorithm.\n    //   0.333 - too little (faster)\n    //   0.250 - low quality\n    //   0.166 - default\n    //   0.125 - high quality\n    //   0.063 - overkill (slower)\n    FxaaFloat fxaaQualityEdgeThreshold,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\n    // It is here now to allow easier tuning.\n    // Trims the algorithm from processing darks.\n    //   0.0833 - upper limit (default, the start of visible unfiltered edges)\n    //   0.0625 - high quality (faster)\n    //   0.0312 - visible limit (slower)\n    // Special notes when using FXAA_GREEN_AS_LUMA,\n    //   Likely want to set this to zero.\n    //   As colors that are mostly not-green\n    //   will appear very dark in the green channel!\n    //   Tune by looking at mostly non-green content,\n    //   then start at zero and increase until aliasing is a problem.\n    FxaaFloat fxaaQualityEdgeThresholdMin\n) {\n/*--------------------------------------------------------------------------*/\n    FxaaFloat2 posM;\n    posM.x = pos.x;\n    posM.y = pos.y;\n    #if (FXAA_GATHER4_ALPHA == 1)\n        #if (FXAA_DISCARD == 0)\n        FxaaFloat lumaM = FxaaLuma(rgbyM);\n        #endif\n        #if (FXAA_GREEN_AS_LUMA == 0)\n            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);\n            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\n        #else\n            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);\n            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\n        #endif\n        #if (FXAA_DISCARD == 1)\n            FxaaFloat lumaM = luma4A.w;\n        #endif\n        #define lumaE luma4A.z\n        #define lumaS luma4A.x\n        #define lumaSE luma4A.y\n        #define lumaNW luma4B.w\n        #define lumaN luma4B.z\n        #define lumaW luma4B.x\n    #else\n        FxaaFloat lumaM = FxaaLuma(rgbyM);\n        FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\n        FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\n        FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\n        FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n    #endif\n/*--------------------------------------------------------------------------*/\n    FxaaFloat maxSM = max(lumaS, lumaM);\n    FxaaFloat minSM = min(lumaS, lumaM);\n    FxaaFloat maxESM = max(lumaE, maxSM);\n    FxaaFloat minESM = min(lumaE, minSM);\n    FxaaFloat maxWN = max(lumaN, lumaW);\n    FxaaFloat minWN = min(lumaN, lumaW);\n    FxaaFloat rangeMax = max(maxWN, maxESM);\n    FxaaFloat rangeMin = min(minWN, minESM);\n    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n    FxaaFloat range = rangeMax - rangeMin;\n    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n    FxaaBool earlyExit = range < rangeMaxClamped;\n/*--------------------------------------------------------------------------*/\n    if(earlyExit)\n        #if (FXAA_DISCARD == 1)\n            FxaaDiscard;\n        #else\n            return rgbyM;\n        #endif\n/*--------------------------------------------------------------------------*/\n    #if (FXAA_GATHER4_ALPHA == 0)\n        FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\n        FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\n        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\n        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n    #else\n        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\n        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n    #endif\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNS = lumaN + lumaS;\n    FxaaFloat lumaWE = lumaW + lumaE;\n    FxaaFloat subpixRcpRange = 1.0/range;\n    FxaaFloat subpixNSWE = lumaNS + lumaWE;\n    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNESE = lumaNE + lumaSE;\n    FxaaFloat lumaNWNE = lumaNW + lumaNE;\n    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNWSW = lumaNW + lumaSW;\n    FxaaFloat lumaSWSE = lumaSW + lumaSE;\n    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\n    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\n    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;\n    FxaaBool horzSpan = edgeHorz >= edgeVert;\n    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n/*--------------------------------------------------------------------------*/\n    if(!horzSpan) lumaN = lumaW;\n    if(!horzSpan) lumaS = lumaE;\n    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\n    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat gradientN = lumaN - lumaM;\n    FxaaFloat gradientS = lumaS - lumaM;\n    FxaaFloat lumaNN = lumaN + lumaM;\n    FxaaFloat lumaSS = lumaS + lumaM;\n    FxaaBool pairN = abs(gradientN) >= abs(gradientS);\n    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));\n    if(pairN) lengthSign = -lengthSign;\n    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\n/*--------------------------------------------------------------------------*/\n    FxaaFloat2 posB;\n    posB.x = posM.x;\n    posB.y = posM.y;\n    FxaaFloat2 offNP;\n    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n    if(!horzSpan) posB.x += lengthSign * 0.5;\n    if( horzSpan) posB.y += lengthSign * 0.5;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat2 posN;\n    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\n    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\n    FxaaFloat2 posP;\n    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\n    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\n    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\n    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\n    FxaaFloat subpixE = subpixC * subpixC;\n    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\n/*--------------------------------------------------------------------------*/\n    if(!pairN) lumaNN = lumaSS;\n    FxaaFloat gradientScaled = gradient * 1.0/4.0;\n    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;\n    FxaaFloat subpixF = subpixD * subpixE;\n    FxaaBool lumaMLTZero = lumaMM < 0.0;\n/*--------------------------------------------------------------------------*/\n    lumaEndN -= lumaNN * 0.5;\n    lumaEndP -= lumaNN * 0.5;\n    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;\n    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;\n    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\n    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\n    FxaaBool doneNP = (!doneN) || (!doneP);\n    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\n    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\n/*--------------------------------------------------------------------------*/\n    if(doneNP) {\n        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\n        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\n        doneNP = (!doneN) || (!doneP);\n        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\n        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\n/*--------------------------------------------------------------------------*/\n        #if (FXAA_QUALITY_PS > 3)\n        if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\n/*--------------------------------------------------------------------------*/\n            #if (FXAA_QUALITY_PS > 4)\n            if(doneNP) {\n                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\n/*--------------------------------------------------------------------------*/\n                #if (FXAA_QUALITY_PS > 5)\n                if(doneNP) {\n                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\n                    doneNP = (!doneN) || (!doneP);\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\n/*--------------------------------------------------------------------------*/\n                    #if (FXAA_QUALITY_PS > 6)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\n                        doneNP = (!doneN) || (!doneP);\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\n/*--------------------------------------------------------------------------*/\n                        #if (FXAA_QUALITY_PS > 7)\n                        if(doneNP) {\n                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                            doneN = abs(lumaEndN) >= gradientScaled;\n                            doneP = abs(lumaEndP) >= gradientScaled;\n                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\n                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\n                            doneNP = (!doneN) || (!doneP);\n                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\n                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\n/*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PS > 8)\n    if(doneNP) {\n        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\n        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\n        doneNP = (!doneN) || (!doneP);\n        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\n        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\n/*--------------------------------------------------------------------------*/\n        #if (FXAA_QUALITY_PS > 9)\n        if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\n/*--------------------------------------------------------------------------*/\n            #if (FXAA_QUALITY_PS > 10)\n            if(doneNP) {\n                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\n/*--------------------------------------------------------------------------*/\n                #if (FXAA_QUALITY_PS > 11)\n                if(doneNP) {\n                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\n                    doneNP = (!doneN) || (!doneP);\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\n/*--------------------------------------------------------------------------*/\n                    #if (FXAA_QUALITY_PS > 12)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\n                        doneNP = (!doneN) || (!doneP);\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\n/*--------------------------------------------------------------------------*/\n                    }\n                    #endif\n/*--------------------------------------------------------------------------*/\n                }\n                #endif\n/*--------------------------------------------------------------------------*/\n            }\n            #endif\n/*--------------------------------------------------------------------------*/\n        }\n        #endif\n/*--------------------------------------------------------------------------*/\n    }\n    #endif\n/*--------------------------------------------------------------------------*/\n                        }\n                        #endif\n/*--------------------------------------------------------------------------*/\n                    }\n                    #endif\n/*--------------------------------------------------------------------------*/\n                }\n                #endif\n/*--------------------------------------------------------------------------*/\n            }\n            #endif\n/*--------------------------------------------------------------------------*/\n        }\n        #endif\n/*--------------------------------------------------------------------------*/\n    }\n/*--------------------------------------------------------------------------*/\n    FxaaFloat dstN = posM.x - posN.x;\n    FxaaFloat dstP = posP.x - posM.x;\n    if(!horzSpan) dstN = posM.y - posN.y;\n    if(!horzSpan) dstP = posP.y - posM.y;\n/*--------------------------------------------------------------------------*/\n    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n    FxaaFloat spanLength = (dstP + dstN);\n    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n    FxaaFloat spanLengthRcp = 1.0/spanLength;\n/*--------------------------------------------------------------------------*/\n    FxaaBool directionN = dstN < dstP;\n    FxaaFloat dst = min(dstN, dstP);\n    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\n    FxaaFloat subpixG = subpixF * subpixF;\n    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\n    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n\n    #if (FXAA_DISCARD == 1)\n        return FxaaTexTop(tex, posM);\n    #else\n        return FxaaTexTop(tex, posM);\n    #endif\n}\n/*==========================================================================*/\n#endif"; // eslint-disable-line

/**
 * @internal
 * Processing sRGB Conversion and FXAA.
 */ var FinalPass = /*#__PURE__*/ function(PipelinePass) {
    _inherits$2(FinalPass, PipelinePass);
    function FinalPass(engine) {
        var _this;
        _this = PipelinePass.call(this, engine) || this;
        // SRGB Material
        var sRGBmaterial = new Material(engine, Shader.find("FinalSRGB"));
        var sRGBdepthState = sRGBmaterial.renderState.depthState;
        sRGBdepthState.enabled = false;
        sRGBdepthState.writeEnabled = false;
        sRGBmaterial._addReferCount(1);
        _this._sRGBmaterial = sRGBmaterial;
        // FXAA Material
        var antiAliasingMaterial = new Material(engine, Shader.find("FinalAntiAliasing"));
        var antiAliasingDepthState = antiAliasingMaterial.renderState.depthState;
        antiAliasingDepthState.enabled = false;
        antiAliasingDepthState.writeEnabled = false;
        antiAliasingMaterial._addReferCount(1);
        _this._antiAliasingMaterial = antiAliasingMaterial;
        return _this;
    }
    var _proto = FinalPass.prototype;
    _proto.onConfig = function onConfig(camera, inputRenderTarget) {
        this._inputRenderTarget = inputRenderTarget;
        if (camera.antiAliasing === AntiAliasing.FXAA) {
            var pixelViewport = camera.pixelViewport;
            this._srgbRenderTarget = PipelineUtils.recreateRenderTargetIfNeeded(this.engine, this._srgbRenderTarget, pixelViewport.width, pixelViewport.height, TextureFormat.R8G8B8A8, null, false, false, false, 1, TextureWrapMode$1.Clamp, TextureFilterMode.Bilinear);
        }
    };
    _proto.onRender = function onRender(context) {
        var engine = this.engine;
        var camera = context.camera;
        var viewport = camera.viewport, renderTarget = camera.renderTarget;
        var enableFXAA = camera.antiAliasing === AntiAliasing.FXAA;
        // Should convert to sRGB when FXAA is enabled or camera's render target is not set
        var sourceTexture = this._inputRenderTarget.getColorTexture();
        var outputRenderTarget = enableFXAA ? this._srgbRenderTarget : renderTarget;
        Blitter.blitTexture(engine, sourceTexture, outputRenderTarget, 0, viewport, this._sRGBmaterial);
        if (enableFXAA) {
            var sRGBTexture = this._srgbRenderTarget.getColorTexture();
            Blitter.blitTexture(engine, sRGBTexture, renderTarget, 0, viewport, this._antiAliasingMaterial);
        }
    };
    _proto.release = function release() {
        var srgbRenderTarget = this._srgbRenderTarget;
        if (srgbRenderTarget) {
            var _srgbRenderTarget_getColorTexture;
            (_srgbRenderTarget_getColorTexture = srgbRenderTarget.getColorTexture(0)) == null ? void 0 : _srgbRenderTarget_getColorTexture.destroy(true);
            srgbRenderTarget.destroy(true);
            this._srgbRenderTarget = null;
        }
        this._inputRenderTarget = null;
    };
    return FinalPass;
}(PipelinePass);
Object.assign(ShaderLib, {
    FXAA3_11: FXAA3_11
});
Shader.create("FinalSRGB", blitVs, SRGBFS);
Shader.create("FinalAntiAliasing", blitVs, FinalAntiAliasingFS);

/**
 * @internal
 * Render queue mask type.
 */ var RenderQueueMaskType = /*#__PURE__*/ function(RenderQueueMaskType) {
    RenderQueueMaskType[RenderQueueMaskType["No"] = 0] = "No";
    RenderQueueMaskType[RenderQueueMaskType["Increment"] = 1] = "Increment";
    RenderQueueMaskType[RenderQueueMaskType["Decrement"] = 2] = "Decrement";
    return RenderQueueMaskType;
}({});

/**
 * @internal
 */ var RenderQueue = /*#__PURE__*/ function() {
    function RenderQueue(renderQueueType) {
        this.renderQueueType = renderQueueType;
        this.elements = new Array();
        this.batchedSubElements = new Array();
    }
    var _proto = RenderQueue.prototype;
    _proto.pushRenderElement = function pushRenderElement(element) {
        this.elements.push(element);
    };
    _proto.sortBatch = function sortBatch(compareFunc, batcherManager) {
        Utils._quickSort(this.elements, 0, this.elements.length, compareFunc);
        this.batch(batcherManager);
    };
    _proto.batch = function batch(batcherManager) {
        batcherManager.batch(this);
    };
    _proto.render = function render(context, pipelineStageTagValue, maskType) {
        if (maskType === void 0) maskType = RenderQueueMaskType.No;
        var batchedSubElements = this.batchedSubElements;
        var length = batchedSubElements.length;
        if (length === 0) {
            return;
        }
        var rendererUpdateFlag = context.rendererUpdateFlag, camera = context.camera;
        var engine = camera.engine, scene = camera.scene, cameraId = camera.instanceId, cameraData = camera.shaderData;
        var sceneId = scene.instanceId, sceneData = scene.shaderData, maskManager = scene._maskManager;
        var renderCount = engine._renderCount;
        var rhi = engine._hardwareRenderer;
        var pipelineStageKey = RenderContext.pipelineStageKey;
        var renderQueueType = this.renderQueueType;
        for(var i = 0; i < length; i++){
            var subElement = batchedSubElements[i];
            var renderer = subElement.component, batched = subElement.batched, material = subElement.material;
            // @todo: Can optimize update view projection matrix updated
            if (rendererUpdateFlag & ContextRendererUpdateFlag.WorldViewMatrix || renderer._batchedTransformShaderData != batched) {
                // Update world matrix and view matrix and model matrix
                renderer._updateTransformShaderData(context, false, batched);
                renderer._batchedTransformShaderData = batched;
            } else if (rendererUpdateFlag & ContextRendererUpdateFlag.ProjectionMatrix) {
                // Only projection matrix need updated
                renderer._updateTransformShaderData(context, true, batched);
            }
            var maskInteraction = renderer._maskInteraction;
            var needMaskInteraction = maskInteraction !== SpriteMaskInteraction.None;
            var needMaskType = maskType !== RenderQueueMaskType.No;
            var customStates = null;
            if (needMaskType) {
                customStates = BasicResources.getMaskTypeRenderStates(maskType);
            } else {
                if (needMaskInteraction) {
                    maskManager.drawMask(context, pipelineStageTagValue, subElement.component._maskLayer);
                    customStates = BasicResources.getMaskInteractionRenderStates(maskInteraction);
                } else {
                    maskManager.isReadStencil(material) && maskManager.clearMask(context, pipelineStageTagValue);
                }
                maskManager.isStencilWritten(material) && (maskManager.hasStencilWritten = true);
            }
            var compileMacros = Shader._compileMacros;
            var primitive = subElement.primitive, shaderPasses = subElement.shaderPasses, renderElementShaderData = subElement.shaderData;
            var rendererData = renderer.shaderData, rendererId = renderer.instanceId;
            var materialData = material.shaderData, materialId = material.instanceId, renderStates = material.renderStates;
            // Union render global macro and material self macro
            ShaderMacroCollection.unionCollection(renderer._globalShaderMacro, materialData._macroCollection, compileMacros);
            ShaderMacroCollection.unionCollection(compileMacros, engine._macroCollection, compileMacros);
            for(var j = 0, m = shaderPasses.length; j < m; j++){
                var shaderPass = shaderPasses[j];
                if (shaderPass.getTagValue(pipelineStageKey) !== pipelineStageTagValue) {
                    continue;
                }
                var renderState = shaderPass._renderState;
                if (needMaskType) {
                    // Mask don't care render queue type
                    if (!renderState) {
                        renderState = renderStates[j];
                    }
                } else {
                    var passQueueType = void 0;
                    if (renderState) {
                        passQueueType = renderState._getRenderQueueByShaderData(shaderPass._renderStateDataMap, materialData);
                    } else {
                        renderState = renderStates[j];
                        passQueueType = renderState.renderQueueType;
                    }
                    if (passQueueType !== renderQueueType) {
                        continue;
                    }
                }
                var program = shaderPass._getShaderProgram(engine, compileMacros);
                if (!program.isValid) {
                    continue;
                }
                var switchProgram = program.bind();
                var switchRenderCount = renderCount !== program._uploadRenderCount;
                if (switchRenderCount) {
                    program.groupingOtherUniformBlock();
                    program.uploadAll(program.sceneUniformBlock, sceneData);
                    program.uploadAll(program.cameraUniformBlock, cameraData);
                    program.uploadAll(program.rendererUniformBlock, rendererData);
                    program.uploadAll(program.materialUniformBlock, materialData);
                    renderElementShaderData && program.uploadAll(program.renderElementUniformBlock, renderElementShaderData);
                    // UnGroup textures should upload default value, texture uint maybe change by logic of texture bind.
                    program.uploadUnGroupTextures();
                    program._uploadSceneId = sceneId;
                    program._uploadCameraId = cameraId;
                    program._uploadRendererId = rendererId;
                    program._uploadMaterialId = materialId;
                    program._uploadRenderCount = renderCount;
                } else {
                    if (program._uploadSceneId !== sceneId) {
                        program.uploadAll(program.sceneUniformBlock, sceneData);
                        program._uploadSceneId = sceneId;
                    } else if (switchProgram) {
                        program.uploadTextures(program.sceneUniformBlock, sceneData);
                    }
                    if (program._uploadCameraId !== cameraId) {
                        program.uploadAll(program.cameraUniformBlock, cameraData);
                        program._uploadCameraId = cameraId;
                    } else if (switchProgram) {
                        program.uploadTextures(program.cameraUniformBlock, cameraData);
                    }
                    if (program._uploadRendererId !== rendererId) {
                        program.uploadAll(program.rendererUniformBlock, rendererData);
                        program._uploadRendererId = rendererId;
                    } else if (switchProgram) {
                        program.uploadTextures(program.rendererUniformBlock, rendererData);
                    }
                    if (program._uploadMaterialId !== materialId) {
                        program.uploadAll(program.materialUniformBlock, materialData);
                        program._uploadMaterialId = materialId;
                    } else if (switchProgram) {
                        program.uploadTextures(program.materialUniformBlock, materialData);
                    }
                    renderElementShaderData && program.uploadAll(program.renderElementUniformBlock, renderElementShaderData);
                    // We only consider switchProgram case, because UnGroup texture's value is always default.
                    if (switchProgram) {
                        program.uploadUnGroupTextures();
                    }
                }
                renderState._applyStates(engine, renderer._isFrontFaceInvert(), shaderPass._renderStateDataMap, material.shaderData, customStates);
                rhi.drawPrimitive(primitive, subElement.subPrimitive, program);
            }
        }
    };
    _proto.clear = function clear() {
        this.elements.length = 0;
        this.batchedSubElements.length = 0;
    };
    _proto.destroy = function destroy() {};
    RenderQueue.compareForOpaque = function compareForOpaque(a, b) {
        return a.priority - b.priority || a.distanceForSort - b.distanceForSort;
    };
    RenderQueue.compareForTransparent = function compareForTransparent(a, b) {
        return a.priority - b.priority || b.distanceForSort - a.distanceForSort;
    };
    return RenderQueue;
}();

/**
 * @internal
 */ var BatchUtils = /*#__PURE__*/ function() {
    function BatchUtils() {}
    BatchUtils.canBatchSprite = function canBatchSprite(elementA, elementB) {
        if (elementB.shaderPasses[0].getTagValue(BatchUtils._disableBatchTag) === true) {
            return false;
        }
        if (elementA.subChunk.chunk !== elementB.subChunk.chunk) {
            return false;
        }
        var rendererA = elementA.component;
        var rendererB = elementB.component;
        var maskInteractionA = rendererA.maskInteraction;
        // Compare mask, texture and material
        return maskInteractionA === rendererB.maskInteraction && (maskInteractionA === SpriteMaskInteraction.None || rendererA.maskLayer === rendererB.maskLayer) && elementA.texture === elementB.texture && elementA.material === elementB.material;
    };
    BatchUtils.canBatchSpriteMask = function canBatchSpriteMask(elementA, elementB) {
        if (elementA.subChunk.chunk !== elementB.subChunk.chunk) {
            return false;
        }
        var alphaCutoffProperty = SpriteMask._alphaCutoffProperty;
        // Compare renderer property
        return elementA.texture === elementB.texture && elementA.component.shaderData.getFloat(alphaCutoffProperty) === elementB.component.shaderData.getFloat(alphaCutoffProperty);
    };
    BatchUtils.batchFor2D = function batchFor2D(elementA, elementB) {
        var subChunk = elementB ? elementB.subChunk : elementA.subChunk;
        var chunk = subChunk.chunk, subChunkIndices = subChunk.indices;
        var length = subChunkIndices.length;
        var startIndex = chunk.updateIndexLength;
        if (elementB) {
            elementA.subChunk.subMesh.count += length;
        } else {
            // Reset subMesh
            var subMesh = subChunk.subMesh;
            subMesh.start = startIndex;
            subMesh.count = length;
        }
        var _subChunk_vertexArea = subChunk.vertexArea, start = _subChunk_vertexArea.start, size = _subChunk_vertexArea.size;
        var vertexOffset = start / 9;
        var indices = chunk.indices;
        for(var i = 0; i < length; ++i){
            indices[startIndex++] = vertexOffset + subChunkIndices[i];
        }
        chunk.updateIndexLength += length;
        chunk.updateVertexStart = Math.min(chunk.updateVertexStart, start);
        chunk.updateVertexEnd = Math.max(chunk.updateVertexEnd, start + size);
    };
    return BatchUtils;
}();
BatchUtils._disableBatchTag = ShaderTagKey.getByName("spriteDisableBatching");

/**
 * @internal
 */ var ShadowSliceData = function ShadowSliceData() {
    this.virtualCamera = new VirtualCamera();
    this.cullPlanes = [
        new Plane(new Vector3()),
        new Plane(new Vector3()),
        new Plane(new Vector3()),
        new Plane(new Vector3()),
        new Plane(new Vector3()),
        new Plane(new Vector3()),
        new Plane(new Vector3()),
        new Plane(new Vector3()),
        new Plane(new Vector3()),
        new Plane(new Vector3())
    ];
    // bounding sphere
    this.splitBoundSphere = new BoundingSphere(new Vector3(), 0.0);
};

/**
 * Default shadow resolution.
 */ var ShadowResolution = /*#__PURE__*/ function(ShadowResolution) {
    /** Low shadow map resolution. */ ShadowResolution[ShadowResolution["Low"] = 0] = "Low";
    /** Medium shadow map resolution. */ ShadowResolution[ShadowResolution["Medium"] = 1] = "Medium";
    /**  High shadow map resolution. */ ShadowResolution[ShadowResolution["High"] = 2] = "High";
    /** Very high shadow map resolution. */ ShadowResolution[ShadowResolution["VeryHigh"] = 3] = "VeryHigh";
    return ShadowResolution;
}({});

/**
 * Determines which type of shadows should be used.
 */ var ShadowType = /*#__PURE__*/ function(ShadowType) {
    /** Disable Shadows. */ ShadowType[ShadowType["None"] = 0] = "None";
    /** Hard Shadows Only. */ ShadowType[ShadowType["Hard"] = 1] = "Hard";
    /** Cast "soft" shadows with low range. */ ShadowType[ShadowType["SoftLow"] = 2] = "SoftLow";
    /** Cast "soft" shadows with large range. */ ShadowType[ShadowType["SoftHigh"] = 3] = "SoftHigh";
    return ShadowType;
}({});

/**
 * @internal
 */ var ShadowUtils = /*#__PURE__*/ function() {
    function ShadowUtils() {}
    ShadowUtils.shadowResolution = function shadowResolution(value) {
        switch(value){
            case ShadowResolution.Low:
                return 512;
            case ShadowResolution.Medium:
                return 1024;
            case ShadowResolution.High:
                return 2048;
            case ShadowResolution.VeryHigh:
                return 4096;
        }
    };
    ShadowUtils.shadowDepthFormat = function shadowDepthFormat(value, supportDepthTexture) {
        if (supportDepthTexture) {
            return TextureFormat.Depth16;
        } else {
            return TextureFormat.R8G8B8A8;
        }
    };
    ShadowUtils.cullingRenderBounds = function cullingRenderBounds(bounds, cullPlaneCount, cullPlanes) {
        var min = bounds.min, max = bounds.max;
        for(var i = 0; i < cullPlaneCount; i++){
            var plane = cullPlanes[i];
            var normal = plane.normal;
            if (normal.x * (normal.x >= 0.0 ? max.x : min.x) + normal.y * (normal.y >= 0.0 ? max.y : min.y) + normal.z * (normal.z >= 0.0 ? max.z : min.z) < -plane.distance) {
                return false;
            }
        }
        return true;
    };
    ShadowUtils.shadowCullFrustum = function shadowCullFrustum(context, light, renderer, shadowSliceData) {
        var layer = renderer._entity.layer;
        // filter by camera culling mask
        if (context.camera.cullingMask & layer && light.cullingMask & layer) {
            if (renderer.castShadows && ShadowUtils.cullingRenderBounds(renderer.bounds, shadowSliceData.cullPlaneCount, shadowSliceData.cullPlanes)) {
                renderer._prepareRender(context);
                renderer._renderFrameCount = renderer.engine.time.frameCount;
            }
        }
    };
    ShadowUtils.getBoundSphereByFrustum = function getBoundSphereByFrustum(near, far, camera, forward, shadowSliceData) {
        var aspectRatio = camera.aspectRatio, fieldOfView = camera.fieldOfView;
        // https://lxjk.github.io/2017/04/15/Calculate-Minimal-Bounding-Sphere-of-Frustum.html
        var centerZ;
        var radius;
        var k = Math.sqrt(1.0 + aspectRatio * aspectRatio) * Math.tan(MathUtil.degreeToRadian(fieldOfView) / 2.0);
        var k2 = k * k;
        var farSNear = far - near;
        var farANear = far + near;
        if (k2 > farSNear / farANear) {
            centerZ = far;
            radius = far * k;
        } else {
            centerZ = 0.5 * farANear * (1 + k2);
            radius = 0.5 * Math.sqrt(farSNear * farSNear + 2.0 * (far * far + near * near) * k2 + farANear * farANear * k2 * k2);
        }
        var center = shadowSliceData.splitBoundSphere.center;
        shadowSliceData.splitBoundSphere.radius = radius;
        Vector3.scale(forward, centerZ, center);
        Vector3.add(camera.entity.transform.worldPosition, center, center);
        shadowSliceData.sphereCenterZ = centerZ;
    };
    ShadowUtils.getDirectionLightShadowCullPlanes = function getDirectionLightShadowCullPlanes(cameraFrustum, splitDistance, cameraNear, direction, shadowSliceData) {
        // http://lspiroengine.com/?p=187
        var frustumCorners = ShadowUtils._frustumCorners;
        var backPlaneFaces = ShadowUtils._backPlaneFaces;
        var planeNeighbors = ShadowUtils._frustumPlaneNeighbors;
        var twoPlaneCorners = ShadowUtils._frustumTwoPlaneCorners;
        var edgePlanePoint2 = ShadowUtils._edgePlanePoint2;
        var out = shadowSliceData.cullPlanes;
        // cameraFrustumPlanes is share
        var near = cameraFrustum.getPlane(FrustumFace.Near);
        var far = cameraFrustum.getPlane(FrustumFace.Far);
        var left = cameraFrustum.getPlane(FrustumFace.Left);
        var right = cameraFrustum.getPlane(FrustumFace.Right);
        var bottom = cameraFrustum.getPlane(FrustumFace.Bottom);
        var top = cameraFrustum.getPlane(FrustumFace.Top);
        // adjustment the near/far plane
        var splitNearDistance = splitDistance - cameraNear;
        var splitNear = ShadowUtils._adjustNearPlane;
        var splitFar = ShadowUtils._adjustFarPlane;
        splitNear.normal.copyFrom(near.normal);
        splitFar.normal.copyFrom(far.normal);
        splitNear.distance = near.distance - splitNearDistance;
        // do a clamp if the sphere is out of range the far plane
        splitFar.distance = Math.min(-near.distance + shadowSliceData.sphereCenterZ + shadowSliceData.splitBoundSphere.radius, far.distance);
        CollisionUtil.intersectionPointThreePlanes(splitNear, bottom, right, frustumCorners[7]);
        CollisionUtil.intersectionPointThreePlanes(splitNear, top, right, frustumCorners[6]);
        CollisionUtil.intersectionPointThreePlanes(splitNear, top, left, frustumCorners[5]);
        CollisionUtil.intersectionPointThreePlanes(splitNear, bottom, left, frustumCorners[4]);
        CollisionUtil.intersectionPointThreePlanes(splitFar, bottom, right, frustumCorners[3]);
        CollisionUtil.intersectionPointThreePlanes(splitFar, top, right, frustumCorners[2]);
        CollisionUtil.intersectionPointThreePlanes(splitFar, top, left, frustumCorners[1]);
        CollisionUtil.intersectionPointThreePlanes(splitFar, bottom, left, frustumCorners[0]);
        var backIndex = 0;
        for(var i = 0; i < 6; i++){
            // maybe 3、4、5(light eye is at far, forward is near, or orthographic camera is any axis)
            var plane = void 0;
            switch(i){
                case FrustumFace.Near:
                    plane = splitNear;
                    break;
                case FrustumFace.Far:
                    plane = splitFar;
                    break;
                default:
                    plane = cameraFrustum.getPlane(i);
                    break;
            }
            if (Vector3.dot(plane.normal, direction) < 0.0) {
                out[backIndex].copyFrom(plane);
                backPlaneFaces[backIndex] = i;
                backIndex++;
            }
        }
        var edgeIndex = backIndex;
        for(var i1 = 0; i1 < backIndex; i1++){
            var backFace = backPlaneFaces[i1];
            var neighborFaces = planeNeighbors[backFace];
            for(var j = 0; j < 4; j++){
                var neighborFace = neighborFaces[j];
                var notBackFace = true;
                for(var k = 0; k < backIndex; k++)if (neighborFace == backPlaneFaces[k]) {
                    notBackFace = false;
                    break;
                }
                if (notBackFace) {
                    var corners = twoPlaneCorners[backFace][neighborFace];
                    var point0 = frustumCorners[corners[0]];
                    var point1 = frustumCorners[corners[1]];
                    Vector3.add(point0, direction, edgePlanePoint2);
                    Plane.fromPoints(point0, point1, edgePlanePoint2, out[edgeIndex++]);
                }
            }
        }
        shadowSliceData.cullPlaneCount = edgeIndex;
    };
    ShadowUtils.getDirectionalLightMatrices = function getDirectionalLightMatrices(lightUp, lightSide, lightForward, cascadeIndex, nearPlane, shadowResolution, shadowSliceData, outShadowMatrices) {
        var boundSphere = shadowSliceData.splitBoundSphere;
        shadowSliceData.resolution = shadowResolution;
        // To solve shadow swimming problem.
        var center = boundSphere.center;
        var radius = boundSphere.radius;
        var halfShadowResolution = shadowResolution / 2;
        // Add border to project edge pixel PCF.
        // Improve:the clip planes not consider the border,but I think is OK,because the object can clip is not continuous.
        var borderRadius = radius * halfShadowResolution / (halfShadowResolution - ShadowUtils.atlasBorderSize);
        var borderDiam = borderRadius * 2.0;
        var sizeUnit = shadowResolution / borderDiam;
        var radiusUnit = borderDiam / shadowResolution;
        var upLen = Math.ceil(Vector3.dot(center, lightUp) * sizeUnit) * radiusUnit;
        var sideLen = Math.ceil(Vector3.dot(center, lightSide) * sizeUnit) * radiusUnit;
        var forwardLen = Vector3.dot(center, lightForward);
        center.x = lightUp.x * upLen + lightSide.x * sideLen + lightForward.x * forwardLen;
        center.y = lightUp.y * upLen + lightSide.y * sideLen + lightForward.y * forwardLen;
        center.z = lightUp.z * upLen + lightSide.z * sideLen + lightForward.z * forwardLen;
        // Direction light use shadow pancaking tech,do special dispose with nearPlane.
        var virtualCamera = shadowSliceData.virtualCamera;
        var position = virtualCamera.position;
        var viewMatrix = virtualCamera.viewMatrix;
        var projectMatrix = virtualCamera.projectionMatrix;
        Vector3.scale(lightForward, radius + nearPlane, position);
        Vector3.subtract(center, position, position);
        Matrix.lookAt(position, center, lightUp, viewMatrix);
        Matrix.ortho(-borderRadius, borderRadius, -borderRadius, borderRadius, 0.0, radius * 2.0 + nearPlane, projectMatrix);
        var viewProjectionMatrix = virtualCamera.viewProjectionMatrix;
        Matrix.multiply(projectMatrix, viewMatrix, viewProjectionMatrix);
        Utils._floatMatrixMultiply(ShadowUtils._shadowMapCoordMatrix, viewProjectionMatrix.elements, 0, outShadowMatrices, cascadeIndex * 16);
    };
    ShadowUtils.getMaxTileResolutionInAtlas = function getMaxTileResolutionInAtlas(atlasWidth, atlasHeight, tileCount) {
        var resolution = Math.min(atlasWidth, atlasHeight);
        var currentTileCount = Math.floor(atlasWidth / resolution) * Math.floor(atlasHeight / resolution);
        while(currentTileCount < tileCount){
            resolution = Math.floor(resolution >> 1);
            currentTileCount = Math.floor(atlasWidth / resolution) * Math.floor(atlasHeight / resolution);
        }
        return resolution;
    };
    ShadowUtils.getShadowBias = function getShadowBias(light, projectionMatrix, shadowResolution, out) {
        // Frustum size is guaranteed to be a cube as we wrap shadow frustum around a sphere
        // elements[0] = 2.0 / (right - left)
        var frustumSize = 2.0 / projectionMatrix.elements[0];
        // depth and normal bias scale is in shadowmap texel size in world space
        var texelSize = frustumSize / shadowResolution;
        var depthBias = -light.shadowBias * texelSize;
        var normalBias = -light.shadowNormalBias * texelSize;
        if (light.shadowType == ShadowType.SoftHigh) {
            // TODO: depth and normal bias assume sample is no more than 1 texel away from shadowmap
            // This is not true with PCF. Ideally we need to do either
            // cone base bias (based on distance to center sample)
            // or receiver place bias based on derivatives.
            // For now we scale it by the PCF kernel size (5x5)
            var kernelRadius = 2.5;
            depthBias *= kernelRadius;
            normalBias *= kernelRadius;
        }
        out.set(depthBias, normalBias);
    };
    /**
   * Apply shadow slice scale and offset
   */ ShadowUtils.applySliceTransform = function applySliceTransform(tileSize, atlasWidth, atlasHeight, cascadeIndex, atlasOffset, outShadowMatrices) {
        var sliceMatrix = ShadowUtils._tempMatrix0;
        var slice = sliceMatrix.elements;
        var oneOverAtlasWidth = 1.0 / atlasWidth;
        var oneOverAtlasHeight = 1.0 / atlasHeight;
        var scaleX = tileSize * oneOverAtlasWidth;
        var scaleY = tileSize * oneOverAtlasHeight;
        var offsetX = atlasOffset.x * oneOverAtlasWidth;
        var offsetY = atlasOffset.y * oneOverAtlasHeight;
        slice[0] = scaleX, slice[1] = 0, slice[2] = 0, slice[3] = 0;
        slice[4] = 0, slice[5] = scaleY, slice[6] = 0, slice[7] = 0;
        slice[8] = 0, slice[9] = 0, slice[10] = 1, slice[11] = 0;
        slice[12] = offsetX, slice[13] = offsetY, slice[14] = 0, slice[15] = 1;
        var offset = cascadeIndex * 16;
        Utils._floatMatrixMultiply(sliceMatrix, outShadowMatrices, offset, outShadowMatrices, offset);
    };
    /**
   * Extract scale and bias from a fade distance to achieve a linear fading of the fade distance.
   */ ShadowUtils.getScaleAndBiasForLinearDistanceFade = function getScaleAndBiasForLinearDistanceFade(fadeDistance, border, outInfo) {
        // (P^2-N^2)/(F^2-N^2)
        // To avoid division from zero
        // This values ensure that fade within cascade will be 0 and outside 1
        if (border < 0.0001) {
            var multiplier = 1000; // To avoid blending if difference is in fractions
            outInfo.z = multiplier;
            outInfo.w = -fadeDistance * multiplier;
            return;
        }
        border = 1 - border;
        border *= border;
        // Fade with distance calculation is just a linear fade from 90% of fade distance to fade distance. 90% arbitrarily chosen but should work well enough.
        var distanceFadeNear = border * fadeDistance;
        var fadeRange = fadeDistance - distanceFadeNear;
        outInfo.z = 1.0 / fadeRange;
        outInfo.w = -distanceFadeNear / fadeRange;
    };
    return ShadowUtils;
}();
ShadowUtils._tempMatrix0 = new Matrix();
// prettier-ignore
/** @internal */ ShadowUtils._shadowMapCoordMatrix = new Matrix(0.5, 0.0, 0.0, 0.0, 0.0, -0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0);
ShadowUtils._frustumCorners = [
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3()
];
ShadowUtils._adjustNearPlane = new Plane(new Vector3());
ShadowUtils._adjustFarPlane = new Plane(new Vector3());
ShadowUtils._backPlaneFaces = new Array(5);
ShadowUtils._edgePlanePoint2 = new Vector3();
/** near, far, left, right, bottom, top  */ ShadowUtils._frustumPlaneNeighbors = [
    [
        FrustumFace.Left,
        FrustumFace.Right,
        FrustumFace.Top,
        FrustumFace.Bottom
    ],
    [
        FrustumFace.Left,
        FrustumFace.Right,
        FrustumFace.Top,
        FrustumFace.Bottom
    ],
    [
        FrustumFace.Near,
        FrustumFace.Far,
        FrustumFace.Top,
        FrustumFace.Bottom
    ],
    [
        FrustumFace.Near,
        FrustumFace.Far,
        FrustumFace.Top,
        FrustumFace.Bottom
    ],
    [
        FrustumFace.Near,
        FrustumFace.Far,
        FrustumFace.Left,
        FrustumFace.Right
    ],
    [
        FrustumFace.Near,
        FrustumFace.Far,
        FrustumFace.Left,
        FrustumFace.Right
    ]
];
/** near, far, left, right, bottom, top  */ ShadowUtils._frustumTwoPlaneCorners = [
    [
        // near, far, left, right, bottom, top
        [
            8,
            8
        ],
        [
            8,
            8
        ],
        [
            4,
            5
        ],
        [
            6,
            7
        ],
        [
            7,
            4
        ],
        [
            5,
            6
        ]
    ],
    [
        // near, far, left, right, bottom, top
        [
            8,
            8
        ],
        [
            8,
            8
        ],
        [
            1,
            0
        ],
        [
            3,
            2
        ],
        [
            0,
            3
        ],
        [
            2,
            1
        ]
    ],
    [
        // near, far, left, right, bottom, top
        [
            5,
            4
        ],
        [
            0,
            1
        ],
        [
            8,
            8
        ],
        [
            8,
            8
        ],
        [
            4,
            0
        ],
        [
            1,
            5
        ]
    ],
    [
        // near, far, left, right, bottom, top
        [
            7,
            6
        ],
        [
            2,
            3
        ],
        [
            8,
            8
        ],
        [
            8,
            8
        ],
        [
            3,
            7
        ],
        [
            6,
            2
        ]
    ],
    [
        // near, far, left, right, bottom, top
        [
            4,
            7
        ],
        [
            3,
            0
        ],
        [
            0,
            4
        ],
        [
            7,
            3
        ],
        [
            8,
            8
        ],
        [
            8,
            8
        ]
    ],
    [
        // near, far, left, right, bottom, top
        [
            6,
            5
        ],
        [
            1,
            2
        ],
        [
            5,
            1
        ],
        [
            2,
            6
        ],
        [
            8,
            8
        ],
        [
            8,
            8
        ]
    ]
];
//now max shadow sample tent is 5x5, atlas borderSize at least 3=ceil(2.5),and +1 pixel is for global border for no cascade mode.
ShadowUtils.atlasBorderSize = 4.0;

/**
 * Number of cascades to use for directional light shadows.
 */ var ShadowCascadesMode = /*#__PURE__*/ function(ShadowCascadesMode) {
    /** No cascades */ ShadowCascadesMode[ShadowCascadesMode["NoCascades"] = 1] = "NoCascades";
    /** Two cascades */ ShadowCascadesMode[ShadowCascadesMode["TwoCascades"] = 2] = "TwoCascades";
    /** Four cascades */ ShadowCascadesMode[ShadowCascadesMode["FourCascades"] = 4] = "FourCascades";
    return ShadowCascadesMode;
}({});

/**
 * Cascade shadow caster pass.
 */ var CascadedShadowCasterPass = /*#__PURE__*/ function(PipelinePass) {
    _inherits$2(CascadedShadowCasterPass, PipelinePass);
    function CascadedShadowCasterPass(camera) {
        var _this;
        _this = PipelinePass.call(this, camera.engine) || this, _this._shadowMapSize = new Vector4(), _this._shadowBias = new Vector2(), _this._shadowSliceData = new ShadowSliceData(), _this._lightUp = new Vector3(), _this._lightSide = new Vector3(), _this._splitBoundSpheres = new Float32Array(CascadedShadowCasterPass._maxCascades * 4), /** The end is project precision problem in shader. */ _this._shadowMatrices = new Float32Array((CascadedShadowCasterPass._maxCascades + 1) * 16), // intensity, null, fadeScale, fadeBias
        _this._shadowInfos = new Vector4(), _this._viewportOffsets = [
            new Vector2(),
            new Vector2(),
            new Vector2(),
            new Vector2()
        ];
        _this._camera = camera;
        _this._supportDepthTexture = camera.engine._hardwareRenderer.canIUse(GLCapabilityType.depthTexture);
        _this._shadowSliceData.virtualCamera.isOrthographic = true;
        return _this;
    }
    var _proto = CascadedShadowCasterPass.prototype;
    /**
   * @internal
   */ _proto.onRender = function onRender(context) {
        var light = this._camera.scene._lightManager._sunlight;
        this._updateShadowSettings();
        this._renderDirectShadowMap(context, light);
        this._updateReceiversShaderData(light);
    };
    _proto._renderDirectShadowMap = function _renderDirectShadowMap(context, light) {
        var _this = this, engine = _this.engine, camera = _this._camera, viewports = _this._viewportOffsets, shadowSliceData = _this._shadowSliceData, splitBoundSpheres = _this._splitBoundSpheres, shadowMatrices = _this._shadowMatrices;
        var _camera__renderPipeline__cullingResults = camera._renderPipeline._cullingResults, opaqueQueue = _camera__renderPipeline__cullingResults.opaqueQueue, alphaTestQueue = _camera__renderPipeline__cullingResults.alphaTestQueue;
        var scene = camera.scene;
        var componentsManager = scene._componentsManager;
        var rhi = engine._hardwareRenderer;
        var shadowCascades = scene.shadowCascades;
        var splitDistance = CascadedShadowCasterPass._cascadesSplitDistance;
        var boundSphere = shadowSliceData.splitBoundSphere;
        var lightWorld = CascadedShadowCasterPass._tempMatrix0;
        var lightWorldE = lightWorld.elements;
        var lightUp = this._lightUp;
        var lightSide = this._lightSide;
        var lightForward = shadowSliceData.virtualCamera.forward;
        // Prepare render target
        var _this__shadowMapSize = this._shadowMapSize, width = _this__shadowMapSize.z, height = _this__shadowMapSize.w;
        var format = this._shadowMapFormat;
        var renderTarget;
        var shadowTexture;
        if (this._supportDepthTexture) {
            renderTarget = PipelineUtils.recreateRenderTargetIfNeeded(engine, this._renderTarget, width, height, null, format, true, false, false, 1, TextureWrapMode$1.Clamp, TextureFilterMode.Bilinear);
            shadowTexture = renderTarget.depthTexture;
        } else {
            renderTarget = PipelineUtils.recreateRenderTargetIfNeeded(engine, this._renderTarget, width, height, format, null, false, false, false, 1, TextureWrapMode$1.Clamp, TextureFilterMode.Bilinear);
            shadowTexture = renderTarget.getColorTexture(0);
        }
        if (engine._hardwareRenderer._isWebGL2) {
            shadowTexture.depthCompareFunction = TextureDepthCompareFunction.Less;
        }
        this._renderTarget = renderTarget;
        this._depthTexture = shadowTexture;
        // @todo: shouldn't set viewport and scissor in activeRenderTarget
        context.setRenderTarget(renderTarget, CascadedShadowCasterPass._viewport, 0);
        if (this._supportDepthTexture) {
            rhi.clearRenderTarget(engine, CameraClearFlags.Depth, null);
        } else {
            rhi.clearRenderTarget(engine, CameraClearFlags.All, CascadedShadowCasterPass._clearColor);
        }
        // prepare light and camera direction
        Matrix.rotationQuaternion(light.entity.transform.worldRotationQuaternion, lightWorld);
        lightSide.set(lightWorldE[0], lightWorldE[1], lightWorldE[2]);
        lightUp.set(lightWorldE[4], lightWorldE[5], lightWorldE[6]);
        lightForward.set(-lightWorldE[8], -lightWorldE[9], -lightWorldE[10]);
        var cameraForward = CascadedShadowCasterPass._tempVector;
        cameraForward.copyFrom(camera.entity.transform.worldForward);
        var shadowTileResolution = this._shadowTileResolution;
        for(var j = 0; j < shadowCascades; j++){
            ShadowUtils.getBoundSphereByFrustum(splitDistance[j], splitDistance[j + 1], camera, cameraForward, shadowSliceData);
            ShadowUtils.getDirectionLightShadowCullPlanes(camera._frustum, splitDistance[j], camera.nearClipPlane, lightForward, shadowSliceData);
            ShadowUtils.getDirectionalLightMatrices(lightUp, lightSide, lightForward, j, light.shadowNearPlaneOffset, shadowTileResolution, shadowSliceData, shadowMatrices);
            if (shadowCascades > 1) {
                ShadowUtils.applySliceTransform(shadowTileResolution, width, height, j, this._viewportOffsets[j], shadowMatrices);
            }
            this._updateSingleShadowCasterShaderData(light, shadowSliceData, context);
            // upload pre-cascade infos.
            var center = boundSphere.center;
            var radius = boundSphere.radius;
            var offset = j * 4;
            splitBoundSpheres[offset] = center.x;
            splitBoundSpheres[offset + 1] = center.y;
            splitBoundSpheres[offset + 2] = center.z;
            splitBoundSpheres[offset + 3] = radius * radius;
            opaqueQueue.clear();
            alphaTestQueue.clear();
            var renderers = componentsManager._renderers;
            var elements = renderers._elements;
            for(var k = renderers.length - 1; k >= 0; --k){
                ShadowUtils.shadowCullFrustum(context, light, elements[k], shadowSliceData);
            }
            if (opaqueQueue.elements.length || alphaTestQueue.elements.length) {
                // @todo: It is more appropriate to prevent duplication based on `virtualCamera` at `RenderQueue#render`.
                engine._renderCount++;
                var batcherManager = engine._batcherManager;
                opaqueQueue.sortBatch(RenderQueue.compareForOpaque, batcherManager);
                alphaTestQueue.sortBatch(RenderQueue.compareForOpaque, batcherManager);
                var _viewports_j = viewports[j], x = _viewports_j.x, y = _viewports_j.y;
                rhi.setGlobalDepthBias(1.0, 1.0);
                rhi.viewport(x, y, shadowTileResolution, shadowTileResolution);
                // for no cascade is for the edge,for cascade is for the beyond maxCascade pixel can use (0,0,0) trick sample the shadowMap
                rhi.scissor(x + 1, y + 1, shadowTileResolution - 2, shadowTileResolution - 2);
                opaqueQueue.render(context, PipelineStage.ShadowCaster);
                alphaTestQueue.render(context, PipelineStage.ShadowCaster);
                rhi.setGlobalDepthBias(0, 0);
            }
        }
    };
    _proto._updateReceiversShaderData = function _updateReceiversShaderData(light) {
        var camera = this._camera;
        var scene = camera.scene;
        var splitBoundSpheres = this._splitBoundSpheres;
        var shadowMatrices = this._shadowMatrices;
        var shadowCascades = scene.shadowCascades;
        var shadowFar = Math.min(scene.shadowDistance, camera.farClipPlane);
        ShadowUtils.getScaleAndBiasForLinearDistanceFade(Math.pow(shadowFar, 2), scene.shadowFadeBorder, this._shadowInfos);
        this._shadowInfos.x = light.shadowStrength;
        // set zero matrix to project the index out of max cascade
        if (shadowCascades > 1) {
            for(var i = shadowCascades * 4, n = splitBoundSpheres.length; i < n; i++){
                splitBoundSpheres[i] = 0.0;
            }
        }
        // set zero matrix to project the index out of max cascade
        for(var i1 = shadowCascades * 16, n1 = shadowMatrices.length; i1 < n1; i1++){
            shadowMatrices[i1] = 0.0;
        }
        var shaderData = scene.shaderData;
        shaderData.setFloatArray(CascadedShadowCasterPass._shadowMatricesProperty, this._shadowMatrices);
        shaderData.setVector4(CascadedShadowCasterPass._shadowInfosProperty, this._shadowInfos);
        shaderData.setTexture(CascadedShadowCasterPass._shadowMapsProperty, this._depthTexture);
        shaderData.setFloatArray(CascadedShadowCasterPass._shadowSplitSpheresProperty, this._splitBoundSpheres);
        shaderData.setVector4(CascadedShadowCasterPass._shadowMapSize, this._shadowMapSize);
    };
    _proto._getCascadesSplitDistance = function _getCascadesSplitDistance(shadowFar) {
        var cascadesSplitDistance = CascadedShadowCasterPass._cascadesSplitDistance;
        var _this__camera_scene = this._camera.scene, shadowTwoCascadeSplits = _this__camera_scene.shadowTwoCascadeSplits, shadowFourCascadeSplits = _this__camera_scene.shadowFourCascadeSplits, shadowCascades = _this__camera_scene.shadowCascades;
        var _this__camera = this._camera, nearClipPlane = _this__camera.nearClipPlane, aspectRatio = _this__camera.aspectRatio, fieldOfView = _this__camera.fieldOfView;
        cascadesSplitDistance[0] = nearClipPlane;
        var range = shadowFar - nearClipPlane;
        var tFov = Math.tan(MathUtil.degreeToRadian(fieldOfView) * 0.5);
        var denominator = 1.0 + tFov * tFov * (aspectRatio * aspectRatio + 1.0);
        switch(shadowCascades){
            case ShadowCascadesMode.NoCascades:
                cascadesSplitDistance[1] = this._getFarWithRadius(shadowFar, denominator);
                break;
            case ShadowCascadesMode.TwoCascades:
                cascadesSplitDistance[1] = this._getFarWithRadius(nearClipPlane + range * shadowTwoCascadeSplits, denominator);
                cascadesSplitDistance[2] = this._getFarWithRadius(shadowFar, denominator);
                break;
            case ShadowCascadesMode.FourCascades:
                cascadesSplitDistance[1] = this._getFarWithRadius(nearClipPlane + range * shadowFourCascadeSplits.x, denominator);
                cascadesSplitDistance[2] = this._getFarWithRadius(nearClipPlane + range * shadowFourCascadeSplits.y, denominator);
                cascadesSplitDistance[3] = this._getFarWithRadius(nearClipPlane + range * shadowFourCascadeSplits.z, denominator);
                cascadesSplitDistance[4] = this._getFarWithRadius(shadowFar, denominator);
                break;
        }
    };
    _proto._getFarWithRadius = function _getFarWithRadius(radius, denominator) {
        // use the frustum side as the radius and get the far distance form camera.
        // var tFov: number = Math.tan(fov * 0.5);// get this the equation using Pythagorean
        // return Math.sqrt(radius * radius / (1.0 + tFov * tFov * (aspectRatio * aspectRatio + 1.0)));
        return Math.sqrt(radius * radius / denominator);
    };
    _proto._updateShadowSettings = function _updateShadowSettings() {
        var camera = this._camera;
        var scene = camera.scene;
        var shadowFormat = ShadowUtils.shadowDepthFormat(scene.shadowResolution, this._supportDepthTexture);
        var shadowResolution = ShadowUtils.shadowResolution(scene.shadowResolution);
        var shadowCascades = scene.shadowCascades;
        var shadowFar = Math.min(scene.shadowDistance, camera.farClipPlane);
        this._getCascadesSplitDistance(shadowFar);
        if (shadowFormat !== this._shadowMapFormat || shadowResolution !== this._shadowMapResolution || shadowCascades !== this._shadowCascadeMode) {
            this._shadowMapFormat = shadowFormat;
            this._shadowMapResolution = shadowResolution;
            this._shadowCascadeMode = shadowCascades;
            if (shadowCascades == ShadowCascadesMode.NoCascades) {
                this._shadowTileResolution = shadowResolution;
                this._shadowMapSize.set(1 / shadowResolution, 1 / shadowResolution, shadowResolution, shadowResolution);
            } else {
                var shadowTileResolution = ShadowUtils.getMaxTileResolutionInAtlas(shadowResolution, shadowResolution, shadowCascades);
                this._shadowTileResolution = shadowTileResolution;
                var width = shadowTileResolution * 2;
                var height = shadowCascades == ShadowCascadesMode.TwoCascades ? shadowTileResolution : shadowTileResolution * 2;
                this._shadowMapSize.set(1.0 / width, 1.0 / height, width, height);
            }
            this._renderTarget = null;
            var viewportOffset = this._viewportOffsets;
            var shadowTileResolution1 = this._shadowTileResolution;
            switch(shadowCascades){
                case ShadowCascadesMode.NoCascades:
                    viewportOffset[0].set(0, 0);
                    break;
                case ShadowCascadesMode.TwoCascades:
                    viewportOffset[0].set(0, 0);
                    viewportOffset[1].set(shadowTileResolution1, 0);
                    break;
                case ShadowCascadesMode.FourCascades:
                    viewportOffset[0].set(0, 0);
                    viewportOffset[1].set(shadowTileResolution1, 0);
                    viewportOffset[2].set(0, shadowTileResolution1);
                    viewportOffset[3].set(shadowTileResolution1, shadowTileResolution1);
            }
        }
    };
    _proto._updateSingleShadowCasterShaderData = function _updateSingleShadowCasterShaderData(light, shadowSliceData, context) {
        var virtualCamera = shadowSliceData.virtualCamera;
        ShadowUtils.getShadowBias(light, virtualCamera.projectionMatrix, this._shadowTileResolution, this._shadowBias);
        var sceneShaderData = this._camera.scene.shaderData;
        sceneShaderData.setVector2(CascadedShadowCasterPass._lightShadowBiasProperty, this._shadowBias);
        sceneShaderData.setVector3(CascadedShadowCasterPass._lightDirectionProperty, light.direction);
        // Every light use self virtual camera
        context.rendererUpdateFlag |= ContextRendererUpdateFlag.viewProjectionMatrix;
        context.applyVirtualCamera(virtualCamera, true);
    };
    return CascadedShadowCasterPass;
}(PipelinePass);
CascadedShadowCasterPass._lightShadowBiasProperty = ShaderProperty.getByName("scene_ShadowBias");
CascadedShadowCasterPass._lightDirectionProperty = ShaderProperty.getByName("scene_LightDirection");
CascadedShadowCasterPass._shadowMatricesProperty = ShaderProperty.getByName("scene_ShadowMatrices");
CascadedShadowCasterPass._shadowMapSize = ShaderProperty.getByName("scene_ShadowMapSize");
CascadedShadowCasterPass._shadowInfosProperty = ShaderProperty.getByName("scene_ShadowInfo");
CascadedShadowCasterPass._shadowMapsProperty = ShaderProperty.getByName("scene_ShadowMap");
CascadedShadowCasterPass._shadowSplitSpheresProperty = ShaderProperty.getByName("scene_ShadowSplitSpheres");
CascadedShadowCasterPass._maxCascades = 4;
CascadedShadowCasterPass._cascadesSplitDistance = new Array(CascadedShadowCasterPass._maxCascades + 1);
CascadedShadowCasterPass._viewport = new Vector4(0, 0, 1, 1);
CascadedShadowCasterPass._clearColor = new Color(1, 1, 1, 1);
CascadedShadowCasterPass._tempVector = new Vector3();
CascadedShadowCasterPass._tempMatrix0 = new Matrix();

/**
 * @internal
 * Culling results.
 */ var CullingResults = /*#__PURE__*/ function() {
    function CullingResults() {
        this.opaqueQueue = new RenderQueue(RenderQueueType.Opaque);
        this.transparentQueue = new RenderQueue(RenderQueueType.Transparent);
        this.alphaTestQueue = new RenderQueue(RenderQueueType.AlphaTest);
    }
    var _proto = CullingResults.prototype;
    _proto.reset = function reset() {
        this.opaqueQueue.clear();
        this.transparentQueue.clear();
        this.alphaTestQueue.clear();
    };
    _proto.sortBatch = function sortBatch(batcherManager) {
        this.opaqueQueue.sortBatch(RenderQueue.compareForOpaque, batcherManager);
        this.alphaTestQueue.sortBatch(RenderQueue.compareForOpaque, batcherManager);
        this.transparentQueue.sortBatch(RenderQueue.compareForTransparent, batcherManager);
    };
    _proto.destroy = function destroy() {
        this.opaqueQueue.destroy();
        this.transparentQueue.destroy();
        this.alphaTestQueue.destroy();
    };
    return CullingResults;
}();

/**
 * @internal
 * Depth only pass.
 */ var DepthOnlyPass = /*#__PURE__*/ function(PipelinePass) {
    _inherits$2(DepthOnlyPass, PipelinePass);
    function DepthOnlyPass(engine) {
        var _this;
        _this = PipelinePass.call(this, engine) || this;
        _this._supportDepthTexture = engine._hardwareRenderer.canIUse(GLCapabilityType.depthTexture);
        return _this;
    }
    var _proto = DepthOnlyPass.prototype;
    _proto.onConfig = function onConfig(camera) {
        var engine = this.engine;
        var _camera_pixelViewport = camera.pixelViewport, width = _camera_pixelViewport.width, height = _camera_pixelViewport.height;
        var renderTarget = PipelineUtils.recreateRenderTargetIfNeeded(engine, this._renderTarget, width, height, null, TextureFormat.Depth16, true, false, false, 1, TextureWrapMode$1.Clamp, TextureFilterMode.Point);
        this._renderTarget = renderTarget;
    };
    _proto.onRender = function onRender(context, cullingResults) {
        var engine = this.engine;
        var renderTarget = this._renderTarget;
        var camera = context.camera;
        var rhi = engine._hardwareRenderer;
        context.setRenderTarget(renderTarget, PipelineUtils.defaultViewport, 0);
        rhi.clearRenderTarget(engine, CameraClearFlags.Depth, null);
        engine._renderCount++;
        cullingResults.opaqueQueue.render(context, PipelineStage.DepthOnly);
        cullingResults.alphaTestQueue.render(context, PipelineStage.DepthOnly);
        camera.shaderData.setTexture(Camera._cameraDepthTextureProperty, this._renderTarget.depthTexture);
    };
    return DepthOnlyPass;
}(PipelinePass);

/**
 * @internal
 * Opaque texture pass.
 */ var OpaqueTexturePass = /*#__PURE__*/ function(PipelinePass) {
    _inherits$2(OpaqueTexturePass, PipelinePass);
    function OpaqueTexturePass(engine) {
        return PipelinePass.call(this, engine) || this;
    }
    var _proto = OpaqueTexturePass.prototype;
    _proto.onConfig = function onConfig(camera, cameraColorTexture) {
        this._cameraColorTexture = cameraColorTexture;
        var downsampling = camera.opaqueTextureDownsampling;
        var isNoDownsampling = downsampling === Downsampling.None;
        var viewport = camera.pixelViewport;
        var sizeScale = isNoDownsampling ? 1.0 : downsampling === Downsampling.TwoX ? 0.5 : 0.25;
        var opaqueRenderTarget = PipelineUtils.recreateRenderTargetIfNeeded(this.engine, this._renderTarget, viewport.width * sizeScale, viewport.height * sizeScale, camera._getInternalColorTextureFormat(), null, false, false, !camera.enableHDR, 1, TextureWrapMode$1.Clamp, isNoDownsampling ? TextureFilterMode.Point : TextureFilterMode.Bilinear);
        this._renderTarget = opaqueRenderTarget;
    };
    _proto.onRender = function onRender(context) {
        Blitter.blitTexture(this.engine, this._cameraColorTexture, this._renderTarget);
        context.camera.shaderData.setTexture(Camera._cameraOpaqueTextureProperty, this._renderTarget.getColorTexture(0));
    };
    return OpaqueTexturePass;
}(PipelinePass);

/**
 * Basic render pipeline.
 */ var BasicRenderPipeline = /*#__PURE__*/ function() {
    function BasicRenderPipeline(camera) {
        this._lastCanvasSize = new Vector2();
        this._internalColorTarget = null;
        this._canUseBlitFrameBuffer = false;
        this._shouldCopyBackgroundColor = false;
        this._camera = camera;
        var engine = camera.engine;
        this._cullingResults = new CullingResults();
        this._cascadedShadowCasterPass = new CascadedShadowCasterPass(camera);
        this._depthOnlyPass = new DepthOnlyPass(engine);
        this._opaqueTexturePass = new OpaqueTexturePass(engine);
        this._finalPass = new FinalPass(engine);
    }
    var _proto = BasicRenderPipeline.prototype;
    /**
   * Destroy internal resources.
   */ _proto.destroy = function destroy() {
        this._cullingResults.destroy();
        this._camera = null;
    };
    /**
   * Perform scene rendering.
   * @param context - Render context
   * @param cubeFace - Render surface of cube texture
   * @param mipLevel - Set mip level the data want to write
   * @param ignoreClear - Ignore clear flag
   */ _proto.render = function render(context, cubeFace, mipLevel, ignoreClear) {
        context.rendererUpdateFlag = ContextRendererUpdateFlag.All;
        var camera = this._camera;
        var scene = camera.scene, engine = camera.engine, renderTarget = camera.renderTarget;
        var independentCanvasEnabled = camera._isIndependentCanvasEnabled();
        var rhi = engine._hardwareRenderer;
        var cullingResults = this._cullingResults;
        var sunlight = scene._lightManager._sunlight;
        var depthOnlyPass = this._depthOnlyPass;
        var depthPassEnabled = camera.depthTextureMode === DepthTextureMode.PrePass && depthOnlyPass._supportDepthTexture;
        var finalClearFlags = camera.clearFlags & ~(ignoreClear != null ? ignoreClear : CameraClearFlags.None);
        var msaaSamples = renderTarget ? renderTarget.antiAliasing : camera.msaaSamples;
        // Check whether can use `blitFramebuffer` to blit internal render target, source maybe screen canvas or camera's render target
        // Our screen canvas's anti-aliasing is always disable, so blit source and dest is always same by below rules:
        // 1. Only support blitFramebuffer in webgl2 context
        // 2. Can't blit normal FBO to MSAA FBO
        // 3. Can't blit screen MSAA FBO to normal FBO in mac safari platform and mobile, but mac chrome and firfox is OK
        this._canUseBlitFrameBuffer = rhi.isWebGL2 && msaaSamples === 1;
        // Because internal render target is linear color space, so we should convert srgb background color to linear color space
        var isSRGBBackground = !renderTarget || renderTarget.getColorTexture(0).isSRGBColorSpace;
        this._shouldCopyBackgroundColor = independentCanvasEnabled && !(finalClearFlags & CameraClearFlags.Color) && (!this._canUseBlitFrameBuffer || isSRGBBackground);
        if (scene.castShadows && sunlight && sunlight.shadowType !== ShadowType.None) {
            this._cascadedShadowCasterPass.onRender(context);
            context.rendererUpdateFlag = ContextRendererUpdateFlag.None;
        }
        var batcherManager = engine._batcherManager;
        cullingResults.reset();
        // Depth use camera's view and projection matrix
        context.rendererUpdateFlag |= ContextRendererUpdateFlag.viewProjectionMatrix;
        context.applyVirtualCamera(camera._virtualCamera, depthPassEnabled);
        this._prepareRender(context);
        cullingResults.sortBatch(batcherManager);
        batcherManager.uploadBuffer();
        if (depthPassEnabled) {
            depthOnlyPass.onConfig(camera);
            depthOnlyPass.onRender(context, cullingResults);
            context.rendererUpdateFlag = ContextRendererUpdateFlag.None;
        } else {
            camera.shaderData.setTexture(Camera._cameraDepthTextureProperty, engine._basicResources.whiteTexture2D);
        }
        // Check if need to create internal color texture or grab texture
        if (independentCanvasEnabled) {
            var depthFormat;
            if (camera.renderTarget) {
                depthFormat = camera.renderTarget._depthFormat;
            } else if (rhi._options.depth && rhi._options.stencil) {
                depthFormat = TextureFormat.Depth24Stencil8;
            } else if (rhi._options.depth) {
                depthFormat = TextureFormat.Depth24;
            } else if (rhi._options.stencil) {
                depthFormat = TextureFormat.Stencil;
            } else {
                depthFormat = null;
            }
            var viewport = camera.pixelViewport;
            var internalColorTarget = PipelineUtils.recreateRenderTargetIfNeeded(engine, this._internalColorTarget, viewport.width, viewport.height, camera._getInternalColorTextureFormat(), depthFormat, false, false, !camera.enableHDR, msaaSamples, TextureWrapMode$1.Clamp, TextureFilterMode.Bilinear);
            if (this._shouldCopyBackgroundColor) {
                var _camera_renderTarget;
                var colorTexture = (_camera_renderTarget = camera.renderTarget) == null ? void 0 : _camera_renderTarget.getColorTexture(0);
                var _colorTexture_format, _colorTexture_isSRGBColorSpace;
                var copyBackgroundTexture = PipelineUtils.recreateTextureIfNeeded(engine, this._copyBackgroundTexture, viewport.width, viewport.height, (_colorTexture_format = colorTexture == null ? void 0 : colorTexture.format) != null ? _colorTexture_format : TextureFormat.R8G8B8A8, false, (_colorTexture_isSRGBColorSpace = colorTexture == null ? void 0 : colorTexture.isSRGBColorSpace) != null ? _colorTexture_isSRGBColorSpace : false, TextureWrapMode$1.Clamp, TextureFilterMode.Bilinear);
                this._copyBackgroundTexture = copyBackgroundTexture;
            }
            this._internalColorTarget = internalColorTarget;
        } else {
            var internalColorTarget1 = this._internalColorTarget;
            var copyBackgroundTexture1 = this._copyBackgroundTexture;
            if (internalColorTarget1) {
                var _internalColorTarget_getColorTexture;
                (_internalColorTarget_getColorTexture = internalColorTarget1.getColorTexture(0)) == null ? void 0 : _internalColorTarget_getColorTexture.destroy(true);
                internalColorTarget1.destroy(true);
                this._internalColorTarget = null;
            }
            if (copyBackgroundTexture1) {
                copyBackgroundTexture1.destroy(true);
                this._copyBackgroundTexture = null;
            }
        }
        this._drawRenderPass(context, camera, finalClearFlags, cubeFace, mipLevel);
    };
    _proto._drawRenderPass = function _drawRenderPass(context, camera, finalClearFlags, cubeFace, mipLevel) {
        var cullingResults = this._cullingResults;
        var opaqueQueue = cullingResults.opaqueQueue, alphaTestQueue = cullingResults.alphaTestQueue, transparentQueue = cullingResults.transparentQueue;
        var engine = camera.engine, scene = camera.scene, cameraRenderTarget = camera.renderTarget;
        var background = scene.background;
        var rhi = engine._hardwareRenderer;
        var internalColorTarget = this._internalColorTarget;
        var colorTarget = internalColorTarget || camera.renderTarget;
        var colorViewport = internalColorTarget ? PipelineUtils.defaultViewport : camera.viewport;
        var needFlipProjection = !!internalColorTarget || camera.renderTarget && cubeFace == undefined;
        if (context.flipProjection !== needFlipProjection) {
            // Just add projection matrix update type is enough
            context.rendererUpdateFlag |= ContextRendererUpdateFlag.ProjectionMatrix;
            context.applyVirtualCamera(camera._virtualCamera, needFlipProjection);
        }
        context.setRenderTarget(colorTarget, colorViewport, mipLevel, cubeFace);
        // Clear color
        if (finalClearFlags !== CameraClearFlags.None) {
            var premultiplyColor = Background._premultiplySolidColor;
            var solidColor = background.solidColor;
            var a = solidColor.a;
            premultiplyColor.set(solidColor.r * a, solidColor.g * a, solidColor.b * a, a);
            rhi.clearRenderTarget(engine, finalClearFlags, premultiplyColor);
        }
        if (internalColorTarget) {
            // Force clear internal color target depth and stencil buffer, because it already missed due to post process, HDR, sRGB covert, etc.
            var keepDSFlags = ~finalClearFlags & CameraClearFlags.DepthStencil;
            if (keepDSFlags) {
                rhi.clearRenderTarget(engine, keepDSFlags);
            }
            var keepColorFlag = ~finalClearFlags & CameraClearFlags.Color;
            if (keepColorFlag) {
                if (this._shouldCopyBackgroundColor) {
                    // Copy RT's color buffer to grab texture
                    rhi.copyRenderTargetToSubTexture(camera.renderTarget, this._copyBackgroundTexture, camera.viewport);
                    // Then blit grab texture to internal RT's color buffer
                    Blitter.blitTexture(engine, this._copyBackgroundTexture, internalColorTarget, 0, undefined, camera.renderTarget ? undefined : engine._basicResources.blitScreenMaterial);
                } else {
                    // Only blit color buffer from back buffer
                    var ignoreFlags = CameraClearFlags.DepthStencil;
                    rhi.blitInternalRTByBlitFrameBuffer(camera.renderTarget, internalColorTarget, ignoreFlags, camera.viewport);
                }
            }
            context.setRenderTarget(colorTarget, colorViewport, mipLevel, cubeFace);
        }
        var maskManager = scene._maskManager;
        if (finalClearFlags & CameraClearFlags.Stencil) {
            maskManager.hasStencilWritten = false;
        }
        opaqueQueue.render(context, PipelineStage.Forward);
        alphaTestQueue.render(context, PipelineStage.Forward);
        if (finalClearFlags & CameraClearFlags.Color) {
            if (background.mode === BackgroundMode.Sky) {
                background.sky._render(context);
            } else if (background.mode === BackgroundMode.Texture && background.texture) {
                this._drawBackgroundTexture(camera, background);
            }
        }
        // Copy opaque texture
        if (camera.opaqueTextureEnabled) {
            // Should blit to resolve the MSAA
            colorTarget._blitRenderTarget();
            var opaqueTexturePass = this._opaqueTexturePass;
            opaqueTexturePass.onConfig(camera, colorTarget.getColorTexture(0));
            opaqueTexturePass.onRender(context);
            // Should revert to original render target
            context.setRenderTarget(colorTarget, colorViewport, mipLevel, cubeFace);
        } else {
            camera.shaderData.setTexture(Camera._cameraOpaqueTextureProperty, null);
        }
        transparentQueue.render(context, PipelineStage.Forward);
        // Revert stencil buffer generated by mask
        maskManager.clearMask(context, PipelineStage.Forward);
        // Output render target of each stage
        var outputTarget = null;
        // Post process
        var needFinalPass = camera._needFinalPass();
        var postProcessManager = scene.postProcessManager;
        if (camera.enablePostProcess && postProcessManager._isValid()) {
            outputTarget = needFinalPass ? postProcessManager._getOutputRenderTarget(camera) : camera.renderTarget;
            postProcessManager._render(camera, internalColorTarget, outputTarget);
        } else {
            // Maybe internalColorTarget or camera.renderTarget or null
            outputTarget = colorTarget;
            if (internalColorTarget) {
                internalColorTarget._blitRenderTarget();
            }
            postProcessManager._releaseSwapRenderTarget();
            postProcessManager._releaseOutputRenderTarget();
        }
        // Final pass
        var finalPass = this._finalPass;
        if (needFinalPass) {
            finalPass.onConfig(camera, outputTarget);
            finalPass.onRender(context);
            outputTarget = cameraRenderTarget;
        } else {
            finalPass.release();
        }
        // If output target is not camera's render target(only enable HDR or opaqueTexture), we should blit it to camera's render target
        if (outputTarget !== cameraRenderTarget) {
            Blitter.blitTexture(engine, outputTarget.getColorTexture(0), cameraRenderTarget, 0, camera.viewport);
        }
        cameraRenderTarget == null ? void 0 : cameraRenderTarget._blitRenderTarget();
        cameraRenderTarget == null ? void 0 : cameraRenderTarget.generateMipmaps();
    };
    /**
   * Push render data to render queue.
   * @param context - Render context
   * @param renderElement - Render element
   */ _proto.pushRenderElement = function pushRenderElement(context, renderElement) {
        renderElement.renderQueueFlags = 0;
        var subRenderElements = renderElement.subRenderElements;
        for(var i = 0, n = subRenderElements.length; i < n; ++i){
            var subRenderElement = subRenderElements[i];
            var material = subRenderElement.material;
            var renderStates = material.renderStates;
            var materialSubShader = material.shader.subShaders[0];
            var replacementShader = context.replacementShader;
            if (replacementShader) {
                var replacementSubShaders = replacementShader.subShaders;
                var replacementTag = context.replacementTag;
                if (replacementTag) {
                    var replacementSuccess = false;
                    for(var j = 0, m = replacementSubShaders.length; j < m; j++){
                        var subShader = replacementSubShaders[j];
                        if (subShader.getTagValue(replacementTag) === materialSubShader.getTagValue(replacementTag)) {
                            this.pushRenderElementByType(renderElement, subRenderElement, subShader.passes, renderStates);
                            replacementSuccess = true;
                        }
                    }
                    if (!replacementSuccess && context.replacementFailureStrategy === ReplacementFailureStrategy.KeepOriginalShader) {
                        this.pushRenderElementByType(renderElement, subRenderElement, materialSubShader.passes, renderStates);
                    }
                } else {
                    this.pushRenderElementByType(renderElement, subRenderElement, replacementSubShaders[0].passes, renderStates);
                }
            } else {
                this.pushRenderElementByType(renderElement, subRenderElement, materialSubShader.passes, renderStates);
            }
        }
    };
    _proto.pushRenderElementByType = function pushRenderElementByType(renderElement, subRenderElement, shaderPasses, renderStates) {
        var cullingResults = this._cullingResults;
        for(var i = 0, n = shaderPasses.length; i < n; i++){
            // Get render queue type
            var renderQueueType = void 0;
            var shaderPass = shaderPasses[i];
            var renderState = shaderPass._renderState;
            if (renderState) {
                renderQueueType = renderState._getRenderQueueByShaderData(shaderPass._renderStateDataMap, subRenderElement.material.shaderData);
            } else {
                renderQueueType = renderStates[i].renderQueueType;
            }
            var flag = 1 << renderQueueType;
            subRenderElement.shaderPasses = shaderPasses;
            subRenderElement.renderQueueFlags |= flag;
            if (renderElement.renderQueueFlags & flag) {
                continue;
            }
            switch(renderQueueType){
                case RenderQueueType.Opaque:
                    cullingResults.opaqueQueue.pushRenderElement(renderElement);
                    break;
                case RenderQueueType.AlphaTest:
                    cullingResults.alphaTestQueue.pushRenderElement(renderElement);
                    break;
                case RenderQueueType.Transparent:
                    cullingResults.transparentQueue.pushRenderElement(renderElement);
                    break;
            }
            renderElement.renderQueueFlags |= flag;
        }
    };
    _proto._drawBackgroundTexture = function _drawBackgroundTexture(camera, background) {
        var engine = camera.engine;
        var rhi = engine._hardwareRenderer;
        var canvas = engine.canvas;
        var material = background._material, mesh = background._mesh;
        if ((this._lastCanvasSize.x !== canvas.width || this._lastCanvasSize.y !== canvas.height) && background._textureFillMode !== BackgroundTextureFillMode.Fill) {
            this._lastCanvasSize.set(canvas.width, canvas.height);
            background._resizeBackgroundTexture();
        }
        var pass = material.shader.subShaders[0].passes[0];
        var compileMacros = Shader._compileMacros;
        ShaderMacroCollection.unionCollection(compileMacros, engine._macroCollection, compileMacros);
        var program = pass._getShaderProgram(engine, compileMacros);
        program.bind();
        program.uploadAll(program.materialUniformBlock, material.shaderData);
        program.uploadAll(program.cameraUniformBlock, camera.shaderData);
        program.uploadUnGroupTextures();
        (pass._renderState || material.renderState)._applyStates(engine, false, pass._renderStateDataMap, material.shaderData);
        rhi.drawPrimitive(mesh._primitive, mesh.subMesh, program);
    };
    _proto._prepareRender = function _prepareRender(context) {
        var camera = context.camera;
        var engine = camera.engine, enableFrustumCulling = camera.enableFrustumCulling, cullingMask = camera.cullingMask, frustum = camera._frustum;
        var _camera_scene__componentsManager = camera.scene._componentsManager, renderers = _camera_scene__componentsManager._renderers, canvases = _camera_scene__componentsManager._canvases;
        var rendererElements = renderers._elements;
        for(var i = renderers.length - 1; i >= 0; --i){
            var renderer = rendererElements[i];
            // Filter by camera culling mask
            if (!(cullingMask & renderer._entity.layer)) {
                continue;
            }
            // Filter by camera frustum
            if (enableFrustumCulling) {
                if (!frustum.intersectsBox(renderer.bounds)) {
                    continue;
                }
            }
            renderer._prepareRender(context);
            renderer._renderFrameCount = engine.time.frameCount;
        }
        var canvasesElements = canvases._elements;
        for(var i1 = canvases.length - 1; i1 >= 0; i1--){
            var canvas = canvasesElements[i1];
            // Filter by camera culling mask
            if (!(cullingMask & canvas.entity.layer)) {
                continue;
            }
            if (!canvas._canRender(camera)) {
                continue;
            }
            canvas._prepareRender(context);
            this.pushRenderElement(context, canvas._renderElement);
        }
    };
    return BasicRenderPipeline;
}();
var RenderQueueFlags = /*#__PURE__*/ function(RenderQueueFlags) {
    RenderQueueFlags[RenderQueueFlags["None"] = 0] = "None";
    RenderQueueFlags[RenderQueueFlags["Opaque"] = 1] = "Opaque";
    RenderQueueFlags[RenderQueueFlags["AlphaTest"] = 2] = "AlphaTest";
    RenderQueueFlags[RenderQueueFlags["Transparent"] = 4] = "Transparent";
    RenderQueueFlags[RenderQueueFlags["All"] = 7] = "All";
    return RenderQueueFlags;
}({});

var RenderElement = /*#__PURE__*/ function() {
    function RenderElement() {
        this.subRenderElements = Array();
    }
    var _proto = RenderElement.prototype;
    _proto.set = function set(priority, distanceForSort) {
        this.priority = priority;
        this.distanceForSort = distanceForSort;
        this.subRenderElements.length = 0;
    };
    _proto.addSubRenderElement = function addSubRenderElement(element) {
        this.subRenderElements.push(element);
    };
    _proto.dispose = function dispose() {
        this.subRenderElements.length = 0;
    };
    return RenderElement;
}();

var SubRenderElement = /*#__PURE__*/ function() {
    function SubRenderElement() {}
    var _proto = SubRenderElement.prototype;
    _proto.set = function set(component, material, primitive, subPrimitive, texture, subChunk) {
        this.component = component;
        this.material = material;
        this.primitive = primitive;
        this.subPrimitive = subPrimitive;
        this.texture = texture;
        this.subChunk = subChunk;
    };
    _proto.dispose = function dispose() {
        this.component = null;
        this.material = null;
        this.primitive = null;
        this.subPrimitive = null;
        this.shaderPasses = null;
        this.shaderData && (this.shaderData = null);
        this.texture && (this.texture = null);
        this.subChunk && (this.subChunk = null);
    };
    return SubRenderElement;
}();

/**
 * Sprite mask layer.
 */ var SpriteMaskLayer = /*#__PURE__*/ function(SpriteMaskLayer) {
    /** Mask layer 0. */ SpriteMaskLayer[SpriteMaskLayer["Layer0"] = 1] = "Layer0";
    /** Mask layer 1. */ SpriteMaskLayer[SpriteMaskLayer["Layer1"] = 2] = "Layer1";
    /** Mask layer 2. */ SpriteMaskLayer[SpriteMaskLayer["Layer2"] = 4] = "Layer2";
    /** Mask layer 3. */ SpriteMaskLayer[SpriteMaskLayer["Layer3"] = 8] = "Layer3";
    /** Mask layer 4. */ SpriteMaskLayer[SpriteMaskLayer["Layer4"] = 16] = "Layer4";
    /** Mask layer 5. */ SpriteMaskLayer[SpriteMaskLayer["Layer5"] = 32] = "Layer5";
    /** Mask layer 6. */ SpriteMaskLayer[SpriteMaskLayer["Layer6"] = 64] = "Layer6";
    /** Mask layer 7. */ SpriteMaskLayer[SpriteMaskLayer["Layer7"] = 128] = "Layer7";
    /** Mask layer 8. */ SpriteMaskLayer[SpriteMaskLayer["Layer8"] = 256] = "Layer8";
    /** Mask layer 9. */ SpriteMaskLayer[SpriteMaskLayer["Layer9"] = 512] = "Layer9";
    /** Mask layer 10. */ SpriteMaskLayer[SpriteMaskLayer["Layer10"] = 1024] = "Layer10";
    /** Mask layer 11. */ SpriteMaskLayer[SpriteMaskLayer["Layer11"] = 2048] = "Layer11";
    /** Mask layer 12. */ SpriteMaskLayer[SpriteMaskLayer["Layer12"] = 4096] = "Layer12";
    /** Mask layer 13. */ SpriteMaskLayer[SpriteMaskLayer["Layer13"] = 8192] = "Layer13";
    /** Mask layer 14. */ SpriteMaskLayer[SpriteMaskLayer["Layer14"] = 16384] = "Layer14";
    /** Mask layer 15. */ SpriteMaskLayer[SpriteMaskLayer["Layer15"] = 32768] = "Layer15";
    /** Mask layer 16. */ SpriteMaskLayer[SpriteMaskLayer["Layer16"] = 65536] = "Layer16";
    /** Mask layer 17. */ SpriteMaskLayer[SpriteMaskLayer["Layer17"] = 131072] = "Layer17";
    /** Mask layer 18. */ SpriteMaskLayer[SpriteMaskLayer["Layer18"] = 262144] = "Layer18";
    /** Mask layer 19. */ SpriteMaskLayer[SpriteMaskLayer["Layer19"] = 524288] = "Layer19";
    /** Mask layer 20. */ SpriteMaskLayer[SpriteMaskLayer["Layer20"] = 1048576] = "Layer20";
    /** Mask layer 21. */ SpriteMaskLayer[SpriteMaskLayer["Layer21"] = 2097152] = "Layer21";
    /** Mask layer 22. */ SpriteMaskLayer[SpriteMaskLayer["Layer22"] = 4194304] = "Layer22";
    /** Mask layer 23. */ SpriteMaskLayer[SpriteMaskLayer["Layer23"] = 8388608] = "Layer23";
    /** Mask layer 24. */ SpriteMaskLayer[SpriteMaskLayer["Layer24"] = 16777216] = "Layer24";
    /** Mask layer 25. */ SpriteMaskLayer[SpriteMaskLayer["Layer25"] = 33554432] = "Layer25";
    /** Mask layer 26. */ SpriteMaskLayer[SpriteMaskLayer["Layer26"] = 67108864] = "Layer26";
    /** Mask layer 27. */ SpriteMaskLayer[SpriteMaskLayer["Layer27"] = 134217728] = "Layer27";
    /** Mask layer 28. */ SpriteMaskLayer[SpriteMaskLayer["Layer28"] = 268435456] = "Layer28";
    /** Mask layer 29. */ SpriteMaskLayer[SpriteMaskLayer["Layer29"] = 536870912] = "Layer29";
    /** Mask layer 30. */ SpriteMaskLayer[SpriteMaskLayer["Layer30"] = 1073741824] = "Layer30";
    /** Mask layer 31. */ SpriteMaskLayer[SpriteMaskLayer["Layer31"] = 2147483648] = "Layer31";
    /** All mask layers. */ SpriteMaskLayer[SpriteMaskLayer["Everything"] = 4294967295] = "Everything";
    /** None mask layer. */ SpriteMaskLayer[SpriteMaskLayer["Nothing"] = 0] = "Nothing";
    return SpriteMaskLayer;
}({});

// @ts-ignore
var Renderer = /*#__PURE__*/ function(Component) {
    _inherits$2(Renderer, Component);
    function Renderer(entity) {
        var _this;
        _this = Component.call(this, entity) || this, /** @internal */ _this._onUpdateIndex = -1, /** @internal */ _this._rendererIndex = -1, /** @internal */ _this._globalShaderMacro = new ShaderMacroCollection(), /** @internal */ _this._maskInteraction = SpriteMaskInteraction.None, /** @internal */ _this._batchedTransformShaderData = false, _this._maskLayer = SpriteMaskLayer.Layer0, _this._overrideUpdate = false, _this._materials = [], _this._dirtyUpdateFlag = 0, _this._rendererLayer = new Vector4(), _this._bounds = new BoundingBox(), _this._shaderData = new ShaderData(ShaderDataGroup.Renderer), _this._mvMatrix = new Matrix(), _this._mvpMatrix = new Matrix(), _this._mvInvMatrix = new Matrix(), _this._normalMatrix = new Matrix(), _this._materialsInstanced = [], _this._priority = 0, _this._receiveShadows = true, /** Whether cast shadow. */ _this.castShadows = true;
        var prototype = Renderer.prototype;
        var shaderData = _this.shaderData;
        _this._overrideUpdate = _this.update !== prototype.update;
        _this._addResourceReferCount(_this.shaderData, 1);
        _this._onTransformChanged = _this._onTransformChanged.bind(_this);
        _this._setTransformEntity(entity);
        shaderData.enableMacro(Renderer._receiveShadowMacro);
        shaderData.setVector4(Renderer._rendererLayerProperty, _this._rendererLayer);
        return _this;
    }
    var _proto = Renderer.prototype;
    _proto.getInstanceMaterial = function getInstanceMaterial(index) {
        if (index === void 0) index = 0;
        var materials = this._materials;
        if (materials.length > index) {
            var material = materials[index];
            if (material) {
                if (this._materialsInstanced[index]) {
                    return material;
                } else {
                    return this._createInstanceMaterial(material, index);
                }
            }
        }
        return null;
    };
    _proto.getMaterial = function getMaterial(index) {
        if (index === void 0) index = 0;
        return this._materials[index] || null;
    };
    _proto.setMaterial = function setMaterial(indexOrMaterial, material) {
        if (material === void 0) material = null;
        if (typeof indexOrMaterial === "number") {
            this._setMaterial(indexOrMaterial, material);
        } else {
            this._setMaterial(0, indexOrMaterial);
        }
    };
    /**
   * Get all instance materials.
   * @remarks Calling this function for the first time after the material is set will create an instance material to ensure that it is unique to the renderer.
   * @returns All instance materials
   */ _proto.getInstanceMaterials = function getInstanceMaterials() {
        var materials = this._materials;
        var materialsInstance = this._materialsInstanced;
        for(var i = 0, n = materials.length; i < n; i++){
            if (!materialsInstance[i]) {
                this._createInstanceMaterial(this._materials[i], i);
            }
        }
        return materials;
    };
    /**
   * Get all materials.
   * @returns All materials
   */ _proto.getMaterials = function getMaterials() {
        return this._materials;
    };
    /**
   * Set all materials.
   * @param materials - All materials
   */ _proto.setMaterials = function setMaterials(materials) {
        var count = materials.length;
        var internalMaterials = this._materials;
        var materialsInstanced = this._materialsInstanced;
        for(var i = count, n = internalMaterials.length; i < n; i++){
            var internalMaterial = internalMaterials[i];
            internalMaterial && this._addResourceReferCount(internalMaterial, -1);
        }
        internalMaterials.length !== count && (internalMaterials.length = count);
        materialsInstanced.length !== 0 && (materialsInstanced.length = 0);
        for(var i1 = 0; i1 < count; i1++){
            var internalMaterial1 = internalMaterials[i1];
            var material = materials[i1];
            if (internalMaterial1 !== material) {
                internalMaterials[i1] = material;
                internalMaterial1 && this._addResourceReferCount(internalMaterial1, -1);
                material && this._addResourceReferCount(material, 1);
            }
        }
    };
    _proto.update = function update(deltaTime) {};
    /**
   * @internal
   */ _proto._onEnableInScene = function _onEnableInScene() {
        var componentsManager = this.scene._componentsManager;
        if (this._overrideUpdate) {
            componentsManager.addOnUpdateRenderers(this);
        }
        componentsManager.addRenderer(this);
    };
    /**
   * @internal
   */ _proto._onDisableInScene = function _onDisableInScene() {
        var componentsManager = this.scene._componentsManager;
        if (this._overrideUpdate) {
            componentsManager.removeOnUpdateRenderers(this);
        }
        componentsManager.removeRenderer(this);
    };
    /**
   * @internal
   */ _proto._prepareRender = function _prepareRender(context) {
        if (this._renderFrameCount !== this.engine.time.frameCount) {
            this._update(context);
        }
        var virtualCamera = context.virtualCamera;
        var cameraPosition = virtualCamera.position;
        var boundsCenter = this.bounds.getCenter(Renderer._tempVector0);
        if (virtualCamera.isOrthographic) {
            Vector3.subtract(boundsCenter, cameraPosition, boundsCenter);
            this._distanceForSort = Vector3.dot(boundsCenter, virtualCamera.forward);
        } else {
            this._distanceForSort = Vector3.distanceSquared(boundsCenter, cameraPosition);
        }
        this._render(context);
        // union camera global macro and renderer macro.
        ShaderMacroCollection.unionCollection(context.camera._globalShaderMacro, this.shaderData._macroCollection, this._globalShaderMacro);
    };
    /**
   * @internal
   */ _proto._cloneTo = function _cloneTo(target, srcRoot, targetRoot) {
        var materials = this._materials;
        for(var i = 0, n = materials.length; i < n; i++){
            target._setMaterial(i, materials[i]);
        }
    };
    /**
   * @internal
   */ _proto._isFrontFaceInvert = function _isFrontFaceInvert() {
        return this._transformEntity.transform._isFrontFaceInvert();
    };
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        Component.prototype._onDestroy.call(this);
        this._setTransformEntity(null);
        this._addResourceReferCount(this.shaderData, -1);
        var materials = this._materials;
        for(var i = 0, n = materials.length; i < n; i++){
            var material = materials[i];
            material && this._addResourceReferCount(material, -1);
        }
        this._globalShaderMacro = null;
        this._bounds = null;
        this._materials = null;
        this._shaderData = null;
        this._mvMatrix = null;
        this._mvpMatrix = null;
        this._mvInvMatrix = null;
        this._normalMatrix = null;
        this._materialsInstanced = null;
        this._rendererLayer = null;
    };
    /**
   * @internal
   */ _proto._updateTransformShaderData = function _updateTransformShaderData(context, onlyMVP, batched) {
        var worldMatrix = this._transformEntity.transform.worldMatrix;
        if (onlyMVP) {
            this._updateProjectionRelatedShaderData(context, worldMatrix, batched);
        } else {
            this._updateWorldViewRelatedShaderData(context, worldMatrix, batched);
        }
    };
    /**
   * @internal
   */ _proto._canBatch = function _canBatch(elementA, elementB) {
        return false;
    };
    /**
   * @internal
   */ _proto._batch = function _batch(elementA, elementB) {};
    /**
   * Update once per frame per renderer, not influenced by batched.
   */ _proto._update = function _update(context) {
        var layer = this.entity.layer;
        this._rendererLayer.set(layer & 65535, layer >>> 16 & 65535, 0, 0);
    };
    _proto._updateWorldViewRelatedShaderData = function _updateWorldViewRelatedShaderData(context, worldMatrix, batched) {
        var _this = this, shaderData = _this.shaderData, mvInvMatrix = _this._mvInvMatrix;
        if (batched) {
            // @ts-ignore
            var identityMatrix = Matrix._identity;
            Matrix.invert(context.viewMatrix, mvInvMatrix);
            shaderData.setMatrix(Renderer._localMatrixProperty, identityMatrix);
            shaderData.setMatrix(Renderer._worldMatrixProperty, identityMatrix);
            shaderData.setMatrix(Renderer._mvMatrixProperty, context.viewMatrix);
            shaderData.setMatrix(Renderer._mvInvMatrixProperty, mvInvMatrix);
            shaderData.setMatrix(Renderer._normalMatrixProperty, identityMatrix);
        } else {
            var mvMatrix = this._mvMatrix;
            var normalMatrix = this._normalMatrix;
            Matrix.multiply(context.viewMatrix, worldMatrix, mvMatrix);
            Matrix.invert(mvMatrix, mvInvMatrix);
            Matrix.invert(worldMatrix, normalMatrix);
            normalMatrix.transpose();
            shaderData.setMatrix(Renderer._localMatrixProperty, this._transformEntity.transform.localMatrix);
            shaderData.setMatrix(Renderer._worldMatrixProperty, worldMatrix);
            shaderData.setMatrix(Renderer._mvMatrixProperty, mvMatrix);
            shaderData.setMatrix(Renderer._mvInvMatrixProperty, mvInvMatrix);
            shaderData.setMatrix(Renderer._normalMatrixProperty, normalMatrix);
        }
        this._updateProjectionRelatedShaderData(context, worldMatrix, batched);
    };
    _proto._updateProjectionRelatedShaderData = function _updateProjectionRelatedShaderData(context, worldMatrix, batched) {
        if (batched) {
            this.shaderData.setMatrix(Renderer._mvpMatrixProperty, context.viewProjectionMatrix);
        } else {
            var mvpMatrix = this._mvpMatrix;
            Matrix.multiply(context.viewProjectionMatrix, worldMatrix, mvpMatrix);
            this.shaderData.setMatrix(Renderer._mvpMatrixProperty, mvpMatrix);
        }
    };
    /**
   * @internal
   */ _proto._setTransformEntity = function _setTransformEntity(entity) {
        var preEntity = this._transformEntity;
        if (entity !== preEntity) {
            preEntity == null ? void 0 : preEntity._updateFlagManager.removeListener(this._onTransformChanged);
            entity == null ? void 0 : entity._updateFlagManager.addListener(this._onTransformChanged);
            this._transformEntity = entity;
        }
    };
    _proto._updateBounds = function _updateBounds(worldBounds) {};
    _proto._render = function _render(context) {
        throw "not implement";
    };
    _proto._createInstanceMaterial = function _createInstanceMaterial(material, index) {
        var insMaterial = material.clone();
        insMaterial.name = material.name + "(Instance)";
        this._addResourceReferCount(material, -1);
        this._addResourceReferCount(insMaterial, 1);
        this._materialsInstanced[index] = true;
        this._materials[index] = insMaterial;
        return insMaterial;
    };
    _proto._setMaterial = function _setMaterial(index, material) {
        var materials = this._materials;
        if (index >= materials.length) {
            materials.length = index + 1;
        }
        var internalMaterial = materials[index];
        if (internalMaterial !== material) {
            var materialsInstance = this._materialsInstanced;
            index < materialsInstance.length && (materialsInstance[index] = false);
            internalMaterial && this._addResourceReferCount(internalMaterial, -1);
            material && this._addResourceReferCount(material, 1);
            materials[index] = material;
        }
    };
    _proto._onTransformChanged = function _onTransformChanged(type) {
        this._dirtyUpdateFlag |= 1;
    };
    _create_class$2(Renderer, [
        {
            key: "shaderData",
            get: /**
   * ShaderData related to renderer.
   */ function get() {
                return this._shaderData;
            }
        },
        {
            key: "isCulled",
            get: /**
   * Whether it is culled in the current frame and does not participate in rendering.
   */ function get() {
                return !(this._renderFrameCount === undefined || this._renderFrameCount === this._engine.time.frameCount - 1);
            }
        },
        {
            key: "receiveShadows",
            get: /**
   * Whether receive shadow.
   */ function get() {
                return this._receiveShadows;
            },
            set: function set(value) {
                if (this._receiveShadows !== value) {
                    if (value) {
                        this.shaderData.enableMacro(Renderer._receiveShadowMacro);
                    } else {
                        this.shaderData.disableMacro(Renderer._receiveShadowMacro);
                    }
                    this._receiveShadows = value;
                }
            }
        },
        {
            key: "materialCount",
            get: /**
   * Material count.
   */ function get() {
                return this._materials.length;
            },
            set: function set(value) {
                var materials = this._materials;
                var materialsInstanced = this._materialsInstanced;
                materials.length !== value && (materials.length = value);
                materialsInstanced.length > value && (materialsInstanced.length = value);
            }
        },
        {
            key: "bounds",
            get: /**
   * The world bounding volume of the renderer.
   */ function get() {
                if (this._dirtyUpdateFlag & 1) {
                    this._updateBounds(this._bounds);
                    this._dirtyUpdateFlag &= -2;
                }
                return this._bounds;
            }
        },
        {
            key: "priority",
            get: /**
   * The render priority of the renderer, lower values are rendered first and higher values are rendered last.
   */ function get() {
                return this._priority;
            },
            set: function set(value) {
                this._priority = value;
            }
        }
    ]);
    return Renderer;
}(Component);
Renderer._tempVector0 = new Vector3();
Renderer._receiveShadowMacro = ShaderMacro.getByName("RENDERER_IS_RECEIVE_SHADOWS");
Renderer._localMatrixProperty = ShaderProperty.getByName("renderer_LocalMat");
Renderer._worldMatrixProperty = ShaderProperty.getByName("renderer_ModelMat");
Renderer._mvMatrixProperty = ShaderProperty.getByName("renderer_MVMat");
Renderer._mvpMatrixProperty = ShaderProperty.getByName("renderer_MVPMat");
Renderer._mvInvMatrixProperty = ShaderProperty.getByName("renderer_MVInvMat");
Renderer._normalMatrixProperty = ShaderProperty.getByName("renderer_NormalMat");
Renderer._rendererLayerProperty = ShaderProperty.getByName("renderer_Layer");
__decorate$1([
    ignoreClone
], Renderer.prototype, "_distanceForSort", void 0);
__decorate$1([
    ignoreClone
], Renderer.prototype, "_onUpdateIndex", void 0);
__decorate$1([
    ignoreClone
], Renderer.prototype, "_rendererIndex", void 0);
__decorate$1([
    ignoreClone
], Renderer.prototype, "_globalShaderMacro", void 0);
__decorate$1([
    ignoreClone
], Renderer.prototype, "_renderFrameCount", void 0);
__decorate$1([
    assignmentClone
], Renderer.prototype, "_maskInteraction", void 0);
__decorate$1([
    ignoreClone
], Renderer.prototype, "_batchedTransformShaderData", void 0);
__decorate$1([
    assignmentClone
], Renderer.prototype, "_maskLayer", void 0);
__decorate$1([
    ignoreClone
], Renderer.prototype, "_overrideUpdate", void 0);
__decorate$1([
    ignoreClone
], Renderer.prototype, "_materials", void 0);
__decorate$1([
    ignoreClone
], Renderer.prototype, "_dirtyUpdateFlag", void 0);
__decorate$1([
    ignoreClone
], Renderer.prototype, "_rendererLayer", void 0);
__decorate$1([
    ignoreClone
], Renderer.prototype, "_bounds", void 0);
__decorate$1([
    ignoreClone
], Renderer.prototype, "_transformEntity", void 0);
__decorate$1([
    deepClone
], Renderer.prototype, "_shaderData", void 0);
__decorate$1([
    ignoreClone
], Renderer.prototype, "_mvMatrix", void 0);
__decorate$1([
    ignoreClone
], Renderer.prototype, "_mvpMatrix", void 0);
__decorate$1([
    ignoreClone
], Renderer.prototype, "_mvInvMatrix", void 0);
__decorate$1([
    ignoreClone
], Renderer.prototype, "_normalMatrix", void 0);
__decorate$1([
    ignoreClone
], Renderer.prototype, "_materialsInstanced", void 0);
__decorate$1([
    assignmentClone
], Renderer.prototype, "_priority", void 0);
__decorate$1([
    assignmentClone
], Renderer.prototype, "_receiveShadows", void 0);
__decorate$1([
    ignoreClone
], Renderer.prototype, "_onTransformChanged", null);
Renderer = __decorate$1([
    dependentComponents(Transform, DependentMode.CheckOnly)
], Renderer);
var RendererUpdateFlags = /*#__PURE__*/ function(RendererUpdateFlags) {
    /** Include world position and world bounds. */ RendererUpdateFlags[RendererUpdateFlags["WorldVolume"] = 1] = "WorldVolume";
    return RendererUpdateFlags;
}({});

/**
 * A component for masking Sprites.
 */ var SpriteMask = /*#__PURE__*/ function(Renderer) {
    _inherits$2(SpriteMask, Renderer);
    function SpriteMask(entity) {
        var _this;
        _this = Renderer.call(this, entity) || this, /** The mask layers the sprite mask influence to. */ _this.influenceLayers = SpriteMaskLayer.Everything, /** @internal */ _this._maskIndex = -1, _this._sprite = null, _this._automaticWidth = 0, _this._automaticHeight = 0, _this._customWidth = undefined, _this._customHeight = undefined, _this._flipX = false, _this._flipY = false, _this._alphaCutoff = 0.5;
        SimpleSpriteAssembler.resetData(_this);
        _this.setMaterial(_this._engine._basicResources.spriteMaskDefaultMaterial);
        _this.shaderData.setFloat(SpriteMask._alphaCutoffProperty, _this._alphaCutoff);
        _this._renderElement = new RenderElement();
        _this._renderElement.addSubRenderElement(new SubRenderElement());
        _this._onSpriteChange = _this._onSpriteChange.bind(_this);
        return _this;
    }
    var _proto = SpriteMask.prototype;
    /**
   * @internal
   */ _proto._updateTransformShaderData = function _updateTransformShaderData(context, onlyMVP, batched) {
        //@todo: Always update world positions to buffer, should opt
        Renderer.prototype._updateTransformShaderData.call(this, context, onlyMVP, true);
    };
    /**
   * @internal
   */ _proto._cloneTo = function _cloneTo(target, srcRoot, targetRoot) {
        Renderer.prototype._cloneTo.call(this, target, srcRoot, targetRoot);
        target.sprite = this._sprite;
    };
    /**
   * @internal
   */ _proto._canBatch = function _canBatch(elementA, elementB) {
        return BatchUtils.canBatchSpriteMask(elementA, elementB);
    };
    /**
   * @internal
   */ _proto._batch = function _batch(elementA, elementB) {
        BatchUtils.batchFor2D(elementA, elementB);
    };
    /**
   * @internal
   */ _proto._onEnableInScene = function _onEnableInScene() {
        Renderer.prototype._onEnableInScene.call(this);
        this.scene._maskManager.addSpriteMask(this);
    };
    /**
   * @internal
   */ _proto._onDisableInScene = function _onDisableInScene() {
        Renderer.prototype._onDisableInScene.call(this);
        this.scene._maskManager.removeSpriteMask(this);
    };
    /**
   * @internal
   */ _proto._getChunkManager = function _getChunkManager() {
        return this.engine._batcherManager.primitiveChunkManagerMask;
    };
    _proto._updateBounds = function _updateBounds(worldBounds) {
        var sprite = this._sprite;
        if (sprite) {
            SimpleSpriteAssembler.updatePositions(this, this._transformEntity.transform.worldMatrix, this.width, this.height, sprite.pivot, this._flipX, this._flipY);
        } else {
            var worldPosition = this._transformEntity.transform.worldPosition;
            worldBounds.min.copyFrom(worldPosition);
            worldBounds.max.copyFrom(worldPosition);
        }
    };
    /**
   * @inheritdoc
   */ _proto._render = function _render(context) {
        var _this = this, sprite = _this._sprite;
        if (!(sprite == null ? void 0 : sprite.texture) || !this.width || !this.height) {
            return;
        }
        var material = this.getMaterial();
        if (!material) {
            return;
        }
        var _this1 = this, engine = _this1._engine;
        // @todo: This question needs to be raised rather than hidden.
        if (material.destroyed) {
            material = engine._basicResources.spriteMaskDefaultMaterial;
        }
        // Update position
        if (this._dirtyUpdateFlag & RendererUpdateFlags.WorldVolume) {
            SimpleSpriteAssembler.updatePositions(this, this._transformEntity.transform.worldMatrix, this.width, this.height, sprite.pivot, this._flipX, this._flipY);
            this._dirtyUpdateFlag &= ~RendererUpdateFlags.WorldVolume;
        }
        // Update uv
        if (this._dirtyUpdateFlag & 2) {
            SimpleSpriteAssembler.updateUVs(this);
            this._dirtyUpdateFlag &= -3;
        }
        var renderElement = this._renderElement;
        var subRenderElement = renderElement.subRenderElements[0];
        renderElement.set(this.priority, this._distanceForSort);
        var subChunk = this._subChunk;
        subRenderElement.set(this, material, subChunk.chunk.primitive, subChunk.subMesh, this.sprite.texture, subChunk);
        subRenderElement.shaderPasses = material.shader.subShaders[0].passes;
        subRenderElement.renderQueueFlags = RenderQueueFlags.All;
        renderElement.addSubRenderElement(subRenderElement);
    };
    /**
   * @inheritdoc
   */ _proto._onDestroy = function _onDestroy() {
        var sprite = this._sprite;
        if (sprite) {
            this._addResourceReferCount(sprite, -1);
            sprite._updateFlagManager.removeListener(this._onSpriteChange);
        }
        Renderer.prototype._onDestroy.call(this);
        this._sprite = null;
        if (this._subChunk) {
            this._getChunkManager().freeSubChunk(this._subChunk);
            this._subChunk = null;
        }
        this._renderElement = null;
    };
    _proto._calDefaultSize = function _calDefaultSize() {
        var sprite = this._sprite;
        if (sprite) {
            this._automaticWidth = sprite.width;
            this._automaticHeight = sprite.height;
        } else {
            this._automaticWidth = this._automaticHeight = 0;
        }
        this._dirtyUpdateFlag &= -5;
    };
    _proto._onSpriteChange = function _onSpriteChange(type) {
        switch(type){
            case SpriteModifyFlags.texture:
                this.shaderData.setTexture(SpriteMask._textureProperty, this.sprite.texture);
                break;
            case SpriteModifyFlags.size:
                this._dirtyUpdateFlag |= 4;
                if (this._customWidth === undefined || this._customHeight === undefined) {
                    this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
                }
                break;
            case SpriteModifyFlags.region:
            case SpriteModifyFlags.atlasRegionOffset:
                this._dirtyUpdateFlag |= 3;
                break;
            case SpriteModifyFlags.atlasRegion:
                this._dirtyUpdateFlag |= 2;
                break;
            case SpriteModifyFlags.pivot:
                this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
                break;
            case SpriteModifyFlags.destroy:
                this.sprite = null;
                break;
        }
    };
    _create_class$2(SpriteMask, [
        {
            key: "width",
            get: /**
   * Render width (in world coordinates).
   *
   * @remarks
   * If width is set, return the set value,
   * otherwise return `SpriteMask.sprite.width`.
   */ function get() {
                if (this._customWidth !== undefined) {
                    return this._customWidth;
                } else {
                    this._dirtyUpdateFlag & 4 && this._calDefaultSize();
                    return this._automaticWidth;
                }
            },
            set: function set(value) {
                if (this._customWidth !== value) {
                    this._customWidth = value;
                    this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
                }
            }
        },
        {
            key: "height",
            get: /**
   * Render height (in world coordinates).
   *
   * @remarks
   * If height is set, return the set value,
   * otherwise return `SpriteMask.sprite.height`.
   */ function get() {
                if (this._customHeight !== undefined) {
                    return this._customHeight;
                } else {
                    this._dirtyUpdateFlag & 4 && this._calDefaultSize();
                    return this._automaticHeight;
                }
            },
            set: function set(value) {
                if (this._customHeight !== value) {
                    this._customHeight = value;
                    this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
                }
            }
        },
        {
            key: "flipX",
            get: /**
   * Flips the sprite on the X axis.
   */ function get() {
                return this._flipX;
            },
            set: function set(value) {
                if (this._flipX !== value) {
                    this._flipX = value;
                    this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
                }
            }
        },
        {
            key: "flipY",
            get: /**
   * Flips the sprite on the Y axis.
   */ function get() {
                return this._flipY;
            },
            set: function set(value) {
                if (this._flipY !== value) {
                    this._flipY = value;
                    this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
                }
            }
        },
        {
            key: "sprite",
            get: /**
   * The Sprite to render.
   */ function get() {
                return this._sprite;
            },
            set: function set(value) {
                var lastSprite = this._sprite;
                if (lastSprite !== value) {
                    if (lastSprite) {
                        this._addResourceReferCount(lastSprite, -1);
                        lastSprite._updateFlagManager.removeListener(this._onSpriteChange);
                    }
                    this._dirtyUpdateFlag |= 7;
                    if (value) {
                        this._addResourceReferCount(value, 1);
                        value._updateFlagManager.addListener(this._onSpriteChange);
                        this.shaderData.setTexture(SpriteMask._textureProperty, value.texture);
                    } else {
                        this.shaderData.setTexture(SpriteMask._textureProperty, null);
                    }
                    this._sprite = value;
                }
            }
        },
        {
            key: "alphaCutoff",
            get: /**
   * The minimum alpha value used by the mask to select the area of influence defined over the mask's sprite. Value between 0 and 1.
   */ function get() {
                return this._alphaCutoff;
            },
            set: function set(value) {
                if (this._alphaCutoff !== value) {
                    this._alphaCutoff = value;
                    this.shaderData.setFloat(SpriteMask._alphaCutoffProperty, value);
                }
            }
        }
    ]);
    return SpriteMask;
}(Renderer);
/** @internal */ SpriteMask._textureProperty = ShaderProperty.getByName("renderer_MaskTexture");
/** @internal */ SpriteMask._alphaCutoffProperty = ShaderProperty.getByName("renderer_MaskAlphaCutoff");
__decorate$1([
    assignmentClone
], SpriteMask.prototype, "influenceLayers", void 0);
__decorate$1([
    ignoreClone
], SpriteMask.prototype, "_renderElement", void 0);
__decorate$1([
    ignoreClone
], SpriteMask.prototype, "_subChunk", void 0);
__decorate$1([
    ignoreClone
], SpriteMask.prototype, "_maskIndex", void 0);
__decorate$1([
    ignoreClone
], SpriteMask.prototype, "_sprite", void 0);
__decorate$1([
    ignoreClone
], SpriteMask.prototype, "_automaticWidth", void 0);
__decorate$1([
    ignoreClone
], SpriteMask.prototype, "_automaticHeight", void 0);
__decorate$1([
    assignmentClone
], SpriteMask.prototype, "_customWidth", void 0);
__decorate$1([
    assignmentClone
], SpriteMask.prototype, "_customHeight", void 0);
__decorate$1([
    assignmentClone
], SpriteMask.prototype, "_flipX", void 0);
__decorate$1([
    assignmentClone
], SpriteMask.prototype, "_flipY", void 0);
__decorate$1([
    assignmentClone
], SpriteMask.prototype, "_alphaCutoff", void 0);
__decorate$1([
    ignoreClone
], SpriteMask.prototype, "_onSpriteChange", null);

/**
 * Renders a Sprite for 2D graphics.
 */ var SpriteRenderer = /*#__PURE__*/ function(Renderer) {
    _inherits$2(SpriteRenderer, Renderer);
    function SpriteRenderer(entity) {
        var _this;
        _this = Renderer.call(this, entity) || this, _this._tileMode = SpriteTileMode.Continuous, _this._tiledAdaptiveThreshold = 0.5, _this._color = new Color(1, 1, 1, 1), _this._sprite = null, _this._automaticWidth = 0, _this._automaticHeight = 0, _this._customWidth = undefined, _this._customHeight = undefined, _this._flipX = false, _this._flipY = false;
        _this.drawMode = SpriteDrawMode.Simple;
        _this._dirtyUpdateFlag |= 4;
        _this.setMaterial(_this._engine._basicResources.spriteDefaultMaterial);
        _this._onSpriteChange = _this._onSpriteChange.bind(_this);
        //@ts-ignore
        _this._color._onValueChanged = _this._onColorChanged.bind(_this);
        return _this;
    }
    var _proto = SpriteRenderer.prototype;
    /**
   * @internal
   */ _proto._updateTransformShaderData = function _updateTransformShaderData(context, onlyMVP, batched) {
        //@todo: Always update world positions to buffer, should opt
        Renderer.prototype._updateTransformShaderData.call(this, context, onlyMVP, true);
    };
    /**
   * @internal
   */ _proto._cloneTo = function _cloneTo(target, srcRoot, targetRoot) {
        Renderer.prototype._cloneTo.call(this, target, srcRoot, targetRoot);
        target.sprite = this._sprite;
        target.drawMode = this._drawMode;
    };
    /**
   * @internal
   */ _proto._canBatch = function _canBatch(elementA, elementB) {
        return BatchUtils.canBatchSprite(elementA, elementB);
    };
    /**
   * @internal
   */ _proto._batch = function _batch(elementA, elementB) {
        BatchUtils.batchFor2D(elementA, elementB);
    };
    /**
   * @internal
   */ _proto._getChunkManager = function _getChunkManager() {
        return this.engine._batcherManager.primitiveChunkManager2D;
    };
    _proto._updateBounds = function _updateBounds(worldBounds) {
        var sprite = this._sprite;
        if (sprite) {
            this._assembler.updatePositions(this, this._transformEntity.transform.worldMatrix, this.width, this.height, sprite.pivot, this._flipX, this._flipY);
        } else {
            var worldPosition = this._transformEntity.transform.worldPosition;
            worldBounds.min.copyFrom(worldPosition);
            worldBounds.max.copyFrom(worldPosition);
        }
    };
    _proto._render = function _render(context) {
        var _this = this, sprite = _this._sprite;
        if (!(sprite == null ? void 0 : sprite.texture) || !this.width || !this.height) {
            return;
        }
        var material = this.getMaterial();
        if (!material) {
            return;
        }
        // @todo: This question needs to be raised rather than hidden.
        if (material.destroyed) {
            material = this._engine._basicResources.spriteDefaultMaterial;
        }
        // Update position
        if (this._dirtyUpdateFlag & RendererUpdateFlags.WorldVolume) {
            this._assembler.updatePositions(this, this._transformEntity.transform.worldMatrix, this.width, this.height, sprite.pivot, this._flipX, this._flipY);
            this._dirtyUpdateFlag &= ~RendererUpdateFlags.WorldVolume;
        }
        // Update uv
        if (this._dirtyUpdateFlag & 2) {
            this._assembler.updateUVs(this);
            this._dirtyUpdateFlag &= -3;
        }
        // Update color
        if (this._dirtyUpdateFlag & 4) {
            this._assembler.updateColor(this, 1);
            this._dirtyUpdateFlag &= -5;
        }
        // Push primitive
        var camera = context.camera;
        var engine = camera.engine;
        var renderElement = engine._renderElementPool.get();
        renderElement.set(this.priority, this._distanceForSort);
        var subRenderElement = engine._subRenderElementPool.get();
        var subChunk = this._subChunk;
        subRenderElement.set(this, material, subChunk.chunk.primitive, subChunk.subMesh, this.sprite.texture, subChunk);
        renderElement.addSubRenderElement(subRenderElement);
        camera._renderPipeline.pushRenderElement(context, renderElement);
    };
    _proto._onDestroy = function _onDestroy() {
        var sprite = this._sprite;
        if (sprite) {
            this._addResourceReferCount(sprite, -1);
            sprite._updateFlagManager.removeListener(this._onSpriteChange);
        }
        Renderer.prototype._onDestroy.call(this);
        this._sprite = null;
        this._assembler = null;
        if (this._subChunk) {
            this._getChunkManager().freeSubChunk(this._subChunk);
            this._subChunk = null;
        }
    };
    _proto._calDefaultSize = function _calDefaultSize() {
        var sprite = this._sprite;
        if (sprite) {
            this._automaticWidth = sprite.width;
            this._automaticHeight = sprite.height;
        } else {
            this._automaticWidth = this._automaticHeight = 0;
        }
        this._dirtyUpdateFlag &= -9;
    };
    _proto._onSpriteChange = function _onSpriteChange(type) {
        switch(type){
            case SpriteModifyFlags.texture:
                this.shaderData.setTexture(SpriteRenderer._textureProperty, this.sprite.texture);
                break;
            case SpriteModifyFlags.size:
                this._dirtyUpdateFlag |= 8;
                if (this._customWidth === undefined || this._customHeight === undefined) {
                    this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
                }
                switch(this._drawMode){
                    case SpriteDrawMode.Simple:
                        // When the width and height of `SpriteRenderer` are `undefined`,
                        // the `size` of `Sprite` will affect the position of `SpriteRenderer`.
                        if (this._customWidth === undefined || this._customHeight === undefined) {
                            this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
                        }
                        break;
                    case SpriteDrawMode.Sliced:
                        this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
                        break;
                    case SpriteDrawMode.Tiled:
                        this._dirtyUpdateFlag |= 7;
                        break;
                }
                break;
            case SpriteModifyFlags.border:
                switch(this._drawMode){
                    case SpriteDrawMode.Sliced:
                        this._dirtyUpdateFlag |= 3;
                        break;
                    case SpriteDrawMode.Tiled:
                        this._dirtyUpdateFlag |= 7;
                        break;
                }
                break;
            case SpriteModifyFlags.region:
            case SpriteModifyFlags.atlasRegionOffset:
                this._dirtyUpdateFlag |= 3;
                break;
            case SpriteModifyFlags.atlasRegion:
                this._dirtyUpdateFlag |= 2;
                break;
            case SpriteModifyFlags.pivot:
                this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
                break;
            case SpriteModifyFlags.destroy:
                this.sprite = null;
                break;
        }
    };
    _proto._onColorChanged = function _onColorChanged() {
        this._dirtyUpdateFlag |= 4;
    };
    _create_class$2(SpriteRenderer, [
        {
            key: "drawMode",
            get: /**
   * The draw mode of the sprite renderer.
   */ function get() {
                return this._drawMode;
            },
            set: function set(value) {
                if (this._drawMode !== value) {
                    this._drawMode = value;
                    switch(value){
                        case SpriteDrawMode.Simple:
                            this._assembler = SimpleSpriteAssembler;
                            break;
                        case SpriteDrawMode.Sliced:
                            this._assembler = SlicedSpriteAssembler;
                            break;
                        case SpriteDrawMode.Tiled:
                            this._assembler = TiledSpriteAssembler;
                            break;
                    }
                    this._assembler.resetData(this);
                    this._dirtyUpdateFlag |= 7;
                }
            }
        },
        {
            key: "tileMode",
            get: /**
   * The tiling mode of the sprite renderer. (Only works in tiled mode.)
   */ function get() {
                return this._tileMode;
            },
            set: function set(value) {
                if (this._tileMode !== value) {
                    this._tileMode = value;
                    if (this.drawMode === SpriteDrawMode.Tiled) {
                        this._dirtyUpdateFlag |= 7;
                    }
                }
            }
        },
        {
            key: "tiledAdaptiveThreshold",
            get: /**
   * Stretch Threshold in Tile Adaptive Mode, specified in normalized. (Only works in tiled adaptive mode.)
   */ function get() {
                return this._tiledAdaptiveThreshold;
            },
            set: function set(value) {
                if (value !== this._tiledAdaptiveThreshold) {
                    value = MathUtil.clamp(value, 0, 1);
                    this._tiledAdaptiveThreshold = value;
                    if (this.drawMode === SpriteDrawMode.Tiled) {
                        this._dirtyUpdateFlag |= 7;
                    }
                }
            }
        },
        {
            key: "sprite",
            get: /**
   * The Sprite to render.
   */ function get() {
                return this._sprite;
            },
            set: function set(value) {
                var lastSprite = this._sprite;
                if (lastSprite !== value) {
                    if (lastSprite) {
                        this._addResourceReferCount(lastSprite, -1);
                        lastSprite._updateFlagManager.removeListener(this._onSpriteChange);
                    }
                    this._dirtyUpdateFlag |= 15;
                    if (value) {
                        this._addResourceReferCount(value, 1);
                        value._updateFlagManager.addListener(this._onSpriteChange);
                        this.shaderData.setTexture(SpriteRenderer._textureProperty, value.texture);
                    } else {
                        this.shaderData.setTexture(SpriteRenderer._textureProperty, null);
                    }
                    this._sprite = value;
                }
            }
        },
        {
            key: "color",
            get: /**
   * Rendering color for the Sprite graphic.
   */ function get() {
                return this._color;
            },
            set: function set(value) {
                if (this._color !== value) {
                    this._color.copyFrom(value);
                }
            }
        },
        {
            key: "width",
            get: /**
   * Render width (in world coordinates).
   *
   * @remarks
   * If width is set, return the set value,
   * otherwise return `SpriteRenderer.sprite.width`.
   */ function get() {
                if (this._customWidth !== undefined) {
                    return this._customWidth;
                } else {
                    this._dirtyUpdateFlag & 8 && this._calDefaultSize();
                    return this._automaticWidth;
                }
            },
            set: function set(value) {
                if (this._customWidth !== value) {
                    this._customWidth = value;
                    this._dirtyUpdateFlag |= this._drawMode === SpriteDrawMode.Tiled ? 7 : RendererUpdateFlags.WorldVolume;
                }
            }
        },
        {
            key: "height",
            get: /**
   * Render height (in world coordinates).
   *
   * @remarks
   * If height is set, return the set value,
   * otherwise return `SpriteRenderer.sprite.height`.
   */ function get() {
                if (this._customHeight !== undefined) {
                    return this._customHeight;
                } else {
                    this._dirtyUpdateFlag & 8 && this._calDefaultSize();
                    return this._automaticHeight;
                }
            },
            set: function set(value) {
                if (this._customHeight !== value) {
                    this._customHeight = value;
                    this._dirtyUpdateFlag |= this._drawMode === SpriteDrawMode.Tiled ? 7 : RendererUpdateFlags.WorldVolume;
                }
            }
        },
        {
            key: "flipX",
            get: /**
   * Flips the sprite on the X axis.
   */ function get() {
                return this._flipX;
            },
            set: function set(value) {
                if (this._flipX !== value) {
                    this._flipX = value;
                    this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
                }
            }
        },
        {
            key: "flipY",
            get: /**
   * Flips the sprite on the Y axis.
   */ function get() {
                return this._flipY;
            },
            set: function set(value) {
                if (this._flipY !== value) {
                    this._flipY = value;
                    this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
                }
            }
        },
        {
            key: "maskLayer",
            get: /**
   * The mask layer the sprite renderer belongs to.
   */ function get() {
                return this._maskLayer;
            },
            set: function set(value) {
                this._maskLayer = value;
            }
        },
        {
            key: "maskInteraction",
            get: /**
   * Interacts with the masks.
   */ function get() {
                return this._maskInteraction;
            },
            set: function set(value) {
                if (this._maskInteraction !== value) {
                    this._maskInteraction = value;
                }
            }
        }
    ]);
    return SpriteRenderer;
}(Renderer);
/** @internal */ SpriteRenderer._textureProperty = ShaderProperty.getByName("renderer_SpriteTexture");
__decorate$1([
    ignoreClone
], SpriteRenderer.prototype, "_subChunk", void 0);
__decorate$1([
    ignoreClone
], SpriteRenderer.prototype, "_drawMode", void 0);
__decorate$1([
    ignoreClone
], SpriteRenderer.prototype, "_assembler", void 0);
__decorate$1([
    assignmentClone
], SpriteRenderer.prototype, "_tileMode", void 0);
__decorate$1([
    assignmentClone
], SpriteRenderer.prototype, "_tiledAdaptiveThreshold", void 0);
__decorate$1([
    deepClone
], SpriteRenderer.prototype, "_color", void 0);
__decorate$1([
    ignoreClone
], SpriteRenderer.prototype, "_sprite", void 0);
__decorate$1([
    ignoreClone
], SpriteRenderer.prototype, "_automaticWidth", void 0);
__decorate$1([
    ignoreClone
], SpriteRenderer.prototype, "_automaticHeight", void 0);
__decorate$1([
    assignmentClone
], SpriteRenderer.prototype, "_customWidth", void 0);
__decorate$1([
    assignmentClone
], SpriteRenderer.prototype, "_customHeight", void 0);
__decorate$1([
    assignmentClone
], SpriteRenderer.prototype, "_flipX", void 0);
__decorate$1([
    assignmentClone
], SpriteRenderer.prototype, "_flipY", void 0);
__decorate$1([
    ignoreClone
], SpriteRenderer.prototype, "_onSpriteChange", null);
__decorate$1([
    ignoreClone
], SpriteRenderer.prototype, "_onColorChanged", null);

/**
 * Renders a text for 2D graphics.
 */ var TextRenderer = /*#__PURE__*/ function(Renderer) {
    _inherits$2(TextRenderer, Renderer);
    function TextRenderer(entity) {
        var _this;
        _this = Renderer.call(this, entity) || this, _this._textChunks = Array(), /** @internal */ _this._subFont = null, /** @internal */ _this._dirtyFlag = 15, _this._color = new Color(1, 1, 1, 1), _this._text = "", _this._width = 0, _this._height = 0, _this._localBounds = new BoundingBox(), _this._font = null, _this._fontSize = 24, _this._fontStyle = FontStyle.None, _this._lineSpacing = 0, _this._horizontalAlignment = TextHorizontalAlignment.Center, _this._verticalAlignment = TextVerticalAlignment.Center, _this._enableWrapping = false, _this._overflowMode = OverflowMode.Overflow;
        var engine = _this.engine;
        _this._font = engine._textDefaultFont;
        _this._addResourceReferCount(_this._font, 1);
        _this.setMaterial(engine._basicResources.textDefaultMaterial);
        //@ts-ignore
        _this._color._onValueChanged = _this._onColorChanged.bind(_this);
        return _this;
    }
    var _proto = TextRenderer.prototype;
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        if (this._font) {
            this._addResourceReferCount(this._font, -1);
            this._font = null;
        }
        Renderer.prototype._onDestroy.call(this);
        this._freeTextChunks();
        this._textChunks = null;
        this._subFont && (this._subFont = null);
    };
    /**
   * @internal
   */ _proto._cloneTo = function _cloneTo(target, srcRoot, targetRoot) {
        Renderer.prototype._cloneTo.call(this, target, srcRoot, targetRoot);
        target.font = this._font;
        target._subFont = this._subFont;
    };
    /**
   * @internal
   */ _proto._isContainDirtyFlag = function _isContainDirtyFlag(type) {
        return (this._dirtyFlag & type) != 0;
    };
    /**
   * @internal
   */ _proto._setDirtyFlagTrue = function _setDirtyFlagTrue(type) {
        this._dirtyFlag |= type;
    };
    /**
   * @internal
   */ _proto._setDirtyFlagFalse = function _setDirtyFlagFalse(type) {
        this._dirtyFlag &= ~type;
    };
    /**
   * @internal
   */ _proto._getSubFont = function _getSubFont() {
        if (!this._subFont) {
            this._resetSubFont();
        }
        return this._subFont;
    };
    /**
   * @internal
   */ _proto._updateTransformShaderData = function _updateTransformShaderData(context, onlyMVP, batched) {
        //@todo: Always update world positions to buffer, should opt
        Renderer.prototype._updateTransformShaderData.call(this, context, onlyMVP, true);
    };
    /**
   * @internal
   */ _proto._canBatch = function _canBatch(elementA, elementB) {
        return BatchUtils.canBatchSprite(elementA, elementB);
    };
    /**
   * @internal
   */ _proto._batch = function _batch(elementA, elementB) {
        BatchUtils.batchFor2D(elementA, elementB);
    };
    /**
   * @internal
   */ _proto._getChunkManager = function _getChunkManager() {
        return this.engine._batcherManager.primitiveChunkManager2D;
    };
    _proto._updateBounds = function _updateBounds(worldBounds) {
        BoundingBox.transform(this._localBounds, this._entity.transform.worldMatrix, worldBounds);
    };
    _proto._render = function _render(context) {
        if (this._isTextNoVisible()) {
            return;
        }
        if (this._isContainDirtyFlag(1)) {
            this._resetSubFont();
            this._setDirtyFlagFalse(1);
        }
        if (this._isContainDirtyFlag(2)) {
            this._updateLocalData();
            this._setDirtyFlagFalse(2);
        }
        if (this._isContainDirtyFlag(4)) {
            this._updatePosition();
            this._setDirtyFlagFalse(4);
        }
        if (this._isContainDirtyFlag(16)) {
            this._updateColor();
            this._setDirtyFlagFalse(16);
        }
        var camera = context.camera;
        var engine = camera.engine;
        var textSubRenderElementPool = engine._textSubRenderElementPool;
        var material = this.getMaterial();
        var renderElement = engine._renderElementPool.get();
        renderElement.set(this.priority, this._distanceForSort);
        var textChunks = this._textChunks;
        for(var i = 0, n = textChunks.length; i < n; ++i){
            var _subRenderElement;
            var _textChunks_i = textChunks[i], subChunk = _textChunks_i.subChunk, texture = _textChunks_i.texture;
            var subRenderElement = textSubRenderElementPool.get();
            subRenderElement.set(this, material, subChunk.chunk.primitive, subChunk.subMesh, texture, subChunk);
            (_subRenderElement = subRenderElement).shaderData || (_subRenderElement.shaderData = new ShaderData(ShaderDataGroup.RenderElement));
            subRenderElement.shaderData.setTexture(TextRenderer._textureProperty, texture);
            renderElement.addSubRenderElement(subRenderElement);
        }
        camera._renderPipeline.pushRenderElement(context, renderElement);
    };
    _proto._resetSubFont = function _resetSubFont() {
        var font = this._font;
        this._subFont = font._getSubFont(this.fontSize, this.fontStyle);
        this._subFont.nativeFontString = TextUtils.getNativeFontString(font.name, this.fontSize, this.fontStyle);
    };
    _proto._updatePosition = function _updatePosition() {
        var transform = this.entity.transform;
        var e = transform.worldMatrix.elements;
        // prettier-ignore
        var e0 = e[0], e1 = e[1], e2 = e[2], e4 = e[4], e5 = e[5], e6 = e[6], e12 = e[12], e13 = e[13], e14 = e[14];
        var up = TextRenderer._tempVec31.set(e4, e5, e6);
        var right = TextRenderer._tempVec30.set(e0, e1, e2);
        var worldPositions = TextRenderer._worldPositions;
        var worldPosition0 = worldPositions[0];
        var worldPosition1 = worldPositions[1];
        var worldPosition2 = worldPositions[2];
        var worldPosition3 = worldPositions[3];
        var textChunks = this._textChunks;
        for(var i = 0, n = textChunks.length; i < n; ++i){
            var _textChunks_i = textChunks[i], subChunk = _textChunks_i.subChunk, charRenderInfos = _textChunks_i.charRenderInfos;
            for(var j = 0, m = charRenderInfos.length; j < m; ++j){
                var charRenderInfo = charRenderInfos[j];
                var localPositions = charRenderInfo.localPositions;
                var topLeftX = localPositions.x, topLeftY = localPositions.y;
                // Top-Left
                worldPosition0.set(topLeftX * e0 + topLeftY * e4 + e12, topLeftX * e1 + topLeftY * e5 + e13, topLeftX * e2 + topLeftY * e6 + e14);
                // Right offset
                Vector3.scale(right, localPositions.z - topLeftX, worldPosition1);
                // Top-Right
                Vector3.add(worldPosition0, worldPosition1, worldPosition1);
                // Up offset
                Vector3.scale(up, localPositions.w - topLeftY, worldPosition2);
                // Bottom-Left
                Vector3.add(worldPosition0, worldPosition2, worldPosition3);
                // Bottom-Right
                Vector3.add(worldPosition1, worldPosition2, worldPosition2);
                var vertices = subChunk.chunk.vertices;
                for(var k = 0, o = subChunk.vertexArea.start + charRenderInfo.indexInChunk * 36; k < 4; ++k, o += 9){
                    worldPositions[k].copyToArray(vertices, o);
                }
            }
        }
    };
    _proto._updateColor = function _updateColor() {
        var _this__color = this._color, r = _this__color.r, g = _this__color.g, b = _this__color.b, a = _this__color.a;
        var textChunks = this._textChunks;
        for(var i = 0, n = textChunks.length; i < n; ++i){
            var subChunk = textChunks[i].subChunk;
            var vertexArea = subChunk.vertexArea;
            var vertexCount = vertexArea.size / 9;
            var vertices = subChunk.chunk.vertices;
            for(var j = 0, o = vertexArea.start + 5; j < vertexCount; ++j, o += 9){
                vertices[o] = r;
                vertices[o + 1] = g;
                vertices[o + 2] = b;
                vertices[o + 3] = a;
            }
        }
    };
    _proto._updateLocalData = function _updateLocalData() {
        var _pixelsPerUnit = Engine._pixelsPerUnit;
        var _this__localBounds = this._localBounds, min = _this__localBounds.min, max = _this__localBounds.max;
        var charRenderInfos = TextRenderer._charRenderInfos;
        var charFont = this._getSubFont();
        var textMetrics = this.enableWrapping ? TextUtils.measureTextWithWrap(this, this.width * _pixelsPerUnit, this.height * _pixelsPerUnit, this._lineSpacing * _pixelsPerUnit) : TextUtils.measureTextWithoutWrap(this, this.height * _pixelsPerUnit, this._lineSpacing * _pixelsPerUnit);
        var height = textMetrics.height, lines = textMetrics.lines, lineWidths = textMetrics.lineWidths, lineHeight = textMetrics.lineHeight, lineMaxSizes = textMetrics.lineMaxSizes;
        var charRenderInfoPool = this.engine._charRenderInfoPool;
        var linesLen = lines.length;
        var renderElementCount = 0;
        if (linesLen > 0) {
            var horizontalAlignment = this.horizontalAlignment;
            var pixelsPerUnitReciprocal = 1.0 / _pixelsPerUnit;
            var rendererWidth = this.width * _pixelsPerUnit;
            var halfRendererWidth = rendererWidth * 0.5;
            var rendererHeight = this.height * _pixelsPerUnit;
            var halfLineHeight = lineHeight * 0.5;
            var startY = 0;
            var topDiff = lineHeight * 0.5 - lineMaxSizes[0].ascent;
            var bottomDiff = lineHeight * 0.5 - lineMaxSizes[linesLen - 1].descent - 1;
            switch(this.verticalAlignment){
                case TextVerticalAlignment.Top:
                    startY = rendererHeight * 0.5 - halfLineHeight + topDiff;
                    break;
                case TextVerticalAlignment.Center:
                    startY = height * 0.5 - halfLineHeight - (bottomDiff - topDiff) * 0.5;
                    break;
                case TextVerticalAlignment.Bottom:
                    startY = height - rendererHeight * 0.5 - halfLineHeight - bottomDiff;
                    break;
            }
            var firstLine = -1;
            var minX = Number.MAX_SAFE_INTEGER;
            var minY = Number.MAX_SAFE_INTEGER;
            var maxX = Number.MIN_SAFE_INTEGER;
            var maxY = Number.MIN_SAFE_INTEGER;
            for(var i = 0; i < linesLen; ++i){
                var lineWidth = lineWidths[i];
                if (lineWidth > 0) {
                    var line = lines[i];
                    var startX = 0;
                    var firstRow = -1;
                    if (firstLine < 0) {
                        firstLine = i;
                    }
                    switch(horizontalAlignment){
                        case TextHorizontalAlignment.Left:
                            startX = -halfRendererWidth;
                            break;
                        case TextHorizontalAlignment.Center:
                            startX = -lineWidth * 0.5;
                            break;
                        case TextHorizontalAlignment.Right:
                            startX = halfRendererWidth - lineWidth;
                            break;
                    }
                    for(var j = 0, n = line.length; j < n; ++j){
                        var char = line[j];
                        var charInfo = charFont._getCharInfo(char);
                        if (charInfo.h > 0) {
                            firstRow < 0 && (firstRow = j);
                            var charRenderInfo = charRenderInfos[renderElementCount++] = charRenderInfoPool.get();
                            var localPositions = charRenderInfo.localPositions;
                            charRenderInfo.texture = charFont._getTextureByIndex(charInfo.index);
                            charRenderInfo.uvs = charInfo.uvs;
                            var w = charInfo.w, ascent = charInfo.ascent, descent = charInfo.descent;
                            var left = startX * pixelsPerUnitReciprocal;
                            var right = (startX + w) * pixelsPerUnitReciprocal;
                            var top = (startY + ascent) * pixelsPerUnitReciprocal;
                            var bottom = (startY - descent) * pixelsPerUnitReciprocal;
                            localPositions.set(left, top, right, bottom);
                            i === firstLine && (maxY = Math.max(maxY, top));
                            minY = Math.min(minY, bottom);
                            j === firstRow && (minX = Math.min(minX, left));
                            maxX = Math.max(maxX, right);
                        }
                        startX += charInfo.xAdvance + charInfo.offsetX;
                    }
                }
                startY -= lineHeight;
            }
            if (firstLine < 0) {
                min.set(0, 0, 0);
                max.set(0, 0, 0);
            } else {
                min.set(minX, minY, 0);
                max.set(maxX, maxY, 0);
            }
        } else {
            min.set(0, 0, 0);
            max.set(0, 0, 0);
        }
        charFont._getLastIndex() > 0 && charRenderInfos.sort(function(a, b) {
            return a.texture.instanceId - b.texture.instanceId;
        });
        this._freeTextChunks();
        if (renderElementCount === 0) {
            return;
        }
        var textChunks = this._textChunks;
        var curTextChunk = new TextChunk();
        textChunks.push(curTextChunk);
        var chunkMaxVertexCount = this._getChunkManager().maxVertexCount;
        var curCharRenderInfo = charRenderInfos[0];
        var curTexture = curCharRenderInfo.texture;
        curTextChunk.texture = curTexture;
        var curCharInfos = curTextChunk.charRenderInfos;
        curCharInfos.push(curCharRenderInfo);
        for(var i1 = 1; i1 < renderElementCount; ++i1){
            var charRenderInfo1 = charRenderInfos[i1];
            var texture = charRenderInfo1.texture;
            if (curTexture !== texture || curCharInfos.length * 4 + 4 > chunkMaxVertexCount) {
                this._buildChunk(curTextChunk, curCharInfos.length);
                curTextChunk = new TextChunk();
                textChunks.push(curTextChunk);
                curTexture = texture;
                curTextChunk.texture = texture;
                curCharInfos = curTextChunk.charRenderInfos;
            }
            curCharInfos.push(charRenderInfo1);
        }
        var charLength = curCharInfos.length;
        if (charLength > 0) {
            this._buildChunk(curTextChunk, charLength);
        }
        charRenderInfos.length = 0;
    };
    _proto._onTransformChanged = function _onTransformChanged(bit) {
        Renderer.prototype._onTransformChanged.call(this, bit);
        this._setDirtyFlagTrue(4 | 8);
    };
    _proto._isTextNoVisible = function _isTextNoVisible() {
        return this._text === "" || this._fontSize === 0 || this.enableWrapping && this.width <= 0 || this.overflowMode === OverflowMode.Truncate && this.height <= 0;
    };
    _proto._buildChunk = function _buildChunk(textChunk, count) {
        var _this_color = this.color, r = _this_color.r, g = _this_color.g, b = _this_color.b, a = _this_color.a;
        var tempIndices = CharRenderInfo.triangles;
        var tempIndicesLength = tempIndices.length;
        var subChunk = textChunk.subChunk = this._getChunkManager().allocateSubChunk(count * 4);
        var vertices = subChunk.chunk.vertices;
        var indices = subChunk.indices = [];
        var charRenderInfos = textChunk.charRenderInfos;
        for(var i = 0, ii = 0, io = 0, vo = subChunk.vertexArea.start + 3; i < count; ++i, io += 4){
            var charRenderInfo = charRenderInfos[i];
            charRenderInfo.indexInChunk = i;
            // Set indices
            for(var j = 0; j < tempIndicesLength; ++j){
                indices[ii++] = tempIndices[j] + io;
            }
            // Set uv and color for vertices
            for(var j1 = 0; j1 < 4; ++j1, vo += 9){
                var uv = charRenderInfo.uvs[j1];
                uv.copyToArray(vertices, vo);
                vertices[vo + 2] = r;
                vertices[vo + 3] = g;
                vertices[vo + 4] = b;
                vertices[vo + 5] = a;
            }
        }
        return subChunk;
    };
    _proto._freeTextChunks = function _freeTextChunks() {
        var textChunks = this._textChunks;
        var charRenderInfoPool = this.engine._charRenderInfoPool;
        var manager = this._getChunkManager();
        for(var i = 0, n = textChunks.length; i < n; ++i){
            var textChunk = textChunks[i];
            var charRenderInfos = textChunk.charRenderInfos;
            for(var j = 0, m = charRenderInfos.length; j < m; ++j){
                charRenderInfoPool.return(charRenderInfos[j]);
            }
            charRenderInfos.length = 0;
            manager.freeSubChunk(textChunk.subChunk);
            textChunk.subChunk = null;
            textChunk.texture = null;
        }
        textChunks.length = 0;
    };
    _proto._onColorChanged = function _onColorChanged() {
        this._setDirtyFlagTrue(16);
    };
    _create_class$2(TextRenderer, [
        {
            key: "color",
            get: /**
   * Rendering color for the Text.
   */ function get() {
                return this._color;
            },
            set: function set(value) {
                if (this._color !== value) {
                    this._color.copyFrom(value);
                }
            }
        },
        {
            key: "text",
            get: /**
   * Rendering string for the Text.
   */ function get() {
                return this._text;
            },
            set: function set(value) {
                value = value || "";
                if (this._text !== value) {
                    this._text = value;
                    this._setDirtyFlagTrue(14);
                }
            }
        },
        {
            key: "width",
            get: /**
   * The width of the TextRenderer (in 3D world coordinates).
   */ function get() {
                return this._width;
            },
            set: function set(value) {
                if (this._width !== value) {
                    this._width = value;
                    this._setDirtyFlagTrue(14);
                }
            }
        },
        {
            key: "height",
            get: /**
   * The height of the TextRenderer (in 3D world coordinates).
   */ function get() {
                return this._height;
            },
            set: function set(value) {
                if (this._height !== value) {
                    this._height = value;
                    this._setDirtyFlagTrue(14);
                }
            }
        },
        {
            key: "font",
            get: /**
   * The font of the Text.
   */ function get() {
                return this._font;
            },
            set: function set(value) {
                var lastFont = this._font;
                if (lastFont !== value) {
                    lastFont && this._addResourceReferCount(lastFont, -1);
                    value && this._addResourceReferCount(value, 1);
                    this._font = value;
                    this._setDirtyFlagTrue(15);
                }
            }
        },
        {
            key: "fontSize",
            get: /**
   * The font size of the Text.
   */ function get() {
                return this._fontSize;
            },
            set: function set(value) {
                if (this._fontSize !== value) {
                    this._fontSize = value;
                    this._setDirtyFlagTrue(15);
                }
            }
        },
        {
            key: "fontStyle",
            get: /**
   * The style of the font.
   */ function get() {
                return this._fontStyle;
            },
            set: function set(value) {
                if (this.fontStyle !== value) {
                    this._fontStyle = value;
                    this._setDirtyFlagTrue(15);
                }
            }
        },
        {
            key: "lineSpacing",
            get: /**
   * The space between two lines (in pixels).
   */ function get() {
                return this._lineSpacing;
            },
            set: function set(value) {
                if (this._lineSpacing !== value) {
                    this._lineSpacing = value;
                    this._setDirtyFlagTrue(14);
                }
            }
        },
        {
            key: "horizontalAlignment",
            get: /**
   * The horizontal alignment.
   */ function get() {
                return this._horizontalAlignment;
            },
            set: function set(value) {
                if (this._horizontalAlignment !== value) {
                    this._horizontalAlignment = value;
                    this._setDirtyFlagTrue(14);
                }
            }
        },
        {
            key: "verticalAlignment",
            get: /**
   * The vertical alignment.
   */ function get() {
                return this._verticalAlignment;
            },
            set: function set(value) {
                if (this._verticalAlignment !== value) {
                    this._verticalAlignment = value;
                    this._setDirtyFlagTrue(14);
                }
            }
        },
        {
            key: "enableWrapping",
            get: /**
   * Whether wrap text to next line when exceeds the width of the container.
   */ function get() {
                return this._enableWrapping;
            },
            set: function set(value) {
                if (this._enableWrapping !== value) {
                    this._enableWrapping = value;
                    this._setDirtyFlagTrue(14);
                }
            }
        },
        {
            key: "overflowMode",
            get: /**
   * The overflow mode.
   */ function get() {
                return this._overflowMode;
            },
            set: function set(value) {
                if (this._overflowMode !== value) {
                    this._overflowMode = value;
                    this._setDirtyFlagTrue(14);
                }
            }
        },
        {
            key: "maskInteraction",
            get: /**
   * Interacts with the masks.
   */ function get() {
                return this._maskInteraction;
            },
            set: function set(value) {
                if (this._maskInteraction !== value) {
                    this._maskInteraction = value;
                }
            }
        },
        {
            key: "maskLayer",
            get: /**
   * The mask layer the sprite renderer belongs to.
   */ function get() {
                return this._maskLayer;
            },
            set: function set(value) {
                this._maskLayer = value;
            }
        },
        {
            key: "bounds",
            get: /**
   * The bounding volume of the TextRenderer.
   */ function get() {
                if (this._isTextNoVisible()) {
                    if (this._isContainDirtyFlag(8)) {
                        var localBounds = this._localBounds;
                        localBounds.min.set(0, 0, 0);
                        localBounds.max.set(0, 0, 0);
                        this._updateBounds(this._bounds);
                        this._setDirtyFlagFalse(8);
                    }
                    return this._bounds;
                }
                this._isContainDirtyFlag(1) && this._resetSubFont();
                this._isContainDirtyFlag(2) && this._updateLocalData();
                this._isContainDirtyFlag(4) && this._updatePosition();
                this._isContainDirtyFlag(8) && this._updateBounds(this._bounds);
                this._setDirtyFlagFalse(15);
                return this._bounds;
            }
        }
    ]);
    return TextRenderer;
}(Renderer);
TextRenderer._textureProperty = ShaderProperty.getByName("renderElement_TextTexture");
TextRenderer._tempVec30 = new Vector3();
TextRenderer._tempVec31 = new Vector3();
TextRenderer._worldPositions = [
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3()
];
TextRenderer._charRenderInfos = [];
__decorate$1([
    ignoreClone
], TextRenderer.prototype, "_textChunks", void 0);
__decorate$1([
    assignmentClone
], TextRenderer.prototype, "_subFont", void 0);
__decorate$1([
    ignoreClone
], TextRenderer.prototype, "_dirtyFlag", void 0);
__decorate$1([
    deepClone
], TextRenderer.prototype, "_color", void 0);
__decorate$1([
    assignmentClone
], TextRenderer.prototype, "_text", void 0);
__decorate$1([
    assignmentClone
], TextRenderer.prototype, "_width", void 0);
__decorate$1([
    assignmentClone
], TextRenderer.prototype, "_height", void 0);
__decorate$1([
    ignoreClone
], TextRenderer.prototype, "_localBounds", void 0);
__decorate$1([
    assignmentClone
], TextRenderer.prototype, "_font", void 0);
__decorate$1([
    assignmentClone
], TextRenderer.prototype, "_fontSize", void 0);
__decorate$1([
    assignmentClone
], TextRenderer.prototype, "_fontStyle", void 0);
__decorate$1([
    assignmentClone
], TextRenderer.prototype, "_lineSpacing", void 0);
__decorate$1([
    assignmentClone
], TextRenderer.prototype, "_horizontalAlignment", void 0);
__decorate$1([
    assignmentClone
], TextRenderer.prototype, "_verticalAlignment", void 0);
__decorate$1([
    assignmentClone
], TextRenderer.prototype, "_enableWrapping", void 0);
__decorate$1([
    assignmentClone
], TextRenderer.prototype, "_overflowMode", void 0);
__decorate$1([
    ignoreClone
], TextRenderer.prototype, "_onTransformChanged", null);
__decorate$1([
    ignoreClone
], TextRenderer.prototype, "_onColorChanged", null);
var TextChunk = function TextChunk() {
    this.charRenderInfos = new Array();
};

/**
 * Buffer usage.
 */ var BufferUsage = /*#__PURE__*/ function(BufferUsage) {
    /** The buffer content are intended to be specified once, and used many times */ BufferUsage[BufferUsage["Static"] = 0] = "Static";
    /** The buffer contents are intended to be respecified repeatedly, and used many times */ BufferUsage[BufferUsage["Dynamic"] = 1] = "Dynamic";
    /** The buffer contents are intended to be specified once, and used at most a few times */ BufferUsage[BufferUsage["Stream"] = 2] = "Stream";
    return BufferUsage;
}({});

/**
 * Define update strategy when call bufferData/bufferSubData func.
 */ var SetDataOptions = /*#__PURE__*/ function(SetDataOptions) {
    /** Can overwrite part of used buffer data and ensure correct rendering */ SetDataOptions[SetDataOptions["None"] = 0] = "None";
    /** Discard old buffer and create a new buffer, and won't affect the previous rendering */ SetDataOptions[SetDataOptions["Discard"] = 1] = "Discard";
    return SetDataOptions;
}({});

/**
 * Buffer.
 */ var Buffer = /*#__PURE__*/ function(GraphicsResource) {
    _inherits$2(Buffer, GraphicsResource);
    function Buffer(engine, type, byteLengthOrData, bufferUsage, readable) {
        if (bufferUsage === void 0) bufferUsage = BufferUsage.Static;
        if (readable === void 0) readable = false;
        var _this;
        _this = GraphicsResource.call(this, engine) || this, /** @internal */ _this._dataUpdateManager = new UpdateFlagManager();
        _this._engine = engine;
        _this._type = type;
        _this._bufferUsage = bufferUsage;
        _this._readable = readable;
        if (typeof byteLengthOrData === "number") {
            _this._byteLength = byteLengthOrData;
            _this._platformBuffer = engine._hardwareRenderer.createPlatformBuffer(type, byteLengthOrData, bufferUsage);
            if (readable) {
                _this._data = new Uint8Array(byteLengthOrData);
            }
        } else {
            var data = byteLengthOrData;
            var byteLength = data.byteLength;
            _this._byteLength = byteLength;
            _this._platformBuffer = engine._hardwareRenderer.createPlatformBuffer(type, byteLength, bufferUsage, data);
            if (readable) {
                var buffer = data.constructor === ArrayBuffer ? data.slice(0) : data.buffer.slice(data.byteOffset, data.byteOffset + byteLength);
                _this._data = new Uint8Array(buffer);
            }
        }
        return _this;
    }
    var _proto = Buffer.prototype;
    /**
   * Bind buffer.
   */ _proto.bind = function bind() {
        this._platformBuffer.bind();
    };
    _proto.setData = function setData(data, bufferByteOffset, dataOffset, dataLength, options) {
        if (bufferByteOffset === void 0) bufferByteOffset = 0;
        if (dataOffset === void 0) dataOffset = 0;
        if (options === void 0) options = SetDataOptions.None;
        this._platformBuffer.setData(this._byteLength, data, bufferByteOffset, dataOffset, dataLength, options);
        if (this._readable) {
            var arrayBuffer = data.constructor === ArrayBuffer ? data : data.buffer;
            if (this._data.buffer !== arrayBuffer) {
                var byteSize = data.BYTES_PER_ELEMENT || 1; // TypeArray is BYTES_PER_ELEMENT, unTypeArray is 1
                var dataByteLength = dataLength ? byteSize * dataLength : data.byteLength;
                var isArrayBufferView = data.byteOffset !== undefined;
                var byteOffset = isArrayBufferView ? data.byteOffset + dataOffset * byteSize : dataOffset;
                var srcData = new Uint8Array(arrayBuffer, byteOffset, dataByteLength);
                this._data.set(srcData, bufferByteOffset);
            }
        }
        this._isContentLost = false;
        this._dataUpdateManager.dispatch();
    };
    _proto.getData = function getData(data, bufferByteOffset, dataOffset, dataLength) {
        if (bufferByteOffset === void 0) bufferByteOffset = 0;
        if (dataOffset === void 0) dataOffset = 0;
        this._platformBuffer.getData(data, bufferByteOffset, dataOffset, dataLength);
    };
    /**
   * Mark buffer as readable, the `data` property will be not accessible anymore.
   */ _proto.markAsUnreadable = function markAsUnreadable() {
        this._data = null;
        this._readable = false;
    };
    _proto._rebuild = function _rebuild() {
        var platformBuffer = this._engine._hardwareRenderer.createPlatformBuffer(this._type, this._byteLength, this._bufferUsage);
        this._platformBuffer = platformBuffer;
    };
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        GraphicsResource.prototype._onDestroy.call(this);
        this._platformBuffer.destroy();
    };
    _create_class$2(Buffer, [
        {
            key: "type",
            get: /**
   * Buffer binding flag.
   */ function get() {
                return this._type;
            }
        },
        {
            key: "byteLength",
            get: /**
   * Byte length.
   */ function get() {
                return this._byteLength;
            }
        },
        {
            key: "bufferUsage",
            get: /**
   * Buffer usage.
   */ function get() {
                return this._bufferUsage;
            }
        },
        {
            key: "readable",
            get: /**
   * If buffer is readable.
   */ function get() {
                return this._readable;
            }
        },
        {
            key: "data",
            get: /**
   * Buffer data cache.
   *
   * @remarks
   * Buffer must be readable.
   * If the data you get is modified, must call `setData()` to update buffer to GPU.
   */ function get() {
                if (this._readable) {
                    return this._data;
                } else {
                    throw "Buffer is not readable.";
                }
            }
        }
    ]);
    return Buffer;
}(GraphicsResource);

/**
 * Index format.
 */ var IndexFormat = /*#__PURE__*/ function(IndexFormat) {
    /** 8 bit */ IndexFormat[IndexFormat["UInt8"] = 0] = "UInt8";
    /** 16 bit */ IndexFormat[IndexFormat["UInt16"] = 1] = "UInt16";
    /** 32 bit */ IndexFormat[IndexFormat["UInt32"] = 2] = "UInt32";
    return IndexFormat;
}({});

/**
 * Vertex element format.
 */ var VertexElementFormat = /*#__PURE__*/ function(VertexElementFormat) {
    /** 32-bit float */ VertexElementFormat[VertexElementFormat["Float"] = 0] = "Float";
    /** Two-dimensional 32-bit float */ VertexElementFormat[VertexElementFormat["Vector2"] = 1] = "Vector2";
    /** Three-dimensional 32-bit float */ VertexElementFormat[VertexElementFormat["Vector3"] = 2] = "Vector3";
    /** Four-dimensional 32-bit float */ VertexElementFormat[VertexElementFormat["Vector4"] = 3] = "Vector4";
    /** Four-dimensional 8-bit integer,range is [-128,127] */ VertexElementFormat[VertexElementFormat["Byte4"] = 4] = "Byte4";
    /** Four-dimensional 8-bit Unsigned integer, range is [0,255] */ VertexElementFormat[VertexElementFormat["UByte4"] = 5] = "UByte4";
    /** Four-dimensional 8-bit Normalized integer, range is [-1,1] */ VertexElementFormat[VertexElementFormat["NormalizedByte4"] = 6] = "NormalizedByte4";
    /** Four-dimensional 8-bit Normalized unsigned integer, range is [0,1] */ VertexElementFormat[VertexElementFormat["NormalizedUByte4"] = 7] = "NormalizedUByte4";
    /** Two-dimensional 16-bit integer, range is[-32768, 32767] */ VertexElementFormat[VertexElementFormat["Short2"] = 8] = "Short2";
    /** Two-dimensional 16-bit Unsigned integer, range is [0, 65535] */ VertexElementFormat[VertexElementFormat["UShort2"] = 9] = "UShort2";
    /** Two-dimensional 16-bit Unsigned integer, range is [-1, 1] */ VertexElementFormat[VertexElementFormat["NormalizedShort2"] = 10] = "NormalizedShort2";
    /** Two-dimensional 16-bit Normalized unsigned integer, range is [0, 1] */ VertexElementFormat[VertexElementFormat["NormalizedUShort2"] = 11] = "NormalizedUShort2";
    /** Four-dimensional 16-bit integer, range is [-32768, 32767] */ VertexElementFormat[VertexElementFormat["Short4"] = 12] = "Short4";
    /** Four-dimensional 16-bit Unsigned integer, range is [0, 65535] */ VertexElementFormat[VertexElementFormat["UShort4"] = 13] = "UShort4";
    /** Four-dimensional 16-bit Normalized integer, range is[-1, 1] */ VertexElementFormat[VertexElementFormat["NormalizedShort4"] = 14] = "NormalizedShort4";
    /** Four-dimensional 16-bit Normalized unsigned integer, range is [0, 1] */ VertexElementFormat[VertexElementFormat["NormalizedUShort4"] = 15] = "NormalizedUShort4";
    return VertexElementFormat;
}({});

var BufferUtil = /*#__PURE__*/ function() {
    function BufferUtil() {}
    BufferUtil._getGLIndexType = function _getGLIndexType(indexFormat) {
        switch(indexFormat){
            case IndexFormat.UInt8:
                return DataType.UNSIGNED_BYTE;
            case IndexFormat.UInt16:
                return DataType.UNSIGNED_SHORT;
            case IndexFormat.UInt32:
                return DataType.UNSIGNED_INT;
        }
    };
    BufferUtil._getGLIndexByteCount = function _getGLIndexByteCount(indexFormat) {
        switch(indexFormat){
            case IndexFormat.UInt8:
                return 1;
            case IndexFormat.UInt16:
                return 2;
            case IndexFormat.UInt32:
                return 4;
        }
    };
    /**
   * @internal
   */ BufferUtil._getElementInfo = function _getElementInfo(format) {
        var size;
        var type;
        var normalized = false;
        var normalizedScaleFactor;
        switch(format){
            case VertexElementFormat.Float:
                size = 1;
                type = DataType.FLOAT;
                break;
            case VertexElementFormat.Vector2:
                size = 2;
                type = DataType.FLOAT;
                break;
            case VertexElementFormat.Vector3:
                size = 3;
                type = DataType.FLOAT;
                break;
            case VertexElementFormat.Vector4:
                size = 4;
                type = DataType.FLOAT;
                break;
            case VertexElementFormat.Byte4:
                size = 4;
                type = DataType.BYTE;
                break;
            case VertexElementFormat.UByte4:
                size = 4;
                type = DataType.UNSIGNED_BYTE;
                break;
            case VertexElementFormat.NormalizedByte4:
                size = 4;
                type = DataType.BYTE;
                normalized = true;
                normalizedScaleFactor = 1 / 127;
                break;
            case VertexElementFormat.NormalizedUByte4:
                size = 4;
                type = DataType.UNSIGNED_BYTE;
                normalized = true;
                normalizedScaleFactor = 1 / 255;
                break;
            case VertexElementFormat.Short2:
                size = 2;
                type = DataType.SHORT;
                break;
            case VertexElementFormat.UShort2:
                size = 2;
                type = DataType.UNSIGNED_SHORT;
                break;
            case VertexElementFormat.NormalizedShort2:
                size = 2;
                type = DataType.SHORT;
                normalized = true;
                normalizedScaleFactor = 1 / 32767;
                break;
            case VertexElementFormat.NormalizedUShort2:
                size = 2;
                type = DataType.UNSIGNED_SHORT;
                normalized = true;
                normalizedScaleFactor = 1 / 65535;
                break;
            case VertexElementFormat.Short4:
                size = 4;
                type = DataType.SHORT;
                break;
            case VertexElementFormat.UShort4:
                size = 4;
                type = DataType.UNSIGNED_SHORT;
                break;
            case VertexElementFormat.NormalizedShort4:
                size = 4;
                type = DataType.SHORT;
                normalized = true;
                normalizedScaleFactor = 1 / 32767;
                break;
            case VertexElementFormat.NormalizedUShort4:
                size = 4;
                type = DataType.UNSIGNED_SHORT;
                normalized = true;
                normalizedScaleFactor = 1 / 65535;
                break;
        }
        return {
            size: size,
            type: type,
            normalized: normalized,
            normalizedScaleFactor: normalizedScaleFactor
        };
    };
    return BufferUtil;
}();

/**
 * Vertex element.
 */ var VertexElement = /*#__PURE__*/ function() {
    function VertexElement(attribute, offset, format, bindingIndex, instanceStepRate) {
        if (instanceStepRate === void 0) instanceStepRate = 0;
        this._attributeName = attribute;
        this._offset = offset;
        this._format = format;
        this._bindingIndex = bindingIndex;
        this._formatMetaInfo = BufferUtil._getElementInfo(this.format);
        this._instanceStepRate = Math.floor(instanceStepRate);
    }
    _create_class$2(VertexElement, [
        {
            key: "attribute",
            get: /**
   * Vertex attribute.
   */ function get() {
                return this._attributeName;
            }
        },
        {
            key: "offset",
            get: /**
   * Vertex data byte offset.
   */ function get() {
                return this._offset;
            },
            set: function set(value) {
                this._offset = value;
            }
        },
        {
            key: "format",
            get: /**
   * Vertex data format.
   */ function get() {
                return this._format;
            }
        },
        {
            key: "bindingIndex",
            get: /**
   * Vertex buffer binding index.
   */ function get() {
                return this._bindingIndex;
            },
            set: function set(value) {
                this._bindingIndex = value;
            }
        },
        {
            key: "instanceStepRate",
            get: /**
   * Instance cadence, the number of instances drawn for each vertex in the buffer, non-instance elements must be 0.
   */ function get() {
                return this._instanceStepRate;
            }
        },
        {
            key: "semantic",
            get: /**
   * @deprecated use `attributeName` instead
   */ function get() {
                return this.attribute;
            }
        }
    ]);
    return VertexElement;
}();

/**
 * Buffer binding flag.
 */ var BufferBindFlag = /*#__PURE__*/ function(BufferBindFlag) {
    /** Vertex buffer binding flag */ BufferBindFlag[BufferBindFlag["VertexBuffer"] = 0] = "VertexBuffer";
    /** Index buffer binding flag */ BufferBindFlag[BufferBindFlag["IndexBuffer"] = 1] = "IndexBuffer";
    return BufferBindFlag;
}({});

/**
 * Mesh topology.
 */ var MeshTopology = /*#__PURE__*/ function(MeshTopology) {
    /** Draws a single dot */ MeshTopology[MeshTopology["Points"] = 0] = "Points";
    /** Draws a line between a pair of vertices */ MeshTopology[MeshTopology["Lines"] = 1] = "Lines";
    /** Draws a straight line to the next vertex, and connects the last vertex back to the first */ MeshTopology[MeshTopology["LineLoop"] = 2] = "LineLoop";
    /** Draws a straight line to the next vertex. */ MeshTopology[MeshTopology["LineStrip"] = 3] = "LineStrip";
    /** Draws a triangle for a group of three vertices */ MeshTopology[MeshTopology["Triangles"] = 4] = "Triangles";
    /** Draws a triangle strip */ MeshTopology[MeshTopology["TriangleStrip"] = 5] = "TriangleStrip";
    /** Draws a triangle fan */ MeshTopology[MeshTopology["TriangleFan"] = 6] = "TriangleFan";
    return MeshTopology;
}({});

var PrefilteredDFG = /*#__PURE__*/ function() {
    function PrefilteredDFG() {}
    PrefilteredDFG.create = function create(engine) {
        return new Promise(function(resolve, reject) {
            var texture = new Texture2D(engine, PrefilteredDFG._size, PrefilteredDFG._size, TextureFormat.R8G8B8, false, false);
            texture.wrapModeU = texture.wrapModeV = TextureWrapMode$1.Clamp;
            texture.isGCIgnored = true;
            var image = new Image();
            image.onload = function() {
                texture.setImageSource(image);
                resolve(texture);
            };
            image.onerror = image.onabort = function() {
                var message = "Failed to load prefiltered LUT image.";
                Logger.error(message);
                reject(message);
            };
            image.src = PrefilteredDFG._base64;
            engine.resourceManager.addContentRestorer(new (/*#__PURE__*/ function(ContentRestorer) {
                _inherits$2(_class, ContentRestorer);
                function _class() {
                    return ContentRestorer.call(this, texture) || this;
                }
                var _proto = _class.prototype;
                _proto.restoreContent = function restoreContent() {
                    texture.setImageSource(image);
                };
                return _class;
            }(ContentRestorer))());
            return texture;
        });
    };
    return PrefilteredDFG;
}();
PrefilteredDFG._size = 256;
PrefilteredDFG._base64 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAIAAADTED8xAAAABGdBTUEAALGPC/xhBQAACjVpQ0NQc1JHQiBJRUM2MTk2Ni0yLjEAAEjHnZZ3VFTXFofPvXd6oc0w0hl6ky4wgPQuIB0EURhmBhjKAMMMTWyIqEBEEREBRZCggAGjoUisiGIhKKhgD0gQUGIwiqioZEbWSnx5ee/l5ffHvd/aZ+9z99l7n7UuACRPHy4vBZYCIJkn4Ad6ONNXhUfQsf0ABniAAaYAMFnpqb5B7sFAJC83F3q6yAn8i94MAUj8vmXo6U+ng/9P0qxUvgAAyF/E5mxOOkvE+SJOyhSkiu0zIqbGJIoZRomZL0pQxHJijlvkpZ99FtlRzOxkHlvE4pxT2clsMfeIeHuGkCNixEfEBRlcTqaIb4tYM0mYzBXxW3FsMoeZDgCKJLYLOKx4EZuImMQPDnQR8XIAcKS4LzjmCxZwsgTiQ7mkpGbzuXHxArouS49uam3NoHtyMpM4AoGhP5OVyOSz6S4pyalMXjYAi2f+LBlxbemiIluaWltaGpoZmX5RqP+6+Dcl7u0ivQr43DOI1veH7a/8UuoAYMyKarPrD1vMfgA6tgIgd/8Pm+YhACRFfWu/8cV5aOJ5iRcIUm2MjTMzM424HJaRuKC/6386/A198T0j8Xa/l4fuyollCpMEdHHdWClJKUI+PT2VyeLQDf88xP848K/zWBrIieXwOTxRRKhoyri8OFG7eWyugJvCo3N5/6mJ/zDsT1qca5Eo9Z8ANcoISN2gAuTnPoCiEAESeVDc9d/75oMPBeKbF6Y6sTj3nwX9+65wifiRzo37HOcSGExnCfkZi2viawnQgAAkARXIAxWgAXSBITADVsAWOAI3sAL4gWAQDtYCFogHyYAPMkEu2AwKQBHYBfaCSlAD6kEjaAEnQAc4DS6Ay+A6uAnugAdgBIyD52AGvAHzEARhITJEgeQhVUgLMoDMIAZkD7lBPlAgFA5FQ3EQDxJCudAWqAgqhSqhWqgR+hY6BV2ArkID0D1oFJqCfoXewwhMgqmwMqwNG8MM2An2hoPhNXAcnAbnwPnwTrgCroOPwe3wBfg6fAcegZ/DswhAiAgNUUMMEQbigvghEUgswkc2IIVIOVKHtCBdSC9yCxlBppF3KAyKgqKjDFG2KE9UCIqFSkNtQBWjKlFHUe2oHtQt1ChqBvUJTUYroQ3QNmgv9Cp0HDoTXYAuRzeg29CX0HfQ4+g3GAyGhtHBWGE8MeGYBMw6TDHmAKYVcx4zgBnDzGKxWHmsAdYO64dlYgXYAux+7DHsOewgdhz7FkfEqeLMcO64CBwPl4crxzXhzuIGcRO4ebwUXgtvg/fDs/HZ+BJ8Pb4LfwM/jp8nSBN0CHaEYEICYTOhgtBCuER4SHhFJBLVidbEACKXuIlYQTxOvEIcJb4jyZD0SS6kSJKQtJN0hHSedI/0ikwma5MdyRFkAXknuZF8kfyY/FaCImEk4SXBltgoUSXRLjEo8UISL6kl6SS5VjJHslzypOQNyWkpvJS2lIsUU2qDVJXUKalhqVlpirSptJ90snSxdJP0VelJGayMtoybDFsmX+awzEWZMQpC0aC4UFiULZR6yiXKOBVD1aF6UROoRdRvqP3UGVkZ2WWyobJZslWyZ2RHaAhNm+ZFS6KV0E7QhmjvlygvcVrCWbJjScuSwSVzcopyjnIcuUK5Vrk7cu/l6fJu8onyu+U75B8poBT0FQIUMhUOKlxSmFakKtoqshQLFU8o3leClfSVApXWKR1W6lOaVVZR9lBOVd6vfFF5WoWm4qiSoFKmclZlSpWiaq/KVS1TPaf6jC5Ld6In0SvoPfQZNSU1TzWhWq1av9q8uo56iHqeeqv6Iw2CBkMjVqNMo1tjRlNV01czV7NZ874WXouhFa+1T6tXa05bRztMe5t2h/akjpyOl06OTrPOQ12yroNumm6d7m09jB5DL1HvgN5NfVjfQj9ev0r/hgFsYGnANThgMLAUvdR6KW9p3dJhQ5Khk2GGYbPhqBHNyMcoz6jD6IWxpnGE8W7jXuNPJhYmSSb1Jg9MZUxXmOaZdpn+aqZvxjKrMrttTjZ3N99o3mn+cpnBMs6yg8vuWlAsfC22WXRbfLS0suRbtlhOWWlaRVtVWw0zqAx/RjHjijXa2tl6o/Vp63c2ljYCmxM2v9ga2ibaNtlOLtdZzllev3zMTt2OaVdrN2JPt4+2P2Q/4qDmwHSoc3jiqOHIdmxwnHDSc0pwOub0wtnEme/c5jznYuOy3uW8K+Lq4Vro2u8m4xbiVun22F3dPc692X3Gw8Jjncd5T7Snt+duz2EvZS+WV6PXzAqrFetX9HiTvIO8K72f+Oj78H26fGHfFb57fB+u1FrJW9nhB/y8/Pb4PfLX8U/z/z4AE+AfUBXwNNA0MDewN4gSFBXUFPQm2Dm4JPhBiG6IMKQ7VDI0MrQxdC7MNaw0bGSV8ar1q66HK4RzwzsjsBGhEQ0Rs6vdVu9dPR5pEVkQObRGZ03WmqtrFdYmrT0TJRnFjDoZjY4Oi26K/sD0Y9YxZ2O8YqpjZlgurH2s52xHdhl7imPHKeVMxNrFlsZOxtnF7YmbineIL4+f5rpwK7kvEzwTahLmEv0SjyQuJIUltSbjkqOTT/FkeIm8nhSVlKyUgVSD1ILUkTSbtL1pM3xvfkM6lL4mvVNAFf1M9Ql1hVuFoxn2GVUZbzNDM09mSWfxsvqy9bN3ZE/kuOd8vQ61jrWuO1ctd3Pu6Hqn9bUboA0xG7o3amzM3zi+yWPT0c2EzYmbf8gzySvNe70lbEtXvnL+pvyxrR5bmwskCvgFw9tst9VsR23nbu/fYb5j/45PhezCa0UmReVFH4pZxde+Mv2q4quFnbE7+0ssSw7uwuzi7Rra7bD7aKl0aU7p2B7fPe1l9LLCstd7o/ZeLV9WXrOPsE+4b6TCp6Jzv+b+Xfs/VMZX3qlyrmqtVqreUT13gH1g8KDjwZYa5ZqimveHuIfu1nrUttdp15UfxhzOOPy0PrS+92vG140NCg1FDR+P8I6MHA082tNo1djYpNRU0gw3C5unjkUeu/mN6zedLYYtta201qLj4Ljw+LNvo78dOuF9ovsk42TLd1rfVbdR2grbofbs9pmO+I6RzvDOgVMrTnV32Xa1fW/0/ZHTaqerzsieKTlLOJt/duFczrnZ86nnpy/EXRjrjup+cHHVxds9AT39l7wvXbnsfvlir1PvuSt2V05ftbl66hrjWsd1y+vtfRZ9bT9Y/NDWb9nffsPqRudN65tdA8sHzg46DF645Xrr8m2v29fvrLwzMBQydHc4cnjkLvvu5L2key/vZ9yff7DpIfph4SOpR+WPlR7X/aj3Y+uI5ciZUdfRvidBTx6Mscae/5T+04fx/Kfkp+UTqhONk2aTp6fcp24+W/1s/Hnq8/npgp+lf65+ofviu18cf+mbWTUz/pL/cuHX4lfyr468Xva6e9Z/9vGb5Dfzc4Vv5d8efcd41/s+7P3EfOYH7IeKj3ofuz55f3q4kLyw8Bv3hPP7Ori+UwAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAACXBIWXMAAAsTAAALEwEAmpwYAAAF1GlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgOS4xLWMwMDIgNzkuYTZhNjM5NjhhLCAyMDI0LzAzLzA2LTExOjUyOjA1ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgMjUuMTIgKE1hY2ludG9zaCkiIHhtcDpDcmVhdGVEYXRlPSIyMDI0LTEyLTEyVDE4OjIwOjQwKzA4OjAwIiB4bXA6TW9kaWZ5RGF0ZT0iMjAyNC0xMi0xM1QxMzoxNjozMSswODowMCIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAyNC0xMi0xM1QxMzoxNjozMSswODowMCIgZGM6Zm9ybWF0PSJpbWFnZS9wbmciIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NTBhZWJkMjMtOGJlMi00OTBlLWEzOGItZmEwMDQwODNmMTJmIiB4bXBNTTpEb2N1bWVudElEPSJhZG9iZTpkb2NpZDpwaG90b3Nob3A6NDNhMDNiNmEtYWIyYi02ODQ1LThhOWEtY2JmNDg0YzVjOWIxIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6ODkwMGQxMjktYTQ2MS00NTE2LWFmNWItMjRkM2ZjOGE4NGJhIj4gPHhtcE1NOkhpc3Rvcnk+IDxyZGY6U2VxPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY3JlYXRlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDo4OTAwZDEyOS1hNDYxLTQ1MTYtYWY1Yi0yNGQzZmM4YTg0YmEiIHN0RXZ0OndoZW49IjIwMjQtMTItMTJUMTg6MjA6NDArMDg6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCAyNS4xMiAoTWFjaW50b3NoKSIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6NTBhZWJkMjMtOGJlMi00OTBlLWEzOGItZmEwMDQwODNmMTJmIiBzdEV2dDp3aGVuPSIyMDI0LTEyLTEzVDEzOjE2OjMxKzA4OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgMjUuMTIgKE1hY2ludG9zaCkiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+pKcSgwAAFRNJREFUeNrtnQeSG9cRhp+O5OuZSlYgZSpQiaKSywdwle8ll11yYNwFBoYIYTg7sV/nftNTW1sAdgYK+3/df4fBvlXKH8tvx6ksHqea14EvCr1i8pT+I8Rpoo95T+Z6keWn49PeugJQK/Q9A4A7k6hyc6GbiJ5T67MPQgNgxUN7IZ83/AfKA6chAHIMQE5zBYAVDBKXK4f5AKIfnj8CoCqu8wJA17eO4umSDRfyQxgejPpHFkjO8JgEeAXF65gc0TBvToJCDbB2/hQAtSTg1uI36fjbq3EZ1D9rgfxUvQ5r3KB1bYb8xQezAJgYHkMARP2PFRi7Dfl1kFQB0GqX07zJs8N611L0mxZIJwkYzrky5O835E8t0D1y1euk7ZMhfz8unyT6kQW6twPTr1bXZshXkDWb+nEAhDD93ka5kLdKly8q+sUa4J5RvOcFYA+j3GZCvrHopzUA3d8X69WGiCG/5MaOgPqRNYAH09/qLoPnJc02SltSG/SeVpPHCgD/Xc6ge/lRRb9igYruhrMrAHJhU83nGIt+xQJJJwFzABzCkCFfW/TrFig9T4b8xkW/boE0PU9xs7+w29LWj8/RE/3IAr0dZLtBbYEn6L2I8Ku87+hrPlgCoIQa7ua9iMV9X9+R6EcW6G3WwtdknyeXdpT7+obbOyIWyGfIL02388PtabYj+qkFYgSgWO8w72SC2+rKGtd7Vlsgh4pvuLeT96Po5Io6C9QeAK4+WjBFr2yQqi2QN8WXXFvY4XqmMgYSABT57n44o7+3Ow+91btQC6Tf6qEDEGtvp72dZP/dnjoLpOyCfFa9rsJ/il7WAr3j9fMahLKBoefJbQWPFugdDsWjjU3zRj9F790CvZOVrorR38+Kjkb7ktcCKdueJu9KyS6+QRef/iYrAJQWZ7q8F+7hw6Rcl7D0a4cAqNkeZQCypRPd+itZoBKwwR9ijJV9TCsMtk8YAVC8bvLsYXabLR1t9U8zANEFNQ9AruBrNnAo7w894QzAuxn1d9nJabClU6v+iwVqG4AGPkinmerWnfr7DFDcLPPs3N833MnRwaD6BDoAJce32cDxU9TWntADsM+on58g0kxRu3nm4hzg3Xop7yTqR/pbV3FsjCP1rwNQJAdb+4n6aettqlvghSMASqi+vv7UNmdVyrZeTv3zGSDbmqG1ruZenBgbqvovGeA965t0zQFIq+PZ3wuq/5IB3rNu+ITrYDbs5qMYGx719wDYWn8TANLNl4hte1719xbI1voznpDNnGYal5wqX3m9B8Cw3s2on41LG/UPM0DZwRA33Icep8MRf30IAGNjpyiupmmSkK0b8dGspvrhADix+GlssofD/PoZgPeDu50mPxREyAXtMcZvFsHv08ZbmgBksM8Yz6n+PgM4DPa2zr7h2wVbq2Ip6u8zQDgA2vyDbRnjldU/BKA4G9822cbJaZQv9Q8tUJa2uXFgVebqXL5WBBMDfPE0tMrVA58qV5U1ogg21HpxOY7d1d58POtCOG2cAf7UusvPsrU1486l/nUAvLn8vXxgd3BLE0j9bzJAkdlckL6/hPhWWb+2oX7SVVMAivvB7d68TVoawat6AHB+pklzH++zPRru0ugUwTs097afUKmm2ohOHW/oEVcNAbDSvRwAed+ToYM3vKriTRgBUC5hy25GTnu05nzq394F+iBUMyeK3J0PUGOHbcZ/xAWAtns4DUf3ZoK9vvrvZIB96j7lXqLEabmnUwCC6r691d92Oi2e/4k9ANK6d+vmm1wNMKgmg8IwC0Bxv4ngp9G+E1tiLnfBNugHWN0XfwPXJpfXU9+CT88AfBhnSuXcxhja8dQ3fhv0Q/fLCLHiegbsSE8vADTWptxnuzCfItugCAB0CtkGdJ9PvT/tAYhrbERXuNrDIP9V5zOAH4fjwbhb6X5XbHjJAB85W5r3Y1H2rN29ZJ51AIqDUZS3iO5fyqn+ujboR6GsvJVX8fCGUWCI9LtYAqCNSB80mobmJ1j26AGQa88rhHaHGHg7xy1jxmZpCoBPb2Oiaa63jQhMG2YJ1Ab9WPgTB+QA8INB9AvdphTxNxwC4NDNG0rcyYVxKYqRH2YBiKV4z0q1+ke0mkOKxCDs42g2xr/UWmLJDyGMb3inDfqxruKjx++VF/cJWOz80APgqhujJm7n77wfy2Rmh84A3A8S3U0kFVf3bRcMnIOw+w46MCEU7/OtJN7Z3EepAbMGwE4Cuf8fKWeJEFUEcwbw7GSi/CgcEnErBOZB2H2x/yr/WheVdfMJROhCNULeFMFRIrqHE6ze3JCWlgviMwAP9qpyP+/j2Vk5L4ipT6cA6JgZZfH5PM1VMnGChGDDZ2kQ9kBA+ib6dnKyc3JcVcn2CeECgFUAk5asziXe+AldJVMuwbzzLABqQY54if6FcpdESQtBS4KysgrxwM4fM17o50182qqgpkgchjMAn/iQvuhb+YFE4pK4tbIcIdDT1gFoUrWNoWKufs2hGD8MFwDiqtPtv6QTB4U7waosFi95Zwdhn7Qu+hA4hUgO5kgw+59LEfxJij4UPFGskceSd7YN+mcHgkjFh2iqum0K4U8zBKBh3jy8bWYAjxkgU0fozinxfDkk8K9fAPCv1N0yY2KTQmeAuteXAGDUjeaFzXAifblJeWBo+tcGYQ/rf98SJwdiQ+5tnRTKsTIA+vXfLdBDYckqE5KFhFsGKEhwwTAzCHtop29v8LRBBdfJbktezj9WdAGAolR9NtSwab50ZuwFSbsgNtM/LYIfiomS8Xz2q5rnIYQLMjD90zbop3O/URYVyqHih4d0QbZtH2oq6AEoYAyivKhgpTyT4JMBe9M/bYN+uvW7hPy+0WLlvZAdkv2Q4Lz1ySn6URH8KUxhdI1q4mFLQjKAO0eq0t20QLO/PGnF+8SDDkkyYJsB6s48A/BZje5xT5VzizQecs2lBhjQnHYxpIIegCXJ6iveed4IzYDOIpBoBmCwPaMi+DOCgokASKQXXjCUC+iIDLjqdWKK4M8A4Z8LAA/AOCwYcJebMMCeFrTbPuXN8cYCoXVPP4GXEFdgmIyZeS9xUvjKZYDfAPgcHP4RutdHJUpykDZLQRnQsD2jDKAMgFxWUW490ZODTqngnwGK1rdNzmYR/PmCenjlbpIlpJGINTSgnEavhs0zwGIR/Pmq6J08QJ9pyIDbBpEaAwoZgIrBCABGEsyl77CV5K09Gsv2UN3O7PlnAL5Y1a6V7nlpYWGDiIRaeeCWAbUMUPHTTQBqlW3OiVD9ID1QM28HCTHg0faMLNAXleEfIWhvrmmfpkhu+mvb8cSrvwdgU/3hqGB3TeadIkPrH6LeRWJwBuDRQGpo0ROp8AlDkVk68lMKEx2RZr3L4HaWLNAjbPjnhcG5TVK2Q8o7EWoM6NS7my/esUCP5kSmBoOcd5JrIqFhMCwG9BnwUuYCLdCK+iVgcMuAcm2gb4REGZCGAf5T6AkXAODqBwpaxzWxgyEBA6/6TSYAQjsOZrZnZIG+XJU7XNnEJKBTRiunAg9dUQnzo2P9GW3P4uMRAFP1wxVP58FPwSBRIpsbIScMuAj8wxrgS7D6GZ8W3d5r6FRgSIJJ+asR+KcWCKL+TYmLMhCiPGBJBVxgsJgfrr6nTocHaYFm1Q/Rdy0SCr0mRh6UjVAGfgUMxk/PAHwFVj8OCdu0IGeNqqjg1b3C2KvJwD/fBv0KJn04EnJOCXKaToXgpzFqXvW6DfygH40AWJJ+LRh0KhBZQq1QZndE0haIKxsg2p0OA/+4BvgKIH1EZmB3R8pFgm0SwIGhsO/Abn5YMECq/wLA1wDpb+YH0eQgigGOhxBJQKgMwMFgUuOuk/D7HIAFAIXKwaEpoieBKP2f1gL/sAb4mkP9uBQhOnqTLpHdJgHpwK+5x8ZCwkYNwAiAaBkt5IvMk4BJ+FcwP8btHSAMZwC+uaukjgaAtFmC947cYiCUBHhJ0Pc8Sycw+JyVV6YAzGJQpf5wCUGnL6ScBMwZ0PQ8GOn3RfA3WHEzksA4eBbqEaEx0EkCHho+Vp4Hp/7TegYwhEGiXGbvkOpg4NP3Ox1pVQX+TQsUCwbG5SKFjhBj+Pfp+82a+rXqvwDw7Wrtu1kecLWPWIbNok1SCQysln94GZD2PIjAD+WhBwAo7k6rJCBWyQgSdIoBw/Av7XnQN6dztjVreJgBYF3inakjYoGhamZchQQvBjptH2+ep1brcKHPq//SBfoWLPTOU4UgtEwh1BJtNfwL2X3xwN//6AzA44myO5r6O0lfJGGKlHtBas0fCQbYu/v8jR24+nsATgAGOpXagKVTBJ8W61TD+qNfxjY/bwZgt/t46Y8AGIm4E/NFHVPLqFjnAXYMTMK/mvmR6GmeIBLfXIV4PKfOjqz+zl8qYFmXcDUC4w3/jE0exkqXK/AvtkEfL6i2Q1UFHV+dQMkGLDAwdoFYXJBV+A9h9+sC/xCA7xa0XuuI9HtHRaAqsO0CyYV/oQmXf+lv/PQCwKzuVwBg6Rp1Wm0iXE3MshPBjgEiCaT0Cy8AuH6R1RANPSarIgG9BLF+AlfhC2HAQ39TW/1DAHqNMqYCtRKZfTig3AZVcD4sjc6mpN8D8GRB+lWpwGqMwDgqlm4EUWCgrDnsSvpV6j+NABhJH2eKhIbKRcAOSTeC5PyPVaOzGenfmQQ/WZD+CgBcJGiOC3DFAL0AMGn5p/Sh58MBWG+VwgcI0iUyrh5AlMJqBUBKn1H6M6sQ6wBA8sDmGEEtIRRse9RbAaDpfIJKnxT4hwB8P1E8JA+wYMDbKUKrXxkAuT0fBemz3JCuL/2yckMMBAAEBh1Ht7QKA1cACFl/Cekr35LrRfoIABgx6LBCx31ulwIAjHlA1PQbSv9EkzVC+ttXXQAY6b6rqQo6rVRA+dyuzb6QEAC1GLiqdxuX/hSAXv0rCaGqUEZ0S3GpgBcAtdoX7X+kZ1sKNa699HsAfpiE/6pUsO6L5BigJ4GqOYBy7YuQvsIeG4vRF5V+9YUIACTsUOceAK69N7T/YZF+q0Yff20PwFD9HaoqQA/RGHeHKKVwbRngs+qtDf/R3Q712gsAI/UD6wEECVxJoGO6bZLiglgAiCV9b26HeO0aACtJgJEBHAAd60ygGAEg0fBRNvqGumeQfg/Aj3PqXy8JgLVBVXeIfVei0JKAHADS0m/b7bBJfxOAKgboSYB3j5r3rgCulj+x4YMO/7XrDEK6N3Y7CACADGwmBKIdou/J8fZAEQBwrTlID7baD/m1ACwxgEsFLDdeSjAgBwCl2a/pdhyGfFnpwwFgxKA2FSCqYXQXiGh+pj9il77OLkPjIX8KwE+vlXRUwYAyMOZqBAmZH64Rr630bXWvKv1NAI4L7VH41IwyMxatgxEM0KWvsNSQVgcPwIiBI0D3iBIZ2COiLMkRawBgElCL/bjwnyGfBMCx0gvhBmfAPIBLBbX+p4D/CMCS7zexPWl1NAA4LosePTVDfAwR132SxMkXpeSttT2809zUfR0AwLK4tjJGu6DOzv+wd/r9hPyd6n4IwM93FX9cTQLrLmipPkZ7IXQpXGj+B1EBA2O/UJMndS8FADwPQBpE+kmAJfYL3b1OD/8Sug/c0uEC4AhrClUxUFUPUJIApPyV6HsW1rFu4dtiAIpyF/EeAQAOA/qomKUIxoV/LunrzLNS9wwA9LrfZIA4MwbOidEZoNBGv7iWv0KlW2q2GFL3JACWjBAxFSAYINYARaDtgwYAaHWEbkJP3dcBcNwqiHGVMXxRYmUoVpsBarv+lF4nl+3xpvvWRD8C4C9z6j9u9UZnGYCsD9XePsbu/gt52YHL7heZbc3UPRsAR1gSONKKATgDiDvi0c6nCoAqBkR1nyaHBMABlgSOhJp4pRioKoJxBQDc9LPYfZamvoLu9yX6JQAO9V4ISAJiTw5tgURNv1qHR0H3+xX9LAAHQh5AN0ZX9qWJDdD1sVchz3cNdZ/BXhaAw4SBbu4Bwg7R6+Ba/7PZ8qcAgLP7pX6YlcFeD4DDHANdTUkA2ZwjDoOB/ofX85joPkWvCsBhIQOw1ANVt00iCgDebg9Xe0dZ9yl6KgCHuzD0pqijMVB1u0zVh0FsWv9NBhAAFO6NnQz2jgA43AVgthioXZfgBQBu/VmK3YJd2MxgHwaAwzIDh2UXVLUuUVUD0K3/pu9He/0iv6GZojcA4FADACQJqAFQCKudcM9DaWtS5JuiVwXgtj4JwCcDwDkA7qOvisBSw6b1Fwr2KXobAG6XGZhi0MF25oAMVIX/spUE6LqnBPtTKj4iALdz32c7QlMAjoAPlYCH/45jxxPR5FHWfYreHQC3A+nfLrig9TywmQSqRmA6gb/Ur+an6FsD4PYuA7dgIwRckai9GwZxVzuluVm4F/FT9PEAmP2Cd4TWe0HK6kfrPkW/awBuJg9mAThU3jvWkdUPHHLx6v6Uit8VADdX3Q+/r7RED5UASKh/0+gXcFM/Rb9rAIbqvxk8HXZFIR2hTQAgte9SsVtgtkcu2KfiGweg/3o1AWC9JQrPAMCu/7rLp0yyUvR5jAH4eSL9y4PadtD6JLjqfhdEf7OQVxVS9LsG4NVV/a8GGNzOZYCR9A8LbdDRp6Sc6vv9ZfkW9VkA0KJPxe8dgFdzXzfL/dDNDDBdh978rE9IewcS+FP0eVQD8PIq+uGDm7mZwFIzdNP/nLC2h1LdpuLz2Abgp6viX14BeHkFYDYJHLcAmP5VJfhWc5XJSdHnwQPARfEvBhi8mPRDDws1wBGw/1N1F8t6S6fI3GuSx34B+PGq+BeDBy+ujaCb1d24I2D0W7vBXxXpU/F5UAH4YSD689fzAQz9aGwpA4z6P0trz/BpLlDZqfs8OAF4fv16MXj8ctIM3VT/0sCr1E9wU+55KAHwfSnPrqJ/dn38bADAzWQSPN19WBn0nir7Oan4PFQBeHLV/dPB92eDOrjPAMcBALMffDJqd5a5jn6pNzx55CEIwHevRX/5+t/g+wiA4+TmL2CfJ71NHq4BePxa8Zev/w6+P7/bBRranhOgzC2VPfs88jAD4Kz4/1y/91/PJzPglZBfVdTmkYevIvjfpfz6+qt/8OtrAIaN/6Wmfhr6PGID8NdS/jX4+uf1+7PJX79Lb5NHgwD8vZR/lPLL9fsv18dPwbVsHnkEBuBvA+kPGXia/3fy2AMAfxjcCjP8fsz/O3k0f/wfg5rUWhyQPr4AAAAASUVORK5CYII=";

/**
 * BlendShapeFrame.
 */ var BlendShapeFrame = /*#__PURE__*/ function() {
    function BlendShapeFrame(weight, deltaPositions, deltaNormals, deltaTangents) {
        if (deltaNormals === void 0) deltaNormals = null;
        if (deltaTangents === void 0) deltaTangents = null;
        /** @internal */ this._dataChangeManager = new UpdateFlagManager();
        this._dirty = 7;
        if (deltaNormals && deltaNormals.length !== deltaPositions.length) {
            throw "deltaNormals length must same with deltaPositions length.";
        }
        if (deltaTangents && deltaTangents.length !== deltaPositions.length) {
            throw "deltaTangents length must same with deltaPositions length.";
        }
        this.weight = weight;
        this._deltaPositions = deltaPositions;
        this._deltaNormals = deltaNormals;
        this._deltaTangents = deltaTangents;
    }
    var _proto = BlendShapeFrame.prototype;
    /**
   * @internal
   */ _proto._releaseData = function _releaseData() {
        this._deltaPositions = null;
        this._deltaNormals = null;
        this._deltaTangents = null;
    };
    _create_class$2(BlendShapeFrame, [
        {
            key: "deltaPositions",
            get: /**
   * Delta positions for the frame being added.
   * @remarks Need to re-assign after modification to ensure that the modification takes effect.
   */ function get() {
                return this._deltaPositions;
            },
            set: function set(value) {
                this._deltaPositions = value;
                this._dirty |= 1;
                this._dataChangeManager.dispatch(this._dirty, this);
            }
        },
        {
            key: "deltaNormals",
            get: /**
   * Delta normals for the frame being added.
   * @remarks Need to re-assign after modification to ensure that the modification takes effect.
   */ function get() {
                return this._deltaNormals;
            },
            set: function set(value) {
                this._deltaNormals = value;
                this._dirty |= 2;
                this._dataChangeManager.dispatch(this._dirty, this);
            }
        },
        {
            key: "deltaTangents",
            get: /**
   * Delta tangents for the frame being added.
   * @remarks Need to re-assign after modification to ensure that the modification takes effect.
   */ function get() {
                return this._deltaTangents;
            },
            set: function set(value) {
                this._deltaTangents = value;
                this._dirty |= 4;
                this._dataChangeManager.dispatch(this._dirty, this);
            }
        }
    ]);
    return BlendShapeFrame;
}();
var BlendShapeFrameDirty = /*#__PURE__*/ function(BlendShapeFrameDirty) {
    BlendShapeFrameDirty[BlendShapeFrameDirty["Position"] = 1] = "Position";
    BlendShapeFrameDirty[BlendShapeFrameDirty["Normal"] = 2] = "Normal";
    BlendShapeFrameDirty[BlendShapeFrameDirty["Tangent"] = 4] = "Tangent";
    BlendShapeFrameDirty[BlendShapeFrameDirty["All"] = 7] = "All";
    return BlendShapeFrameDirty;
}({});

/**
 * BlendShape.
 */ var BlendShape = /*#__PURE__*/ function() {
    function BlendShape(name) {
        /** @internal */ this._useBlendShapeNormal = true;
        /** @internal */ this._useBlendShapeTangent = true;
        /** @internal */ this._layoutChangeManager = new UpdateFlagManager();
        /** @internal */ this._dataChangeManager = new UpdateFlagManager();
        this._frames = [];
        this.name = name;
        this._frameDataChangeListener = this._frameDataChangeListener.bind(this);
    }
    var _proto = BlendShape.prototype;
    _proto.addFrame = function addFrame(frameOrWeight, deltaPositions, deltaNormals, deltaTangents) {
        if (typeof frameOrWeight === "number") {
            var frame = new BlendShapeFrame(frameOrWeight, deltaPositions, deltaNormals, deltaTangents);
            this._addFrame(frame);
            return frame;
        } else {
            this._addFrame(frameOrWeight);
        }
    };
    /**
   * Clear all frames.
   */ _proto.clearFrames = function clearFrames() {
        var frames = this._frames;
        for(var i = 0, n = frames.length; i < n; i++){
            frames[i]._dataChangeManager.removeListener(this._frameDataChangeListener);
        }
        frames.length = 0;
        this._updateUseNormalAndTangent(true, true);
        this._dataChangeManager.dispatch();
    };
    /**
   * @internal
   */ _proto._releaseData = function _releaseData() {
        var frames = this._frames;
        for(var i = 0, n = frames.length; i < n; i++){
            frames[i]._releaseData();
        }
    };
    _proto._addFrame = function _addFrame(frame) {
        var frames = this._frames;
        var frameCount = frames.length;
        if (frameCount > 0 && frame.deltaPositions.length !== frames[frameCount - 1].deltaPositions.length) {
            throw "Frame's deltaPositions length must same with before frame deltaPositions length.";
        }
        this._frames.push(frame);
        this._frameDataChangeListener(BlendShapeFrameDirty.All, frame);
        frame._dataChangeManager.addListener(this._frameDataChangeListener);
    };
    _proto._updateUseNormalAndTangent = function _updateUseNormalAndTangent(useNormal, useTangent) {
        var useBlendShapeNormal = this._useBlendShapeNormal && useNormal;
        var useBlendShapeTangent = this._useBlendShapeTangent && useTangent;
        if (this._useBlendShapeNormal !== useBlendShapeNormal || this._useBlendShapeTangent !== useBlendShapeTangent) {
            this._useBlendShapeNormal = useBlendShapeNormal;
            this._useBlendShapeTangent = useBlendShapeTangent;
            this._layoutChangeManager.dispatch(0, this);
        }
    };
    _proto._frameDataChangeListener = function _frameDataChangeListener(type, frame) {
        this._updateUseNormalAndTangent(!!frame.deltaNormals, !!frame.deltaTangents);
        this._dataChangeManager.dispatch();
    };
    _create_class$2(BlendShape, [
        {
            key: "frames",
            get: /**
   * Frames of BlendShape.
   */ function get() {
                return this._frames;
            }
        }
    ]);
    return BlendShape;
}();

/**
 * Index buffer binding.
 */ var IndexBufferBinding = /*#__PURE__*/ function() {
    function IndexBufferBinding(buffer, format) {
        this._buffer = buffer;
        this._format = format;
    }
    _create_class$2(IndexBufferBinding, [
        {
            key: "buffer",
            get: /**
   * Index buffer.
   */ function get() {
                return this._buffer;
            }
        },
        {
            key: "format",
            get: /**
   * Index buffer format.
   */ function get() {
                return this._format;
            }
        }
    ]);
    return IndexBufferBinding;
}();

/**
 * Sub-primitive, mainly contains drawing information.
 */ var SubPrimitive = function SubPrimitive(start, count, topology) {
    if (start === void 0) start = 0;
    if (count === void 0) count = 0;
    if (topology === void 0) topology = MeshTopology.Triangles;
    this.start = start;
    this.count = count;
    this.topology = topology;
};

/**
 * Sub-mesh, mainly contains drawing information.
 */ var SubMesh = /*#__PURE__*/ function(SubPrimitive) {
    _inherits$2(SubMesh, SubPrimitive);
    function SubMesh() {
        return SubPrimitive.apply(this, arguments) || this;
    }
    var _proto = SubMesh.prototype;
    _proto.dispose = function dispose() {};
    return SubMesh;
}(SubPrimitive);

/**
 * @internal
 * Primitive.
 */ var Primitive = /*#__PURE__*/ function(GraphicsResource) {
    _inherits$2(Primitive, GraphicsResource);
    function Primitive(engine) {
        var _this;
        _this = GraphicsResource.call(this, engine) || this, _this.enableVAO = true, _this.instanceCount = 0, _this.vertexBufferBindings = [], /** @internal */ _this._vertexElementMap = {}, /** @internal */ _this._bufferStructChanged = false, _this._vertexElements = [];
        _this._platformPrimitive = engine._hardwareRenderer.createPlatformPrimitive(_this);
        return _this;
    }
    var _proto = Primitive.prototype;
    _proto.addVertexElement = function addVertexElement(element) {
        var vertexElementMap = this._vertexElementMap;
        var vertexElements = this._vertexElements;
        var semantic = element.attribute;
        var oldVertexElement = vertexElementMap[semantic];
        if (oldVertexElement) {
            console.warn("VertexElement " + semantic + " already exists.");
            vertexElements.splice(vertexElements.indexOf(oldVertexElement), 1);
        }
        vertexElementMap[semantic] = element;
        vertexElements.push(element);
        this._bufferStructChanged = true;
    };
    _proto.removeVertexElement = function removeVertexElement(index) {
        var vertexElements = this._vertexElements;
        // Delete the old vertex element
        var vertexElement = vertexElements[index];
        vertexElements.splice(index, 1);
        delete this._vertexElementMap[vertexElement.attribute];
        this._bufferStructChanged = true;
    };
    _proto.clearVertexElements = function clearVertexElements() {
        this._vertexElements.length = 0;
        var vertexElementMap = this._vertexElementMap;
        for(var k in vertexElementMap){
            delete vertexElementMap[k];
        }
        this._bufferStructChanged = true;
    };
    /**
   * @remarks should use together with `setVertexElementsLength`
   */ _proto.setVertexElement = function setVertexElement(index, element) {
        var vertexElementMap = this._vertexElementMap;
        var vertexElements = this._vertexElements;
        // Delete the old vertex element
        var oldVertexElement = vertexElements[index];
        oldVertexElement && delete vertexElementMap[oldVertexElement.attribute];
        vertexElementMap[element.attribute] = element;
        vertexElements[index] = element;
        this._bufferStructChanged = true;
    };
    _proto.setVertexElementsLength = function setVertexElementsLength(length) {
        var vertexElementMap = this._vertexElementMap;
        var vertexElements = this._vertexElements;
        for(var i = length, n = vertexElements.length; i < n; i++){
            var element = vertexElements[i];
            delete vertexElementMap[element.attribute];
        }
        vertexElements.length = length;
    };
    _proto.setVertexBufferBinding = function setVertexBufferBinding(index, binding) {
        var referCount = this._getReferCount();
        var vertexBufferBindings = this.vertexBufferBindings;
        if (referCount > 0) {
            var _vertexBufferBindings_index;
            (_vertexBufferBindings_index = vertexBufferBindings[index]) == null ? void 0 : _vertexBufferBindings_index.buffer._addReferCount(-referCount);
            binding == null ? void 0 : binding.buffer._addReferCount(referCount);
        }
        vertexBufferBindings[index] = binding;
        this._bufferStructChanged = true;
    };
    /**
   * Set vertex buffer binding.
   * @param vertexBufferBindings - Vertex buffer binding
   * @param firstIndex - First vertex buffer index, the default value is 0
   */ _proto.setVertexBufferBindings = function setVertexBufferBindings(vertexBufferBindings, firstIndex) {
        if (firstIndex === void 0) firstIndex = 0;
        var bindings = this.vertexBufferBindings;
        var count = vertexBufferBindings.length;
        var needLength = firstIndex + count;
        bindings.length < needLength && (bindings.length = needLength);
        for(var i = 0; i < count; i++){
            this.setVertexBufferBinding(firstIndex + i, vertexBufferBindings[i]);
        }
    };
    _proto.setIndexBufferBinding = function setIndexBufferBinding(binding) {
        var lastBinding = this.indexBufferBinding;
        var referCount = this._getReferCount();
        if (lastBinding !== binding) {
            this._indexBufferBinding = binding;
            referCount > 0 && (lastBinding == null ? void 0 : lastBinding.buffer._addReferCount(-referCount));
            if (binding) {
                referCount > 0 && binding.buffer._addReferCount(referCount);
                this._glIndexType = BufferUtil._getGLIndexType(binding.format);
                this._glIndexByteCount = BufferUtil._getGLIndexByteCount(binding.format);
            } else {
                this._glIndexType = undefined;
            }
            this._bufferStructChanged = (lastBinding == null ? void 0 : lastBinding.buffer) !== (binding == null ? void 0 : binding.buffer);
        }
    };
    _proto.draw = function draw(shaderProgram, subMesh) {
        this._platformPrimitive.draw(shaderProgram, subMesh);
        this._bufferStructChanged = false;
    };
    _proto._addReferCount = function _addReferCount(value) {
        var _this_indexBufferBinding;
        GraphicsResource.prototype._addReferCount.call(this, value);
        var vertexBufferBindings = this.vertexBufferBindings;
        for(var i = 0, n = vertexBufferBindings.length; i < n; i++){
            var _vertexBufferBindings_i;
            (_vertexBufferBindings_i = vertexBufferBindings[i]) == null ? void 0 : _vertexBufferBindings_i.buffer._addReferCount(value);
        }
        (_this_indexBufferBinding = this.indexBufferBinding) == null ? void 0 : _this_indexBufferBinding._buffer._addReferCount(value);
    };
    _proto._rebuild = function _rebuild() {
        this._engine._hardwareRenderer.createPlatformPrimitive(this);
        this._isContentLost = false;
    };
    _proto._onDestroy = function _onDestroy() {
        GraphicsResource.prototype._onDestroy.call(this);
        this._platformPrimitive.destroy();
        this._vertexElementMap = null;
    };
    _create_class$2(Primitive, [
        {
            key: "vertexElements",
            get: function get() {
                return this._vertexElements;
            }
        },
        {
            key: "indexBufferBinding",
            get: function get() {
                return this._indexBufferBinding;
            }
        }
    ]);
    return Primitive;
}(GraphicsResource);

/**
 * Mesh.
 */ var Mesh = /*#__PURE__*/ function(ReferResource) {
    _inherits$2(Mesh, ReferResource);
    function Mesh(engine, name) {
        var _this;
        _this = ReferResource.call(this, engine) || this, /** @internal */ _this._updateFlagManager = new UpdateFlagManager(), _this._bounds = new BoundingBox(), _this._subMeshes = [];
        _this.name = name;
        _this._primitive = new Primitive(engine);
        _this._onBoundsChanged = _this._onBoundsChanged.bind(_this);
        var bounds = _this._bounds;
        // @ts-ignore
        bounds.min._onValueChanged = _this._onBoundsChanged;
        // @ts-ignore
        bounds.max._onValueChanged = _this._onBoundsChanged;
        return _this;
    }
    var _proto = Mesh.prototype;
    _proto.addSubMesh = function addSubMesh(startOrSubMesh, count, topology) {
        if (topology === void 0) topology = MeshTopology.Triangles;
        if (typeof startOrSubMesh === "number") {
            startOrSubMesh = new SubMesh(startOrSubMesh, count, topology);
        }
        this._subMeshes.push(startOrSubMesh);
        return startOrSubMesh;
    };
    /**
   * Remove sub-mesh.
   * @param subMesh - Sub-mesh needs to be removed
   */ _proto.removeSubMesh = function removeSubMesh(subMesh) {
        var subMeshes = this._subMeshes;
        var index = subMeshes.indexOf(subMesh);
        if (index !== -1) {
            subMeshes.splice(index, 1);
        }
    };
    /**
   * Clear all sub-mesh.
   */ _proto.clearSubMesh = function clearSubMesh() {
        this._subMeshes.length = 0;
    };
    /**
   * @internal
   */ _proto._clearVertexElements = function _clearVertexElements() {
        this._primitive.clearVertexElements();
        this._updateFlagManager.dispatch(2);
    };
    /**
   * @internal
   */ _proto._addVertexElement = function _addVertexElement(element) {
        this._primitive.addVertexElement(element);
        this._updateFlagManager.dispatch(2);
    };
    /**
   * @internal
   */ _proto._removeVertexElement = function _removeVertexElement(index) {
        this._primitive.removeVertexElement(index);
        this._updateFlagManager.dispatch(2);
    };
    /**
   * @internal
   * @remarks should use together with `_setVertexElementsLength`
   */ _proto._setVertexElement = function _setVertexElement(index, element) {
        this._primitive.setVertexElement(index, element);
        this._updateFlagManager.dispatch(2);
    };
    /**
   * @internal
   *
   */ _proto._setVertexElementsLength = function _setVertexElementsLength(length) {
        this._primitive.setVertexElementsLength(length);
    };
    /**
   * @internal
   */ _proto._setVertexBufferBinding = function _setVertexBufferBinding(index, binding) {
        this._primitive.setVertexBufferBinding(index, binding);
    };
    _proto._addReferCount = function _addReferCount(value) {
        ReferResource.prototype._addReferCount.call(this, value);
        this._primitive._addReferCount(value);
    };
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        ReferResource.prototype._onDestroy.call(this);
        this._primitive.destroy();
    };
    /**
   * @internal
   */ _proto._setVertexElements = function _setVertexElements(elements) {
        this._clearVertexElements();
        for(var i = 0, n = elements.length; i < n; i++){
            this._addVertexElement(elements[i]);
        }
    };
    /**
   * @internal
   */ _proto._setIndexBufferBinding = function _setIndexBufferBinding(binding) {
        this._primitive.setIndexBufferBinding(binding);
    };
    _proto._onBoundsChanged = function _onBoundsChanged() {
        this._updateFlagManager.dispatch(1);
    };
    _create_class$2(Mesh, [
        {
            key: "bounds",
            get: /**
   * The bounding volume of the mesh.
   */ function get() {
                return this._bounds;
            },
            set: function set(value) {
                if (this._bounds !== value) {
                    this._bounds.copyFrom(value);
                }
            }
        },
        {
            key: "subMesh",
            get: /**
   * First sub-mesh. Rendered using the first material.
   */ function get() {
                return this._subMeshes[0] || null;
            }
        },
        {
            key: "subMeshes",
            get: /**
   * A collection of sub-mesh, each sub-mesh can be rendered with an independent material.
   */ function get() {
                return this._subMeshes;
            }
        }
    ]);
    return Mesh;
}(ReferResource);
/**
 * @internal
 */ var MeshModifyFlags = /*#__PURE__*/ function(MeshModifyFlags) {
    MeshModifyFlags[MeshModifyFlags["Bounds"] = 1] = "Bounds";
    MeshModifyFlags[MeshModifyFlags["VertexElements"] = 2] = "VertexElements";
    return MeshModifyFlags;
}({});

/**
 * Vertex buffer binding.
 */ var VertexBufferBinding = /*#__PURE__*/ function() {
    function VertexBufferBinding(buffer, stride) {
        this._buffer = buffer;
        this._stride = stride;
    }
    _create_class$2(VertexBufferBinding, [
        {
            key: "buffer",
            get: /**
   * Vertex buffer.
   */ function get() {
                return this._buffer;
            }
        },
        {
            key: "stride",
            get: /**
   * Vertex buffer stride.
   */ function get() {
                return this._stride;
            }
        }
    ]);
    return VertexBufferBinding;
}();

/**
 * BufferMesh.
 */ var BufferMesh = /*#__PURE__*/ function(Mesh) {
    _inherits$2(BufferMesh, Mesh);
    function BufferMesh() {
        return Mesh.apply(this, arguments) || this;
    }
    var _proto = BufferMesh.prototype;
    /**
   * Set vertex elements.
   * @param elements - Vertex element collection
   */ _proto.setVertexElements = function setVertexElements(elements) {
        this._setVertexElements(elements);
    };
    _proto.setVertexBufferBinding = function setVertexBufferBinding(bufferOrBinding, strideOrFirstIndex, index) {
        if (strideOrFirstIndex === void 0) strideOrFirstIndex = 0;
        if (index === void 0) index = 0;
        var binding = bufferOrBinding;
        var isBinding = binding.buffer !== undefined;
        isBinding || (binding = new VertexBufferBinding(bufferOrBinding, strideOrFirstIndex));
        var bindings = this._primitive.vertexBufferBindings;
        bindings.length <= index && (bindings.length = index + 1);
        this._setVertexBufferBinding(isBinding ? strideOrFirstIndex : index, binding);
    };
    /**
   * Set vertex buffer binding.
   * @param vertexBufferBindings - Vertex buffer binding
   * @param firstIndex - First vertex buffer index, the default value is 0
   */ _proto.setVertexBufferBindings = function setVertexBufferBindings(vertexBufferBindings, firstIndex) {
        if (firstIndex === void 0) firstIndex = 0;
        var bindings = this._primitive.vertexBufferBindings;
        var count = vertexBufferBindings.length;
        var needLength = firstIndex + count;
        bindings.length < needLength && (bindings.length = needLength);
        for(var i = 0; i < count; i++){
            this._setVertexBufferBinding(firstIndex + i, vertexBufferBindings[i]);
        }
    };
    _proto.setIndexBufferBinding = function setIndexBufferBinding(bufferOrBinding, format) {
        var binding = bufferOrBinding;
        if (binding) {
            var isBinding = binding.buffer !== undefined;
            isBinding || (binding = new IndexBufferBinding(bufferOrBinding, format));
        }
        this._setIndexBufferBinding(binding);
    };
    _create_class$2(BufferMesh, [
        {
            key: "instanceCount",
            get: /**
   * Instanced count, disable instanced drawing when set zero.
   */ function get() {
                return this._primitive.instanceCount;
            },
            set: function set(value) {
                this._primitive.instanceCount = value;
            }
        },
        {
            key: "vertexBufferBindings",
            get: /**
   * Vertex buffer binding collection.
   */ function get() {
                return this._primitive.vertexBufferBindings;
            }
        },
        {
            key: "indexBufferBinding",
            get: /**
   * Index buffer binding.
   */ function get() {
                return this._primitive.indexBufferBinding;
            }
        },
        {
            key: "vertexElements",
            get: /**
   * Vertex element collection.
   */ function get() {
                return this._primitive.vertexElements;
            }
        }
    ]);
    return BufferMesh;
}(Mesh);

/**
 * MeshRenderer Component.
 */ var MeshRenderer = /*#__PURE__*/ function(Renderer) {
    _inherits$2(MeshRenderer, Renderer);
    function MeshRenderer(entity) {
        var _this;
        _this = Renderer.call(this, entity) || this, _this._enableVertexColor = false;
        _this._onMeshChanged = _this._onMeshChanged.bind(_this);
        return _this;
    }
    var _proto = MeshRenderer.prototype;
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        var mesh = this._mesh;
        if (mesh) {
            mesh.destroyed || this._addResourceReferCount(mesh, -1);
            mesh._updateFlagManager.removeListener(this._onMeshChanged);
            this._mesh = null;
        }
        Renderer.prototype._onDestroy.call(this);
    };
    /**
   * @internal
   */ _proto._cloneTo = function _cloneTo(target, srcRoot, targetRoot) {
        Renderer.prototype._cloneTo.call(this, target, srcRoot, targetRoot);
        target.mesh = this._mesh;
    };
    /**
   * @internal
   */ _proto._prepareRender = function _prepareRender(context) {
        if (!this._mesh) {
            Logger.error("mesh is null.");
            return;
        }
        if (this._mesh.destroyed) {
            Logger.error("mesh is destroyed.");
            return;
        }
        Renderer.prototype._prepareRender.call(this, context);
    };
    /**
   * @internal
   */ _proto._updateBounds = function _updateBounds(worldBounds) {
        var mesh = this._mesh;
        if (mesh) {
            var localBounds = mesh.bounds;
            BoundingBox.transform(localBounds, this._transformEntity.transform.worldMatrix, worldBounds);
        } else {
            var worldPosition = this._transformEntity.transform.worldPosition;
            worldBounds.min.copyFrom(worldPosition);
            worldBounds.max.copyFrom(worldPosition);
        }
    };
    /**
   * @internal
   */ _proto._render = function _render(context) {
        var mesh = this._mesh;
        if (this._dirtyUpdateFlag & 2) {
            var shaderData = this.shaderData;
            var vertexElements = mesh._primitive.vertexElements;
            shaderData.disableMacro(MeshRenderer._uvMacro);
            shaderData.disableMacro(MeshRenderer._uv1Macro);
            shaderData.disableMacro(MeshRenderer._normalMacro);
            shaderData.disableMacro(MeshRenderer._tangentMacro);
            shaderData.disableMacro(MeshRenderer._enableVertexColorMacro);
            for(var i = 0, n = vertexElements.length; i < n; i++){
                switch(vertexElements[i].attribute){
                    case "TEXCOORD_0":
                        shaderData.enableMacro(MeshRenderer._uvMacro);
                        break;
                    case "TEXCOORD_1":
                        shaderData.enableMacro(MeshRenderer._uv1Macro);
                        break;
                    case "NORMAL":
                        shaderData.enableMacro(MeshRenderer._normalMacro);
                        break;
                    case "TANGENT":
                        shaderData.enableMacro(MeshRenderer._tangentMacro);
                        break;
                    case "COLOR_0":
                        this._enableVertexColor && shaderData.enableMacro(MeshRenderer._enableVertexColorMacro);
                        break;
                }
            }
            this._dirtyUpdateFlag &= -3;
        }
        var _this = this, materials = _this._materials, engine = _this._engine;
        var subMeshes = mesh.subMeshes;
        var renderElement = engine._renderElementPool.get();
        renderElement.set(this.priority, this._distanceForSort);
        var subRenderElementPool = engine._subRenderElementPool;
        for(var i1 = 0, n1 = subMeshes.length; i1 < n1; i1++){
            var material = materials[i1];
            if (!material) {
                continue;
            }
            if (material.destroyed || material.shader.destroyed) {
                material = this.engine._meshMagentaMaterial;
            }
            var subRenderElement = subRenderElementPool.get();
            subRenderElement.set(this, material, mesh._primitive, subMeshes[i1]);
            renderElement.addSubRenderElement(subRenderElement);
        }
        context.camera._renderPipeline.pushRenderElement(context, renderElement);
    };
    _proto._setMesh = function _setMesh(mesh) {
        var lastMesh = this._mesh;
        if (lastMesh) {
            this._addResourceReferCount(lastMesh, -1);
            lastMesh._updateFlagManager.removeListener(this._onMeshChanged);
        }
        if (mesh) {
            this._addResourceReferCount(mesh, 1);
            mesh._updateFlagManager.addListener(this._onMeshChanged);
            this._dirtyUpdateFlag |= 3;
        }
        this._mesh = mesh;
    };
    _proto._onMeshChanged = function _onMeshChanged(type) {
        type & MeshModifyFlags.Bounds && (this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume);
        type & MeshModifyFlags.VertexElements && (this._dirtyUpdateFlag |= 2);
    };
    _create_class$2(MeshRenderer, [
        {
            key: "mesh",
            get: /**
   * Mesh assigned to the renderer.
   */ function get() {
                return this._mesh;
            },
            set: function set(value) {
                if (this._mesh !== value) {
                    this._setMesh(value);
                }
            }
        },
        {
            key: "enableVertexColor",
            get: /**
   * Whether enable vertex color.
   */ function get() {
                return this._enableVertexColor;
            },
            set: function set(value) {
                if (value !== this._enableVertexColor) {
                    this._dirtyUpdateFlag |= 2;
                    this._enableVertexColor = value;
                }
            }
        }
    ]);
    return MeshRenderer;
}(Renderer);
MeshRenderer._uvMacro = ShaderMacro.getByName("RENDERER_HAS_UV");
MeshRenderer._uv1Macro = ShaderMacro.getByName("RENDERER_HAS_UV1");
MeshRenderer._normalMacro = ShaderMacro.getByName("RENDERER_HAS_NORMAL");
MeshRenderer._tangentMacro = ShaderMacro.getByName("RENDERER_HAS_TANGENT");
MeshRenderer._enableVertexColorMacro = ShaderMacro.getByName("RENDERER_ENABLE_VERTEXCOLOR");
__decorate$1([
    ignoreClone
], MeshRenderer.prototype, "_mesh", void 0);
__decorate$1([
    ignoreClone
], MeshRenderer.prototype, "_onMeshChanged", null);

/**
 * @internal
 */ var BlendShapeManager = /*#__PURE__*/ function() {
    function BlendShapeManager(engine, modelMesh) {
        /** @internal */ this._blendShapeCount = 0;
        /** @internal */ this._blendShapes = [];
        /** @internal */ this._subDataDirtyFlags = [];
        /** @internal */ this._vertexBuffers = [];
        /** @internal */ this._uniformOccupiesCount = 0;
        /** @internal */ this._bufferBindingOffset = -1;
        /** @internal */ this._vertexElementOffset = 0;
        this._useBlendNormal = false;
        this._useBlendTangent = false;
        this._vertexElementCount = 0;
        this._storeInVertexBufferInfo = [];
        this._maxCountSingleVertexBuffer = 0;
        this._lastHostCreatedInfo = new Vector4() // x: blendShapeCount, y: useNormal, z: useBlendTangent, w: vertexCount
        ;
        this._canUseTextureStoreData = true;
        this._dataTextureInfo = new Vector3();
        this._engine = engine;
        this._modelMesh = modelMesh;
        this._canUseTextureStoreData = this._engine._hardwareRenderer.capability.canUseFloatTextureBlendShape;
        this._updateLayoutChange = this._updateLayoutChange.bind(this);
    }
    var _proto = BlendShapeManager.prototype;
    /**
   * @internal
   */ _proto._addBlendShape = function _addBlendShape(blendShape) {
        this._blendShapes.push(blendShape);
        this._blendShapeCount++;
        blendShape._layoutChangeManager.addListener(this._updateLayoutChange);
        this._updateLayoutChange(0, blendShape);
        this._subDataDirtyFlags.push(blendShape._dataChangeManager.createFlag(BoolUpdateFlag));
    };
    /**
   * @internal
   */ _proto._clearBlendShapes = function _clearBlendShapes() {
        var blendShapes = this._blendShapes;
        for(var i = 0, n = blendShapes.length; i < n; i++){
            blendShapes[i]._layoutChangeManager.removeListener(this._updateLayoutChange);
        }
        this._useBlendNormal = false;
        this._useBlendTangent = false;
        this._vertexElementCount = 0;
        this._blendShapes.length = 0;
        this._blendShapeCount = 0;
        var subDataDirtyFlags = this._subDataDirtyFlags;
        for(var i1 = 0, n1 = subDataDirtyFlags.length; i1 < n1; i1++){
            subDataDirtyFlags[i1].destroy();
        }
        subDataDirtyFlags.length = 0;
    };
    /**
   * @internal
   */ _proto._updateShaderData = function _updateShaderData(shaderData, skinnedMeshRenderer) {
        var blendShapeCount = this._blendShapeCount;
        if (blendShapeCount > 0) {
            shaderData.enableMacro(BlendShapeManager._blendShapeMacro);
            if (this._useTextureMode()) {
                shaderData.enableMacro(BlendShapeManager._blendShapeTextureMacro);
                shaderData.setTexture(BlendShapeManager._blendShapeTextureProperty, this._vertexTexture);
                shaderData.setVector3(BlendShapeManager._blendShapeTextureInfoProperty, this._dataTextureInfo);
                shaderData.setFloatArray(BlendShapeManager._blendShapeWeightsProperty, skinnedMeshRenderer.blendShapeWeights);
                shaderData.enableMacro("RENDERER_BLENDSHAPE_COUNT", blendShapeCount.toString());
                this._uniformOccupiesCount = blendShapeCount + 1;
            } else {
                var maxBlendCount = this._getVertexBufferModeSupportCount();
                if (blendShapeCount > maxBlendCount) {
                    var condensedBlendShapeWeights = skinnedMeshRenderer._condensedBlendShapeWeights;
                    if (!condensedBlendShapeWeights) {
                        condensedBlendShapeWeights = new Float32Array(maxBlendCount);
                        skinnedMeshRenderer._condensedBlendShapeWeights = condensedBlendShapeWeights;
                    }
                    this._filterCondensedBlendShapeWeights(skinnedMeshRenderer.blendShapeWeights, condensedBlendShapeWeights);
                    shaderData.setFloatArray(BlendShapeManager._blendShapeWeightsProperty, condensedBlendShapeWeights);
                    this._modelMesh._primitive.enableVAO = false;
                    blendShapeCount = maxBlendCount;
                } else {
                    shaderData.setFloatArray(BlendShapeManager._blendShapeWeightsProperty, skinnedMeshRenderer.blendShapeWeights);
                    this._modelMesh._primitive.enableVAO = true;
                }
                shaderData.disableMacro(BlendShapeManager._blendShapeTextureMacro);
                shaderData.disableMacro("RENDERER_BLENDSHAPE_COUNT");
                this._uniformOccupiesCount = blendShapeCount;
            }
            if (this._useBlendNormal) {
                shaderData.enableMacro(BlendShapeManager._blendShapeNormalMacro);
            } else {
                shaderData.disableMacro(BlendShapeManager._blendShapeNormalMacro);
            }
            if (this._useBlendTangent) {
                shaderData.enableMacro(BlendShapeManager._blendShapeTangentMacro);
            } else {
                shaderData.disableMacro(BlendShapeManager._blendShapeTangentMacro);
            }
        } else {
            shaderData.disableMacro(BlendShapeManager._blendShapeMacro);
            shaderData.disableMacro("RENDERER_BLENDSHAPE_COUNT");
        }
    };
    /**
   * @internal
   */ _proto._useTextureMode = function _useTextureMode() {
        if (!this._canUseTextureStoreData) {
            return false;
        }
        return this._blendShapeCount > this._getVertexBufferModeSupportCount();
    };
    /**
   * @internal
   */ _proto._isCreateHost = function _isCreateHost(vertexCount) {
        var createdInfo = this._lastHostCreatedInfo;
        return createdInfo.x !== this._blendShapeCount || !!createdInfo.y !== this._useBlendNormal || !!createdInfo.z !== this._useBlendTangent || createdInfo.w !== vertexCount;
    };
    /**
   * @internal
   */ _proto._vertexElementsNeedUpdate = function _vertexElementsNeedUpdate() {
        var maxSupportCount = this._getVertexBufferModeSupportCount();
        var info = this._lastHostCreatedInfo;
        return Math.min(info.x, maxSupportCount) !== Math.min(this._blendShapeCount, maxSupportCount) || !!info.y !== this._useBlendNormal || !!info.z !== this._useBlendTangent;
    };
    /**
   * @internal
   */ _proto._needUpdateData = function _needUpdateData() {
        var subDataDirtyFlags = this._subDataDirtyFlags;
        for(var i = 0, n = subDataDirtyFlags.length; i < n; i++){
            if (subDataDirtyFlags[i].flag) {
                return true;
            }
        }
        return false;
    };
    _proto._updateVertexBufferIndex = function _updateVertexBufferIndex() {
        if (this._bufferBindingOffset !== -1) {
            return;
        }
        var modelMesh = this._modelMesh;
        var internalVertexBufferIndex = modelMesh._internalVertexBufferIndex;
        var vertexBufferBindings = modelMesh._primitive.vertexBufferBindings;
        var i = 0;
        var n = Math.max(vertexBufferBindings.length, internalVertexBufferIndex + 1);
        for(; i < n; i++){
            if (!vertexBufferBindings[i] && i !== internalVertexBufferIndex) {
                break;
            }
        }
        this._bufferBindingOffset = i;
    };
    /**
   * @internal
   */ _proto._addVertexElements = function _addVertexElements(modelMesh) {
        this._updateVertexBufferIndex();
        var elementIndex = this._vertexElementOffset;
        var bindingOffset = this._bufferBindingOffset;
        var offset = 0;
        for(var i = 0, n = Math.min(this._blendShapeCount, this._getVertexBufferModeSupportCount()); i < n; i++){
            modelMesh._setVertexElement(elementIndex++, new VertexElement("POSITION_BS" + i, offset, VertexElementFormat.Vector3, bindingOffset));
            offset += 12;
            if (this._useBlendNormal) {
                modelMesh._setVertexElement(elementIndex++, new VertexElement("NORMAL_BS" + i, offset, VertexElementFormat.Vector3, bindingOffset));
                offset += 12;
            }
            if (this._useBlendTangent) {
                modelMesh._setVertexElement(elementIndex++, new VertexElement("TANGENT_BS" + i, offset, VertexElementFormat.Vector3, bindingOffset));
                offset += 12;
            }
        }
        return elementIndex;
    };
    /**
   * @internal
   */ _proto._update = function _update(noLongerReadable) {
        var vertexCount = this._modelMesh.vertexCount;
        var useTexture = this._useTextureMode();
        var createHost = this._isCreateHost(vertexCount);
        if (createHost) {
            if (useTexture) {
                this._createTextureArray(vertexCount);
            } else {
                this._createVertexBuffers(vertexCount, noLongerReadable);
            }
            this._lastHostCreatedInfo.set(this._blendShapeCount, +this._useBlendNormal, +this._useBlendTangent, vertexCount);
        }
        if (this._needUpdateData()) {
            if (useTexture) {
                this._updateTextureArray(vertexCount, createHost);
            } else {
                this._updateVertexBuffers(vertexCount, createHost);
            }
        }
    };
    /**
   * @internal
   */ _proto._releaseMemoryCache = function _releaseMemoryCache() {
        var blendShapes = this._blendShapes;
        for(var i = 0, n = blendShapes.length; i < n; i++){
            blendShapes[i]._releaseData();
        }
        this._vertices = null;
    };
    _proto._createVertexBuffers = function _createVertexBuffers(vertexCount, noLongerAccessible) {
        var _this = this, engine = _this._engine, modelMesh = _this._modelMesh, blendShapeCount = _this._blendShapeCount, vertexBuffers = _this._vertexBuffers;
        var vertexFloatCount = this._vertexElementCount * 3;
        var vertexByteCount = vertexFloatCount * 4;
        var maxCountSingleBuffer = Math.floor(255 / vertexByteCount); // 255: Attribute MaxStride
        var bufferCount = Math.ceil(blendShapeCount / maxCountSingleBuffer);
        var floatCount = vertexFloatCount * vertexCount * Math.min(maxCountSingleBuffer, blendShapeCount);
        vertexBuffers.length = bufferCount;
        this._vertices = new Float32Array(floatCount);
        this._maxCountSingleVertexBuffer = maxCountSingleBuffer;
        this._storeInVertexBufferInfo.length = blendShapeCount;
        var bufferBindingOffset = this._bufferBindingOffset;
        for(var i = 0; i < bufferCount; i++){
            var lastIndex = bufferCount - 1;
            var containCount = i === lastIndex ? blendShapeCount - lastIndex * maxCountSingleBuffer : maxCountSingleBuffer;
            var stride = containCount * vertexByteCount;
            var byteLength = stride * vertexCount;
            var usage = noLongerAccessible ? BufferUsage.Static : BufferUsage.Dynamic;
            var blendShapeBuffer = new Buffer(engine, BufferBindFlag.VertexBuffer, byteLength, usage);
            modelMesh._setVertexBufferBinding(bufferBindingOffset + i, new VertexBufferBinding(blendShapeBuffer, stride));
            vertexBuffers[i] = blendShapeBuffer;
        }
    };
    _proto._createTextureArray = function _createTextureArray(vertexCount) {
        var maxTextureSize = this._engine._hardwareRenderer.capability.maxTextureSize;
        var vertexPixelStride = this._vertexElementCount;
        var textureWidth = vertexPixelStride * vertexCount;
        var textureHeight = 1;
        if (textureWidth > maxTextureSize) {
            textureHeight = Math.ceil(textureWidth / maxTextureSize);
            textureWidth = maxTextureSize;
        }
        var blendShapeDataTexture = this._vertexTexture;
        var blendShapeCount = this._blendShapes.length;
        blendShapeDataTexture && blendShapeDataTexture.destroy();
        blendShapeDataTexture = new Texture2DArray(this._engine, textureWidth, textureHeight, blendShapeCount, TextureFormat.R32G32B32A32, false, false);
        blendShapeDataTexture.filterMode = TextureFilterMode.Point;
        this._vertices = new Float32Array(blendShapeCount * textureWidth * textureHeight * 4);
        this._vertexTexture = blendShapeDataTexture;
        this._dataTextureInfo.set(vertexPixelStride, textureWidth, textureHeight);
    };
    /**
   * @internal
   */ _proto._updateVertexBuffers = function _updateVertexBuffers(vertexCount, force) {
        var _this = this, blendShapes = _this._blendShapes, maxCountSingleBuffer = _this._maxCountSingleVertexBuffer;
        var _this1 = this, vertices = _this1._vertices, vertexBuffers = _this1._vertexBuffers, storeInfos = _this1._storeInVertexBufferInfo;
        var subDataDirtyFlags = this._subDataDirtyFlags;
        var blendShapeFloatStride = this._vertexElementCount * 3;
        var blendShapeByteStride = blendShapeFloatStride * 4;
        var bufferOffset = this._bufferBindingOffset;
        // @todo: should fix bug when dataChangedFlag is true
        for(var i = 0, n = blendShapes.length; i < n; i++){
            var dataChangedFlag = subDataDirtyFlags[i];
            if (force || dataChangedFlag.flag) {
                var frames = blendShapes[i].frames;
                var frameCount = frames.length;
                var endFrame = frames[frameCount - 1];
                if (frameCount > 0 && endFrame.deltaPositions.length !== vertexCount) {
                    throw "BlendShape frame deltaPositions length must same with mesh vertexCount.";
                }
                var bufferIndex = Math.floor(i / maxCountSingleBuffer);
                var indexInBuffer = i % maxCountSingleBuffer;
                var buffer = vertexBuffers[bufferIndex];
                var bufferFloatStride = buffer.byteLength / (vertexCount * 4);
                var offset = indexInBuffer * blendShapeFloatStride;
                var storeInfo = storeInfos[i];
                storeInfo || (storeInfos[i] = storeInfo = new Vector2());
                storeInfo.set(bufferOffset + bufferIndex, indexInBuffer * blendShapeByteStride); // BufferOffset is mesh vertexBuffer offset
                var deltaPositions = endFrame.deltaPositions;
                for(var j = 0; j < vertexCount; j++){
                    var start = offset + bufferFloatStride * j;
                    var deltaPosition = deltaPositions[j];
                    if (deltaPosition) {
                        vertices[start] = deltaPosition.x;
                        vertices[start + 1] = deltaPosition.y;
                        vertices[start + 2] = deltaPosition.z;
                    }
                }
                offset += 3;
                if (this._useBlendNormal) {
                    var deltaNormals = endFrame.deltaNormals;
                    if (deltaNormals) {
                        for(var j1 = 0; j1 < vertexCount; j1++){
                            var start1 = offset + bufferFloatStride * j1;
                            var deltaNormal = deltaNormals[j1];
                            if (deltaNormal) {
                                vertices[start1] = deltaNormal.x;
                                vertices[start1 + 1] = deltaNormal.y;
                                vertices[start1 + 2] = deltaNormal.z;
                            }
                        }
                    }
                    offset += 3;
                }
                if (this._useBlendTangent) {
                    var deltaTangents = endFrame.deltaTangents;
                    if (deltaTangents) {
                        for(var j2 = 0; j2 < vertexCount; j2++){
                            var start2 = offset + bufferFloatStride * j2;
                            var deltaTangent = deltaTangents[j2];
                            if (deltaTangent) {
                                vertices[start2] = deltaTangent.x;
                                vertices[start2 + 1] = deltaTangent.y;
                                vertices[start2 + 2] = deltaTangent.z;
                            }
                        }
                    }
                    offset += 3;
                }
                if (indexInBuffer === maxCountSingleBuffer - 1 || i === n - 1) {
                    // @todo: can optimize in setData
                    buffer.setData(vertices, 0, 0, buffer.byteLength / 4);
                }
                dataChangedFlag.flag = false;
            }
        }
    };
    _proto._updateTextureArray = function _updateTextureArray(vertexCount, force) {
        var _this = this, blendShapes = _this._blendShapes, vertexTexture = _this._vertexTexture, vertices = _this._vertices, subDataDirtyFlags = _this._subDataDirtyFlags;
        for(var i = 0, n = blendShapes.length; i < n; i++){
            var subDirtyFlag = subDataDirtyFlags[i];
            var subBlendShapeDataStride = vertexTexture.width * vertexTexture.height * 4;
            if (force || subDirtyFlag.flag) {
                var frames = blendShapes[i].frames;
                var frameCount = frames.length;
                var endFrame = frames[frameCount - 1];
                if (frameCount > 0 && endFrame.deltaPositions.length !== vertexCount) {
                    throw "BlendShape frame deltaPositions length must same with mesh vertexCount.";
                }
                var deltaPositions = endFrame.deltaPositions, deltaNormals = endFrame.deltaNormals, deltaTangents = endFrame.deltaTangents;
                var offset = i * subBlendShapeDataStride;
                for(var j = 0; j < vertexCount; j++){
                    var position = deltaPositions[j];
                    vertices[offset] = position.x;
                    vertices[offset + 1] = position.y;
                    vertices[offset + 2] = position.z;
                    offset += 4;
                    if (deltaNormals) {
                        var normal = deltaNormals[j];
                        vertices[offset] = normal.x;
                        vertices[offset + 1] = normal.y;
                        vertices[offset + 2] = normal.z;
                        offset += 4;
                    }
                    if (deltaTangents) {
                        var tangent = deltaTangents[j];
                        vertices[offset] = tangent.x;
                        vertices[offset + 1] = tangent.y;
                        vertices[offset + 2] = tangent.z;
                        offset += 4;
                    }
                }
                subDirtyFlag.flag = false;
            }
        }
        vertexTexture.setPixelBuffer(0, vertices);
    };
    _proto._updateLayoutChange = function _updateLayoutChange(type, blendShape) {
        var notFirst = this._blendShapeCount > 1;
        var vertexElementCount = 1;
        var useBlendNormal = blendShape._useBlendShapeNormal;
        var useBlendTangent = blendShape._useBlendShapeTangent;
        if (notFirst) {
            useBlendNormal && (useBlendNormal = this._useBlendNormal);
            useBlendTangent && (useBlendTangent = this._useBlendTangent);
        }
        useBlendNormal && vertexElementCount++;
        useBlendTangent && vertexElementCount++;
        this._useBlendNormal = useBlendNormal;
        this._useBlendTangent = useBlendTangent;
        this._vertexElementCount = vertexElementCount;
    };
    _proto._attributeModeUpdateVertexElement = function _attributeModeUpdateVertexElement(vertexElements, vertexBufferStoreInfo, index, condensedIndex) {
        var elementOffset = this._vertexElementOffset + this._vertexElementCount * condensedIndex;
        var _vertexBufferStoreInfo_index = vertexBufferStoreInfo[index], bufferIndex = _vertexBufferStoreInfo_index.x, offset = _vertexBufferStoreInfo_index.y;
        var vertexElement = vertexElements[elementOffset];
        vertexElement.bindingIndex = bufferIndex;
        vertexElement.offset = offset;
        if (this._useBlendNormal) {
            var vertexElement1 = vertexElements[++elementOffset];
            offset += 12;
            vertexElement1.bindingIndex = bufferIndex;
            vertexElement1.offset = offset;
        }
        if (this._useBlendTangent) {
            var vertexElement2 = vertexElements[++elementOffset];
            offset += 12;
            vertexElement2.bindingIndex = bufferIndex;
            vertexElement2.offset = offset;
        }
    };
    _proto._getVertexBufferModeSupportCount = function _getVertexBufferModeSupportCount() {
        if (this._useBlendNormal && this._useBlendTangent) {
            return 2;
        } else {
            return this._useBlendNormal || this._useBlendTangent ? 4 : 8;
        }
    };
    _proto._filterCondensedBlendShapeWeights = function _filterCondensedBlendShapeWeights(blendShapeWeights, condensedBlendShapeWeights) {
        var condensedWeightsCount = condensedBlendShapeWeights.length;
        var vertexElements = this._modelMesh._primitive.vertexElements;
        var vertexBufferStoreInfo = this._storeInVertexBufferInfo;
        var thresholdWeight = Number.POSITIVE_INFINITY;
        var thresholdIndex;
        for(var i = 0, n = Math.min(blendShapeWeights.length, this._blendShapeCount); i < n; i++){
            var weight = blendShapeWeights[i];
            if (i < condensedWeightsCount) {
                this._attributeModeUpdateVertexElement(vertexElements, vertexBufferStoreInfo, i, i);
                condensedBlendShapeWeights[i] = weight;
                if (weight < thresholdWeight) {
                    thresholdWeight = weight;
                    thresholdIndex = i;
                }
            } else if (weight > thresholdWeight) {
                this._attributeModeUpdateVertexElement(vertexElements, vertexBufferStoreInfo, i, thresholdIndex);
                condensedBlendShapeWeights[thresholdIndex] = weight;
                thresholdWeight = Number.POSITIVE_INFINITY;
                for(var j = 0; j < condensedWeightsCount; j++){
                    var condensedWeight = condensedBlendShapeWeights[j];
                    if (condensedWeight < thresholdWeight) {
                        thresholdWeight = condensedWeight;
                        thresholdIndex = j;
                    }
                }
            }
        }
    };
    return BlendShapeManager;
}();
BlendShapeManager._blendShapeMacro = ShaderMacro.getByName("RENDERER_HAS_BLENDSHAPE");
BlendShapeManager._blendShapeTextureMacro = ShaderMacro.getByName("RENDERER_BLENDSHAPE_USE_TEXTURE");
BlendShapeManager._blendShapeNormalMacro = ShaderMacro.getByName("RENDERER_BLENDSHAPE_HAS_NORMAL");
BlendShapeManager._blendShapeTangentMacro = ShaderMacro.getByName("RENDERER_BLENDSHAPE_HAS_TANGENT");
BlendShapeManager._blendShapeWeightsProperty = ShaderProperty.getByName("renderer_BlendShapeWeights");
BlendShapeManager._blendShapeTextureProperty = ShaderProperty.getByName("renderer_BlendShapeTexture");
BlendShapeManager._blendShapeTextureInfoProperty = ShaderProperty.getByName("renderer_BlendShapeTextureInfo");

/**
 * Vertex attribute types of a vertex in a ModelMesh.
 */ var VertexAttribute = /*#__PURE__*/ function(VertexAttribute) {
    /** Vertex position. */ VertexAttribute["Position"] = "POSITION";
    /** Vertex normal. */ VertexAttribute["Normal"] = "NORMAL";
    /** Vertex color. */ VertexAttribute["Color"] = "COLOR_0";
    /** Vertex tangent. */ VertexAttribute["Tangent"] = "TANGENT";
    /** Vertex bone weight. */ VertexAttribute["BoneWeight"] = "WEIGHTS_0";
    /** Vertex bone index. */ VertexAttribute["BoneIndex"] = "JOINTS_0";
    /** Vertex UV. */ VertexAttribute["UV"] = "TEXCOORD_0";
    /** Vertex UV1. */ VertexAttribute["UV1"] = "TEXCOORD_1";
    /** Vertex UV2. */ VertexAttribute["UV2"] = "TEXCOORD_2";
    /** Vertex UV3. */ VertexAttribute["UV3"] = "TEXCOORD_3";
    /** Vertex UV4. */ VertexAttribute["UV4"] = "TEXCOORD_4";
    /** Vertex UV5. */ VertexAttribute["UV5"] = "TEXCOORD_5";
    /** Vertex UV6. */ VertexAttribute["UV6"] = "TEXCOORD_6";
    /** Vertex UV7. */ VertexAttribute["UV7"] = "TEXCOORD_7";
    return VertexAttribute;
}({});

/**
 * Mesh containing common vertex elements of the model.
 */ var ModelMesh = /*#__PURE__*/ function(Mesh) {
    _inherits$2(ModelMesh, Mesh);
    function ModelMesh(engine, name) {
        var _this;
        _this = Mesh.call(this, engine) || this, /** @internal */ _this._internalVertexBufferIndex = -1, _this._vertexCount = 0, _this._vertexCountDirty = false, _this._dataVersionCounter = 0, _this._positions = null, _this._normals = null, _this._colors = null, _this._tangents = null, _this._uv = null, _this._uv1 = null, _this._uv2 = null, _this._uv3 = null, _this._uv4 = null, _this._uv5 = null, _this._uv6 = null, _this._uv7 = null, _this._boneWeights = null, _this._boneIndices = null, _this._advancedElementUpdateFlag = 0, _this._advancedDataUpdateFlag = 0, _this._advancedVertexDataVersions = new Array(14) // Only have 14 vertex element can set advanced data
        , _this._advancedDataSyncToBuffer = false, _this._internalVertexBufferStride = 0, _this._internalVertexBufferCreatedInfo = new Vector3(0, 0, -1) // x:vertexCount, y:vertexStride, z:bufferIndex
        , _this._internalVertexElementsOffset = 0, _this._internalVertexElementsFlags = 0, _this._vertexBufferInfos = [], _this._indices = null, _this._indicesFormat = null, _this._indicesChangeFlag = false, /** @deprecated */ _this._accessible = true;
        _this.name = name;
        _this._blendShapeManager = new BlendShapeManager(engine, _this);
        return _this;
    }
    var _proto = ModelMesh.prototype;
    /**
   * Set positions for the mesh.
   * @param positions - The positions for the mesh
   */ _proto.setPositions = function setPositions(positions) {
        if (!this._positions && !positions) {
            return;
        }
        this._updateAdvancedVertexDataMarks(1, 0);
        this._positions = positions;
        var _positions_length;
        this._vertexCount = (_positions_length = positions == null ? void 0 : positions.length) != null ? _positions_length : 0;
        this._vertexCountDirty = false;
    };
    /**
   * Get positions for the mesh.
   * @remarks Please call the setPositions() method after modification to ensure that the modification takes effect.
   */ _proto.getPositions = function getPositions() {
        var positions = this._getVertexElementData(this._positions, VertexAttribute.Position, 0, this._readVector3VertexData);
        this._positions = positions;
        return positions;
    };
    /**
   * Set per-vertex normals for the mesh.
   * @param normals - The normals for the mesh
   */ _proto.setNormals = function setNormals(normals) {
        this._beforeSetAdvancedVertexData(normals, 2, 1);
        this._normals = normals;
    };
    /**
   * Get normals for the mesh.
   * @remarks Please call the setNormals() method after modification to ensure that the modification takes effect.
   */ _proto.getNormals = function getNormals() {
        var normals = this._getVertexElementData(this._normals, VertexAttribute.Normal, 1, this._readVector3VertexData);
        this._normals = normals;
        return normals;
    };
    /**
   * Set per-vertex colors for the mesh.
   * @param colors - The colors for the mesh
   */ _proto.setColors = function setColors(colors) {
        this._beforeSetAdvancedVertexData(colors, 4, 2);
        this._colors = colors;
    };
    /**
   * Get colors for the mesh.
   * @remarks Please call the setColors() method after modification to ensure that the modification takes effect.
   */ _proto.getColors = function getColors() {
        var colors = this._getVertexElementData(this._colors, VertexAttribute.Color, 2, this._readColorVertexData);
        this._colors = colors;
        return colors;
    };
    /**
   * Set per-vertex bone weights for the mesh.
   * @param boneWeights - The bone weights for the mesh
   */ _proto.setBoneWeights = function setBoneWeights(boneWeights) {
        this._beforeSetAdvancedVertexData(boneWeights, 16, 4);
        this._boneWeights = boneWeights;
    };
    /**
   * Get bone weights for the mesh.
   * @remarks Please call the setWeights() method after modification to ensure that the modification takes effect.
   */ _proto.getBoneWeights = function getBoneWeights() {
        var boneWeights = this._getVertexElementData(this._boneWeights, VertexAttribute.BoneWeight, 4, this._readVector4VertexData);
        this._boneWeights = boneWeights;
        return boneWeights;
    };
    /**
   * Set per-vertex bone indices for the mesh.
   * @param boneIndices - The bone indices for the mesh
   */ _proto.setBoneIndices = function setBoneIndices(boneIndices) {
        this._beforeSetAdvancedVertexData(boneIndices, 32, 5);
        this._boneIndices = boneIndices;
    };
    /**
   * Get bone indices for the mesh.
   * @remarks Please call the setBoneIndices() method after modification to ensure that the modification takes effect.
   */ _proto.getBoneIndices = function getBoneIndices() {
        var boneIndices = this._getVertexElementData(this._boneIndices, VertexAttribute.BoneIndex, 5, this._readVector4VertexData);
        this._boneIndices = boneIndices;
        return boneIndices;
    };
    /**
   * Set per-vertex tangents for the mesh.
   * @param tangents - The tangents for the mesh
   */ _proto.setTangents = function setTangents(tangents) {
        this._beforeSetAdvancedVertexData(tangents, 8, 3);
        this._tangents = tangents;
    };
    /**
   * Get tangents for the mesh.
   * @remarks Please call the setTangents() method after modification to ensure that the modification takes effect.
   */ _proto.getTangents = function getTangents() {
        var tangents = this._getVertexElementData(this._tangents, VertexAttribute.Tangent, 3, this._readVector4VertexData);
        this._tangents = tangents;
        return tangents;
    };
    _proto.setUVs = function setUVs(uv, channelIndex) {
        channelIndex = channelIndex != null ? channelIndex : 0;
        switch(channelIndex){
            case 0:
                this._beforeSetAdvancedVertexData(uv, 64, 6);
                this._uv = uv;
                break;
            case 1:
                this._beforeSetAdvancedVertexData(uv, 128, 7);
                this._uv1 = uv;
                break;
            case 2:
                this._beforeSetAdvancedVertexData(uv, 256, 8);
                this._uv2 = uv;
                break;
            case 3:
                this._beforeSetAdvancedVertexData(uv, 512, 9);
                this._uv3 = uv;
                break;
            case 4:
                this._beforeSetAdvancedVertexData(uv, 1024, 10);
                this._uv4 = uv;
                break;
            case 5:
                this._beforeSetAdvancedVertexData(uv, 2048, 11);
                this._uv5 = uv;
                break;
            case 6:
                this._beforeSetAdvancedVertexData(uv, 4096, 12);
                this._uv6 = uv;
                break;
            case 7:
                this._beforeSetAdvancedVertexData(uv, 8192, 13);
                this._uv7 = uv;
                break;
            default:
                throw "The index of channel needs to be in range [0 - 7].";
        }
    };
    _proto.getUVs = function getUVs(channelIndex) {
        channelIndex = channelIndex != null ? channelIndex : 0;
        switch(channelIndex){
            case 0:
                var uvs = this._getVertexElementData(this._uv, VertexAttribute.UV, 6, this._readVector2VertexData);
                this._uv = uvs;
                return uvs;
            case 1:
                var uv1s = this._getVertexElementData(this._uv1, VertexAttribute.UV1, 7, this._readVector2VertexData);
                this._uv1 = uv1s;
                return uv1s;
            case 2:
                var uv2s = this._getVertexElementData(this._uv2, VertexAttribute.UV2, 8, this._readVector2VertexData);
                this._uv2 = uv2s;
                return uv2s;
            case 3:
                var uv3s = this._getVertexElementData(this._uv3, VertexAttribute.UV3, 9, this._readVector2VertexData);
                this._uv3 = uv3s;
                return uv3s;
            case 4:
                var uv4s = this._getVertexElementData(this._uv4, VertexAttribute.UV4, 10, this._readVector2VertexData);
                this._uv4 = uv4s;
                return uv4s;
            case 5:
                var uv5s = this._getVertexElementData(this._uv5, VertexAttribute.UV5, 11, this._readVector2VertexData);
                this._uv5 = uv5s;
                return uv5s;
            case 6:
                var uv6s = this._getVertexElementData(this._uv6, VertexAttribute.UV6, 12, this._readVector2VertexData);
                this._uv6 = uv6s;
                return uv6s;
            case 7:
                var uv7s = this._getVertexElementData(this._uv7, VertexAttribute.UV7, 13, this._readVector2VertexData);
                this._uv7 = uv7s;
                return uv7s;
        }
        throw "The index of channel needs to be in range [0 - 7].";
    };
    /**
   * Set indices for the mesh.
   * @param indices - The indices for the mesh
   */ _proto.setIndices = function setIndices(indices) {
        if (this._indices !== indices) {
            this._indices = indices;
            if (_instanceof$3(indices, Uint8Array)) {
                this._indicesFormat = IndexFormat.UInt8;
            } else if (_instanceof$3(indices, Uint16Array)) {
                this._indicesFormat = IndexFormat.UInt16;
            } else if (_instanceof$3(indices, Uint32Array)) {
                this._indicesFormat = IndexFormat.UInt32;
            }
        }
        this._indicesChangeFlag = true;
    };
    /**
   * Get indices for the mesh.
   */ _proto.getIndices = function getIndices() {
        if (!this._accessible) {
            throw "Not allowed to access data while accessible is false.";
        }
        return this._indices;
    };
    /**
   * Set vertex elements.
   * @param elements - Vertex element collection
   *
   * @remarks
   * Call this method will clear the vertex data set by the setPositions(), setNormals(), setColors(), setBoneWeights(), setBoneIndices(), setTangents(), setUVs() methods.
   */ _proto.setVertexElements = function setVertexElements(elements) {
        this._clearVertexElements();
        var count = elements.length;
        for(var i = 0; i < count; i++){
            this._addVertexElement(elements[i]);
        }
        // Clear data if vertex element not contains
        var vertexElementMap = this._primitive._vertexElementMap;
        vertexElementMap[VertexAttribute.Position] || this.setPositions(null);
        vertexElementMap[VertexAttribute.Normal] || this.setNormals(null);
        vertexElementMap[VertexAttribute.Color] || this.setColors(null);
        vertexElementMap[VertexAttribute.BoneWeight] || this.setBoneWeights(null);
        vertexElementMap[VertexAttribute.BoneIndex] || this.setBoneIndices(null);
        vertexElementMap[VertexAttribute.Tangent] || this.setTangents(null);
        vertexElementMap[VertexAttribute.UV] || this.setUVs(null, 0);
        vertexElementMap[VertexAttribute.UV1] || this.setUVs(null, 1);
        vertexElementMap[VertexAttribute.UV2] || this.setUVs(null, 2);
        vertexElementMap[VertexAttribute.UV3] || this.setUVs(null, 3);
        vertexElementMap[VertexAttribute.UV4] || this.setUVs(null, 4);
        vertexElementMap[VertexAttribute.UV5] || this.setUVs(null, 5);
        vertexElementMap[VertexAttribute.UV6] || this.setUVs(null, 6);
        vertexElementMap[VertexAttribute.UV7] || this.setUVs(null, 7);
        // Destroy internal vertex buffer immediately
        var internalVertexBufferIndex = this._internalVertexBufferCreatedInfo.z;
        if (internalVertexBufferIndex !== -1) {
            var _this__primitive_vertexBufferBindings_internalVertexBufferIndex;
            (_this__primitive_vertexBufferBindings_internalVertexBufferIndex = this._primitive.vertexBufferBindings[internalVertexBufferIndex]) == null ? void 0 : _this__primitive_vertexBufferBindings_internalVertexBufferIndex.buffer.destroy();
            this._setVertexBufferBinding(internalVertexBufferIndex, null);
            this._internalVertexBufferCreatedInfo.z = -1;
        }
        this._internalVertexBufferStride = 0;
        this._internalVertexElementsOffset = count;
        this._advancedElementUpdateFlag = 0;
        this._vertexCountDirty = true;
        this._blendShapeManager._bufferBindingOffset = -1;
        this._blendShapeManager._vertexElementOffset = count;
    };
    _proto.setVertexBufferBinding = function setVertexBufferBinding(bufferOrBinding, strideOrIndex, indexOrNull) {
        if (strideOrIndex === void 0) strideOrIndex = 0;
        if (indexOrNull === void 0) indexOrNull = 0;
        var binding = bufferOrBinding;
        var isBinding = binding.buffer !== undefined;
        isBinding || (binding = new VertexBufferBinding(bufferOrBinding, strideOrIndex));
        var index = isBinding ? strideOrIndex : indexOrNull;
        var bindings = this._primitive.vertexBufferBindings;
        var updateInfos = this._vertexBufferInfos;
        var needLength = index + 1;
        if (bindings.length < needLength) {
            bindings.length = needLength;
            updateInfos.length = needLength;
        }
        this._setVertexBufferBinding(index, binding);
        // Reset internal vertex buffer index if by custom buffer binding
        if (index === this._internalVertexBufferIndex) {
            this._internalVertexBufferIndex = -1;
        }
        // Reset blend shape buffer binding offset if by custom buffer binding
        if (index === this._blendShapeManager._bufferBindingOffset) {
            this._blendShapeManager._bufferBindingOffset = -1;
        }
        this._vertexCountDirty = true;
    };
    /**
   * Set vertex buffer binding.
   * @param vertexBufferBindings - Vertex buffer binding
   * @param firstIndex - First vertex buffer index, the default value is 0
   */ _proto.setVertexBufferBindings = function setVertexBufferBindings(vertexBufferBindings, firstIndex) {
        if (firstIndex === void 0) firstIndex = 0;
        var count = vertexBufferBindings.length;
        var bindings = this._primitive.vertexBufferBindings;
        var updateInfos = this._vertexBufferInfos;
        var needLength = firstIndex + count;
        if (bindings.length < needLength) {
            bindings.length = needLength;
            updateInfos.length = needLength;
        }
        for(var i = 0; i < count; i++){
            var index = firstIndex + i;
            this._setVertexBufferBinding(index, vertexBufferBindings[i]);
            // Reset internal vertex buffer index if by custom buffer binding
            if (index === this._internalVertexBufferIndex) {
                this._internalVertexBufferIndex = -1;
            }
            // Reset blend shape buffer binding offset if by custom buffer binding
            if (index === this._blendShapeManager._bufferBindingOffset) {
                this._blendShapeManager._bufferBindingOffset = -1;
            }
        }
        this._vertexCountDirty = true;
    };
    /**
   * Get `VertexElement` by attribute.
   * @param attribute - Vertex attribute
   * @returns Vertex element
   */ _proto.getVertexElement = function getVertexElement(attribute) {
        this._updateVertexElements();
        return this._primitive._vertexElementMap[attribute];
    };
    /**
   * Add a BlendShape for this ModelMesh.
   * @param blendShape - The BlendShape
   */ _proto.addBlendShape = function addBlendShape(blendShape) {
        this._blendShapeManager._addBlendShape(blendShape);
    };
    /**
   * Clear all BlendShapes.
   */ _proto.clearBlendShapes = function clearBlendShapes() {
        this._blendShapeManager._clearBlendShapes();
    };
    /**
   * Get name of BlendShape by given index.
   * @param index - The index of BlendShape
   * @returns The name of BlendShape
   */ _proto.getBlendShapeName = function getBlendShapeName(index) {
        var blendShapes = this._blendShapeManager._blendShapes;
        return blendShapes[index].name;
    };
    /**
   * Upload data to GPU set by `setPositions()`, `setNormals()`, `setColors()`, `setBoneWeights()`, `setBoneIndices()`, `setTangents()`, `setUVs()`, `setIndices()` methods.
   * This method will be auto generate vertex element and vertex buffer binding if needed.
   *
   * @param releaseData - Whether to release the data cache, release data can reduce memory usage.
   */ _proto.uploadData = function uploadData(releaseData) {
        this._updateVertexElements();
        // Shouldn't update buffer data version when sync advanced data to buffer
        this._advancedDataSyncToBuffer = true;
        // Update internal vertex buffer if needed
        this._updateInternalVertexBuffer(releaseData);
        // Update advanced vertex data to buffer
        if (this._advancedDataUpdateFlag & 65535) {
            this._updateAdvancedVertices();
            var vertexBufferInfos = this._vertexBufferInfos;
            var vertexBufferBindings = this._primitive.vertexBufferBindings;
            for(var i = 0, n = vertexBufferBindings.length; i < n; i++){
                var vertexBufferInfo = vertexBufferInfos[i];
                // VertexBufferInfo maybe undefined
                if (vertexBufferInfo == null ? void 0 : vertexBufferInfo.uploadAdvancedData) {
                    var _vertexBufferBindings_i;
                    var buffer = (_vertexBufferBindings_i = vertexBufferBindings[i]) == null ? void 0 : _vertexBufferBindings_i.buffer;
                    buffer.setData(buffer.data);
                    vertexBufferInfo.uploadAdvancedData = false;
                }
            }
        }
        this._advancedDataSyncToBuffer = false;
        if (this._indicesChangeFlag) {
            var _this__primitive_indexBufferBinding;
            var _this = this, indices = _this._indices;
            var indexBuffer = (_this__primitive_indexBufferBinding = this._primitive.indexBufferBinding) == null ? void 0 : _this__primitive_indexBufferBinding._buffer;
            if (indices) {
                if (!indexBuffer || indices.byteLength != indexBuffer.byteLength) {
                    indexBuffer == null ? void 0 : indexBuffer.destroy();
                    var newIndexBuffer = new Buffer(this._engine, BufferBindFlag.IndexBuffer, indices);
                    this._setIndexBufferBinding(new IndexBufferBinding(newIndexBuffer, this._indicesFormat));
                } else {
                    indexBuffer.setData(indices);
                    if (this._primitive.indexBufferBinding._format !== this._indicesFormat) {
                        this._setIndexBufferBinding(new IndexBufferBinding(indexBuffer, this._indicesFormat));
                    }
                }
            } else if (indexBuffer) {
                indexBuffer.destroy();
                this._setIndexBufferBinding(null);
            }
            this._indicesChangeFlag = false;
        }
        var blendShapeManager = this._blendShapeManager;
        blendShapeManager._blendShapeCount > 0 && blendShapeManager._update(releaseData);
        if (releaseData) {
            this._accessible = false;
            this._releaseCache(false);
        }
    };
    /**
   * Calculate mesh tangent.
   * @remark need to set positions(with or not with indices), normals, uv before calculation.
   * @remark based on http://foundationsofgameenginedev.com/FGED2-sample.pdf
   */ _proto.calculateTangents = function calculateTangents() {
        var positions = this.getPositions();
        var normals = this.getNormals();
        var uvs = this.getUVs();
        if (!normals || !uvs) {
            throw "Set normal and uv before calculation.";
        }
        var _this = this, indices = _this._indices, vertexCount = _this.vertexCount;
        var e1 = ModelMesh._tempVec0, e2 = ModelMesh._tempVec1, t = ModelMesh._tempVec2, b = ModelMesh._tempVec3, temp = ModelMesh._tempVec4;
        var triangleCount = indices ? indices.length / 3 : positions.length / 3;
        var tangents = new Array(vertexCount);
        var biTangents = new Array(vertexCount);
        for(var i = 0; i < vertexCount; i++){
            tangents[i] = new Vector4();
            biTangents[i] = new Vector3();
        }
        // Calculate tangent and bi-tangent for each triangle and add to all three vertices.
        for(var k = 0; k < triangleCount; k++){
            var i0 = 3 * k;
            var i1 = 3 * k + 1;
            var i2 = 3 * k + 2;
            if (indices) {
                i0 = indices[i0];
                i1 = indices[i1];
                i2 = indices[i2];
            }
            var p0 = positions[i0];
            var p1 = positions[i1];
            var p2 = positions[i2];
            var w0 = uvs[i0];
            var w1 = uvs[i1];
            var w2 = uvs[i2];
            Vector3.subtract(p1, p0, e1);
            Vector3.subtract(p2, p0, e2);
            var x1 = w1.x - w0.x;
            var x2 = w2.x - w0.x;
            var y1 = w1.y - w0.y;
            var y2 = w2.y - w0.y;
            var r = 1.0 / (x1 * y2 - x2 * y1);
            Vector3.scale(e1, y2 * r, t);
            Vector3.scale(e2, y1 * r, temp);
            Vector3.subtract(t, temp, t);
            Vector3.scale(e2, x1 * r, b);
            Vector3.scale(e1, x2 * r, temp);
            Vector3.subtract(b, temp, b);
            var tangent = tangents[i0];
            tangent.set(tangent.x + t.x, tangent.y + t.y, tangent.z + t.z, 1.0);
            tangent = tangents[i1];
            tangent.set(tangent.x + t.x, tangent.y + t.y, tangent.z + t.z, 1.0);
            tangent = tangents[i2];
            tangent.set(tangent.x + t.x, tangent.y + t.y, tangent.z + t.z, 1.0);
            biTangents[i0].add(b);
            biTangents[i1].add(b);
            biTangents[i2].add(b);
        }
        // Orthonormalize each tangent and calculate the handedness.
        for(var i3 = 0; i3 < vertexCount; i3++){
            var n = normals[i3];
            var b1 = biTangents[i3];
            var tangent1 = tangents[i3];
            t.set(tangent1.x, tangent1.y, tangent1.z);
            Vector3.cross(t, b1, temp);
            var w = Vector3.dot(temp, n) > 0.0 ? 1 : -1;
            Vector3.scale(n, Vector3.dot(t, n), temp);
            Vector3.subtract(t, temp, t);
            t.normalize();
            tangent1.set(t.x, t.y, t.z, w);
        }
        this.setTangents(tangents);
    };
    /**
   * @internal
   */ _proto._setVertexBufferBinding = function _setVertexBufferBinding(index, binding) {
        var _this = this;
        var vertexBufferBindings = this._primitive.vertexBufferBindings;
        var updateInfos = this._vertexBufferInfos;
        var onVertexBufferChanged = function() {
            if (!_this._advancedDataSyncToBuffer) {
                updateInfos[index].dataVersion = _this._dataVersionCounter++;
            }
        };
        // Remove listener from previous binding
        var previousBinding = vertexBufferBindings[index];
        previousBinding && previousBinding.buffer._dataUpdateManager.removeListener(onVertexBufferChanged);
        Mesh.prototype._setVertexBufferBinding.call(this, index, binding);
        // Add listener to new binding and trigger update
        if (binding) {
            var _updateInfos, _index;
            binding.buffer._dataUpdateManager.addListener(onVertexBufferChanged);
            ((_updateInfos = updateInfos)[_index = index] || (_updateInfos[_index] = new BufferUpdateInfo())).reset();
            onVertexBufferChanged();
        } else {
            if (index + 1 == vertexBufferBindings.length) {
                vertexBufferBindings.length--;
            }
        }
    };
    /**
   * @internal
   */ _proto._getVertexTypedArray = function _getVertexTypedArray(vertexDataBuffer, dataType) {
        switch(dataType){
            case DataType.BYTE:
                return new Int8Array(vertexDataBuffer);
            case DataType.UNSIGNED_BYTE:
                return new Uint8Array(vertexDataBuffer);
            case DataType.SHORT:
                return new Int16Array(vertexDataBuffer);
            case DataType.UNSIGNED_SHORT:
                return new Uint16Array(vertexDataBuffer);
            case DataType.FLOAT:
                return new Float32Array(vertexDataBuffer);
        }
    };
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        Mesh.prototype._onDestroy.call(this);
        this._releaseCache(true);
    };
    _proto._getVertexElementData = function _getVertexElementData(vertices, vertexAttribute, vertexElementIndex, readVertexData) {
        var advancedVertexDataVersions = this._advancedVertexDataVersions;
        var _advancedVertexDataVersions_vertexElementIndex;
        var advancedDataVersion = (_advancedVertexDataVersions_vertexElementIndex = advancedVertexDataVersions[vertexElementIndex]) != null ? _advancedVertexDataVersions_vertexElementIndex : -1;
        var vertexElement = this._primitive._vertexElementMap[vertexAttribute];
        var bufferDataVersion = vertexElement ? this._vertexBufferInfos[vertexElement.bindingIndex].dataVersion : -1;
        if (advancedDataVersion >= bufferDataVersion) {
            return vertices;
        } else {
            advancedVertexDataVersions[vertexElementIndex] = bufferDataVersion;
            return readVertexData.call(this, vertexAttribute);
        }
    };
    _proto._beforeSetAdvancedVertexData = function _beforeSetAdvancedVertexData(vertices, elementChangeFlag, elementIndex) {
        if (vertices) {
            if (vertices.length !== this._vertexCount) {
                throw "The array provided needs to be the same size as vertex count.";
            }
        }
        this._updateAdvancedVertexDataMarks(elementChangeFlag, elementIndex);
    };
    _proto._updateAdvancedVertexDataMarks = function _updateAdvancedVertexDataMarks(elementChangeFlag, elementIndex) {
        this._advancedElementUpdateFlag |= elementChangeFlag;
        this._advancedDataUpdateFlag |= elementChangeFlag;
        this._advancedVertexDataVersions[elementIndex] = this._dataVersionCounter++;
    };
    _proto._updateInternalVertexBuffer = function _updateInternalVertexBuffer(releaseData) {
        var bufferStride = this._internalVertexBufferStride;
        var vertexCount = this.vertexCount;
        var bufferCreatedInfo = this._internalVertexBufferCreatedInfo;
        // If need recreate internal vertex buffer
        var needByteLength = bufferStride * vertexCount;
        if (bufferCreatedInfo.x * bufferCreatedInfo.y !== needByteLength) {
            // Destroy old internal vertex buffer
            var createdInternalBufferIndex = bufferCreatedInfo.z;
            if (createdInternalBufferIndex !== -1) {
                var _this__primitive_vertexBufferBindings_createdInternalBufferIndex;
                (_this__primitive_vertexBufferBindings_createdInternalBufferIndex = this._primitive.vertexBufferBindings[createdInternalBufferIndex]) == null ? void 0 : _this__primitive_vertexBufferBindings_createdInternalBufferIndex.buffer.destroy();
                this._setVertexBufferBinding(createdInternalBufferIndex, null);
            }
            var vertexBufferIndex = this._internalVertexBufferIndex;
            var isCreate = bufferStride * this.vertexCount > 0;
            if (isCreate) {
                // No matter the internal buffer is stride change or vertex count change, we need set to internal buffer again
                this._advancedDataUpdateFlag |= this._internalVertexElementsFlags;
                var bufferUsage = releaseData ? BufferUsage.Static : BufferUsage.Dynamic;
                var vertexBuffer = new Buffer(this._engine, BufferBindFlag.VertexBuffer, needByteLength, bufferUsage, true);
                this._setVertexBufferBinding(vertexBufferIndex, new VertexBufferBinding(vertexBuffer, bufferStride));
            }
            bufferCreatedInfo.set(bufferStride, vertexCount, isCreate ? vertexBufferIndex : -1);
        }
    };
    _proto._readVector2VertexData = function _readVector2VertexData(attributeType) {
        return this._readVertexData(attributeType, function(dataReader, offset) {
            return new Vector2(dataReader[offset], dataReader[offset + 1]);
        });
    };
    _proto._readVector3VertexData = function _readVector3VertexData(attributeType) {
        return this._readVertexData(attributeType, function(dataReader, offset) {
            return new Vector3(dataReader[offset], dataReader[offset + 1], dataReader[offset + 2]);
        });
    };
    _proto._readVector4VertexData = function _readVector4VertexData(attributeType) {
        return this._readVertexData(attributeType, function(dataReader, offset) {
            return new Vector4(dataReader[offset], dataReader[offset + 1], dataReader[offset + 2], dataReader[offset + 3]);
        });
    };
    _proto._readColorVertexData = function _readColorVertexData(attributeType) {
        return this._readVertexData(attributeType, function(dataReader, offset) {
            return new Color(dataReader[offset], dataReader[offset + 1], dataReader[offset + 2], dataReader[offset + 3]);
        });
    };
    _proto._readVertexData = function _readVertexData(attributeType, onVertexParse) {
        var primitive = this._primitive;
        var vertexElement = primitive._vertexElementMap[attributeType];
        if (!vertexElement) {
            return null;
        }
        var bufferBinding = primitive.vertexBufferBindings[vertexElement.bindingIndex];
        var buffer = bufferBinding == null ? void 0 : bufferBinding.buffer;
        if (!buffer) {
            return null;
        }
        if (!buffer.readable) {
            throw "Not allowed to access data while vertex buffer readable is false.";
        }
        var vertexCount = this.vertexCount;
        var formatMetaInfo = vertexElement._formatMetaInfo;
        var vertices = new Array(vertexCount);
        var dataReader = this._getVertexTypedArray(buffer.data.buffer, formatMetaInfo.type);
        var byteOffset = vertexElement.offset;
        var byteStride = bufferBinding.stride;
        for(var i = 0; i < vertexCount; i++){
            var offset = (i * byteStride + byteOffset) / dataReader.BYTES_PER_ELEMENT;
            var vertex = onVertexParse(dataReader, offset);
            formatMetaInfo.normalized && vertex.scale(formatMetaInfo.normalizedScaleFactor);
            vertices[i] = vertex;
        }
        return vertices;
    };
    _proto._updateAdvancedVertexElement = function _updateAdvancedVertexElement(vertices, attribute, flag) {
        var primitive = this._primitive;
        var vertexElementMap = primitive._vertexElementMap;
        if (vertices) {
            if (!vertexElementMap[attribute]) {
                var format = this._getAttributeFormat(attribute);
                var offset = this._internalVertexBufferStride;
                var bufferIndex = this._getInternalVertexBufferIndex();
                this._addVertexElement(new VertexElement(attribute, offset, format, bufferIndex));
                this._internalVertexBufferStride += this._getAttributeByteLength(attribute);
                this._internalVertexElementsFlags |= flag;
                this._blendShapeManager._vertexElementOffset++;
            }
        } else {
            var vertexElement = vertexElementMap[attribute];
            if (vertexElement) {
                var index = this._primitive.vertexElements.indexOf(vertexElement);
                if (index >= this._internalVertexElementsOffset) {
                    this._internalVertexBufferStride -= this._getAttributeByteLength(attribute);
                    this._internalVertexElementsFlags &= ~flag;
                } else {
                    // If custom element should be removed
                    this._internalVertexElementsOffset--;
                }
                this._blendShapeManager._vertexElementOffset--;
                this._removeVertexElement(index);
            }
        }
    };
    _proto._updateAdvancedVertexElements = function _updateAdvancedVertexElements() {
        var advancedElementUpdateFlag = this._advancedElementUpdateFlag;
        if (advancedElementUpdateFlag & 1) {
            this._updateAdvancedVertexElement(this._positions, VertexAttribute.Position, 1);
        }
        if (advancedElementUpdateFlag & 2) {
            this._updateAdvancedVertexElement(this._normals, VertexAttribute.Normal, 2);
        }
        if (advancedElementUpdateFlag & 4) {
            this._updateAdvancedVertexElement(this._colors, VertexAttribute.Color, 4);
        }
        if (advancedElementUpdateFlag & 16) {
            this._updateAdvancedVertexElement(this._boneWeights, VertexAttribute.BoneWeight, 16);
        }
        if (advancedElementUpdateFlag & 32) {
            this._updateAdvancedVertexElement(this._boneIndices, VertexAttribute.BoneIndex, 32);
        }
        if (advancedElementUpdateFlag & 8) {
            this._updateAdvancedVertexElement(this._tangents, VertexAttribute.Tangent, 8);
        }
        if (advancedElementUpdateFlag & 64) {
            this._updateAdvancedVertexElement(this._uv, VertexAttribute.UV, 64);
        }
        if (advancedElementUpdateFlag & 128) {
            this._updateAdvancedVertexElement(this._uv1, VertexAttribute.UV1, 128);
        }
        if (advancedElementUpdateFlag & 256) {
            this._updateAdvancedVertexElement(this._uv2, VertexAttribute.UV2, 256);
        }
        if (advancedElementUpdateFlag & 512) {
            this._updateAdvancedVertexElement(this._uv3, VertexAttribute.UV3, 512);
        }
        if (advancedElementUpdateFlag & 1024) {
            this._updateAdvancedVertexElement(this._uv4, VertexAttribute.UV4, 1024);
        }
        if (advancedElementUpdateFlag & 2048) {
            this._updateAdvancedVertexElement(this._uv5, VertexAttribute.UV5, 2048);
        }
        if (advancedElementUpdateFlag & 4096) {
            this._updateAdvancedVertexElement(this._uv6, VertexAttribute.UV6, 4096);
        }
        if (advancedElementUpdateFlag & 8192) {
            this._updateAdvancedVertexElement(this._uv7, VertexAttribute.UV7, 8192);
        }
    };
    _proto._updateVertexElements = function _updateVertexElements() {
        var vertexElements = this._primitive.vertexElements;
        var bsManager = this._blendShapeManager;
        var previousCount = vertexElements.length;
        var previousBSOffset = bsManager._vertexElementOffset;
        if (this._advancedElementUpdateFlag & 65535) {
            this._updateAdvancedVertexElements();
            this._advancedElementUpdateFlag = 0;
        }
        var bsUpdate = !bsManager._useTextureMode() && bsManager._vertexElementsNeedUpdate();
        if (previousBSOffset !== bsManager._vertexElementOffset || bsUpdate && bsManager._blendShapeCount > 0) {
            var length = bsManager._addVertexElements(this);
            if (length < previousCount) {
                this._setVertexElementsLength(length);
            }
        }
    };
    _proto._writeVector2AdvancedVertexData = function _writeVector2AdvancedVertexData(attribute, elementIndex, vertices) {
        this._writeAdvancedVertexData(attribute, elementIndex, function(typedArray, offset, index) {
            var vertex = vertices[index]; // vertex maybe null or advanced data array length less than vertexCount
            if (vertex) {
                typedArray[offset] = vertex.x;
                typedArray[offset + 1] = vertex.y;
            }
        });
    };
    _proto._writeVector3AdvancedVertexData = function _writeVector3AdvancedVertexData(attribute, elementIndex, vertices) {
        this._writeAdvancedVertexData(attribute, elementIndex, function(typedArray, offset, index) {
            var vertex = vertices[index];
            if (vertex) {
                typedArray[offset] = vertex.x;
                typedArray[offset + 1] = vertex.y;
                typedArray[offset + 2] = vertex.z;
            }
        });
    };
    _proto._writeVector4AdvancedVertexData = function _writeVector4AdvancedVertexData(attribute, elementIndex, vertices) {
        this._writeAdvancedVertexData(attribute, elementIndex, function(typedArray, offset, index) {
            var vertex = vertices[index];
            if (vertex) {
                typedArray[offset] = vertex.x;
                typedArray[offset + 1] = vertex.y;
                typedArray[offset + 2] = vertex.z;
                typedArray[offset + 3] = vertex.w;
            }
        });
    };
    _proto._writeColorAdvancedVertexData = function _writeColorAdvancedVertexData(attribute, elementIndex, vertices) {
        this._writeAdvancedVertexData(attribute, elementIndex, function(typedArray, offset, index) {
            var vertex = vertices[index];
            if (vertex) {
                typedArray[offset] = vertex.r;
                typedArray[offset + 1] = vertex.g;
                typedArray[offset + 2] = vertex.b;
                typedArray[offset + 3] = vertex.a;
            }
        });
    };
    _proto._writeAdvancedVertexData = function _writeAdvancedVertexData(attribute, elementIndex, onVertexWrite) {
        var primitive = this._primitive;
        var vertexElement = primitive._vertexElementMap[attribute];
        var bindingIndex = vertexElement.bindingIndex;
        var bufferBinding = primitive.vertexBufferBindings[bindingIndex];
        var buffer = bufferBinding == null ? void 0 : bufferBinding.buffer;
        if (!buffer) {
            return;
        }
        if (!buffer.readable) {
            throw "Vertex buffer is not readable, can't write vertex data.";
        }
        var _this__advancedVertexDataVersions_elementIndex;
        var advancedDataVersion = (_this__advancedVertexDataVersions_elementIndex = this._advancedVertexDataVersions[elementIndex]) != null ? _this__advancedVertexDataVersions_elementIndex : -1;
        var vertexBufferInfo = this._vertexBufferInfos[bindingIndex];
        if (advancedDataVersion > vertexBufferInfo.dataVersion) {
            var formatMetaInfo = vertexElement._formatMetaInfo;
            var typedArray = this._getVertexTypedArray(buffer.data.buffer, formatMetaInfo.type);
            var byteOffset = vertexElement.offset;
            var byteStride = bufferBinding.stride;
            var BYTES_PER_ELEMENT = typedArray.BYTES_PER_ELEMENT;
            var normalized = formatMetaInfo.normalized, size = formatMetaInfo.size, normalizedScaleFactor = formatMetaInfo.normalizedScaleFactor;
            for(var i = 0, n = this._vertexCount; i < n; i++){
                var offset = (i * byteStride + byteOffset) / BYTES_PER_ELEMENT;
                onVertexWrite(typedArray, offset, i);
                if (normalized) {
                    for(var j = 0; j < size; j++){
                        typedArray[offset + j] /= normalizedScaleFactor;
                    }
                }
            }
            vertexBufferInfo.uploadAdvancedData = true;
        }
    };
    _proto._updateAdvancedVertices = function _updateAdvancedVertices() {
        // prettier-ignore
        var _this = this, _positions = _this._positions, _normals = _this._normals, _colors = _this._colors, _advancedDataUpdateFlag = _this._advancedDataUpdateFlag, _boneWeights = _this._boneWeights, _boneIndices = _this._boneIndices, _tangents = _this._tangents, _uv = _this._uv, _uv1 = _this._uv1, _uv2 = _this._uv2, _uv3 = _this._uv3, _uv4 = _this._uv4, _uv5 = _this._uv5, _uv6 = _this._uv6, _uv7 = _this._uv7;
        if (_advancedDataUpdateFlag & 1) {
            this._writeVector3AdvancedVertexData(VertexAttribute.Position, 0, _positions);
        }
        if (_normals && _advancedDataUpdateFlag & 2) {
            this._writeVector3AdvancedVertexData(VertexAttribute.Normal, 1, _normals);
        }
        if (_colors && _advancedDataUpdateFlag & 4) {
            this._writeColorAdvancedVertexData(VertexAttribute.Color, 2, _colors);
        }
        if (_boneWeights && _advancedDataUpdateFlag & 16) {
            this._writeVector4AdvancedVertexData(VertexAttribute.BoneWeight, 4, _boneWeights);
        }
        if (_boneIndices && _advancedDataUpdateFlag & 32) {
            this._writeVector4AdvancedVertexData(VertexAttribute.BoneIndex, 5, _boneIndices);
        }
        if (_tangents && _advancedDataUpdateFlag & 8) {
            this._writeVector4AdvancedVertexData(VertexAttribute.Tangent, 3, _tangents);
        }
        if (_uv && _advancedDataUpdateFlag & 64) {
            this._writeVector2AdvancedVertexData(VertexAttribute.UV, 6, _uv);
        }
        if (_uv1 && _advancedDataUpdateFlag & 128) {
            this._writeVector2AdvancedVertexData(VertexAttribute.UV1, 7, _uv1);
        }
        if (_uv2 && _advancedDataUpdateFlag & 256) {
            this._writeVector2AdvancedVertexData(VertexAttribute.UV2, 8, _uv2);
        }
        if (_uv3 && _advancedDataUpdateFlag & 512) {
            this._writeVector2AdvancedVertexData(VertexAttribute.UV3, 9, _uv3);
        }
        if (_uv4 && _advancedDataUpdateFlag & 1024) {
            this._writeVector2AdvancedVertexData(VertexAttribute.UV4, 10, _uv4);
        }
        if (_uv5 && _advancedDataUpdateFlag & 2048) {
            this._writeVector2AdvancedVertexData(VertexAttribute.UV5, 11, _uv5);
        }
        if (_uv6 && _advancedDataUpdateFlag & 4096) {
            this._writeVector2AdvancedVertexData(VertexAttribute.UV6, 12, _uv6);
        }
        if (_uv7 && _advancedDataUpdateFlag & 8192) {
            this._writeVector2AdvancedVertexData(VertexAttribute.UV7, 13, _uv7);
        }
        this._advancedDataUpdateFlag = 0;
    };
    _proto._getInternalVertexBufferIndex = function _getInternalVertexBufferIndex() {
        var internalVertexBufferIndex = this._internalVertexBufferIndex;
        if (internalVertexBufferIndex !== -1) {
            return internalVertexBufferIndex;
        }
        var i = 0;
        var vertexBufferBindings = this._primitive.vertexBufferBindings;
        for(var n = vertexBufferBindings.length; i < n; i++){
            if (!vertexBufferBindings[i]) {
                break;
            }
        }
        this._internalVertexBufferIndex = i;
        return i;
    };
    _proto._getAttributeFormat = function _getAttributeFormat(attribute) {
        switch(attribute){
            case VertexAttribute.Position:
            case VertexAttribute.Normal:
                return VertexElementFormat.Vector3;
            case VertexAttribute.Color:
            case VertexAttribute.BoneWeight:
            case VertexAttribute.Tangent:
                return VertexElementFormat.Vector4;
            case VertexAttribute.BoneIndex:
                return VertexElementFormat.UByte4;
            case VertexAttribute.UV:
            case VertexAttribute.UV1:
            case VertexAttribute.UV2:
            case VertexAttribute.UV3:
            case VertexAttribute.UV4:
            case VertexAttribute.UV5:
            case VertexAttribute.UV6:
            case VertexAttribute.UV7:
                return VertexElementFormat.Vector2;
        }
    };
    _proto._getAttributeByteLength = function _getAttributeByteLength(attribute) {
        switch(attribute){
            case VertexAttribute.Position:
            case VertexAttribute.Normal:
                return 12;
            case VertexAttribute.Color:
            case VertexAttribute.BoneWeight:
            case VertexAttribute.Tangent:
                return 16;
            case VertexAttribute.BoneIndex:
                return 4;
            case VertexAttribute.UV:
            case VertexAttribute.UV1:
            case VertexAttribute.UV2:
            case VertexAttribute.UV3:
            case VertexAttribute.UV4:
            case VertexAttribute.UV5:
            case VertexAttribute.UV6:
            case VertexAttribute.UV7:
                return 8;
        }
    };
    _proto._releaseCache = function _releaseCache(isDestroy) {
        this._positions = null;
        this._tangents = null;
        this._normals = null;
        this._colors = null;
        this._boneIndices = null;
        this._boneWeights = null;
        this._uv = null;
        this._uv1 = null;
        this._uv2 = null;
        this._uv3 = null;
        this._uv4 = null;
        this._uv5 = null;
        this._uv6 = null;
        this._uv7 = null;
        this._indices = null;
        this._blendShapeManager._releaseMemoryCache();
        if (!isDestroy) {
            var _this__primitive_vertexBufferBindings_this__internalVertexBufferIndex;
            (_this__primitive_vertexBufferBindings_this__internalVertexBufferIndex = this._primitive.vertexBufferBindings[this._internalVertexBufferIndex]) == null ? void 0 : _this__primitive_vertexBufferBindings_this__internalVertexBufferIndex.buffer.markAsUnreadable();
            // If release data, we need update buffer data version to ensure get data method can read buffer
            var dataVersion = this._dataVersionCounter++;
            var vertexBufferInfos = this._vertexBufferInfos;
            for(var i = 0, n = vertexBufferInfos.length; i < n; i++){
                var vertexBufferInfo = vertexBufferInfos[i];
                vertexBufferInfo && (vertexBufferInfo.dataVersion = dataVersion);
            }
        }
    };
    _create_class$2(ModelMesh, [
        {
            key: "vertexCount",
            get: /**
   * Vertex count of mesh.
   */ function get() {
                if (this._vertexCountDirty) {
                    var vertexCount = 0;
                    var positionElement = this._primitive._vertexElementMap[VertexAttribute.Position];
                    if (positionElement) {
                        var positionBufferBinding = this._primitive.vertexBufferBindings[positionElement.bindingIndex];
                        if (positionBufferBinding) {
                            vertexCount = positionBufferBinding.buffer.byteLength / positionBufferBinding.stride;
                        }
                    }
                    this._vertexCount = vertexCount;
                    this._vertexCountDirty = false;
                }
                return this._vertexCount;
            }
        },
        {
            key: "vertexElements",
            get: /**
   * Vertex element collection.
   */ function get() {
                this._updateVertexElements();
                return this._primitive.vertexElements;
            }
        },
        {
            key: "vertexBufferBindings",
            get: /**
   * Vertex buffer binding collection.
   */ function get() {
                // @todo: update if dirty like `vertexElements` is better
                return this._primitive.vertexBufferBindings;
            }
        },
        {
            key: "blendShapes",
            get: /**
   * BlendShapes of this ModelMesh.
   */ function get() {
                return this._blendShapeManager._blendShapes;
            }
        },
        {
            key: "blendShapeCount",
            get: /**
   * BlendShape count of this ModelMesh.
   */ function get() {
                return this._blendShapeManager._blendShapeCount;
            }
        },
        {
            key: "accessible",
            get: /**
   * @deprecated
   * Whether to access data of the mesh.
   */ function get() {
                return this._accessible;
            }
        }
    ]);
    return ModelMesh;
}(Mesh);
ModelMesh._tempVec0 = new Vector3();
ModelMesh._tempVec1 = new Vector3();
ModelMesh._tempVec2 = new Vector3();
ModelMesh._tempVec3 = new Vector3();
ModelMesh._tempVec4 = new Vector3();
var BufferUpdateInfo = /*#__PURE__*/ function() {
    function BufferUpdateInfo() {
        this.dataVersion = -1;
        this.uploadAdvancedData = false;
    }
    var _proto = BufferUpdateInfo.prototype;
    _proto.reset = function reset() {
        this.uploadAdvancedData = false;
    };
    return BufferUpdateInfo;
}();

/**
 * @internal
 */ var PrimitiveMeshRestorer = /*#__PURE__*/ function(ContentRestorer) {
    _inherits$2(PrimitiveMeshRestorer, ContentRestorer);
    function PrimitiveMeshRestorer(resource, primitiveInfo) {
        var _this;
        _this = ContentRestorer.call(this, resource) || this, _this.primitiveInfo = primitiveInfo;
        return _this;
    }
    var _proto = PrimitiveMeshRestorer.prototype;
    _proto.restoreContent = function restoreContent() {
        var primitiveInfo = this.primitiveInfo;
        switch(primitiveInfo.type){
            case 0:
                var sphereInfo = primitiveInfo;
                PrimitiveMesh._setSphereData(this.resource, sphereInfo.radius, sphereInfo.segments, sphereInfo.noLongerAccessible, true, sphereInfo.vertexBuffer);
                break;
            case 7:
                var CCSphereInfo = primitiveInfo;
                PrimitiveMesh._setSubdivisionSurfaceSphereData(this.resource, CCSphereInfo.radius, CCSphereInfo.step, CCSphereInfo.noLongerAccessible, true, CCSphereInfo.vertexBuffer);
                break;
            case 1:
                var cuboidInfo = primitiveInfo;
                PrimitiveMesh._setCuboidData(this.resource, cuboidInfo.width, cuboidInfo.height, cuboidInfo.depth, cuboidInfo.noLongerAccessible, true, cuboidInfo.vertexBuffer);
                break;
            case 2:
                var planeInfo = primitiveInfo;
                PrimitiveMesh._setPlaneData(this.resource, planeInfo.width, planeInfo.height, planeInfo.horizontalSegments, planeInfo.verticalSegments, planeInfo.noLongerAccessible, true, planeInfo.vertexBuffer);
                break;
            case 3:
                var cylinderInfo = primitiveInfo;
                PrimitiveMesh._setCylinderData(this.resource, cylinderInfo.radiusTop, cylinderInfo.radiusBottom, cylinderInfo.height, cylinderInfo.radialSegments, cylinderInfo.heightSegments, cylinderInfo.noLongerAccessible, true, cylinderInfo.vertexBuffer);
                break;
            case 4:
                var torusInfo = primitiveInfo;
                PrimitiveMesh._setTorusData(this.resource, torusInfo.radius, torusInfo.tubeRadius, torusInfo.radialSegments, torusInfo.tubularSegments, torusInfo.arc, torusInfo.noLongerAccessible, true, torusInfo.vertexBuffer);
                break;
            case 5:
                var coneInfo = primitiveInfo;
                PrimitiveMesh._setConeData(this.resource, coneInfo.radius, coneInfo.height, coneInfo.radialSegments, coneInfo.heightSegments, coneInfo.noLongerAccessible, true, coneInfo.vertexBuffer);
                break;
            case 6:
                var capsuleInfo = primitiveInfo;
                PrimitiveMesh._setCapsuleData(this.resource, capsuleInfo.radius, capsuleInfo.height, capsuleInfo.radialSegments, capsuleInfo.heightSegments, capsuleInfo.noLongerAccessible, true, capsuleInfo.vertexBuffer);
                break;
        }
    };
    return PrimitiveMeshRestorer;
}(ContentRestorer);
/**
 * @internal
 */ var PrimitiveRestoreInfo = function PrimitiveRestoreInfo(type, vertexBuffer, noLongerAccessible) {
    this.type = type;
    this.vertexBuffer = vertexBuffer;
    this.noLongerAccessible = noLongerAccessible;
};
/**
 * @internal
 */ var SphereRestoreInfo = /*#__PURE__*/ function(PrimitiveRestoreInfo) {
    _inherits$2(SphereRestoreInfo, PrimitiveRestoreInfo);
    function SphereRestoreInfo(radius, segments, vertexBuffer, noLongerAccessible) {
        var _this;
        _this = PrimitiveRestoreInfo.call(this, 0, vertexBuffer, noLongerAccessible) || this, _this.radius = radius, _this.segments = segments;
        return _this;
    }
    return SphereRestoreInfo;
}(PrimitiveRestoreInfo);
/**
 * @internal
 */ var SubdivisionSurfaceSphereRestoreInfo = /*#__PURE__*/ function(PrimitiveRestoreInfo) {
    _inherits$2(SubdivisionSurfaceSphereRestoreInfo, PrimitiveRestoreInfo);
    function SubdivisionSurfaceSphereRestoreInfo(radius, step, vertexBuffer, noLongerAccessible) {
        var _this;
        _this = PrimitiveRestoreInfo.call(this, 7, vertexBuffer, noLongerAccessible) || this, _this.radius = radius, _this.step = step;
        return _this;
    }
    return SubdivisionSurfaceSphereRestoreInfo;
}(PrimitiveRestoreInfo);
/**
 * @internal
 */ var CuboidRestoreInfo = /*#__PURE__*/ function(PrimitiveRestoreInfo) {
    _inherits$2(CuboidRestoreInfo, PrimitiveRestoreInfo);
    function CuboidRestoreInfo(width, height, depth, vertexBuffer, noLongerAccessible) {
        var _this;
        _this = PrimitiveRestoreInfo.call(this, 1, vertexBuffer, noLongerAccessible) || this, _this.width = width, _this.height = height, _this.depth = depth;
        return _this;
    }
    return CuboidRestoreInfo;
}(PrimitiveRestoreInfo);
/**
 * @internal
 */ var PlaneRestoreInfo = /*#__PURE__*/ function(PrimitiveRestoreInfo) {
    _inherits$2(PlaneRestoreInfo, PrimitiveRestoreInfo);
    function PlaneRestoreInfo(width, height, horizontalSegments, verticalSegments, vertexBuffer, noLongerAccessible) {
        var _this;
        _this = PrimitiveRestoreInfo.call(this, 2, vertexBuffer, noLongerAccessible) || this, _this.width = width, _this.height = height, _this.horizontalSegments = horizontalSegments, _this.verticalSegments = verticalSegments;
        return _this;
    }
    return PlaneRestoreInfo;
}(PrimitiveRestoreInfo);
/**
 * @internal
 */ var CylinderRestoreInfo = /*#__PURE__*/ function(PrimitiveRestoreInfo) {
    _inherits$2(CylinderRestoreInfo, PrimitiveRestoreInfo);
    function CylinderRestoreInfo(radiusTop, radiusBottom, height, radialSegments, heightSegments, vertexBuffer, noLongerAccessible) {
        var _this;
        _this = PrimitiveRestoreInfo.call(this, 3, vertexBuffer, noLongerAccessible) || this, _this.radiusTop = radiusTop, _this.radiusBottom = radiusBottom, _this.height = height, _this.radialSegments = radialSegments, _this.heightSegments = heightSegments;
        return _this;
    }
    return CylinderRestoreInfo;
}(PrimitiveRestoreInfo);
/**
 * @internal
 */ var TorusRestoreInfo = /*#__PURE__*/ function(PrimitiveRestoreInfo) {
    _inherits$2(TorusRestoreInfo, PrimitiveRestoreInfo);
    function TorusRestoreInfo(radius, tubeRadius, radialSegments, tubularSegments, arc, vertexBuffer, noLongerAccessible) {
        var _this;
        _this = PrimitiveRestoreInfo.call(this, 4, vertexBuffer, noLongerAccessible) || this, _this.radius = radius, _this.tubeRadius = tubeRadius, _this.radialSegments = radialSegments, _this.tubularSegments = tubularSegments, _this.arc = arc;
        return _this;
    }
    return TorusRestoreInfo;
}(PrimitiveRestoreInfo);
/**
 * @internal
 */ var ConeRestoreInfo = /*#__PURE__*/ function(PrimitiveRestoreInfo) {
    _inherits$2(ConeRestoreInfo, PrimitiveRestoreInfo);
    function ConeRestoreInfo(radius, height, radialSegments, heightSegments, vertexBuffer, noLongerAccessible) {
        var _this;
        _this = PrimitiveRestoreInfo.call(this, 5, vertexBuffer, noLongerAccessible) || this, _this.radius = radius, _this.height = height, _this.radialSegments = radialSegments, _this.heightSegments = heightSegments;
        return _this;
    }
    return ConeRestoreInfo;
}(PrimitiveRestoreInfo);
/**
 * @internal
 */ var CapsuleRestoreInfo = /*#__PURE__*/ function(PrimitiveRestoreInfo) {
    _inherits$2(CapsuleRestoreInfo, PrimitiveRestoreInfo);
    function CapsuleRestoreInfo(radius, height, radialSegments, heightSegments, vertexBuffer, noLongerAccessible) {
        var _this;
        _this = PrimitiveRestoreInfo.call(this, 6, vertexBuffer, noLongerAccessible) || this, _this.radius = radius, _this.height = height, _this.radialSegments = radialSegments, _this.heightSegments = heightSegments;
        return _this;
    }
    return CapsuleRestoreInfo;
}(PrimitiveRestoreInfo);

/**
 * Used to generate common primitive meshes.
 */ var PrimitiveMesh = /*#__PURE__*/ function() {
    function PrimitiveMesh() {}
    /**
   * Create a sphere mesh.
   * @param engine - Engine
   * @param radius - Sphere radius
   * @param segments - Number of segments
   * @param noLongerAccessible - No longer access the vertices of the mesh after creation
   * @returns Sphere model mesh
   */ PrimitiveMesh.createSphere = function createSphere(engine, radius, segments, noLongerAccessible) {
        if (radius === void 0) radius = 0.5;
        if (segments === void 0) segments = 18;
        if (noLongerAccessible === void 0) noLongerAccessible = true;
        var sphereMesh = new ModelMesh(engine);
        PrimitiveMesh._setSphereData(sphereMesh, radius, segments, noLongerAccessible, false);
        var vertexBuffer = sphereMesh.vertexBufferBindings[0].buffer;
        engine.resourceManager.addContentRestorer(new PrimitiveMeshRestorer(sphereMesh, new SphereRestoreInfo(radius, segments, vertexBuffer, noLongerAccessible)));
        return sphereMesh;
    };
    /**
   * Create a sphere mesh by implementing Catmull-Clark Surface Subdivision Algorithm.
   * Max step is limited to 6.
   * @param engine - Engine
   * @param radius - Sphere radius
   * @param step - Number of subdiv steps
   * @param noLongerAccessible - No longer access the vertices of the mesh after creation
   * @returns Sphere model mesh
   */ PrimitiveMesh.createSubdivisionSurfaceSphere = function createSubdivisionSurfaceSphere(engine, radius, step, noLongerAccessible) {
        if (radius === void 0) radius = 0.5;
        if (step === void 0) step = 3;
        if (noLongerAccessible === void 0) noLongerAccessible = true;
        var sphereMesh = new ModelMesh(engine);
        PrimitiveMesh._setSubdivisionSurfaceSphereData(sphereMesh, radius, step, noLongerAccessible, false);
        var vertexBuffer = sphereMesh.vertexBufferBindings[0].buffer;
        engine.resourceManager.addContentRestorer(new PrimitiveMeshRestorer(sphereMesh, new SubdivisionSurfaceSphereRestoreInfo(radius, step, vertexBuffer, noLongerAccessible)));
        return sphereMesh;
    };
    /**
   * Create a cuboid mesh.
   * @param engine - Engine
   * @param width - Cuboid width
   * @param height - Cuboid height
   * @param depth - Cuboid depth
   * @param noLongerAccessible - No longer access the vertices of the mesh after creation
   * @returns Cuboid model mesh
   */ PrimitiveMesh.createCuboid = function createCuboid(engine, width, height, depth, noLongerAccessible) {
        if (width === void 0) width = 1;
        if (height === void 0) height = 1;
        if (depth === void 0) depth = 1;
        if (noLongerAccessible === void 0) noLongerAccessible = true;
        var mesh = new ModelMesh(engine);
        PrimitiveMesh._setCuboidData(mesh, width, height, depth, noLongerAccessible, false);
        var vertexBuffer = mesh.vertexBufferBindings[0].buffer;
        engine.resourceManager.addContentRestorer(new PrimitiveMeshRestorer(mesh, new CuboidRestoreInfo(width, height, depth, vertexBuffer, noLongerAccessible)));
        return mesh;
    };
    /**
   * Create a plane mesh.
   * @param engine - Engine
   * @param width - Plane width
   * @param height - Plane height
   * @param horizontalSegments - Plane horizontal segments
   * @param verticalSegments - Plane vertical segments
   * @param noLongerAccessible - No longer access the vertices of the mesh after creation
   * @returns Plane model mesh
   */ PrimitiveMesh.createPlane = function createPlane(engine, width, height, horizontalSegments, verticalSegments, noLongerAccessible) {
        if (width === void 0) width = 1;
        if (height === void 0) height = 1;
        if (horizontalSegments === void 0) horizontalSegments = 1;
        if (verticalSegments === void 0) verticalSegments = 1;
        if (noLongerAccessible === void 0) noLongerAccessible = true;
        var mesh = new ModelMesh(engine);
        PrimitiveMesh._setPlaneData(mesh, width, height, horizontalSegments, verticalSegments, noLongerAccessible, false);
        var vertexBuffer = mesh.vertexBufferBindings[0].buffer;
        engine.resourceManager.addContentRestorer(new PrimitiveMeshRestorer(mesh, new PlaneRestoreInfo(width, height, horizontalSegments, verticalSegments, vertexBuffer, noLongerAccessible)));
        return mesh;
    };
    /**
   * Create a cylinder mesh.
   * @param engine - Engine
   * @param radiusTop - The radius of top cap
   * @param radiusBottom - The radius of bottom cap
   * @param height - The height of torso
   * @param radialSegments - Cylinder radial segments
   * @param heightSegments - Cylinder height segments
   * @param noLongerAccessible - No longer access the vertices of the mesh after creation
   * @returns Cylinder model mesh
   */ PrimitiveMesh.createCylinder = function createCylinder(engine, radiusTop, radiusBottom, height, radialSegments, heightSegments, noLongerAccessible) {
        if (radiusTop === void 0) radiusTop = 0.5;
        if (radiusBottom === void 0) radiusBottom = 0.5;
        if (height === void 0) height = 2;
        if (radialSegments === void 0) radialSegments = 20;
        if (heightSegments === void 0) heightSegments = 1;
        if (noLongerAccessible === void 0) noLongerAccessible = true;
        var mesh = new ModelMesh(engine);
        PrimitiveMesh._setCylinderData(mesh, radiusTop, radiusBottom, height, radialSegments, heightSegments, noLongerAccessible, false);
        var vertexBuffer = mesh.vertexBufferBindings[0].buffer;
        engine.resourceManager.addContentRestorer(new PrimitiveMeshRestorer(mesh, new CylinderRestoreInfo(radiusTop, radiusBottom, height, radialSegments, heightSegments, vertexBuffer, noLongerAccessible)));
        return mesh;
    };
    /**
   * Create a torus mesh.
   * @param engine - Engine
   * @param radius - Torus radius
   * @param tubeRadius - Torus tube
   * @param radialSegments - Torus radial segments
   * @param tubularSegments - Torus tubular segments
   * @param arc - Central angle
   * @param noLongerAccessible - No longer access the vertices of the mesh after creation
   * @returns Torus model mesh
   */ PrimitiveMesh.createTorus = function createTorus(engine, radius, tubeRadius, radialSegments, tubularSegments, arc, noLongerAccessible) {
        if (radius === void 0) radius = 0.5;
        if (tubeRadius === void 0) tubeRadius = 0.1;
        if (radialSegments === void 0) radialSegments = 30;
        if (tubularSegments === void 0) tubularSegments = 30;
        if (arc === void 0) arc = 360;
        if (noLongerAccessible === void 0) noLongerAccessible = true;
        var mesh = new ModelMesh(engine);
        PrimitiveMesh._setTorusData(mesh, radius, tubeRadius, radialSegments, tubularSegments, arc, noLongerAccessible, false);
        var vertexBuffer = mesh.vertexBufferBindings[0].buffer;
        engine.resourceManager.addContentRestorer(new PrimitiveMeshRestorer(mesh, new TorusRestoreInfo(radius, tubeRadius, radialSegments, tubularSegments, arc, vertexBuffer, noLongerAccessible)));
        return mesh;
    };
    /**
   * Create a cone mesh.
   * @param engine - Engine
   * @param radius - The radius of cap
   * @param height - The height of torso
   * @param radialSegments - Cone radial segments
   * @param heightSegments - Cone height segments
   * @param noLongerAccessible - No longer access the vertices of the mesh after creation
   * @returns Cone model mesh
   */ PrimitiveMesh.createCone = function createCone(engine, radius, height, radialSegments, heightSegments, noLongerAccessible) {
        if (radius === void 0) radius = 0.5;
        if (height === void 0) height = 2;
        if (radialSegments === void 0) radialSegments = 20;
        if (heightSegments === void 0) heightSegments = 1;
        if (noLongerAccessible === void 0) noLongerAccessible = true;
        var mesh = new ModelMesh(engine);
        PrimitiveMesh._setConeData(mesh, radius, height, radialSegments, heightSegments, noLongerAccessible, false);
        var vertexBuffer = mesh.vertexBufferBindings[0].buffer;
        engine.resourceManager.addContentRestorer(new PrimitiveMeshRestorer(mesh, new ConeRestoreInfo(radius, height, radialSegments, heightSegments, vertexBuffer, noLongerAccessible)));
        return mesh;
    };
    /**
   * Create a capsule mesh.
   * @param engine - Engine
   * @param radius - The radius of the two hemispherical ends
   * @param height - The height of the cylindrical part, measured between the centers of the hemispherical ends
   * @param radialSegments - Hemispherical end radial segments
   * @param heightSegments - Cylindrical part height segments
   * @param noLongerAccessible - No longer access the vertices of the mesh after creation
   * @returns Capsule model mesh
   */ PrimitiveMesh.createCapsule = function createCapsule(engine, radius, height, radialSegments, heightSegments, noLongerAccessible) {
        if (radius === void 0) radius = 0.5;
        if (height === void 0) height = 2;
        if (radialSegments === void 0) radialSegments = 6;
        if (heightSegments === void 0) heightSegments = 1;
        if (noLongerAccessible === void 0) noLongerAccessible = true;
        var mesh = new ModelMesh(engine);
        PrimitiveMesh._setCapsuleData(mesh, radius, height, radialSegments, heightSegments, noLongerAccessible, false);
        var vertexBuffer = mesh.vertexBufferBindings[0].buffer;
        engine.resourceManager.addContentRestorer(new PrimitiveMeshRestorer(mesh, new CapsuleRestoreInfo(radius, height, radialSegments, heightSegments, vertexBuffer, noLongerAccessible)));
        return mesh;
    };
    /**
   * @internal
   */ PrimitiveMesh._setSubdivisionSurfaceSphereData = function _setSubdivisionSurfaceSphereData(sphereMesh, radius, step, noLongerAccessible, isRestoreMode, restoreVertexBuffer) {
        // Max step is limited to 6. Because 7 step will generate a single mesh with over 98306 vertices
        step = MathUtil.clamp(Math.floor(step), 1, 6);
        var positions = new Float32Array(3 * (6 * Math.pow(4, step) + 2));
        var cells = new Float32Array(24 * Math.pow(4, step));
        PrimitiveMesh._subdiveCatmullClark(step, positions, cells);
        var positionCount = positions.length / 3;
        var cellsCount = cells.length / 4;
        var poleOffset = positionCount + Math.pow(2, step + 1) - 1;
        // 16 extra vertices for pole uv
        // 2 vertices at each pole are idle
        var vertexCount = poleOffset + 16;
        var vertices = new Float32Array(vertexCount * 8);
        var indices = PrimitiveMesh._generateIndices(sphereMesh.engine, positionCount, cellsCount * 6);
        var seamCount = 0;
        var seamVertices = {};
        // Get normals, uvs, and scale to radius
        for(var i = 0; i < positionCount; i++){
            var offset = 3 * i;
            var x = positions[offset];
            var y = positions[offset + 1];
            var z = positions[offset + 2];
            var reciprocalLength = 1 / Math.sqrt(x * x + y * y + z * z);
            x *= reciprocalLength;
            y *= reciprocalLength;
            z *= reciprocalLength;
            offset = 8 * i;
            vertices[offset] = x * radius;
            vertices[offset + 1] = y * radius;
            vertices[offset + 2] = z * radius;
            vertices[offset + 3] = x;
            vertices[offset + 4] = y;
            vertices[offset + 5] = z;
            vertices[offset + 6] = (Math.PI - Math.atan2(z, x)) / (2 * Math.PI);
            vertices[offset + 7] = Math.acos(y) / Math.PI;
            if (vertices[offset + 6] === 0) {
                // Generate seam vertex
                var seamOffset = 8 * (positionCount + seamCount++);
                vertices.set(vertices.subarray(offset, offset + 8), seamOffset);
                vertices[seamOffset + 6] = 1.0;
                // Cache seam vertex
                seamVertices[offset / 8] = seamOffset / 8;
            }
        }
        // Get indices
        var offset1 = 0;
        this._spherePoleIdx = 0;
        for(var i1 = 0; i1 < cellsCount; i1++){
            var idx = 4 * i1;
            var indexA = cells[idx];
            var indexB = cells[idx + 1];
            var indexC = cells[idx + 2];
            var indexD = cells[idx + 3];
            // Handle seam by replacing vertex index to seam vertex index if necessary
            var floatIndexA = 8 * indexA;
            var floatIndexB = 8 * indexB;
            var floatIndexC = 8 * indexC;
            var floatIndexD = 8 * indexD;
            // If center Z is negative
            if (vertices[floatIndexA + 2] + vertices[floatIndexB + 2] + vertices[floatIndexC + 2] < 0) {
                vertices[floatIndexA + 6] === 0 && (indexA = seamVertices[indexA]);
                vertices[floatIndexB + 6] === 0 && (indexB = seamVertices[indexB]);
                vertices[floatIndexC + 6] === 0 && (indexC = seamVertices[indexC]);
                vertices[floatIndexD + 6] === 0 && (indexD = seamVertices[indexD]);
            }
            indices[offset1] = indexA;
            indices[offset1 + 1] = indexB;
            indices[offset1 + 2] = indexC;
            this._generateAndReplacePoleUV(indices, vertices, offset1, poleOffset);
            indices[offset1 + 3] = indexA;
            indices[offset1 + 4] = indexC;
            indices[offset1 + 5] = indexD;
            this._generateAndReplacePoleUV(indices, vertices, offset1 + 3, poleOffset);
            offset1 += 6;
        }
        if (!isRestoreMode) {
            var bounds = sphereMesh.bounds;
            bounds.min.set(-radius, -radius, -radius);
            bounds.max.set(radius, radius, radius);
        }
        PrimitiveMesh._initialize(sphereMesh, vertices, indices, noLongerAccessible, isRestoreMode, restoreVertexBuffer);
    };
    /**
   * @internal
   */ PrimitiveMesh._setSphereData = function _setSphereData(sphereMesh, radius, segments, noLongerAccessible, isRestoreMode, restoreVertexBuffer) {
        segments = Math.max(2, Math.floor(segments));
        var count = segments + 1;
        var vertexCount = count * count;
        var rectangleCount = segments * segments;
        var indices = PrimitiveMesh._generateIndices(sphereMesh.engine, vertexCount, rectangleCount * 6);
        var thetaRange = Math.PI;
        var alphaRange = thetaRange * 2;
        var countReciprocal = 1.0 / count;
        var segmentsReciprocal = 1.0 / segments;
        var vertexFloatCount = 8;
        var vertices = new Float32Array(vertexCount * vertexFloatCount);
        for(var i = 0; i < vertexCount; ++i){
            var x = i % count;
            var y = i * countReciprocal | 0;
            var u = x * segmentsReciprocal;
            var v = y * segmentsReciprocal;
            var alphaDelta = u * alphaRange;
            var thetaDelta = v * thetaRange;
            var sinTheta = Math.sin(thetaDelta);
            var posX = -radius * Math.cos(alphaDelta) * sinTheta;
            var posY = radius * Math.cos(thetaDelta);
            var posZ = radius * Math.sin(alphaDelta) * sinTheta;
            var offset = i * vertexFloatCount;
            // Position
            vertices[offset++] = posX;
            vertices[offset++] = posY;
            vertices[offset++] = posZ;
            // Normal
            vertices[offset++] = posX;
            vertices[offset++] = posY;
            vertices[offset++] = posZ;
            // TexCoord
            vertices[offset++] = u;
            vertices[offset++] = v;
        }
        var offset1 = 0;
        for(var i1 = 0; i1 < rectangleCount; ++i1){
            var x1 = i1 % segments;
            var y1 = i1 * segmentsReciprocal | 0;
            var a = y1 * count + x1;
            var b = a + 1;
            var c = a + count;
            var d = c + 1;
            indices[offset1++] = b;
            indices[offset1++] = a;
            indices[offset1++] = d;
            indices[offset1++] = a;
            indices[offset1++] = c;
            indices[offset1++] = d;
        }
        if (!isRestoreMode) {
            var bounds = sphereMesh.bounds;
            bounds.min.set(-radius, -radius, -radius);
            bounds.max.set(radius, radius, radius);
        }
        PrimitiveMesh._initialize(sphereMesh, vertices, indices, noLongerAccessible, isRestoreMode, restoreVertexBuffer);
    };
    /**
   * @internal
   */ PrimitiveMesh._subdiveCatmullClark = function _subdiveCatmullClark(step, positions, cells) {
        var edges = new Map();
        var faces = new Array();
        positions.set(PrimitiveMesh._sphereSeedPositions);
        cells.set(PrimitiveMesh._sphereSeedCells);
        for(var i = 0; i < step; i++){
            var cellCount = 6 * Math.pow(4, i);
            var positionCount = 4 * cellCount + 2;
            edges.clear();
            faces.length = 0;
            // Get cell face's facePoint
            for(var j = 0; j < cellCount; j++){
                var face = faces[j] = {
                    facePoint: new Vector3(),
                    adjacentEdges: new Array(4)
                };
                // Get cell's edgePoint
                for(var k = 0; k < 4; k++){
                    var offset = 3 * cells[4 * j + k];
                    face.facePoint.x += 0.25 * positions[offset];
                    face.facePoint.y += 0.25 * positions[offset + 1];
                    face.facePoint.z += 0.25 * positions[offset + 2];
                }
                // Get cell edges
                for(var k1 = 0; k1 < 4; k1++){
                    var vertexIdxA = cells[4 * j + k1];
                    var vertexIdxB = cells[4 * j + (k1 + 1) % 4];
                    var edgeIdxKey = Math.min(vertexIdxA, vertexIdxB) * positionCount + Math.max(vertexIdxA, vertexIdxB);
                    if (!edges.has(edgeIdxKey)) {
                        var edge = {
                            edgePoint: new Vector3(),
                            edgePointIndex: undefined
                        };
                        var offsetA = 3 * vertexIdxA;
                        var offsetB = 3 * vertexIdxB;
                        edge.edgePoint.set(0.25 * (positions[offsetA] + positions[offsetB]), 0.25 * (positions[offsetA + 1] + positions[offsetB + 1]), 0.25 * (positions[offsetA + 2] + positions[offsetB + 2]));
                        edges.set(edgeIdxKey, edge);
                    }
                    var edge1 = edges.get(edgeIdxKey);
                    face.adjacentEdges[k1] = edge1;
                    var edgePoint = edge1.edgePoint;
                    var facePoint = face.facePoint;
                    edgePoint.x += 0.25 * facePoint.x;
                    edgePoint.y += 0.25 * facePoint.y;
                    edgePoint.z += 0.25 * facePoint.z;
                }
            }
            var prePointCount = cellCount + 2;
            var edgePointOffset = prePointCount + cellCount;
            var pointIdx = 0;
            this._sphereEdgeIdx = 0;
            var preCells = cells.slice(0, 4 * cellCount);
            // Get New positions, which consists of updated positions of existing points, face points and edge points
            for(var j1 = 0; j1 < cellCount; j1++){
                // Add face point to new positions
                var face1 = faces[j1];
                face1.facePoint.copyToArray(positions, 3 * (prePointCount + j1));
                // Get the face point index
                var ic = prePointCount + j1;
                var id = void 0, ib = void 0, temp = void 0;
                //  ia -- id -- ia
                //  |     |     |
                //  ib -- ic -- ib
                //  |     |     |
                //  ia -- id -- ia
                for(var k2 = 0; k2 < 4; k2++){
                    // Get the updated existing point index
                    var ia = preCells[pointIdx++];
                    // ib and id share four edge points in one cell
                    switch(k2){
                        case 0:
                            {
                                var edgeB = face1.adjacentEdges[k2 % 4];
                                var edgeD = face1.adjacentEdges[(k2 + 3) % 4];
                                ib = this._calculateEdgeIndex(positions, edgeB, edgePointOffset);
                                id = this._calculateEdgeIndex(positions, edgeD, edgePointOffset);
                                temp = id;
                                break;
                            }
                        case 1:
                        case 2:
                            {
                                var edgeB1 = face1.adjacentEdges[k2 % 4];
                                id = ib;
                                ib = this._calculateEdgeIndex(positions, edgeB1, edgePointOffset);
                                break;
                            }
                        case 3:
                            {
                                id = ib;
                                ib = temp;
                                break;
                            }
                    }
                    var idx = 4 * (4 * j1 + k2);
                    cells[idx] = ia;
                    cells[idx + 1] = ib;
                    cells[idx + 2] = ic;
                    cells[idx + 3] = id;
                }
            }
        }
    };
    /**
   * Duplicate vertices at the poles and adjust their UV coordinates.
   */ PrimitiveMesh._generateAndReplacePoleUV = function _generateAndReplacePoleUV(indices, vertices, idx, poleOffset) {
        var v = vertices[8 * indices[idx] + 7];
        if (v === 0 || v === 1) {
            var offset = 8 * indices[idx];
            var addedOffset = 8 * (poleOffset + this._spherePoleIdx);
            vertices.set(vertices.subarray(offset, offset + 8), addedOffset);
            vertices[addedOffset + 6] = 0.5 * (vertices[offset + 6] + vertices[8 * indices[idx + 1] + 6] + vertices[8 * indices[idx + 2] + 6] - 0.5);
            indices[idx] = poleOffset + this._spherePoleIdx++;
        }
    };
    /**
   * Get edge point index for subdivision surface sphere.
   */ PrimitiveMesh._calculateEdgeIndex = function _calculateEdgeIndex(positions, edge, offset) {
        if (edge.edgePointIndex !== undefined) {
            return edge.edgePointIndex;
        } else {
            edge.edgePoint.copyToArray(positions, 3 * (offset + PrimitiveMesh._sphereEdgeIdx));
            var index = offset + PrimitiveMesh._sphereEdgeIdx++;
            edge.edgePointIndex = index;
            return index;
        }
    };
    /**
   * @internal
   */ PrimitiveMesh._setCuboidData = function _setCuboidData(cuboidMesh, width, height, depth, noLongerAccessible, isRestoreMode, restoreVertexBuffer) {
        var halfWidth = width / 2;
        var halfHeight = height / 2;
        var halfDepth = depth / 2;
        var vertexFloatCount = 8;
        var vertices = new Float32Array(24 * vertexFloatCount);
        // Up
        vertices[0] = -halfWidth, vertices[1] = halfHeight, vertices[2] = -halfDepth;
        vertices[6] = 0, vertices[7] = 0;
        vertices[8] = halfWidth, vertices[9] = halfHeight, vertices[10] = -halfDepth;
        vertices[14] = 1, vertices[15] = 0;
        vertices[16] = halfWidth, vertices[17] = halfHeight, vertices[18] = halfDepth;
        vertices[22] = 1, vertices[23] = 1;
        vertices[24] = -halfWidth, vertices[25] = halfHeight, vertices[26] = halfDepth;
        vertices[30] = 0, vertices[31] = 1;
        for(var i = 0; i < 4; i++){
            var normalOffset = vertexFloatCount * i + 3;
            vertices[normalOffset++] = 0, vertices[normalOffset++] = 1, vertices[normalOffset++] = 0;
        }
        // Down
        vertices[32] = -halfWidth, vertices[33] = -halfHeight, vertices[34] = -halfDepth;
        vertices[38] = 0, vertices[39] = 1;
        vertices[40] = halfWidth, vertices[41] = -halfHeight, vertices[42] = -halfDepth;
        vertices[46] = 1, vertices[47] = 1;
        vertices[48] = halfWidth, vertices[49] = -halfHeight, vertices[50] = halfDepth;
        vertices[54] = 1, vertices[55] = 0;
        vertices[56] = -halfWidth, vertices[57] = -halfHeight, vertices[58] = halfDepth;
        vertices[62] = 0, vertices[63] = 0;
        for(var i1 = 0; i1 < 4; i1++){
            var normalOffset1 = vertexFloatCount * i1 + 35;
            vertices[normalOffset1++] = 0, vertices[normalOffset1++] = -1, vertices[normalOffset1++] = 0;
        }
        // Left
        vertices[64] = -halfWidth, vertices[65] = halfHeight, vertices[66] = -halfDepth;
        vertices[70] = 0, vertices[71] = 0;
        vertices[72] = -halfWidth, vertices[73] = halfHeight, vertices[74] = halfDepth;
        vertices[78] = 1, vertices[79] = 0;
        vertices[80] = -halfWidth, vertices[81] = -halfHeight, vertices[82] = halfDepth;
        vertices[86] = 1, vertices[87] = 1;
        vertices[88] = -halfWidth, vertices[89] = -halfHeight, vertices[90] = -halfDepth;
        vertices[94] = 0, vertices[95] = 1;
        for(var i2 = 0; i2 < 4; i2++){
            var normalOffset2 = vertexFloatCount * i2 + 67;
            vertices[normalOffset2++] = -1, vertices[normalOffset2++] = 0, vertices[normalOffset2++] = 0;
        }
        // Right
        vertices[96] = halfWidth, vertices[97] = halfHeight, vertices[98] = -halfDepth;
        vertices[102] = 1, vertices[103] = 0;
        vertices[104] = halfWidth, vertices[105] = halfHeight, vertices[106] = halfDepth;
        vertices[110] = 0, vertices[111] = 0;
        vertices[112] = halfWidth, vertices[113] = -halfHeight, vertices[114] = halfDepth;
        vertices[118] = 0, vertices[119] = 1;
        vertices[120] = halfWidth, vertices[121] = -halfHeight, vertices[122] = -halfDepth;
        vertices[126] = 1, vertices[127] = 1;
        for(var i3 = 0; i3 < 4; i3++){
            var normalOffset3 = vertexFloatCount * i3 + 99;
            vertices[normalOffset3++] = 1, vertices[normalOffset3++] = 0, vertices[normalOffset3++] = 0;
        }
        // Front
        vertices[128] = -halfWidth, vertices[129] = halfHeight, vertices[130] = halfDepth;
        vertices[134] = 0, vertices[135] = 0;
        vertices[136] = halfWidth, vertices[137] = halfHeight, vertices[138] = halfDepth;
        vertices[142] = 1, vertices[143] = 0;
        vertices[144] = halfWidth, vertices[145] = -halfHeight, vertices[146] = halfDepth;
        vertices[150] = 1, vertices[151] = 1;
        vertices[152] = -halfWidth, vertices[153] = -halfHeight, vertices[154] = halfDepth;
        vertices[158] = 0, vertices[159] = 1;
        for(var i4 = 0; i4 < 4; i4++){
            var normalOffset4 = vertexFloatCount * i4 + 131;
            vertices[normalOffset4++] = 0, vertices[normalOffset4++] = 0, vertices[normalOffset4++] = 1;
        }
        // Back
        vertices[160] = -halfWidth, vertices[161] = halfHeight, vertices[162] = -halfDepth;
        vertices[166] = 1, vertices[167] = 0;
        vertices[168] = halfWidth, vertices[169] = halfHeight, vertices[170] = -halfDepth;
        vertices[174] = 0, vertices[175] = 0;
        vertices[176] = halfWidth, vertices[177] = -halfHeight, vertices[178] = -halfDepth;
        vertices[182] = 0, vertices[183] = 1;
        vertices[184] = -halfWidth, vertices[185] = -halfHeight, vertices[186] = -halfDepth;
        vertices[190] = 1, vertices[191] = 1;
        for(var i5 = 0; i5 < 4; i5++){
            var normalOffset5 = vertexFloatCount * i5 + 163;
            vertices[normalOffset5++] = 0, vertices[normalOffset5++] = 0, vertices[normalOffset5++] = -1;
        }
        var indices = new Uint16Array(36);
        // prettier-ignore
        // Up
        indices[0] = 0, indices[1] = 2, indices[2] = 1, indices[3] = 2, indices[4] = 0, indices[5] = 3, // Down
        indices[6] = 4, indices[7] = 6, indices[8] = 7, indices[9] = 6, indices[10] = 4, indices[11] = 5, // Left
        indices[12] = 8, indices[13] = 10, indices[14] = 9, indices[15] = 10, indices[16] = 8, indices[17] = 11, // Right
        indices[18] = 12, indices[19] = 14, indices[20] = 15, indices[21] = 14, indices[22] = 12, indices[23] = 13, // Front
        indices[24] = 16, indices[25] = 18, indices[26] = 17, indices[27] = 18, indices[28] = 16, indices[29] = 19, // Back
        indices[30] = 20, indices[31] = 22, indices[32] = 23, indices[33] = 22, indices[34] = 20, indices[35] = 21;
        if (!isRestoreMode) {
            var bounds = cuboidMesh.bounds;
            bounds.min.set(-halfWidth, -halfHeight, -halfDepth);
            bounds.max.set(halfWidth, halfHeight, halfDepth);
        }
        PrimitiveMesh._initialize(cuboidMesh, vertices, indices, noLongerAccessible, isRestoreMode, restoreVertexBuffer);
    };
    /**
   * @internal
   */ PrimitiveMesh._setPlaneData = function _setPlaneData(planeMesh, width, height, horizontalSegments, verticalSegments, noLongerAccessible, isRestoreMode, restoreVertexBuffer) {
        horizontalSegments = Math.max(1, Math.floor(horizontalSegments));
        verticalSegments = Math.max(1, Math.floor(verticalSegments));
        var horizontalCount = horizontalSegments + 1;
        var verticalCount = verticalSegments + 1;
        var halfWidth = width / 2;
        var halfHeight = height / 2;
        var gridWidth = width / horizontalSegments;
        var gridHeight = height / verticalSegments;
        var vertexCount = horizontalCount * verticalCount;
        var rectangleCount = verticalSegments * horizontalSegments;
        var indices = PrimitiveMesh._generateIndices(planeMesh.engine, vertexCount, rectangleCount * 6);
        var horizontalCountReciprocal = 1.0 / horizontalCount;
        var horizontalSegmentsReciprocal = 1.0 / horizontalSegments;
        var verticalSegmentsReciprocal = 1.0 / verticalSegments;
        var vertexFloatCount = 8;
        var vertices = new Float32Array(vertexCount * vertexFloatCount);
        for(var i = 0; i < vertexCount; ++i){
            var x = i % horizontalCount;
            var z = i * horizontalCountReciprocal | 0;
            var offset = i * vertexFloatCount;
            // Position
            vertices[offset++] = x * gridWidth - halfWidth;
            vertices[offset++] = 0;
            vertices[offset++] = z * gridHeight - halfHeight;
            // Normal
            vertices[offset++] = 0;
            vertices[offset++] = 1;
            vertices[offset++] = 0;
            // TexCoord
            vertices[offset++] = x * horizontalSegmentsReciprocal;
            vertices[offset++] = z * verticalSegmentsReciprocal;
        }
        var offset1 = 0;
        for(var i1 = 0; i1 < rectangleCount; ++i1){
            var x1 = i1 % horizontalSegments;
            var y = i1 * horizontalSegmentsReciprocal | 0;
            var a = y * horizontalCount + x1;
            var b = a + 1;
            var c = a + horizontalCount;
            var d = c + 1;
            indices[offset1++] = a;
            indices[offset1++] = c;
            indices[offset1++] = b;
            indices[offset1++] = c;
            indices[offset1++] = d;
            indices[offset1++] = b;
        }
        if (!isRestoreMode) {
            var bounds = planeMesh.bounds;
            bounds.min.set(-halfWidth, 0, -halfHeight);
            bounds.max.set(halfWidth, 0, halfHeight);
        }
        PrimitiveMesh._initialize(planeMesh, vertices, indices, noLongerAccessible, isRestoreMode, restoreVertexBuffer);
    };
    PrimitiveMesh._setCylinderData = function _setCylinderData(cylinderMesh, radiusTop, radiusBottom, height, radialSegments, heightSegments, noLongerAccessible, isRestoreMode, restoreVertexBuffer) {
        if (radiusTop === void 0) radiusTop = 0.5;
        if (radiusBottom === void 0) radiusBottom = 0.5;
        if (height === void 0) height = 2;
        if (radialSegments === void 0) radialSegments = 20;
        if (heightSegments === void 0) heightSegments = 1;
        radialSegments = Math.floor(radialSegments);
        heightSegments = Math.floor(heightSegments);
        var radialCount = radialSegments + 1;
        var verticalCount = heightSegments + 1;
        var halfHeight = height * 0.5;
        var unitHeight = height / heightSegments;
        var torsoVertexCount = radialCount * verticalCount;
        var torsoRectangleCount = radialSegments * heightSegments;
        var capTriangleCount = radialSegments * 2;
        var totalVertexCount = torsoVertexCount + 2 + capTriangleCount;
        var indices = PrimitiveMesh._generateIndices(cylinderMesh.engine, totalVertexCount, torsoRectangleCount * 6 + capTriangleCount * 3);
        var radialCountReciprocal = 1.0 / radialCount;
        var radialSegmentsReciprocal = 1.0 / radialSegments;
        var heightSegmentsReciprocal = 1.0 / heightSegments;
        var vertexFloatCount = 8;
        var vertices = new Float32Array(totalVertexCount * vertexFloatCount);
        var indicesOffset = 0;
        // Create torso
        var thetaStart = Math.PI;
        var thetaRange = Math.PI * 2;
        var radiusDiff = radiusBottom - radiusTop;
        var slope = radiusDiff / height;
        var radiusSlope = radiusDiff / heightSegments;
        for(var i = 0; i < torsoVertexCount; ++i){
            var x = i % radialCount;
            var y = i * radialCountReciprocal | 0;
            var u = x * radialSegmentsReciprocal;
            var v = y * heightSegmentsReciprocal;
            var theta = thetaStart + u * thetaRange;
            var sinTheta = Math.sin(theta);
            var cosTheta = Math.cos(theta);
            var radius = radiusBottom - y * radiusSlope;
            var posX = radius * sinTheta;
            var posY = y * unitHeight - halfHeight;
            var posZ = radius * cosTheta;
            var offset = i * vertexFloatCount;
            // Position
            vertices[offset++] = posX;
            vertices[offset++] = posY;
            vertices[offset++] = posZ;
            // Normal
            vertices[offset++] = sinTheta;
            vertices[offset++] = slope;
            vertices[offset++] = cosTheta;
            // TexCoord
            vertices[offset++] = u;
            vertices[offset++] = 1 - v;
        }
        for(var i1 = 0; i1 < torsoRectangleCount; ++i1){
            var x1 = i1 % radialSegments;
            var y1 = i1 * radialSegmentsReciprocal | 0;
            var a = y1 * radialCount + x1;
            var b = a + 1;
            var c = a + radialCount;
            var d = c + 1;
            indices[indicesOffset++] = b;
            indices[indicesOffset++] = c;
            indices[indicesOffset++] = a;
            indices[indicesOffset++] = b;
            indices[indicesOffset++] = d;
            indices[indicesOffset++] = c;
        }
        var offset1 = torsoVertexCount * vertexFloatCount;
        // Bottom position
        vertices[offset1++] = 0;
        vertices[offset1++] = -halfHeight;
        vertices[offset1++] = 0;
        // Bottom normal
        vertices[offset1++] = 0;
        vertices[offset1++] = -1;
        vertices[offset1++] = 0;
        // Bottom texCoord
        vertices[offset1++] = 0.5;
        vertices[offset1++] = 0.5;
        // Top position
        vertices[offset1++] = 0;
        vertices[offset1++] = halfHeight;
        vertices[offset1++] = 0;
        // Top normal
        vertices[offset1++] = 0;
        vertices[offset1++] = 1;
        vertices[offset1++] = 0;
        // Top texCoord
        vertices[offset1++] = 0.5;
        vertices[offset1++] = 0.5;
        // Add cap vertices
        offset1 = (torsoVertexCount + 2) * vertexFloatCount;
        var diameterTopReciprocal = 1.0 / (radiusTop * 2);
        var diameterBottomReciprocal = 1.0 / (radiusBottom * 2);
        var positionStride = radialCount * heightSegments;
        for(var i2 = 0; i2 < radialSegments; ++i2){
            var curPosBottomOffset = i2 * vertexFloatCount;
            var curPosX = vertices[curPosBottomOffset];
            var curPosZ = vertices[curPosBottomOffset + 2];
            // Bottom position
            vertices[offset1++] = curPosX;
            vertices[offset1++] = -halfHeight;
            vertices[offset1++] = curPosZ;
            // Bottom normal
            vertices[offset1++] = 0;
            vertices[offset1++] = -1;
            vertices[offset1++] = 0;
            // Bottom texcoord
            vertices[offset1++] = curPosX * diameterBottomReciprocal + 0.5;
            vertices[offset1++] = 0.5 - curPosZ * diameterBottomReciprocal;
            var curPosTopOffset = (i2 + positionStride) * vertexFloatCount;
            curPosX = vertices[curPosTopOffset];
            curPosZ = vertices[curPosTopOffset + 2];
            // Top position
            vertices[offset1++] = curPosX;
            vertices[offset1++] = halfHeight;
            vertices[offset1++] = curPosZ;
            // Top normal
            vertices[offset1++] = 0;
            vertices[offset1++] = 1;
            vertices[offset1++] = 0;
            // Top texcoord
            vertices[offset1++] = curPosX * diameterTopReciprocal + 0.5;
            vertices[offset1++] = 0.5 - curPosZ * diameterTopReciprocal;
        }
        // Add cap indices
        var topCapIndex = torsoVertexCount + 1;
        var bottomIndiceIndex = torsoVertexCount + 2;
        var topIndiceIndex = bottomIndiceIndex + 1;
        for(var i3 = 0; i3 < radialSegments; ++i3){
            var firstStride = i3 * 2;
            var secondStride = i3 === radialSegments - 1 ? 0 : firstStride + 2;
            // Bottom
            indices[indicesOffset++] = torsoVertexCount;
            indices[indicesOffset++] = bottomIndiceIndex + secondStride;
            indices[indicesOffset++] = bottomIndiceIndex + firstStride;
            // Top
            indices[indicesOffset++] = topCapIndex;
            indices[indicesOffset++] = topIndiceIndex + firstStride;
            indices[indicesOffset++] = topIndiceIndex + secondStride;
        }
        if (!isRestoreMode) {
            var bounds = cylinderMesh.bounds;
            var radiusMax = Math.max(radiusTop, radiusBottom);
            bounds.min.set(-radiusMax, -halfHeight, -radiusMax);
            bounds.max.set(radiusMax, halfHeight, radiusMax);
        }
        PrimitiveMesh._initialize(cylinderMesh, vertices, indices, noLongerAccessible, isRestoreMode, restoreVertexBuffer);
    };
    /**
   * @internal
   */ PrimitiveMesh._setTorusData = function _setTorusData(torusMesh, radius, tubeRadius, radialSegments, tubularSegments, arc, noLongerAccessible, isRestoreMode, restoreVertexBuffer) {
        radialSegments = Math.floor(radialSegments);
        tubularSegments = Math.floor(tubularSegments);
        var vertexCount = (radialSegments + 1) * (tubularSegments + 1);
        var rectangleCount = radialSegments * tubularSegments;
        var indices = PrimitiveMesh._generateIndices(torusMesh.engine, vertexCount, rectangleCount * 6);
        var vertexFloatCount = 8;
        var vertices = new Float32Array(vertexCount * vertexFloatCount);
        arc = arc / 180 * Math.PI;
        var offset = 0;
        var normal = PrimitiveMesh._tempVec30;
        for(var i = 0; i <= radialSegments; i++){
            for(var j = 0; j <= tubularSegments; j++){
                var u = j / tubularSegments * arc;
                var v = i / radialSegments * Math.PI * 2;
                var cosV = Math.cos(v);
                var sinV = Math.sin(v);
                var cosU = Math.cos(u);
                var sinU = Math.sin(u);
                // Position
                var positionX = (radius + tubeRadius * cosV) * cosU;
                var positionY = (radius + tubeRadius * cosV) * sinU;
                var positionZ = tubeRadius * sinV;
                vertices[offset++] = positionX;
                vertices[offset++] = positionY;
                vertices[offset++] = positionZ;
                // Normal
                var centerX = radius * cosU;
                var centerY = radius * sinU;
                normal.set(positionX - centerX, positionY - centerY, positionZ).normalize();
                vertices[offset++] = normal.x;
                vertices[offset++] = normal.y;
                vertices[offset++] = normal.z;
                // UV
                vertices[offset++] = j / tubularSegments;
                vertices[offset++] = i / radialSegments;
            }
        }
        offset = 0;
        for(var i1 = 1; i1 <= radialSegments; i1++){
            for(var j1 = 1; j1 <= tubularSegments; j1++){
                var a = (tubularSegments + 1) * i1 + j1 - 1;
                var b = (tubularSegments + 1) * (i1 - 1) + j1 - 1;
                var c = (tubularSegments + 1) * (i1 - 1) + j1;
                var d = (tubularSegments + 1) * i1 + j1;
                indices[offset++] = a;
                indices[offset++] = b;
                indices[offset++] = d;
                indices[offset++] = b;
                indices[offset++] = c;
                indices[offset++] = d;
            }
        }
        if (!isRestoreMode) {
            var bounds = torusMesh.bounds;
            var outerRadius = radius + tubeRadius;
            bounds.min.set(-outerRadius, -outerRadius, -tubeRadius);
            bounds.max.set(outerRadius, outerRadius, tubeRadius);
        }
        PrimitiveMesh._initialize(torusMesh, vertices, indices, noLongerAccessible, isRestoreMode, restoreVertexBuffer);
    };
    /**
   * @internal
   */ PrimitiveMesh._setConeData = function _setConeData(coneMesh, radius, height, radialSegments, heightSegments, noLongerAccessible, isRestoreMode, restoreVertexBuffer) {
        radialSegments = Math.floor(radialSegments);
        heightSegments = Math.floor(heightSegments);
        var radialCount = radialSegments + 1;
        var verticalCount = heightSegments + 1;
        var halfHeight = height * 0.5;
        var unitHeight = height / heightSegments;
        var torsoVertexCount = radialCount * verticalCount;
        var torsoRectangleCount = radialSegments * heightSegments;
        var totalVertexCount = torsoVertexCount + 1 + radialSegments;
        var indices = PrimitiveMesh._generateIndices(coneMesh.engine, totalVertexCount, torsoRectangleCount * 6 + radialSegments * 3);
        var radialCountReciprocal = 1.0 / radialCount;
        var radialSegmentsReciprocal = 1.0 / radialSegments;
        var heightSegmentsReciprocal = 1.0 / heightSegments;
        var vertexFloatCount = 8;
        var vertices = new Float32Array(totalVertexCount * 8);
        var indicesOffset = 0;
        // Create torso
        var thetaStart = Math.PI;
        var thetaRange = Math.PI * 2;
        var slope = radius / height;
        for(var i = 0; i < torsoVertexCount; ++i){
            var x = i % radialCount;
            var y = i * radialCountReciprocal | 0;
            var u = x * radialSegmentsReciprocal;
            var v = y * heightSegmentsReciprocal;
            var theta = thetaStart + u * thetaRange;
            var sinTheta = Math.sin(theta);
            var cosTheta = Math.cos(theta);
            var curRadius = radius - v * radius;
            var posX = curRadius * sinTheta;
            var posY = y * unitHeight - halfHeight;
            var posZ = curRadius * cosTheta;
            var offset = i * vertexFloatCount;
            // Position
            vertices[offset++] = posX;
            vertices[offset++] = posY;
            vertices[offset++] = posZ;
            // Normal
            vertices[offset++] = sinTheta;
            vertices[offset++] = slope;
            vertices[offset++] = cosTheta;
            // Texcoord
            vertices[offset++] = u;
            vertices[offset++] = 1 - v;
        }
        for(var i1 = 0; i1 < torsoRectangleCount; ++i1){
            var x1 = i1 % radialSegments;
            var y1 = i1 * radialSegmentsReciprocal | 0;
            var a = y1 * radialCount + x1;
            var b = a + 1;
            var c = a + radialCount;
            var d = c + 1;
            indices[indicesOffset++] = b;
            indices[indicesOffset++] = c;
            indices[indicesOffset++] = a;
            indices[indicesOffset++] = b;
            indices[indicesOffset++] = d;
            indices[indicesOffset++] = c;
        }
        var offset1 = torsoVertexCount * vertexFloatCount;
        // Bottom position
        vertices[offset1++] = 0;
        vertices[offset1++] = -halfHeight;
        vertices[offset1++] = 0;
        // Bottom normal
        vertices[offset1++] = 0;
        vertices[offset1++] = -1;
        vertices[offset1++] = 0;
        // Bottom texcoord
        vertices[offset1++] = 0.5;
        vertices[offset1++] = 0.5;
        // Add bottom cap vertices
        offset1 = (torsoVertexCount + 1) * vertexFloatCount;
        var diameterBottomReciprocal = 1.0 / (radius * 2);
        for(var i2 = 0; i2 < radialSegments; ++i2){
            var curPosX = vertices[i2 * vertexFloatCount];
            var curPosZ = vertices[i2 * vertexFloatCount + 2];
            // Bottom position
            vertices[offset1++] = curPosX;
            vertices[offset1++] = -halfHeight;
            vertices[offset1++] = curPosZ;
            // Bottom normal
            vertices[offset1++] = 0;
            vertices[offset1++] = -1;
            vertices[offset1++] = 0;
            // Bottom texcoord
            vertices[offset1++] = curPosX * diameterBottomReciprocal + 0.5;
            vertices[offset1++] = 0.5 - curPosZ * diameterBottomReciprocal;
        }
        var bottomIndiceIndex = torsoVertexCount + 1;
        for(var i3 = 0; i3 < radialSegments; ++i3){
            var firstStride = i3;
            var secondStride = i3 === radialSegments - 1 ? 0 : firstStride + 1;
            // Bottom
            indices[indicesOffset++] = torsoVertexCount;
            indices[indicesOffset++] = bottomIndiceIndex + secondStride;
            indices[indicesOffset++] = bottomIndiceIndex + firstStride;
        }
        if (!isRestoreMode) {
            var bounds = coneMesh.bounds;
            bounds.min.set(-radius, -halfHeight, -radius);
            bounds.max.set(radius, halfHeight, radius);
        }
        PrimitiveMesh._initialize(coneMesh, vertices, indices, noLongerAccessible, isRestoreMode, restoreVertexBuffer);
    };
    PrimitiveMesh._setCapsuleData = function _setCapsuleData(capsuleMesh, radius, height, radialSegments, heightSegments, noLongerAccessible, isRestoreMode, restoreVertexBuffer) {
        radialSegments = Math.max(2, Math.floor(radialSegments));
        heightSegments = Math.floor(heightSegments);
        var radialCount = radialSegments + 1;
        var verticalCount = heightSegments + 1;
        var halfHeight = height * 0.5;
        var unitHeight = height / heightSegments;
        var torsoVertexCount = radialCount * verticalCount;
        var torsoRectangleCount = radialSegments * heightSegments;
        var capVertexCount = radialCount * radialCount;
        var capRectangleCount = radialSegments * radialSegments;
        var totalVertexCount = torsoVertexCount + 2 * capVertexCount;
        var indices = PrimitiveMesh._generateIndices(capsuleMesh.engine, totalVertexCount, (torsoRectangleCount + 2 * capRectangleCount) * 6);
        var radialCountReciprocal = 1.0 / radialCount;
        var radialSegmentsReciprocal = 1.0 / radialSegments;
        var heightSegmentsReciprocal = 1.0 / heightSegments;
        var thetaStart = Math.PI;
        var thetaRange = Math.PI * 2;
        var vertexFloatCount = 8;
        var vertices = new Float32Array(totalVertexCount * vertexFloatCount);
        var indicesOffset = 0;
        // create torso
        for(var i = 0; i < torsoVertexCount; ++i){
            var x = i % radialCount;
            var y = i * radialCountReciprocal | 0;
            var u = x * radialSegmentsReciprocal;
            var v = y * heightSegmentsReciprocal;
            var theta = thetaStart + u * thetaRange;
            var sinTheta = Math.sin(theta);
            var cosTheta = Math.cos(theta);
            var offset = i * vertexFloatCount;
            // position
            vertices[offset++] = radius * sinTheta;
            vertices[offset++] = y * unitHeight - halfHeight;
            vertices[offset++] = radius * cosTheta;
            // Normal
            vertices[offset++] = sinTheta;
            vertices[offset++] = 0;
            vertices[offset++] = cosTheta;
            // Texcoord
            vertices[offset++] = u;
            vertices[offset++] = 1 - v;
        }
        for(var i1 = 0; i1 < torsoRectangleCount; ++i1){
            var x1 = i1 % radialSegments;
            var y1 = i1 * radialSegmentsReciprocal | 0;
            var a = y1 * radialCount + x1;
            var b = a + 1;
            var c = a + radialCount;
            var d = c + 1;
            indices[indicesOffset++] = b;
            indices[indicesOffset++] = c;
            indices[indicesOffset++] = a;
            indices[indicesOffset++] = b;
            indices[indicesOffset++] = d;
            indices[indicesOffset++] = c;
        }
        PrimitiveMesh._createCapsuleCap(radius, height, radialSegments, thetaStart, thetaRange, torsoVertexCount, 1, vertices, indices, indicesOffset);
        PrimitiveMesh._createCapsuleCap(radius, height, radialSegments, thetaStart, -thetaRange, torsoVertexCount + capVertexCount, -1, vertices, indices, indicesOffset + 6 * capRectangleCount);
        if (!isRestoreMode) {
            var bounds = capsuleMesh.bounds;
            bounds.min.set(-radius, -radius - halfHeight, -radius);
            bounds.max.set(radius, radius + halfHeight, radius);
        }
        PrimitiveMesh._initialize(capsuleMesh, vertices, indices, noLongerAccessible, isRestoreMode, restoreVertexBuffer);
    };
    PrimitiveMesh._initialize = function _initialize(mesh, vertices, indices, noLongerAccessible, isRestoreMode, restoreVertexBuffer) {
        if (isRestoreMode) {
            restoreVertexBuffer.setData(vertices);
            mesh.setIndices(indices);
            mesh.uploadData(noLongerAccessible);
        } else {
            var vertexElements = [
                new VertexElement(VertexAttribute.Position, 0, VertexElementFormat.Vector3, 0),
                new VertexElement(VertexAttribute.Normal, 12, VertexElementFormat.Vector3, 0),
                new VertexElement(VertexAttribute.UV, 24, VertexElementFormat.Vector2, 0)
            ];
            mesh.setVertexElements(vertexElements);
            var vertexBuffer = new Buffer(mesh.engine, BufferBindFlag.VertexBuffer, vertices, BufferUsage.Static, true);
            mesh.setVertexBufferBinding(vertexBuffer, 32, 0);
            mesh.setIndices(indices);
            mesh.calculateTangents();
            mesh.uploadData(noLongerAccessible);
            mesh.addSubMesh(0, indices.length);
        }
    };
    PrimitiveMesh._generateIndices = function _generateIndices(engine, vertexCount, indexCount) {
        var indices = null;
        if (vertexCount > 65535) {
            if (engine._hardwareRenderer.canIUse(GLCapabilityType.elementIndexUint)) {
                indices = new Uint32Array(indexCount);
            } else {
                throw Error("The vertex count is over limit.");
            }
        } else {
            indices = new Uint16Array(indexCount);
        }
        return indices;
    };
    PrimitiveMesh._createCapsuleCap = function _createCapsuleCap(radius, height, radialSegments, thetaStart, thetaRange, offset, posIndex, vertices, indices, indicesOffset) {
        var radialCount = radialSegments + 1;
        var halfHeight = height * 0.5 * posIndex;
        var capVertexCount = radialCount * radialCount;
        var capRectangleCount = radialSegments * radialSegments;
        var radialCountReciprocal = 1.0 / radialCount;
        var radialSegmentsReciprocal = 1.0 / radialSegments;
        var vertexFloatCount = 8;
        for(var i = 0; i < capVertexCount; ++i){
            var x = i % radialCount;
            var y = i * radialCountReciprocal | 0;
            var u = x * radialSegmentsReciprocal;
            var v = y * radialSegmentsReciprocal;
            var theta = thetaStart + u * thetaRange;
            var alpha = v * Math.PI * 0.5;
            var sinAlpha = Math.sin(alpha);
            var posX = radius * Math.sin(theta) * sinAlpha;
            var posY = radius * Math.cos(alpha) * posIndex + halfHeight;
            var posZ = radius * Math.cos(theta) * sinAlpha;
            var index = (i + offset) * vertexFloatCount;
            // Position
            vertices[index++] = posX;
            vertices[index++] = posY;
            vertices[index++] = posZ;
            // Normal
            vertices[index++] = posX;
            vertices[index++] = posY - halfHeight;
            vertices[index++] = posZ;
            // Texcoord
            vertices[index++] = u;
            vertices[index++] = v;
        }
        for(var i1 = 0; i1 < capRectangleCount; ++i1){
            var x1 = i1 % radialSegments;
            var y1 = i1 * radialSegmentsReciprocal | 0;
            var a = y1 * radialCount + x1 + offset;
            var b = a + 1;
            var c = a + radialCount;
            var d = c + 1;
            indices[indicesOffset++] = b;
            indices[indicesOffset++] = a;
            indices[indicesOffset++] = d;
            indices[indicesOffset++] = a;
            indices[indicesOffset++] = c;
            indices[indicesOffset++] = d;
        }
    };
    return PrimitiveMesh;
}();
PrimitiveMesh._tempVec30 = new Vector3();
PrimitiveMesh._sphereSeedPositions = new Float32Array([
    -1,
    1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    1,
    1,
    1,
    1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1
]);
PrimitiveMesh._sphereSeedCells = new Float32Array([
    0,
    1,
    2,
    3,
    3,
    2,
    4,
    5,
    5,
    4,
    6,
    7,
    7,
    0,
    3,
    5,
    7,
    6,
    1,
    0,
    6,
    4,
    2,
    1
]);
PrimitiveMesh._sphereEdgeIdx = 0;
PrimitiveMesh._spherePoleIdx = 0;

function _is_native_reflect_construct$1() {
    // Since Reflect.construct can't be properly polyfilled, some
    // implementations (e.g. core-js@2) don't set the correct internal slots.
    // Those polyfills don't allow us to subclass built-ins, so we need to
    // use our fallback implementation.
    try {
        // If the internal slots aren't set, this throws an error similar to
        //   TypeError: this is not a Boolean object.
        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (_) {}
    return (_is_native_reflect_construct$1 = function() {
        return !!result;
    })();
}

function _construct$1(Parent, args, Class) {
    if (_is_native_reflect_construct$1()) _construct$1 = Reflect.construct;
    else {
        _construct$1 = function construct(Parent, args, Class) {
            var a = [null];
            a.push.apply(a, args);
            var Constructor = Function.bind.apply(Parent, a);
            var instance = new Constructor();

            if (Class) _set_prototype_of$2(instance, Class.prototype);

            return instance;
        };
    }

    return _construct$1.apply(null, arguments);
}

var ComponentCloner = /*#__PURE__*/ function() {
    function ComponentCloner() {}
    /**
   * Clone component.
   * @param source - Clone source
   * @param target - Clone target
   */ ComponentCloner.cloneComponent = function cloneComponent(source, target, srcRoot, targetRoot, deepInstanceMap) {
        var cloneModes = CloneManager.getCloneMode(source.constructor);
        for(var k in source){
            CloneManager.cloneProperty(source, target, k, cloneModes[k], srcRoot, targetRoot, deepInstanceMap);
        }
        if (source._cloneTo) {
            source._cloneTo(target, srcRoot, targetRoot);
        }
    };
    return ComponentCloner;
}();

/**
 * The entity modify flags.
 */ var EntityModifyFlags = /*#__PURE__*/ function(EntityModifyFlags) {
    /** The parent changes. */ EntityModifyFlags[EntityModifyFlags["Parent"] = 1] = "Parent";
    /** The child changes. */ EntityModifyFlags[EntityModifyFlags["Child"] = 2] = "Child";
    return EntityModifyFlags;
}({});

/**
 * Entity, be used as components container.
 */ var Entity = /*#__PURE__*/ function(EngineObject) {
    _inherits$2(Entity, EngineObject);
    function Entity(engine, name) {
        for(var _len = arguments.length, components = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){
            components[_key - 2] = arguments[_key];
        }
        var _this;
        _this = EngineObject.call(this, engine) || this, /** The layer the entity belongs to. */ _this.layer = Layer.Layer0, /** @internal */ _this._isActiveInHierarchy = false, /** @internal */ _this._isActiveInScene = false, /** @internal */ _this._components = [], /** @internal */ _this._scripts = new DisorderedArray(), /** @internal */ _this._children = [], /** @internal */ _this._isRoot = false, /** @internal */ _this._isActive = true, /** @internal */ _this._siblingIndex = -1, /** @internal */ _this._isTemplate = false, /** @internal */ _this._updateFlagManager = new UpdateFlagManager(), _this._parent = null, //--------------------------------------------------------------deprecated----------------------------------------------------------------
        _this._invModelMatrix = new Matrix();
        _this.name = name != null ? name : "Entity";
        for(var i = 0, n = components.length; i < n; i++){
            _this.addComponent(components[i]);
        }
        !_this._transform && _this.addComponent(Transform);
        _this._inverseWorldMatFlag = _this.registerWorldChangeFlag();
        return _this;
    }
    var _proto = Entity.prototype;
    /**
   * Add component based on the component type.
   * @param type - The type of the component
   * @param args - The arguments of the component
   * @returns	The component which has been added
   */ _proto.addComponent = function addComponent(type) {
        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            args[_key - 1] = arguments[_key];
        }
        ComponentsDependencies._addCheck(this, type);
        var component = _construct$1(type, [].concat([
            this
        ], args));
        this._components.push(component);
        // @todo: temporary solution
        if (_instanceof$3(component, Transform)) {
            var transform = this._transform;
            this._transform = component;
            transform == null ? void 0 : transform.destroy();
        }
        component._setActive(true, ActiveChangeFlag.All);
        return component;
    };
    /**
   * Get component which match the type.
   * @param type - The type of the component
   * @returns	The first component which match type
   */ _proto.getComponent = function getComponent(type) {
        var components = this._components;
        for(var i = 0, n = components.length; i < n; i++){
            var component = components[i];
            if (_instanceof$3(component, type)) {
                return component;
            }
        }
        return null;
    };
    /**
   * Get components which match the type.
   * @param type - The type of the component
   * @param results - The components which match type
   * @returns	The components which match type
   */ _proto.getComponents = function getComponents(type, results) {
        results.length = 0;
        var components = this._components;
        for(var i = 0, n = components.length; i < n; i++){
            var component = components[i];
            if (_instanceof$3(component, type)) {
                results.push(component);
            }
        }
        return results;
    };
    /**
   * Get the components which match the type of the entity and it's children.
   * @param type - The component type
   * @param results - The components collection
   * @returns	The components collection which match the type
   */ _proto.getComponentsIncludeChildren = function getComponentsIncludeChildren(type, results) {
        results.length = 0;
        this._getComponentsInChildren(type, results);
        return results;
    };
    _proto.addChild = function addChild(indexOrChild, child) {
        var index;
        if (typeof indexOrChild === "number") {
            index = indexOrChild;
        } else {
            index = undefined;
            child = indexOrChild;
        }
        if (child._isRoot) {
            var oldScene = child._scene;
            Entity._removeFromChildren(oldScene._rootEntities, child);
            child._isRoot = false;
            this._addToChildrenList(index, child);
            child._parent = this;
            var newScene = this._scene;
            var inActiveChangeFlag = ActiveChangeFlag.None;
            if (!this._isActiveInHierarchy) {
                child._isActiveInHierarchy && (inActiveChangeFlag |= ActiveChangeFlag.Hierarchy);
            }
            if (child._isActiveInScene) {
                if (this._isActiveInScene) {
                    // Cross scene should inActive first and then active
                    oldScene !== newScene && (inActiveChangeFlag |= ActiveChangeFlag.Scene);
                } else {
                    inActiveChangeFlag |= ActiveChangeFlag.Scene;
                }
            }
            inActiveChangeFlag && child._processInActive(inActiveChangeFlag);
            if (child._scene !== newScene) {
                Entity._traverseSetOwnerScene(child, newScene);
            }
            var activeChangeFlag = ActiveChangeFlag.None;
            if (child._isActive) {
                if (this._isActiveInHierarchy) {
                    !child._isActiveInHierarchy && (activeChangeFlag |= ActiveChangeFlag.Hierarchy);
                }
                if (this._isActiveInScene) {
                    (!child._isActiveInScene || oldScene !== newScene) && (activeChangeFlag |= ActiveChangeFlag.Scene);
                }
            }
            activeChangeFlag && child._processActive(activeChangeFlag);
            child._setParentChange();
        } else {
            child._setParent(this, index);
        }
    };
    /**
   * Remove child entity.
   * @param child - The child entity which want to be removed
   */ _proto.removeChild = function removeChild(child) {
        child._setParent(null);
    };
    /**
   * @deprecated Please use `children` property instead.
   * Find child entity by index.
   * @param index - The index of the child entity
   * @returns	The component which be found
   */ _proto.getChild = function getChild(index) {
        return this._children[index];
    };
    /**
   * Find entity by name.
   * @param name - The name of the entity which want to be found
   * @returns The component which be found
   */ _proto.findByName = function findByName(name) {
        if (name === this.name) {
            return this;
        }
        var children = this._children;
        for(var i = 0, n = children.length; i < n; i++){
            var target = children[i].findByName(name);
            if (target) {
                return target;
            }
        }
        return null;
    };
    /**
   * Find the entity by path.
   * @param path - The path of the entity eg: /entity
   * @returns The component which be found
   */ _proto.findByPath = function findByPath(path) {
        var splits = path.split("/").filter(Boolean);
        if (!splits.length) {
            return this;
        }
        return Entity._findChildByName(this, 0, splits, 0);
    };
    /**
   * Create child entity.
   * @param name - The child entity's name
   * @returns The child entity
   */ _proto.createChild = function createChild(name) {
        var transform = this._transform;
        var child = transform ? new Entity(this.engine, name, transform.constructor) : new Entity(this.engine, name);
        child.layer = this.layer;
        child.parent = this;
        return child;
    };
    /**
   * Clear children entities.
   */ _proto.clearChildren = function clearChildren() {
        var children = this._children;
        for(var i = children.length - 1; i >= 0; i--){
            var child = children[i];
            child._parent = null;
            var activeChangeFlag = ActiveChangeFlag.None;
            child._isActiveInHierarchy && (activeChangeFlag |= ActiveChangeFlag.Hierarchy);
            child._isActiveInScene && (activeChangeFlag |= ActiveChangeFlag.Scene);
            activeChangeFlag && child._processInActive(activeChangeFlag);
            Entity._traverseSetOwnerScene(child, null); // Must after child._processInActive().
        }
        children.length = 0;
    };
    /**
   * Clone this entity include children and components.
   * @returns Cloned entity
   */ _proto.clone = function clone() {
        var cloneEntity = this._createCloneEntity();
        this._parseCloneEntity(this, cloneEntity, this, cloneEntity, new Map());
        return cloneEntity;
    };
    /**
   * Listen for changes in the world pose of this `Entity`.
   * @returns Change flag
   */ _proto.registerWorldChangeFlag = function registerWorldChangeFlag() {
        return this._updateFlagManager.createFlag(BoolUpdateFlag);
    };
    /**
   * @internal
   */ _proto._markAsTemplate = function _markAsTemplate(templateResource) {
        this._isTemplate = true;
        this._templateResource = templateResource;
    };
    _proto._createCloneEntity = function _createCloneEntity() {
        var transform = this._transform;
        var cloneEntity = transform ? new Entity(this.engine, this.name, transform.constructor) : new Entity(this.engine, this.name);
        var templateResource = this._templateResource;
        if (templateResource) {
            cloneEntity._templateResource = templateResource;
            templateResource._addReferCount(1);
        }
        cloneEntity.layer = this.layer;
        cloneEntity._isActive = this._isActive;
        cloneEntity.transform._copyFrom(this.transform);
        var srcChildren = this._children;
        for(var i = 0, n = srcChildren.length; i < n; i++){
            cloneEntity.addChild(srcChildren[i]._createCloneEntity());
        }
        return cloneEntity;
    };
    _proto._parseCloneEntity = function _parseCloneEntity(src, target, srcRoot, targetRoot, deepInstanceMap) {
        var srcChildren = src._children;
        var targetChildren = target._children;
        for(var i = 0, n = srcChildren.length; i < n; i++){
            this._parseCloneEntity(srcChildren[i], targetChildren[i], srcRoot, targetRoot, deepInstanceMap);
        }
        var components = src._components;
        for(var i1 = 0, n1 = components.length; i1 < n1; i1++){
            var sourceComp = components[i1];
            if (!_instanceof$3(sourceComp, Transform)) {
                var targetComp = target.addComponent(sourceComp.constructor);
                ComponentCloner.cloneComponent(sourceComp, targetComp, srcRoot, targetRoot, deepInstanceMap);
            }
        }
    };
    /**
   * Destroy self.
   */ _proto.destroy = function destroy() {
        if (this._destroyed) {
            return;
        }
        EngineObject.prototype.destroy.call(this);
        if (this._templateResource) {
            this._isTemplate || this._templateResource._addReferCount(-1);
            this._templateResource = null;
        }
        var components = this._components;
        for(var i = components.length - 1; i >= 0; i--){
            components[i].destroy();
        }
        this._components.length = 0;
        var children = this._children;
        while(children.length > 0){
            children[0].destroy();
        }
        if (this._isRoot) {
            this._scene.removeRootEntity(this);
        } else {
            this._setParent(null);
        }
        this.isActive = false;
    };
    /**
   * @internal
   */ _proto._removeComponent = function _removeComponent(component) {
        ComponentsDependencies._removeCheck(this, component.constructor);
        var components = this._components;
        components.splice(components.indexOf(component), 1);
    };
    /**
   * @internal
   */ _proto._addScript = function _addScript(script) {
        script._entityScriptsIndex = this._scripts.length;
        this._scripts.add(script);
    };
    /**
   * @internal
   */ _proto._removeScript = function _removeScript(script) {
        var replaced = this._scripts.deleteByIndex(script._entityScriptsIndex);
        replaced && (replaced._entityScriptsIndex = script._entityScriptsIndex);
        script._entityScriptsIndex = -1;
    };
    /**
   * @internal
   */ _proto._removeFromParent = function _removeFromParent() {
        var oldParent = this._parent;
        if (oldParent != null) {
            Entity._removeFromChildren(oldParent._children, this);
            this._parent = null;
            oldParent._dispatchModify(EntityModifyFlags.Child, oldParent);
        }
    };
    /**
   * @internal
   */ _proto._processActive = function _processActive(activeChangeFlag) {
        if (this._activeChangedComponents) {
            throw "Note: can't set the 'main inActive entity' active in hierarchy, if the operation is in main inActive entity or it's children script's onDisable Event.";
        }
        this._activeChangedComponents = this._scene._componentsManager.getActiveChangedTempList();
        this._setActiveInHierarchy(this._activeChangedComponents, activeChangeFlag);
        this._setActiveComponents(true, activeChangeFlag);
    };
    /**
   * @internal
   */ _proto._processInActive = function _processInActive(activeChangeFlag) {
        if (this._activeChangedComponents) {
            throw "Note: can't set the 'main active entity' inActive in hierarchy, if the operation is in main active entity or it's children script's onEnable Event.";
        }
        this._activeChangedComponents = this._scene._componentsManager.getActiveChangedTempList();
        this._setInActiveInHierarchy(this._activeChangedComponents, activeChangeFlag);
        this._setActiveComponents(false, activeChangeFlag);
    };
    /**
   * @internal
   */ _proto._setParentChange = function _setParentChange() {
        this._transform._parentChange();
        this._dispatchModify(EntityModifyFlags.Parent, this);
    };
    /**
   * @internal
   */ _proto._registerModifyListener = function _registerModifyListener(onChange) {
        (this._modifyFlagManager || (this._modifyFlagManager = new UpdateFlagManager())).addListener(onChange);
    };
    /**
   * @internal
   */ _proto._unRegisterModifyListener = function _unRegisterModifyListener(onChange) {
        var _this__modifyFlagManager;
        (_this__modifyFlagManager = this._modifyFlagManager) == null ? void 0 : _this__modifyFlagManager.removeListener(onChange);
    };
    _proto._dispatchModify = function _dispatchModify(flag, param) {
        var _this__modifyFlagManager;
        (_this__modifyFlagManager = this._modifyFlagManager) == null ? void 0 : _this__modifyFlagManager.dispatch(flag, param);
    };
    _proto._addToChildrenList = function _addToChildrenList(index, child) {
        Entity._addToChildren(this._children, child, index);
        this._dispatchModify(EntityModifyFlags.Child, this);
    };
    _proto._setParent = function _setParent(parent, siblingIndex) {
        var oldParent = this._parent;
        if (parent !== oldParent) {
            this._removeFromParent();
            this._parent = parent;
            if (parent) {
                this._isRoot = false;
                parent._addToChildrenList(siblingIndex, this);
                var oldScene = this._scene;
                var parentScene = parent._scene;
                var inActiveChangeFlag = ActiveChangeFlag.None;
                if (!parent._isActiveInHierarchy) {
                    this._isActiveInHierarchy && (inActiveChangeFlag |= ActiveChangeFlag.Hierarchy);
                }
                if (parent._isActiveInScene) {
                    // cross scene should inActive first and then active
                    this._isActiveInScene && oldScene !== parentScene && (inActiveChangeFlag |= ActiveChangeFlag.Scene);
                } else {
                    this._isActiveInScene && (inActiveChangeFlag |= ActiveChangeFlag.Scene);
                }
                inActiveChangeFlag && this._processInActive(inActiveChangeFlag);
                if (oldScene !== parentScene) {
                    Entity._traverseSetOwnerScene(this, parentScene);
                }
                var activeChangeFlag = ActiveChangeFlag.None;
                if (this._isActive) {
                    if (parent._isActiveInHierarchy) {
                        !this._isActiveInHierarchy && (activeChangeFlag |= ActiveChangeFlag.Hierarchy);
                    }
                    if (parent._isActiveInScene) {
                        (!this._isActiveInScene || oldScene !== parentScene) && (activeChangeFlag |= ActiveChangeFlag.Scene);
                    }
                }
                activeChangeFlag && this._processActive(activeChangeFlag);
            } else {
                var inActiveChangeFlag1 = ActiveChangeFlag.None;
                this._isActiveInHierarchy && (inActiveChangeFlag1 |= ActiveChangeFlag.Hierarchy);
                this._isActiveInScene && (inActiveChangeFlag1 |= ActiveChangeFlag.Scene);
                inActiveChangeFlag1 && this._processInActive(inActiveChangeFlag1);
                if (oldParent) {
                    Entity._traverseSetOwnerScene(this, null);
                }
            }
            this._setParentChange();
        } else {
            if (parent && siblingIndex !== undefined) {
                this.siblingIndex = siblingIndex;
            }
        }
    };
    _proto._getComponentsInChildren = function _getComponentsInChildren(type, results) {
        for(var i = this._components.length - 1; i >= 0; i--){
            var component = this._components[i];
            if (_instanceof$3(component, type)) {
                results.push(component);
            }
        }
        for(var i1 = this._children.length - 1; i1 >= 0; i1--){
            this._children[i1]._getComponentsInChildren(type, results);
        }
    };
    _proto._setActiveComponents = function _setActiveComponents(isActive, activeChangeFlag) {
        var activeChangedComponents = this._activeChangedComponents;
        for(var i = 0, length = activeChangedComponents.length; i < length; ++i){
            activeChangedComponents[i]._setActive(isActive, activeChangeFlag);
        }
        this._scene._componentsManager.putActiveChangedTempList(activeChangedComponents);
        this._activeChangedComponents = null;
    };
    _proto._setActiveInHierarchy = function _setActiveInHierarchy(activeChangedComponents, activeChangeFlag) {
        activeChangeFlag & ActiveChangeFlag.Hierarchy && (this._isActiveInHierarchy = true);
        activeChangeFlag & ActiveChangeFlag.Scene && (this._isActiveInScene = true);
        var components = this._components;
        for(var i = 0, n = components.length; i < n; i++){
            var component = components[i];
            (component.enabled || !component._awoken) && activeChangedComponents.push(component);
        }
        var children = this._children;
        for(var i1 = 0, n1 = children.length; i1 < n1; i1++){
            var child = children[i1];
            child.isActive && child._setActiveInHierarchy(activeChangedComponents, activeChangeFlag);
        }
    };
    _proto._setInActiveInHierarchy = function _setInActiveInHierarchy(activeChangedComponents, activeChangeFlag) {
        activeChangeFlag & ActiveChangeFlag.Hierarchy && (this._isActiveInHierarchy = false);
        activeChangeFlag & ActiveChangeFlag.Scene && (this._isActiveInScene = false);
        var components = this._components;
        for(var i = 0, n = components.length; i < n; i++){
            var component = components[i];
            component.enabled && activeChangedComponents.push(component);
        }
        var children = this._children;
        for(var i1 = 0, n1 = children.length; i1 < n1; i1++){
            var child = children[i1];
            child.isActive && child._setInActiveInHierarchy(activeChangedComponents, activeChangeFlag);
        }
    };
    _proto._setSiblingIndex = function _setSiblingIndex(sibling, target) {
        target = Math.min(target, sibling.length - 1);
        if (target < 0) {
            throw "Sibling index " + target + " should large than 0";
        }
        if (this._siblingIndex !== target) {
            var oldIndex = this._siblingIndex;
            if (target < oldIndex) {
                for(var i = oldIndex; i >= target; i--){
                    var child = i == target ? this : sibling[i - 1];
                    sibling[i] = child;
                    child._siblingIndex = i;
                }
            } else {
                for(var i1 = oldIndex; i1 <= target; i1++){
                    var child1 = i1 == target ? this : sibling[i1 + 1];
                    sibling[i1] = child1;
                    child1._siblingIndex = i1;
                }
            }
        }
    };
    /**
   * @deprecated
   */ _proto.getInvModelMatrix = function getInvModelMatrix() {
        if (this._inverseWorldMatFlag.flag) {
            Matrix.invert(this._transform.worldMatrix, this._invModelMatrix);
            this._inverseWorldMatFlag.flag = false;
        }
        return this._invModelMatrix;
    };
    /**
   * @internal
   */ Entity._findChildByName = function _findChildByName(entity, childIndex, paths, pathIndex) {
        var searchPath = paths[pathIndex];
        var isEndPath = pathIndex === paths.length - 1;
        var children = entity._children;
        for(var n = children.length; childIndex < n; childIndex++){
            var child = children[childIndex];
            if (child.name === searchPath) {
                // Search success if end path, or downward search
                return isEndPath ? child : Entity._findChildByName(child, 0, paths, pathIndex + 1);
            }
        }
        // Search failed if first path, or upward search
        return pathIndex === 0 ? null : Entity._findChildByName(entity.parent, entity.siblingIndex + 1, paths, pathIndex - 1);
    };
    /**
   * @internal
   */ Entity._traverseSetOwnerScene = function _traverseSetOwnerScene(entity, scene) {
        entity._scene = scene;
        var children = entity._children;
        for(var i = children.length - 1; i >= 0; i--){
            this._traverseSetOwnerScene(children[i], scene);
        }
    };
    /**
   * @internal
   */ Entity._getEntityHierarchyPath = function _getEntityHierarchyPath(rootEntity, searchEntity, inversePath) {
        inversePath.length = 0;
        while(searchEntity !== rootEntity){
            var parent = searchEntity.parent;
            if (!parent) {
                return false;
            }
            inversePath.push(searchEntity.siblingIndex);
            searchEntity = parent;
        }
        return true;
    };
    /**
   * @internal
   */ Entity._getEntityByHierarchyPath = function _getEntityByHierarchyPath(rootEntity, inversePath) {
        var entity = rootEntity;
        for(var i = inversePath.length - 1; i >= 0; i--){
            entity = entity.children[inversePath[i]];
        }
        return entity;
    };
    /**
   * @internal
   */ Entity._removeFromChildren = function _removeFromChildren(children, entity) {
        var count = children.length - 1;
        for(var i = entity._siblingIndex; i < count; i++){
            var child = children[i + 1];
            children[i] = child;
            child._siblingIndex = i;
        }
        children.length = count;
        entity._siblingIndex = -1;
    };
    /**
   * @internal
   */ Entity._addToChildren = function _addToChildren(children, entity, index) {
        var childCount = children.length;
        children.length = childCount + 1;
        if (index === undefined) {
            children[childCount] = entity;
            entity._siblingIndex = childCount;
        } else {
            if (index < 0 || index > childCount) {
                throw "The index " + index + " is out of child list bounds " + childCount;
            }
            for(var i = childCount; i > index; i--){
                var swapChild = children[i - 1];
                swapChild._siblingIndex = i;
                children[i] = swapChild;
            }
            entity._siblingIndex = index;
            children[index] = entity;
        }
    };
    _create_class$2(Entity, [
        {
            key: "transform",
            get: /**
   * The transform of this entity.
   */ function get() {
                return this._transform;
            }
        },
        {
            key: "isActive",
            get: /**
   * Whether to activate locally.
   */ function get() {
                return this._isActive;
            },
            set: function set(value) {
                if (value !== this._isActive) {
                    this._isActive = value;
                    if (value) {
                        var parent = this._parent;
                        var activeChangeFlag = ActiveChangeFlag.None;
                        if (this._isRoot && this._scene._isActiveInEngine) {
                            activeChangeFlag |= ActiveChangeFlag.All;
                        } else {
                            (parent == null ? void 0 : parent._isActiveInHierarchy) && (activeChangeFlag |= ActiveChangeFlag.Hierarchy);
                            (parent == null ? void 0 : parent._isActiveInScene) && (activeChangeFlag |= ActiveChangeFlag.Scene);
                        }
                        activeChangeFlag && this._processActive(activeChangeFlag);
                    } else {
                        var activeChangeFlag1 = ActiveChangeFlag.None;
                        this._isActiveInHierarchy && (activeChangeFlag1 |= ActiveChangeFlag.Hierarchy);
                        this._isActiveInScene && (activeChangeFlag1 |= ActiveChangeFlag.Scene);
                        activeChangeFlag1 && this._processInActive(activeChangeFlag1);
                    }
                }
            }
        },
        {
            key: "isActiveInHierarchy",
            get: /**
   * Whether it is active in the hierarchy.
   */ function get() {
                return this._isActiveInHierarchy;
            }
        },
        {
            key: "parent",
            get: /**
   * The parent entity.
   */ function get() {
                return this._parent;
            },
            set: function set(value) {
                this._setParent(value);
            }
        },
        {
            key: "children",
            get: /**
   * The children entities
   */ function get() {
                return this._children;
            }
        },
        {
            key: "childCount",
            get: /**
   * @deprecated Please use `children.length` property instead.
   * Number of the children entities
   */ function get() {
                return this._children.length;
            }
        },
        {
            key: "scene",
            get: /**
   * The scene the entity belongs to.
   */ function get() {
                return this._scene;
            }
        },
        {
            key: "siblingIndex",
            get: /**
   * The sibling index.
   */ function get() {
                return this._siblingIndex;
            },
            set: function set(value) {
                if (this._siblingIndex === -1) {
                    throw "The entity " + this.name + " is not in the hierarchy";
                }
                if (this._isRoot) {
                    this._setSiblingIndex(this._scene._rootEntities, value);
                } else {
                    var parent = this._parent;
                    this._setSiblingIndex(parent._children, value);
                    parent._dispatchModify(EntityModifyFlags.Child, parent);
                }
            }
        }
    ]);
    return Entity;
}(EngineObject);

/**
 * Skin used for skinned mesh renderer.
 */ var Skin = /*#__PURE__*/ function(EngineObject) {
    _inherits$2(Skin, EngineObject);
    function Skin(name) {
        var _this;
        _this = EngineObject.call(this, null) || this, _this.name = name, _this.inverseBindMatrices = new Array(), _this._updatedManager = new UpdateFlagManager(), _this._bones = new Array(), _this._updateMark = -1, _this.joints = [];
        return _this;
    }
    var _proto = Skin.prototype;
    /**
   * @internal
   */ _proto._updateSkinMatrices = function _updateSkinMatrices(renderer) {
        if (this._updateMark === renderer.engine.time.frameCount) {
            return;
        }
        var _this = this, bones = _this.bones, bindMatrices = _this.inverseBindMatrices, skinMatrices = _this._skinMatrices;
        var _this_rootBone;
        var worldToLocal = ((_this_rootBone = this.rootBone) != null ? _this_rootBone : renderer.entity).getInvModelMatrix();
        for(var i = bones.length - 1; i >= 0; i--){
            var bone = bones[i];
            var offset = i * 16;
            if (bone) {
                Utils._floatMatrixMultiply(bone.transform.worldMatrix, bindMatrices[i].elements, 0, skinMatrices, offset);
            } else {
                skinMatrices.set(bindMatrices[i].elements, offset);
            }
            Utils._floatMatrixMultiply(worldToLocal, skinMatrices, offset, skinMatrices, offset);
        }
        this._updateMark = renderer.engine.time.frameCount;
    };
    /**
   * @internal
   */ _proto._cloneTo = function _cloneTo(target, srcRoot, targetRoot) {
        var paths = new Array();
        // Clone rootBone
        var rootBone = this.rootBone;
        if (rootBone) {
            var success = Entity._getEntityHierarchyPath(srcRoot, rootBone, paths);
            target.rootBone = success ? Entity._getEntityByHierarchyPath(targetRoot, paths) : rootBone;
        }
        // Clone bones
        var bones = this.bones;
        if (bones.length > 0) {
            var boneCount = bones.length;
            var destBones = new Array(boneCount);
            for(var i = 0; i < boneCount; i++){
                var bone = bones[i];
                var success1 = Entity._getEntityHierarchyPath(srcRoot, bone, paths);
                destBones[i] = success1 ? Entity._getEntityByHierarchyPath(targetRoot, paths) : bone;
            }
            target.bones = destBones;
        }
    };
    _create_class$2(Skin, [
        {
            key: "rootBone",
            get: /**
   * Root bone.
   */ function get() {
                return this._rootBone;
            },
            set: function set(value) {
                if (this._rootBone !== value) {
                    this._updatedManager.dispatch(1, value);
                    this._rootBone = value;
                }
            }
        },
        {
            key: "bones",
            get: /**
   * Bones of the skin.
   */ function get() {
                return this._bones;
            },
            set: function set(value) {
                var bones = this._bones;
                var _value_length;
                var boneCount = (_value_length = value == null ? void 0 : value.length) != null ? _value_length : 0;
                var lastBoneCount = bones.length;
                bones.length = boneCount;
                for(var i = 0; i < boneCount; i++){
                    bones[i] = value[i];
                }
                if (lastBoneCount !== boneCount) {
                    this._skinMatrices = new Float32Array(boneCount * 16);
                    this._updatedManager.dispatch(0, boneCount);
                }
            }
        },
        {
            key: "skeleton",
            get: /** @deprecated Please use `rootBone` instead. */ function get() {
                var _this_rootBone;
                return (_this_rootBone = this.rootBone) == null ? void 0 : _this_rootBone.name;
            },
            set: function set(value) {
                var rootBone = this._rootBone;
                if (rootBone) {
                    rootBone.name = value;
                }
            }
        }
    ]);
    return Skin;
}(EngineObject);
__decorate$1([
    deepClone
], Skin.prototype, "inverseBindMatrices", void 0);
__decorate$1([
    ignoreClone
], Skin.prototype, "_skinMatrices", void 0);
__decorate$1([
    ignoreClone
], Skin.prototype, "_updatedManager", void 0);
__decorate$1([
    ignoreClone
], Skin.prototype, "_rootBone", void 0);
__decorate$1([
    ignoreClone
], Skin.prototype, "_bones", void 0);
__decorate$1([
    ignoreClone
], Skin.prototype, "_updateMark", void 0);
var SkinUpdateFlag = /*#__PURE__*/ function(SkinUpdateFlag) {
    SkinUpdateFlag[SkinUpdateFlag["BoneCountChanged"] = 0] = "BoneCountChanged";
    SkinUpdateFlag[SkinUpdateFlag["RootBoneChanged"] = 1] = "RootBoneChanged";
    return SkinUpdateFlag;
}({});

/**
 * SkinnedMeshRenderer.
 */ var SkinnedMeshRenderer = /*#__PURE__*/ function(MeshRenderer) {
    _inherits$2(SkinnedMeshRenderer, MeshRenderer);
    function SkinnedMeshRenderer(entity) {
        var _this;
        _this = MeshRenderer.call(this, entity) || this, _this._localBounds = new BoundingBox(), _this._jointDataCreateCache = new Vector2(-1, -1);
        _this._skin = null;
        var rhi = _this.entity.engine._hardwareRenderer;
        var maxVertexUniformVectors = rhi.renderStates.getParameter(rhi.gl.MAX_VERTEX_UNIFORM_VECTORS);
        // Limit size to 256 to avoid some problem:
        // For renderer is "Apple GPU", when uniform is large than 256 the skeleton matrix array access in shader very slow in Safari or WKWebview. This may be a apple bug, Chrome and Firefox is OK!
        // For renderer is "ANGLE (AMD, AMD Radeon(TM) Graphics Direct3011 vs_5_0 ps_5_0, D3011)", compile shader si very slow because of max uniform is 4096.
        maxVertexUniformVectors = Math.min(maxVertexUniformVectors, rhi._options._maxAllowSkinUniformVectorCount);
        _this._maxVertexUniformVectors = maxVertexUniformVectors;
        _this._onLocalBoundsChanged = _this._onLocalBoundsChanged.bind(_this);
        _this._onSkinUpdated = _this._onSkinUpdated.bind(_this);
        var localBounds = _this._localBounds;
        // @ts-ignore
        localBounds.min._onValueChanged = _this._onLocalBoundsChanged;
        // @ts-ignore
        localBounds.max._onValueChanged = _this._onLocalBoundsChanged;
        return _this;
    }
    var _proto = SkinnedMeshRenderer.prototype;
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        var _this__jointTexture;
        MeshRenderer.prototype._onDestroy.call(this);
        this._jointDataCreateCache = null;
        this._skin = null;
        this._blendShapeWeights = null;
        this._localBounds = null;
        (_this__jointTexture = this._jointTexture) == null ? void 0 : _this__jointTexture.destroy();
        this._jointTexture = null;
    };
    /**
   * @internal
   */ _proto._cloneTo = function _cloneTo(target, srcRoot, targetRoot) {
        MeshRenderer.prototype._cloneTo.call(this, target, srcRoot, targetRoot);
        if (this.skin) {
            target._applySkin(null, target.skin);
        }
        this._blendShapeWeights && (target._blendShapeWeights = this._blendShapeWeights.slice());
    };
    _proto._update = function _update(context) {
        var skin = this.skin;
        if ((skin == null ? void 0 : skin.bones.length) > 0) {
            skin._updateSkinMatrices(this);
        }
        var shaderData = this.shaderData;
        var mesh = this.mesh;
        var blendShapeManager = mesh._blendShapeManager;
        blendShapeManager._updateShaderData(shaderData, this);
        var bones = skin == null ? void 0 : skin.bones;
        if (bones) {
            var bsUniformOccupiesCount = blendShapeManager._uniformOccupiesCount;
            var boneCount = bones.length;
            var boneDataCreateCache = this._jointDataCreateCache;
            var boneCountChange = boneCount !== boneDataCreateCache.x;
            if (boneCountChange || bsUniformOccupiesCount !== boneDataCreateCache.y) {
                // directly use max joint count to avoid shader recompile
                // @TODO: different shader type should use different count, not always 44
                var remainUniformJointCount = Math.ceil((this._maxVertexUniformVectors - (44 + bsUniformOccupiesCount)) / 4);
                if (boneCount > remainUniformJointCount) {
                    var engine = this.engine;
                    if (engine._hardwareRenderer.canIUseMoreJoints) {
                        if (boneCountChange) {
                            var _this__jointTexture;
                            (_this__jointTexture = this._jointTexture) == null ? void 0 : _this__jointTexture.destroy();
                            this._jointTexture = new Texture2D(engine, 4, boneCount, TextureFormat.R32G32B32A32, false, false);
                            this._jointTexture.filterMode = TextureFilterMode.Point;
                            this._jointTexture.isGCIgnored = true;
                        }
                        shaderData.disableMacro("RENDERER_JOINTS_NUM");
                        shaderData.enableMacro("RENDERER_USE_JOINT_TEXTURE");
                        shaderData.setTexture(SkinnedMeshRenderer._jointSamplerProperty, this._jointTexture);
                    } else {
                        Logger.error("component's joints count(" + boneCount + ") greater than device's MAX_VERTEX_UNIFORM_VECTORS number " + this._maxVertexUniformVectors + ", and don't support jointTexture in this device. suggest joint count less than " + remainUniformJointCount + ".", this);
                    }
                } else {
                    var _this__jointTexture1;
                    (_this__jointTexture1 = this._jointTexture) == null ? void 0 : _this__jointTexture1.destroy();
                    shaderData.disableMacro("RENDERER_USE_JOINT_TEXTURE");
                    shaderData.enableMacro("RENDERER_JOINTS_NUM", remainUniformJointCount.toString());
                    shaderData.setFloatArray(SkinnedMeshRenderer._jointMatrixProperty, skin._skinMatrices);
                }
                boneDataCreateCache.set(boneCount, bsUniformOccupiesCount);
            }
            if (this._jointTexture) {
                this._jointTexture.setPixelBuffer(skin._skinMatrices);
            }
        }
        MeshRenderer.prototype._update.call(this, context);
    };
    /**
   * @internal
   */ _proto._updateBounds = function _updateBounds(worldBounds) {
        var _this_skin;
        var rootBone = (_this_skin = this.skin) == null ? void 0 : _this_skin.rootBone;
        if (rootBone) {
            BoundingBox.transform(this._localBounds, this._transformEntity.transform.worldMatrix, worldBounds);
        } else {
            MeshRenderer.prototype._updateBounds.call(this, worldBounds);
        }
    };
    _proto._checkBlendShapeWeightLength = function _checkBlendShapeWeightLength() {
        var mesh = this._mesh;
        var newBlendShapeCount = mesh ? mesh.blendShapeCount : 0;
        var lastBlendShapeWeights = this._blendShapeWeights;
        if (lastBlendShapeWeights) {
            var lastBlendShapeWeightsCount = lastBlendShapeWeights.length;
            if (lastBlendShapeWeightsCount !== newBlendShapeCount) {
                var newBlendShapeWeights = new Float32Array(newBlendShapeCount);
                if (newBlendShapeCount > lastBlendShapeWeightsCount) {
                    newBlendShapeWeights.set(lastBlendShapeWeights);
                } else {
                    for(var i = 0; i < newBlendShapeCount; i++){
                        newBlendShapeWeights[i] = lastBlendShapeWeights[i];
                    }
                }
                this._blendShapeWeights = newBlendShapeWeights;
            }
        } else {
            this._blendShapeWeights = new Float32Array(newBlendShapeCount);
        }
    };
    _proto._onLocalBoundsChanged = function _onLocalBoundsChanged() {
        this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
    };
    _proto._onSkinUpdated = function _onSkinUpdated(type, value) {
        switch(type){
            case SkinUpdateFlag.BoneCountChanged:
                var shaderData = this.shaderData;
                if (value > 0) {
                    shaderData.enableMacro("RENDERER_HAS_SKIN");
                    shaderData.setInt(SkinnedMeshRenderer._jointCountProperty, value);
                } else {
                    shaderData.disableMacro("RENDERER_HAS_SKIN");
                }
                break;
            case SkinUpdateFlag.RootBoneChanged:
                this._setTransformEntity(value);
                this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
                break;
        }
    };
    _proto._applySkin = function _applySkin(lastSkin, value) {
        var _lastSkin_bones, _value_bones;
        var _lastSkin_bones_length;
        var lastSkinBoneCount = (_lastSkin_bones_length = lastSkin == null ? void 0 : (_lastSkin_bones = lastSkin.bones) == null ? void 0 : _lastSkin_bones.length) != null ? _lastSkin_bones_length : 0;
        var _lastSkin_rootBone;
        var lastRootBone = (_lastSkin_rootBone = lastSkin == null ? void 0 : lastSkin.rootBone) != null ? _lastSkin_rootBone : this.entity;
        lastSkin == null ? void 0 : lastSkin._updatedManager.removeListener(this._onSkinUpdated);
        var _value_bones_length;
        var skinBoneCount = (_value_bones_length = value == null ? void 0 : (_value_bones = value.bones) == null ? void 0 : _value_bones.length) != null ? _value_bones_length : 0;
        var _value_rootBone;
        var rootBone = (_value_rootBone = value == null ? void 0 : value.rootBone) != null ? _value_rootBone : this.entity;
        value == null ? void 0 : value._updatedManager.addListener(this._onSkinUpdated);
        if (lastSkinBoneCount !== skinBoneCount) {
            this._onSkinUpdated(SkinUpdateFlag.BoneCountChanged, skinBoneCount);
        }
        if (lastRootBone !== rootBone) {
            this._onSkinUpdated(SkinUpdateFlag.RootBoneChanged, rootBone);
        }
    };
    _create_class$2(SkinnedMeshRenderer, [
        {
            key: "skin",
            get: /**
   * Skin of the SkinnedMeshRenderer.
   */ function get() {
                return this._skin;
            },
            set: function set(value) {
                var lastSkin = this._skin;
                if (lastSkin !== value) {
                    this._applySkin(lastSkin, value);
                    this._skin = value;
                }
            }
        },
        {
            key: "blendShapeWeights",
            get: /**
   * The weights of the BlendShapes.
   * @remarks Array index is BlendShape index.
   */ function get() {
                this._checkBlendShapeWeightLength();
                return this._blendShapeWeights;
            },
            set: function set(value) {
                this._checkBlendShapeWeightLength();
                var blendShapeWeights = this._blendShapeWeights;
                if (value.length <= blendShapeWeights.length) {
                    blendShapeWeights.set(value);
                } else {
                    for(var i = 0, n = blendShapeWeights.length; i < n; i++){
                        blendShapeWeights[i] = value[i];
                    }
                }
            }
        },
        {
            key: "localBounds",
            get: /**
   * Local bounds.
   */ function get() {
                return this._localBounds;
            },
            set: function set(value) {
                if (this._localBounds !== value) {
                    this._localBounds.copyFrom(value);
                }
            }
        },
        {
            key: "rootBone",
            get: /**
   * @deprecated use {@link SkinnedMeshRenderer.skin.rootBone} instead.
   */ function get() {
                return this.skin.rootBone;
            },
            set: function set(value) {
                this.skin.rootBone = value;
            }
        },
        {
            key: "bones",
            get: /**
   * @deprecated use {@link SkinnedMeshRenderer.skin.bones} instead.
   */ function get() {
                return this.skin.bones;
            },
            set: function set(value) {
                this.skin.bones = value;
            }
        }
    ]);
    return SkinnedMeshRenderer;
}(MeshRenderer);
SkinnedMeshRenderer._jointCountProperty = ShaderProperty.getByName("renderer_JointCount");
SkinnedMeshRenderer._jointSamplerProperty = ShaderProperty.getByName("renderer_JointSampler");
SkinnedMeshRenderer._jointMatrixProperty = ShaderProperty.getByName("renderer_JointMatrix");
__decorate$1([
    ignoreClone
], SkinnedMeshRenderer.prototype, "_condensedBlendShapeWeights", void 0);
__decorate$1([
    deepClone
], SkinnedMeshRenderer.prototype, "_localBounds", void 0);
__decorate$1([
    ignoreClone
], SkinnedMeshRenderer.prototype, "_jointDataCreateCache", void 0);
__decorate$1([
    ignoreClone
], SkinnedMeshRenderer.prototype, "_blendShapeWeights", void 0);
__decorate$1([
    ignoreClone
], SkinnedMeshRenderer.prototype, "_maxVertexUniformVectors", void 0);
__decorate$1([
    ignoreClone
], SkinnedMeshRenderer.prototype, "_jointTexture", void 0);
__decorate$1([
    deepClone
], SkinnedMeshRenderer.prototype, "_skin", void 0);
__decorate$1([
    ignoreClone
], SkinnedMeshRenderer.prototype, "_onLocalBoundsChanged", null);
__decorate$1([
    ignoreClone
], SkinnedMeshRenderer.prototype, "_onSkinUpdated", null);

/**
 * @internal
 */ var BasicResources = /*#__PURE__*/ function() {
    function BasicResources(engine) {
        this.engine = engine;
        // prettier-ignore
        var vertices = new Float32Array([
            -1,
            -1,
            0,
            1,
            3,
            -1,
            2,
            1,
            -1,
            3,
            0,
            -1
        ]); // left-top
        // prettier-ignore
        var flipYVertices = new Float32Array([
            3,
            -1,
            2,
            0,
            -1,
            -1,
            0,
            0,
            -1,
            3,
            0,
            2
        ]); // left-top
        var blitMaterial = new Material(engine, Shader.find("blit"));
        blitMaterial._addReferCount(1);
        blitMaterial.renderState.depthState.enabled = false;
        blitMaterial.renderState.depthState.writeEnabled = false;
        var blitScreenMaterial = new Material(engine, Shader.find("blit-screen"));
        blitScreenMaterial._addReferCount(1);
        blitScreenMaterial.renderState.depthState.enabled = false;
        blitScreenMaterial.renderState.depthState.writeEnabled = false;
        this.blitMaterial = blitMaterial;
        this.blitScreenMaterial = blitScreenMaterial;
        this.blitMesh = this._createBlitMesh(engine, vertices);
        this.flipYBlitMesh = this._createBlitMesh(engine, flipYVertices);
        // Create white and magenta textures
        var whitePixel = new Uint8Array([
            255,
            255,
            255,
            255
        ]);
        this.whiteTexture2D = this._create1x1Texture(engine, 0, TextureFormat.R8G8B8A8, whitePixel, true);
        this.whiteTextureCube = this._create1x1Texture(engine, 1, TextureFormat.R8G8B8A8, whitePixel, true);
        var isWebGL2 = engine._hardwareRenderer.isWebGL2;
        if (isWebGL2) {
            this.whiteTexture2DArray = this._create1x1Texture(engine, 2, TextureFormat.R8G8B8A8, whitePixel, true);
            var whitePixel32 = new Uint32Array([
                255,
                255,
                255,
                255
            ]);
            this.uintWhiteTexture2D = this._create1x1Texture(engine, 0, TextureFormat.R32G32B32A32_UInt, whitePixel32, false);
        }
        this.spriteDefaultMaterial = this._create2DMaterial(engine, Shader.find("Sprite"));
        this.textDefaultMaterial = this._create2DMaterial(engine, Shader.find("Text"));
        this.spriteMaskDefaultMaterial = this._createSpriteMaskMaterial(engine);
    }
    var _proto = BasicResources.prototype;
    /**
   * @internal
   */ _proto._getBlinnPhongMaterial = function _getBlinnPhongMaterial() {
        return this._blinnPhongMaterial || (this._blinnPhongMaterial = new BlinnPhongMaterial(this.engine));
    };
    /**
   * @internal
   */ _proto._initialize = function _initialize() {
        var _this = this;
        return new Promise(function(resolve, reject) {
            PrefilteredDFG.create(_this.engine).then(function(texture) {
                _this._prefilteredDFGTexture = texture;
                resolve(_this);
            }).catch(reject);
        });
    };
    _proto._createBlitMesh = function _createBlitMesh(engine, vertices) {
        var mesh = new ModelMesh(engine);
        mesh._addReferCount(1);
        mesh.setVertexElements([
            new VertexElement("POSITION_UV", 0, VertexElementFormat.Vector4, 0)
        ]);
        var buffer = new Buffer(engine, BufferBindFlag.VertexBuffer, vertices, BufferUsage.Static, true);
        mesh.setVertexBufferBinding(buffer, 16);
        mesh.addSubMesh(0, 3, MeshTopology.Triangles);
        engine.resourceManager.addContentRestorer(new (/*#__PURE__*/ function(ContentRestorer) {
            _inherits$2(_class, ContentRestorer);
            function _class() {
                return ContentRestorer.call(this, mesh) || this;
            }
            var _proto = _class.prototype;
            _proto.restoreContent = function restoreContent() {
                buffer.setData(buffer.data);
            };
            return _class;
        }(ContentRestorer))());
        return mesh;
    };
    _proto._create1x1Texture = function _create1x1Texture(engine, type, format, pixel, isSRGBColorSpace) {
        var texture;
        switch(type){
            case 0:
                var texture2D = new Texture2D(engine, 1, 1, format, false, isSRGBColorSpace);
                texture2D.setPixelBuffer(pixel);
                texture = texture2D;
                break;
            case 2:
                var texture2DArray = new Texture2DArray(engine, 1, 1, 1, format, false, isSRGBColorSpace);
                texture2DArray.setPixelBuffer(0, pixel);
                texture = texture2DArray;
                break;
            case 1:
                var textureCube = new TextureCube(engine, 1, format, false, isSRGBColorSpace);
                for(var i = 0; i < 6; i++){
                    textureCube.setPixelBuffer(TextureCubeFace.PositiveX + i, pixel);
                }
                texture = textureCube;
                break;
            default:
                throw "Invalid texture type";
        }
        texture.isGCIgnored = true;
        engine.resourceManager.addContentRestorer(new (/*#__PURE__*/ function(ContentRestorer) {
            _inherits$2(_class, ContentRestorer);
            function _class() {
                return ContentRestorer.call(this, texture) || this;
            }
            var _proto = _class.prototype;
            _proto.restoreContent = function restoreContent() {
                switch(type){
                    case 0:
                        this.resource.setPixelBuffer(pixel);
                        break;
                    case 2:
                        this.resource.setPixelBuffer(0, pixel);
                        break;
                    case 1:
                        for(var i = 0; i < 6; i++){
                            this.resource.setPixelBuffer(TextureCubeFace.PositiveX + i, pixel);
                        }
                        break;
                }
            };
            return _class;
        }(ContentRestorer))());
        return texture;
    };
    _proto._create2DMaterial = function _create2DMaterial(engine, shader) {
        var material = new Material(engine, shader);
        var renderState = material.renderState;
        var target = renderState.blendState.targetBlendState;
        target.enabled = true;
        target.sourceColorBlendFactor = BlendFactor.SourceAlpha;
        target.destinationColorBlendFactor = BlendFactor.OneMinusSourceAlpha;
        target.sourceAlphaBlendFactor = BlendFactor.One;
        target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
        target.colorBlendOperation = target.alphaBlendOperation = BlendOperation.Add;
        renderState.depthState.writeEnabled = false;
        renderState.rasterState.cullMode = CullMode.Off;
        renderState.renderQueueType = RenderQueueType.Transparent;
        material.isGCIgnored = true;
        return material;
    };
    _proto._createSpriteMaskMaterial = function _createSpriteMaskMaterial(engine) {
        var material = new Material(engine, Shader.find("SpriteMask"));
        material.isGCIgnored = true;
        return material;
    };
    BasicResources.getMaskInteractionRenderStates = function getMaskInteractionRenderStates(maskInteraction) {
        var visibleInsideMask = maskInteraction === SpriteMaskInteraction.VisibleInsideMask;
        var renderStates;
        var compareFunction;
        if (visibleInsideMask) {
            renderStates = BasicResources._maskReadInsideRenderStates;
            if (renderStates) {
                return renderStates;
            }
            BasicResources._maskReadInsideRenderStates = renderStates = {};
            compareFunction = CompareFunction.LessEqual;
        } else {
            renderStates = BasicResources._maskReadOutsideRenderStates;
            if (renderStates) {
                return renderStates;
            }
            BasicResources._maskReadOutsideRenderStates = renderStates = {};
            compareFunction = CompareFunction.Greater;
        }
        renderStates[RenderStateElementKey.StencilStateEnabled] = true;
        renderStates[RenderStateElementKey.StencilStateWriteMask] = 0x00;
        renderStates[RenderStateElementKey.StencilStateReferenceValue] = 1;
        renderStates[RenderStateElementKey.StencilStateCompareFunctionFront] = compareFunction;
        renderStates[RenderStateElementKey.StencilStateCompareFunctionBack] = compareFunction;
        return renderStates;
    };
    BasicResources.getMaskTypeRenderStates = function getMaskTypeRenderStates(maskType) {
        var isIncrement = maskType === RenderQueueMaskType.Increment;
        var renderStates;
        var passOperation;
        if (isIncrement) {
            renderStates = BasicResources._maskWriteIncrementRenderStates;
            if (renderStates) {
                return renderStates;
            }
            BasicResources._maskWriteIncrementRenderStates = renderStates = {};
            passOperation = StencilOperation.IncrementSaturate;
        } else {
            renderStates = BasicResources._maskWriteDecrementRenderStates;
            if (renderStates) {
                return renderStates;
            }
            BasicResources._maskWriteDecrementRenderStates = renderStates = {};
            passOperation = StencilOperation.DecrementSaturate;
        }
        renderStates[RenderStateElementKey.StencilStateEnabled] = true;
        renderStates[RenderStateElementKey.StencilStatePassOperationFront] = passOperation;
        renderStates[RenderStateElementKey.StencilStatePassOperationBack] = passOperation;
        renderStates[RenderStateElementKey.StencilStateCompareFunctionFront] = CompareFunction.Always;
        renderStates[RenderStateElementKey.StencilStateCompareFunctionBack] = CompareFunction.Always;
        var failStencilOperation = StencilOperation.Keep;
        renderStates[RenderStateElementKey.StencilStateFailOperationFront] = failStencilOperation;
        renderStates[RenderStateElementKey.StencilStateFailOperationBack] = failStencilOperation;
        renderStates[RenderStateElementKey.StencilStateZFailOperationFront] = failStencilOperation;
        renderStates[RenderStateElementKey.StencilStateZFailOperationBack] = failStencilOperation;
        renderStates[RenderStateElementKey.BlendStateColorWriteMask0] = ColorWriteMask.None;
        renderStates[RenderStateElementKey.DepthStateEnabled] = false;
        renderStates[RenderStateElementKey.RasterStateCullMode] = CullMode.Off;
        return renderStates;
    };
    _create_class$2(BasicResources, [
        {
            key: "prefilteredDFGTexture",
            get: function get() {
                return this._prefilteredDFGTexture;
            }
        }
    ]);
    return BasicResources;
}();
BasicResources._maskReadInsideRenderStates = null;
BasicResources._maskReadOutsideRenderStates = null;
BasicResources._maskWriteIncrementRenderStates = null;
BasicResources._maskWriteDecrementRenderStates = null;

var ObjectPool = /*#__PURE__*/ function() {
    function ObjectPool(type) {
        this._type = type;
    }
    var _proto = ObjectPool.prototype;
    _proto.garbageCollection = function garbageCollection() {
        var elements = this._elements;
        for(var i = elements.length - 1; i >= 0; i--){
            elements[i].dispose && elements[i].dispose();
        }
        elements.length = 0;
    };
    return ObjectPool;
}();

/**
 * Returnable Object Pool.
 */ var ReturnableObjectPool = /*#__PURE__*/ function(ObjectPool) {
    _inherits$2(ReturnableObjectPool, ObjectPool);
    function ReturnableObjectPool(type, initializeCount) {
        if (initializeCount === void 0) initializeCount = 1;
        var _this;
        _this = ObjectPool.call(this, type) || this;
        _this._lastElementIndex = initializeCount - 1;
        var elements = _this._elements = new Array(initializeCount);
        for(var i = 0; i < initializeCount; ++i){
            elements[i] = new type();
        }
        return _this;
    }
    var _proto = ReturnableObjectPool.prototype;
    /**
   * Get an object from the pool.
   */ _proto.get = function get() {
        if (this._lastElementIndex < 0) {
            return new this._type();
        }
        return this._elements[this._lastElementIndex--];
    };
    /**
   * Return an object to the pool.
   */ _proto.return = function _return(element) {
        this._elements[++this._lastElementIndex] = element;
    };
    return ReturnableObjectPool;
}(ObjectPool);

/**
 * @internal
 */ var SubPrimitiveChunk = /*#__PURE__*/ function() {
    function SubPrimitiveChunk() {}
    var _proto = SubPrimitiveChunk.prototype;
    _proto.dispose = function dispose() {
        this.chunk = null;
        this.vertexArea = null;
        this.subMesh = null;
        this.indices = null;
    };
    return SubPrimitiveChunk;
}();

/**
 * @internal
 */ var VertexArea = /*#__PURE__*/ function() {
    function VertexArea(start, size) {
        this.start = start;
        this.size = size;
    }
    var _proto = VertexArea.prototype;
    _proto.dispose = function dispose() {};
    return VertexArea;
}();

/**
 * @internal
 */ var PrimitiveChunk = /*#__PURE__*/ function() {
    function PrimitiveChunk(engine, maxVertexCount) {
        this.updateVertexStart = Number.MAX_SAFE_INTEGER;
        this.updateVertexEnd = Number.MIN_SAFE_INTEGER;
        this.updateIndexLength = 0;
        var primitive = new Primitive(engine);
        // Vertex elements
        primitive.addVertexElement(new VertexElement("POSITION", 0, VertexElementFormat.Vector3, 0));
        primitive.addVertexElement(new VertexElement("TEXCOORD_0", 12, VertexElementFormat.Vector2, 0));
        primitive.addVertexElement(new VertexElement("COLOR_0", 20, VertexElementFormat.Vector4, 0));
        primitive._addReferCount(1);
        // Vertices
        var vertexStride = 36;
        var vertexBuffer = new Buffer(engine, BufferBindFlag.VertexBuffer, maxVertexCount * vertexStride, BufferUsage.Dynamic, true);
        primitive.setVertexBufferBinding(0, new VertexBufferBinding(vertexBuffer, vertexStride));
        // Indices
        var indexBuffer = new Buffer(engine, BufferBindFlag.IndexBuffer, maxVertexCount * 8, BufferUsage.Dynamic, true);
        primitive.setIndexBufferBinding(new IndexBufferBinding(indexBuffer, IndexFormat.UInt16));
        this.primitive = primitive;
        this.vertices = new Float32Array(vertexBuffer.data.buffer);
        this.indices = new Uint16Array(indexBuffer.data.buffer);
        this.vertexFreeAreas = [
            new VertexArea(0, maxVertexCount * 9)
        ];
    }
    var _proto = PrimitiveChunk.prototype;
    _proto.allocateSubChunk = function allocateSubChunk(vertexCount) {
        var area = this._allocateArea(vertexCount * 9);
        if (area) {
            var subChunk = PrimitiveChunk.subChunkPool.get();
            subChunk.chunk = this;
            subChunk.vertexArea = area;
            var subMesh = PrimitiveChunk.subMeshPool.get();
            subMesh.topology = MeshTopology.Triangles;
            subChunk.subMesh = subMesh;
            return subChunk;
        }
        return null;
    };
    _proto.freeSubChunk = function freeSubChunk(subChunk) {
        this._freeArea(subChunk.vertexArea);
        PrimitiveChunk.subMeshPool.return(subChunk.subMesh);
        PrimitiveChunk.subChunkPool.return(subChunk);
    };
    _proto.uploadBuffer = function uploadBuffer() {
        // Set data option use Discard, or will resulted in performance slowdown when open antialias and cross-rendering of 3D and 2D elements.
        // Device: iphone X(16.7.2)、iphone 15 pro max(17.1.1)、iphone XR(17.1.2) etc.
        var _this = this, primitive = _this.primitive, updateVertexStart = _this.updateVertexStart, updateVertexEnd = _this.updateVertexEnd;
        if (updateVertexStart !== Number.MAX_SAFE_INTEGER && updateVertexEnd !== Number.MIN_SAFE_INTEGER) {
            primitive.vertexBufferBindings[0].buffer.setData(this.vertices, updateVertexStart * 4, updateVertexStart, updateVertexEnd - updateVertexStart, SetDataOptions.Discard);
            this.updateVertexStart = Number.MAX_SAFE_INTEGER;
            this.updateVertexEnd = Number.MIN_SAFE_INTEGER;
        }
        primitive.indexBufferBinding.buffer.setData(this.indices, 0, 0, this.updateIndexLength, SetDataOptions.Discard);
        this.updateIndexLength = 0;
    };
    _proto.destroy = function destroy() {
        this.primitive._addReferCount(-1);
        this.primitive.destroy();
        this.primitive = null;
        this.vertices = null;
        this.indices = null;
    };
    _proto._allocateArea = function _allocateArea(needSize) {
        var areas = this.vertexFreeAreas;
        var pool = PrimitiveChunk.areaPool;
        for(var i = 0, n = areas.length; i < n; ++i){
            var area = areas[i];
            var size = area.size;
            if (size > needSize) {
                var newArea = pool.get();
                newArea.start = area.start;
                newArea.size = needSize;
                area.start += needSize;
                area.size -= needSize;
                return newArea;
            } else if (size === needSize) {
                areas.splice(i, 1);
                return area;
            }
        }
        return null;
    };
    _proto._freeArea = function _freeArea(area) {
        var start = area.start, size = area.size;
        var freeAreas = this.vertexFreeAreas;
        var end = start + size;
        var pool = PrimitiveChunk.areaPool;
        for(var i = 0, areaLen = freeAreas.length; i < areaLen; ++i){
            var curFreeArea = freeAreas[i];
            var curStart = curFreeArea.start;
            var curEnd = curStart + curFreeArea.size;
            if (end < curStart) {
                // The area to be freed is to the left of the current free area and is not connected
                freeAreas.splice(i, 0, area);
                return;
            } else if (end === curStart) {
                // The area to be freed is to the left of the current free area and is connected
                curFreeArea.start = start;
                curFreeArea.size += size;
                pool.return(area);
                return;
            } else if (start === curEnd) {
                // The area to be freed is to the right of the current free area and is connected
                curFreeArea.size += size;
                pool.return(area);
                var nextIndex = i + 1;
                if (nextIndex < areaLen) {
                    var nextFreeArea = freeAreas[nextIndex];
                    if (end === nextFreeArea.start) {
                        // The cur free area after merge is to the left of the next free area and is connected
                        curFreeArea.size += nextFreeArea.size;
                        freeAreas.splice(nextIndex, 1);
                        pool.return(nextFreeArea);
                    }
                }
                return;
            }
        }
        // The area to be freed is to the right of the last free area and is not connected or free areas is empty
        freeAreas.push(area);
    };
    return PrimitiveChunk;
}();
PrimitiveChunk.areaPool = new ReturnableObjectPool(VertexArea, 10);
PrimitiveChunk.subChunkPool = new ReturnableObjectPool(SubPrimitiveChunk, 10);
PrimitiveChunk.subMeshPool = new ReturnableObjectPool(SubMesh, 10);

/**
 * @internal
 */ var PrimitiveChunkManager = /*#__PURE__*/ function() {
    function PrimitiveChunkManager(engine, maxVertexCount) {
        if (maxVertexCount === void 0) maxVertexCount = 4096;
        this.engine = engine;
        this.maxVertexCount = maxVertexCount;
        this.primitiveChunks = new Array();
    }
    var _proto = PrimitiveChunkManager.prototype;
    _proto.allocateSubChunk = function allocateSubChunk(vertexCount) {
        var _primitiveChunks, _length;
        var primitiveChunks = this.primitiveChunks;
        var length = primitiveChunks.length;
        var subChunk = null;
        for(var i = 0; i < length; ++i){
            subChunk = primitiveChunks[i].allocateSubChunk(vertexCount);
            if (subChunk) {
                return subChunk;
            }
        }
        var data = (_primitiveChunks = primitiveChunks)[_length = length] || (_primitiveChunks[_length] = new PrimitiveChunk(this.engine, this.maxVertexCount));
        subChunk = data.allocateSubChunk(vertexCount);
        return subChunk;
    };
    _proto.freeSubChunk = function freeSubChunk(subChunk) {
        subChunk.chunk.freeSubChunk(subChunk);
    };
    _proto.uploadBuffer = function uploadBuffer() {
        var primitiveChunks = this.primitiveChunks;
        for(var i = 0, n = primitiveChunks.length; i < n; ++i){
            primitiveChunks[i].uploadBuffer();
        }
    };
    _proto.destroy = function destroy() {
        var primitiveChunks = this.primitiveChunks;
        for(var i = 0, n = primitiveChunks.length; i < n; ++i){
            primitiveChunks[i].destroy();
        }
        primitiveChunks.length = 0;
        this.primitiveChunks = null;
        this.engine = null;
    };
    return PrimitiveChunkManager;
}();

/**
 * @internal
 */ var BatcherManager = /*#__PURE__*/ function() {
    function BatcherManager(engine) {
        this.engine = engine;
    }
    var _proto = BatcherManager.prototype;
    _proto.destroy = function destroy() {
        if (this._primitiveChunkManager2D) {
            this._primitiveChunkManager2D.destroy();
            this._primitiveChunkManager2D = null;
        }
        if (this._primitiveChunkManagerMask) {
            this._primitiveChunkManagerMask.destroy();
            this._primitiveChunkManagerMask = null;
        }
        if (this._primitiveChunkManagerUI) {
            this._primitiveChunkManagerUI.destroy();
            this._primitiveChunkManagerUI = null;
        }
    };
    _proto.batch = function batch(renderQueue) {
        var elements = renderQueue.elements, batchedSubElements = renderQueue.batchedSubElements, renderQueueType = renderQueue.renderQueueType;
        var preSubElement;
        var preRenderer;
        var preConstructor;
        for(var i = 0, n = elements.length; i < n; ++i){
            var subElements = elements[i].subRenderElements;
            for(var j = 0, m = subElements.length; j < m; ++j){
                var subElement = subElements[j];
                // Some sub render elements may not belong to the current render queue
                if (!(subElement.renderQueueFlags & 1 << renderQueueType)) {
                    continue;
                }
                var renderer = subElement.component;
                var constructor = renderer.constructor;
                if (preSubElement) {
                    if (preConstructor === constructor && preRenderer._canBatch(preSubElement, subElement)) {
                        preRenderer._batch(preSubElement, subElement);
                        preSubElement.batched = true;
                    } else {
                        batchedSubElements.push(preSubElement);
                        preSubElement = subElement;
                        preRenderer = renderer;
                        preConstructor = constructor;
                        renderer._batch(subElement);
                        subElement.batched = false;
                    }
                } else {
                    preSubElement = subElement;
                    preRenderer = renderer;
                    preConstructor = constructor;
                    renderer._batch(subElement);
                    subElement.batched = false;
                }
            }
        }
        preSubElement && batchedSubElements.push(preSubElement);
    };
    _proto.uploadBuffer = function uploadBuffer() {
        var _this__primitiveChunkManager2D, _this__primitiveChunkManagerMask, _this__primitiveChunkManagerUI;
        (_this__primitiveChunkManager2D = this._primitiveChunkManager2D) == null ? void 0 : _this__primitiveChunkManager2D.uploadBuffer();
        (_this__primitiveChunkManagerMask = this._primitiveChunkManagerMask) == null ? void 0 : _this__primitiveChunkManagerMask.uploadBuffer();
        (_this__primitiveChunkManagerUI = this._primitiveChunkManagerUI) == null ? void 0 : _this__primitiveChunkManagerUI.uploadBuffer();
    };
    _create_class$2(BatcherManager, [
        {
            key: "primitiveChunkManager2D",
            get: function get() {
                return this._primitiveChunkManager2D || (this._primitiveChunkManager2D = new PrimitiveChunkManager(this.engine));
            }
        },
        {
            key: "primitiveChunkManagerMask",
            get: function get() {
                return this._primitiveChunkManagerMask || (this._primitiveChunkManagerMask = new PrimitiveChunkManager(this.engine, 128));
            }
        },
        {
            key: "primitiveChunkManagerUI",
            get: function get() {
                return this._primitiveChunkManagerUI || (this._primitiveChunkManagerUI = new PrimitiveChunkManager(this.engine));
            }
        }
    ]);
    return BatcherManager;
}();

/**
 * Asset Type.
 */ var AssetType = /*#__PURE__*/ function(AssetType) {
    /**
   * Plain text.
   * @remarks Will not be cached based on url in ResourceManager.
   */ AssetType["Text"] = "Text";
    /**
   * JSON.
   * @remarks Will not be cached based on url in ResourceManager.
   */ AssetType["JSON"] = "JSON";
    /**
   * ArrayBuffer.
   * @remarks Will not be cached based on url in ResourceManager.
   */ AssetType["Buffer"] = "Buffer";
    /** 2D Texture. */ AssetType["Texture2D"] = "Texture2D";
    /** Cube Texture. */ AssetType["TextureCube"] = "TextureCube";
    /** Material. */ AssetType["Material"] = "Material";
    /** Shader. */ AssetType["Shader"] = "Shader";
    /** Mesh. */ AssetType["Mesh"] = "Mesh";
    /** AnimationClip. */ AssetType["AnimationClip"] = "AnimationClip";
    /** AnimatorController. */ AssetType["AnimatorController"] = "AnimatorController";
    /** Prefab.*/ AssetType["Prefab"] = "Prefab";
    /** GLTF.*/ AssetType["GLTF"] = "GLTF";
    /** Compress Texture. */ AssetType["KTX"] = "KTX";
    /** Cube Compress Texture. */ AssetType["KTXCube"] = "KTXCube";
    /** KTX2 Compress Texture */ AssetType["KTX2"] = "KTX2";
    /** Sprite. */ AssetType["Sprite"] = "Sprite";
    /** PrimitiveMesh. */ AssetType["PrimitiveMesh"] = "PrimitiveMesh";
    /** Sprite Atlas. */ AssetType["SpriteAtlas"] = "SpriteAtlas";
    /** Ambient light. */ AssetType["Env"] = "Environment";
    /** Scene. */ AssetType["Scene"] = "Scene";
    /** HDR to cube. */ AssetType["HDR"] = "HDR";
    /** Font. */ AssetType["Font"] = "Font";
    /** Source Font, include ttf, otf and woff. */ AssetType["SourceFont"] = "SourceFont";
    /** AudioClip, include ogg, wav and mp3. */ AssetType["Audio"] = "Audio";
    /** Project asset. */ AssetType["Project"] = "project";
    /** PhysicsMaterial. */ AssetType["PhysicsMaterial"] = "PhysicsMaterial";
    return AssetType;
}({});

var SafeLoopArray = /*#__PURE__*/ function() {
    function SafeLoopArray() {
        this._array = [];
        this._loopArray = [];
        this._loopArrayDirty = false;
    }
    var _proto = SafeLoopArray.prototype;
    /**
   * Push item to the array.
   * @param item - The item which want to be pushed
   */ _proto.push = function push(item) {
        this._array.push(item);
        this._loopArrayDirty = true;
    };
    /**
   * Add item to the array.
   * @param index - The index of the array
   * @param item - The item which want to be added
   */ _proto.add = function add(index, item) {
        this._array.splice(index, 0, item);
        this._loopArrayDirty = true;
    };
    /**
   * Remove item from the array.
   * @param index - The index of the array
   */ _proto.removeByIndex = function removeByIndex(index) {
        this._array.splice(index, 1);
        this._loopArrayDirty = true;
    };
    /**
   * Remove item from array that pass the specified comparison function.
   * @param filter - The comparison function
   */ _proto.findAndRemove = function findAndRemove(filter) {
        var array = this._array;
        for(var i = array.length - 1; i >= 0; i--){
            filter(array[i]) && this.removeByIndex(i);
        }
    };
    /**
   * The index of the item.
   * @param item - The item which want to get the index
   * @returns Index of the item
   */ _proto.indexOf = function indexOf(item) {
        return this._array.indexOf(item);
    };
    /**
   * Get the array.
   * @returns The array
   */ _proto.getArray = function getArray() {
        return this._array;
    };
    /**
   * Get the array use for loop.
   * @returns The array use for loop
   */ _proto.getLoopArray = function getLoopArray() {
        var loopArray = this._loopArray;
        if (this._loopArrayDirty) {
            var array = this._array;
            var count = array.length;
            loopArray.length = count;
            for(var i = 0; i < count; i++){
                loopArray[i] = array[i];
            }
            this._loopArrayDirty = false;
        }
        return loopArray;
    };
    _create_class$2(SafeLoopArray, [
        {
            key: "length",
            get: /**
   * Get the length of the array.
   */ function get() {
                return this._array.length;
            }
        }
    ]);
    return SafeLoopArray;
}();

/**
 * Scene manager.
 */ var SceneManager = /*#__PURE__*/ function() {
    function SceneManager(engine) {
        this.engine = engine;
        this./** @internal */ _allCreatedScenes = [];
        this./** @internal */ _scenes = new SafeLoopArray();
    }
    var _proto = SceneManager.prototype;
    _proto.addScene = function addScene(indexOrScene, scene) {
        var scenes = this._scenes;
        var index;
        if (typeof indexOrScene === "number") {
            if (indexOrScene < 0 || indexOrScene > scenes.length) {
                throw "The index is out of range.";
            }
            index = indexOrScene;
        } else {
            index = scenes.length;
            scene = indexOrScene;
        }
        if (scene.engine !== this.engine) {
            throw "The scene is not belong to this engine.";
        }
        if (scene._sceneManager) {
            var currentIndex = scenes.indexOf(scene);
            if (currentIndex !== index) {
                scenes.removeByIndex(currentIndex);
                scenes.add(index, scene);
            }
        } else {
            scene._sceneManager = this;
            scenes.add(index, scene);
            scene.isActive && scene._processActive(true);
        }
    };
    /**
   * Remove scene.
   * @param scene - The scene which want to be removed
   */ _proto.removeScene = function removeScene(scene) {
        var scenes = this._scenes;
        var index = scenes.indexOf(scene);
        if (index !== -1) {
            var removedScene = scenes.getArray()[index];
            scenes.removeByIndex(index);
            scene._sceneManager = null;
            removedScene.isActive && removedScene._processActive(false);
        }
    };
    /**
   * Load and activate scene.
   * @param url - the path of the scene
   * @param destroyOldScene - whether to destroy old scene
   * @returns scene promise
   */ _proto.loadScene = function loadScene(url, destroyOldScene) {
        var _this = this;
        if (destroyOldScene === void 0) destroyOldScene = true;
        var scenePromise = this.engine.resourceManager.load({
            url: url,
            type: AssetType.Scene
        });
        scenePromise.then(function(scene) {
            if (destroyOldScene) {
                var scenes = _this._scenes.getArray();
                for(var i = 0, n = scenes.length; i < n; i++){
                    scenes[i].destroy();
                }
            }
            _this.addScene(scene);
        });
        return scenePromise;
    };
    /**
   * Merge the source scene into the target scene.
   * @remarks the global information of destScene will be used after the merge, and the lightingMap information will be merged.
   * @param sourceScene - source scene
   * @param destScene - target scene
   */ _proto.mergeScenes = function mergeScenes(sourceScene, destScene) {
        var oldRootEntities = sourceScene.rootEntities;
        while(oldRootEntities.length > 0){
            destScene.addRootEntity(oldRootEntities[0]);
        }
    };
    /**
   * @internal
   */ _proto._destroyAllScene = function _destroyAllScene() {
        var allCreatedScenes = this._allCreatedScenes;
        while(allCreatedScenes.length > 0){
            allCreatedScenes[0].destroy();
        }
    };
    _create_class$2(SceneManager, [
        {
            key: "scenes",
            get: /**
   * Get the scene list.
   */ function get() {
                return this._scenes.getArray();
            }
        },
        {
            key: "activeScene",
            get: /**
   * @deprecated
   * Please use `scenes` instead.
   *
   * Get the first scene.
   */ function get() {
                return this._scenes.getArray()[0];
            },
            set: function set(scene) {
                var firstScene = this.scenes[0];
                if (firstScene) {
                    this.removeScene(firstScene);
                }
                scene && this.addScene(0, scene);
            }
        }
    ]);
    return SceneManager;
}();

var mimeType = {
    json: "json",
    gltf: "json",
    mtl: "json",
    prefab: "json",
    txt: "text",
    bin: "arraybuffer",
    png: "image",
    webp: "image",
    jpg: "image"
};
var defaultRetryCount = 1;
var defaultTimeout = Infinity;
var defaultInterval = 500;
/**
 * Sends a request to the specified URL and returns a promise for the response.
 * @param url - The URL to send the request to
 * @param config - Configuration options for the request
 * @returns A promise that resolves with the response of type `T`
 */ function request(url, config) {
    if (config === void 0) config = {};
    return new AssetPromise(function(resolve, reject, setTaskCompleteProgress, setTaskDetailProgress) {
        var _config_retryCount;
        var retryCount = (_config_retryCount = config.retryCount) != null ? _config_retryCount : defaultRetryCount;
        var _config_retryInterval;
        var retryInterval = (_config_retryInterval = config.retryInterval) != null ? _config_retryInterval : defaultInterval;
        var _config_timeout;
        config.timeout = (_config_timeout = config.timeout) != null ? _config_timeout : defaultTimeout;
        var _config_type;
        config.type = (_config_type = config.type) != null ? _config_type : getMimeTypeFromUrl(url);
        var executor = new MultiExecutor(function() {
            return requestRes(url, config).onProgress(setTaskCompleteProgress, setTaskDetailProgress);
        }, retryCount, retryInterval);
        executor.start().onError(reject).onComplete(resolve);
    });
}
function requestRes(url, config) {
    return new AssetPromise(function(resolve, reject, setTaskCompleteProgress, setTaskDetailProgress) {
        var xhr = new XMLHttpRequest();
        var isImg = config.type === "image";
        xhr.timeout = config.timeout;
        var _config_method;
        config.method = (_config_method = config.method) != null ? _config_method : "get";
        xhr.onload = function() {
            if (xhr.status < 200 || xhr.status >= 300) {
                reject(new Error("request failed from: " + url));
                return;
            }
            var _xhr_response;
            var result = (_xhr_response = xhr.response) != null ? _xhr_response : xhr.responseText;
            if (isImg) {
                var img = new Image();
                img.onload = function() {
                    // Call requestAnimationFrame to avoid iOS's bug.
                    requestAnimationFrame(function() {
                        setTaskCompleteProgress(1, 1);
                        //@ts-ignore
                        resolve(img);
                        img.onload = null;
                        img.onerror = null;
                        img.onabort = null;
                        URL.revokeObjectURL(img.src);
                    });
                };
                img.onerror = img.onabort = function() {
                    reject(new Error("request " + img.src + " fail"));
                    URL.revokeObjectURL(img.src);
                };
                img.crossOrigin = "anonymous";
                img.src = URL.createObjectURL(result);
            } else {
                setTaskCompleteProgress(1, 1);
                resolve(result);
            }
        };
        xhr.onerror = function() {
            reject(new Error("request failed from: " + url));
        };
        xhr.ontimeout = function() {
            reject(new Error("request timeout from: " + url));
        };
        xhr.onprogress = function(e) {
            if (e.lengthComputable) {
                setTaskDetailProgress(url, e.loaded, e.total);
            }
        };
        xhr.open(config.method, url, true);
        xhr.withCredentials = config.credentials === "include";
        // @ts-ignore
        xhr.responseType = isImg ? "blob" : config.type;
        var headers = config.headers;
        if (headers) {
            Object.keys(headers).forEach(function(name) {
                xhr.setRequestHeader(name, headers[name]);
            });
        }
        // @ts-ignore
        xhr.send(config.body);
    });
}
function getMimeTypeFromUrl(url) {
    var extname = url.substring(url.lastIndexOf(".") + 1);
    return mimeType[extname];
}
var MultiExecutor = /*#__PURE__*/ function() {
    function MultiExecutor(execFunc, totalCount, interval) {
        this.execFunc = execFunc;
        this.totalCount = totalCount;
        this.interval = interval;
        this._timeoutId = -100;
        this._currentCount = 0;
        this.exec = this.exec.bind(this);
    }
    var _proto = MultiExecutor.prototype;
    _proto.start = function start() {
        this.exec();
        return this;
    };
    _proto.onComplete = function onComplete(func) {
        this._onComplete = func;
        return this;
    };
    _proto.onError = function onError(func) {
        this._onError = func;
        return this;
    };
    _proto.cancel = function cancel() {
        window.clearTimeout(this._timeoutId);
    };
    _proto.exec = function exec() {
        var _this = this;
        if (this._currentCount >= this.totalCount) {
            this._onError && this._onError(this._error);
            return;
        }
        this._currentCount++;
        this.execFunc(this._currentCount).then(function(result) {
            return _this._onComplete && _this._onComplete(result);
        }).catch(function(e) {
            _this._error = e;
            _this._timeoutId = window.setTimeout(_this.exec, _this.interval);
        });
    };
    return MultiExecutor;
}();

/**
 * ResourceManager
 */ var ResourceManager = /*#__PURE__*/ function() {
    function ResourceManager(engine) {
        this.engine = engine;
        this./** The number of retries after failing to load assets. */ retryCount = 1;
        this./** Retry delay time after failed to load assets, in milliseconds. */ retryInterval = 0;
        this./** The default timeout period for loading assets, in milliseconds. */ timeout = Infinity;
        this./** Base url for loading assets. */ baseUrl = null;
        this._loadingPromises = {};
        this._assetPool = Object.create(null);
        this._assetUrlPool = Object.create(null);
        this._referResourcePool = Object.create(null);
        this._graphicResourcePool = Object.create(null);
        this._contentRestorerPool = Object.create(null);
        this._subAssetPromiseCallbacks = {};
        this.//-----------------Editor temp solution-----------------
        /** @internal */ _objectPool = Object.create(null);
        this./** @internal */ _idResourceMap = Object.create(null);
        this./** @internal */ _virtualPathResourceMap = Object.create(null);
    }
    var _proto = ResourceManager.prototype;
    _proto.load = function load(assetInfo) {
        var _this = this;
        // single item
        if (!Array.isArray(assetInfo)) {
            return this._loadSingleItem(assetInfo);
        }
        // multi items
        var promises = assetInfo.map(function(item) {
            return _this._loadSingleItem(item);
        });
        return AssetPromise.all(promises);
    };
    /**
   * Get the resource from cache by asset url, return the resource object if it loaded, otherwise return null.
   * @param url - Resource url
   * @returns Resource object
   */ _proto.getFromCache = function getFromCache(url) {
        var _this__assetUrlPool_url;
        return (_this__assetUrlPool_url = this._assetUrlPool[url]) != null ? _this__assetUrlPool_url : null;
    };
    /**
   * Find the resource by type.
   * @param type - Resource type
   * @returns - Resource collection
   */ _proto.findResourcesByType = function findResourcesByType(type) {
        var resources = new Array();
        var referResourcePool = this._referResourcePool;
        for(var k in referResourcePool){
            var resource = referResourcePool[k];
            if (_instanceof$3(resource, type)) {
                resources.push(resource);
            }
        }
        return resources;
    };
    /**
   * Get asset url from instanceId.
   * @param instanceId - Engine instance id
   * @returns Asset url
   */ _proto.getAssetPath = function getAssetPath(instanceId) {
        return this._assetPool[instanceId];
    };
    _proto.cancelNotLoaded = function cancelNotLoaded(url) {
        var _this = this;
        if (!url) {
            Utils.objectValues(this._loadingPromises).forEach(function(promise) {
                promise.cancel();
            });
        } else if (typeof url === "string") {
            var _this__loadingPromises_url;
            (_this__loadingPromises_url = this._loadingPromises[url]) == null ? void 0 : _this__loadingPromises_url.cancel();
        } else {
            url.forEach(function(p) {
                var _this__loadingPromises_p;
                (_this__loadingPromises_p = _this._loadingPromises[p]) == null ? void 0 : _this__loadingPromises_p.cancel();
            });
        }
    };
    /**
   * Garbage collection will release resource objects managed by reference counting.
   * @remarks The release principle is that it is not referenced by the components, including direct and indirect reference.
   */ _proto.gc = function gc() {
        this._gc(false);
        this.engine._pendingGC();
    };
    /**
   * Add content restorer.
   * @param restorer - The restorer
   */ _proto.addContentRestorer = function addContentRestorer(restorer) {
        this._contentRestorerPool[restorer.resource.instanceId] = restorer;
    };
    /**
   * @internal
   */ _proto._getRemoteUrl = function _getRemoteUrl(url) {
        var _this__virtualPathResourceMap_url;
        var _this__virtualPathResourceMap_url_path;
        return (_this__virtualPathResourceMap_url_path = (_this__virtualPathResourceMap_url = this._virtualPathResourceMap[url]) == null ? void 0 : _this__virtualPathResourceMap_url.path) != null ? _this__virtualPathResourceMap_url_path : url;
    };
    /**
   * @internal
   */ _proto._requestByRemoteUrl = function _requestByRemoteUrl(url, config) {
        return request(url, config);
    };
    /**
   * @internal
   */ _proto._request = function _request(url, config) {
        var remoteUrl = this._getRemoteUrl(url);
        return this._requestByRemoteUrl(remoteUrl, config);
    };
    /**
   * @internal
   */ _proto._onSubAssetSuccess = function _onSubAssetSuccess(assetBaseURL, assetSubPath, value) {
        var _this__virtualPathResourceMap_assetBaseURL, _this__subAssetPromiseCallbacks_remoteAssetBaseURL;
        var _this__virtualPathResourceMap_assetBaseURL_path;
        var remoteAssetBaseURL = (_this__virtualPathResourceMap_assetBaseURL_path = (_this__virtualPathResourceMap_assetBaseURL = this._virtualPathResourceMap[assetBaseURL]) == null ? void 0 : _this__virtualPathResourceMap_assetBaseURL.path) != null ? _this__virtualPathResourceMap_assetBaseURL_path : assetBaseURL;
        var subPromiseCallback = (_this__subAssetPromiseCallbacks_remoteAssetBaseURL = this._subAssetPromiseCallbacks[remoteAssetBaseURL]) == null ? void 0 : _this__subAssetPromiseCallbacks_remoteAssetBaseURL[assetSubPath];
        if (subPromiseCallback) {
            subPromiseCallback.resolve(value);
        } else {
            var // Pending
            _this__subAssetPromiseCallbacks, _remoteAssetBaseURL;
            ((_this__subAssetPromiseCallbacks = this._subAssetPromiseCallbacks)[_remoteAssetBaseURL = remoteAssetBaseURL] || (_this__subAssetPromiseCallbacks[_remoteAssetBaseURL] = {}))[assetSubPath] = {
                resolvedValue: value
            };
        }
    };
    /**
   * @internal
   */ _proto._onSubAssetFail = function _onSubAssetFail(assetBaseURL, assetSubPath, value) {
        var _this__subAssetPromiseCallbacks_assetBaseURL;
        var subPromiseCallback = (_this__subAssetPromiseCallbacks_assetBaseURL = this._subAssetPromiseCallbacks[assetBaseURL]) == null ? void 0 : _this__subAssetPromiseCallbacks_assetBaseURL[assetSubPath];
        if (subPromiseCallback) {
            subPromiseCallback.reject(value);
        } else {
            var // Pending
            _this__subAssetPromiseCallbacks, _assetBaseURL;
            ((_this__subAssetPromiseCallbacks = this._subAssetPromiseCallbacks)[_assetBaseURL = assetBaseURL] || (_this__subAssetPromiseCallbacks[_assetBaseURL] = {}))[assetSubPath] = {
                rejectedValue: value
            };
        }
    };
    /**
   * @internal
   */ _proto._addAsset = function _addAsset(path, asset) {
        this._assetPool[asset.instanceId] = path;
        this._assetUrlPool[path] = asset;
    };
    /**
   * @internal
   */ _proto._deleteAsset = function _deleteAsset(asset) {
        var id = asset.instanceId;
        var path = this._assetPool[id];
        if (path) {
            delete this._assetPool[id];
            delete this._assetUrlPool[path];
        }
    };
    /**
   * @internal
   */ _proto._addReferResource = function _addReferResource(resource) {
        this._referResourcePool[resource.instanceId] = resource;
    };
    /**
   * @internal
   */ _proto._deleteReferResource = function _deleteReferResource(resource) {
        delete this._referResourcePool[resource.instanceId];
    };
    /**
   * @internal
   */ _proto._addGraphicResource = function _addGraphicResource(resource) {
        this._graphicResourcePool[resource.instanceId] = resource;
    };
    /**
   * @internal
   */ _proto._deleteGraphicResource = function _deleteGraphicResource(resource) {
        delete this._graphicResourcePool[resource.instanceId];
    };
    /**
   * @internal
   */ _proto._deleteContentRestorer = function _deleteContentRestorer(resource) {
        delete this._contentRestorerPool[resource.instanceId];
    };
    /**
   * @internal
   */ _proto._restoreGraphicResources = function _restoreGraphicResources() {
        var graphicResourcePool = this._graphicResourcePool;
        for(var id in graphicResourcePool){
            graphicResourcePool[id]._rebuild();
        }
    };
    /**
   * @internal
   */ _proto._lostGraphicResources = function _lostGraphicResources() {
        var graphicResourcePool = this._graphicResourcePool;
        for(var id in graphicResourcePool){
            graphicResourcePool[id]._isContentLost = true;
        }
    };
    /**
   * @internal
   */ _proto._restoreResourcesContent = function _restoreResourcesContent() {
        var restoreContentInfoPool = this._contentRestorerPool;
        var restorePromises = new Array();
        for(var k in restoreContentInfoPool){
            var restoreInfo = restoreContentInfoPool[k];
            var promise = restoreInfo.restoreContent();
            promise && restorePromises.push(promise);
        }
        return Promise.all(restorePromises);
    };
    /**
   * @internal
   */ _proto._destroy = function _destroy() {
        this.cancelNotLoaded();
        this._gc(true);
        this._assetPool = null;
        this._assetUrlPool = null;
        this._referResourcePool = null;
        this._graphicResourcePool = null;
        this._contentRestorerPool = null;
        this._loadingPromises = null;
    };
    _proto._assignDefaultOptions = function _assignDefaultOptions(assetInfo) {
        var _assetInfo_type;
        assetInfo.type = (_assetInfo_type = assetInfo.type) != null ? _assetInfo_type : ResourceManager._getTypeByUrl(assetInfo.url);
        if (assetInfo.type === undefined) {
            throw "asset type should be specified: " + assetInfo.url;
        }
        var _assetInfo_retryCount;
        assetInfo.retryCount = (_assetInfo_retryCount = assetInfo.retryCount) != null ? _assetInfo_retryCount : this.retryCount;
        var _assetInfo_timeout;
        assetInfo.timeout = (_assetInfo_timeout = assetInfo.timeout) != null ? _assetInfo_timeout : this.timeout;
        var _assetInfo_retryInterval;
        assetInfo.retryInterval = (_assetInfo_retryInterval = assetInfo.retryInterval) != null ? _assetInfo_retryInterval : this.retryInterval;
        var _assetInfo_url;
        assetInfo.url = (_assetInfo_url = assetInfo.url) != null ? _assetInfo_url : assetInfo.urls.join(",");
        return assetInfo;
    };
    _proto._loadSingleItem = function _loadSingleItem(itemOrURL) {
        var _this = this;
        var item = this._assignDefaultOptions(typeof itemOrURL === "string" ? {
            url: itemOrURL
        } : itemOrURL);
        var url = item.url;
        // Not absolute and base url is set
        if (!Utils.isAbsoluteUrl(url) && this.baseUrl) url = Utils.resolveAbsoluteUrl(this.baseUrl, url);
        // Parse url
        var _this__parseURL = this._parseURL(url), assetBaseURL = _this__parseURL.assetBaseURL, queryPath = _this__parseURL.queryPath;
        var paths = queryPath ? this._parseQueryPath(queryPath) : [];
        // Get remote asset base url
        var remoteConfig = this._virtualPathResourceMap[assetBaseURL];
        var _remoteConfig_path;
        var remoteAssetBaseURL = (_remoteConfig_path = remoteConfig == null ? void 0 : remoteConfig.path) != null ? _remoteConfig_path : assetBaseURL;
        // Check cache
        var cacheObject = this._assetUrlPool[remoteAssetBaseURL];
        if (cacheObject) {
            return new AssetPromise(function(resolve) {
                resolve(_this._getResolveResource(cacheObject, paths));
            });
        }
        // Get asset url
        var remoteAssetURL = remoteAssetBaseURL;
        if (queryPath) {
            remoteAssetURL += "?q=" + paths.shift();
            var index;
            while(index = paths.shift()){
                remoteAssetURL += "[" + index + "]";
            }
        }
        // Check is loading
        var loadingPromises = this._loadingPromises;
        var loadingPromise = loadingPromises[remoteAssetURL];
        if (loadingPromise) {
            return new AssetPromise(function(resolve, reject, setTaskCompleteProgress, setTaskDetailProgress) {
                loadingPromise.onProgress(setTaskCompleteProgress, setTaskDetailProgress).then(function(resource) {
                    resolve(resource);
                }).catch(function(error) {
                    reject(error);
                });
            });
        }
        // Check loader
        var loader = ResourceManager._loaders[item.type];
        if (!loader) {
            throw "loader not found: " + item.type;
        }
        var subpackageName = remoteConfig == null ? void 0 : remoteConfig.subpackageName;
        // Check sub asset
        if (queryPath) {
            // Check whether load main asset
            var mainPromise = loadingPromises[remoteAssetBaseURL] || this._loadSubpackageAndMainAsset(loader, item, remoteAssetBaseURL, assetBaseURL, subpackageName);
            mainPromise.catch(function(e) {
                _this._onSubAssetFail(remoteAssetBaseURL, queryPath, e);
            });
            return this._createSubAssetPromiseCallback(remoteAssetBaseURL, remoteAssetURL, queryPath);
        }
        return this._loadSubpackageAndMainAsset(loader, item, remoteAssetBaseURL, assetBaseURL, subpackageName);
    };
    // For adapter mini-game platform
    _proto._loadSubpackageAndMainAsset = function _loadSubpackageAndMainAsset(loader, item, remoteAssetBaseURL, assetBaseURL, subpackageName) {
        return this._loadMainAsset(loader, item, remoteAssetBaseURL, assetBaseURL);
    };
    _proto._loadMainAsset = function _loadMainAsset(loader, item, remoteAssetBaseURL, assetBaseURL) {
        var _this = this;
        item.url = assetBaseURL;
        var loadingPromises = this._loadingPromises;
        var promise = loader.load(item, this);
        loadingPromises[remoteAssetBaseURL] = promise;
        promise.then(function(resource) {
            if (loader.useCache) {
                _this._addAsset(remoteAssetBaseURL, resource);
            }
            delete loadingPromises[remoteAssetBaseURL];
            _this._releaseSubAssetPromiseCallback(remoteAssetBaseURL);
        }, function() {
            delete loadingPromises[remoteAssetBaseURL];
            _this._releaseSubAssetPromiseCallback(remoteAssetBaseURL);
        });
        return promise;
    };
    _proto._createSubAssetPromiseCallback = function _createSubAssetPromiseCallback(remoteAssetBaseURL, remoteAssetURL, assetSubPath) {
        var _this = this;
        var _this__subAssetPromiseCallbacks_remoteAssetBaseURL;
        var loadingPromises = this._loadingPromises;
        var subPromiseCallback = (_this__subAssetPromiseCallbacks_remoteAssetBaseURL = this._subAssetPromiseCallbacks[remoteAssetBaseURL]) == null ? void 0 : _this__subAssetPromiseCallbacks_remoteAssetBaseURL[assetSubPath];
        var resolvedValue = subPromiseCallback == null ? void 0 : subPromiseCallback.resolvedValue;
        var rejectedValue = subPromiseCallback == null ? void 0 : subPromiseCallback.rejectedValue;
        // Already resolved or rejected
        if (resolvedValue || rejectedValue) {
            return new AssetPromise(function(resolve, reject) {
                if (resolvedValue) {
                    resolve(resolvedValue);
                } else if (rejectedValue) {
                    reject(rejectedValue);
                }
            });
        }
        // Pending
        var promise = new AssetPromise(function(resolve, reject) {
            var _this__subAssetPromiseCallbacks, _remoteAssetBaseURL;
            ((_this__subAssetPromiseCallbacks = _this._subAssetPromiseCallbacks)[_remoteAssetBaseURL = remoteAssetBaseURL] || (_this__subAssetPromiseCallbacks[_remoteAssetBaseURL] = {}))[assetSubPath] = {
                resolve: resolve,
                reject: reject
            };
        });
        loadingPromises[remoteAssetURL] = promise;
        promise.then(function() {
            delete loadingPromises[remoteAssetURL];
        }, function() {
            return delete loadingPromises[remoteAssetURL];
        });
        return promise;
    };
    _proto._gc = function _gc(forceDestroy) {
        var objects = Utils.objectValues(this._referResourcePool);
        for(var i = 0, n = objects.length; i < n; i++){
            var object = objects[i];
            if (!object.isGCIgnored || forceDestroy) {
                object.destroy(forceDestroy, true);
            }
        }
    };
    _proto._getResolveResource = function _getResolveResource(resource, paths) {
        var subResource = resource;
        if (paths) {
            for(var i = 0, n = paths.length; i < n; i++){
                var path = paths[i];
                subResource = subResource[path];
            }
        }
        return subResource;
    };
    _proto._parseURL = function _parseURL(path) {
        var _path_split = path.split("?"), baseUrl = _path_split[0], searchStr = _path_split[1];
        var queryPath = undefined;
        var assetBaseURL = baseUrl;
        if (searchStr) {
            var params = searchStr.split("&");
            for(var i = params.length - 1; i >= 0; i--){
                var param = params[i];
                if (param.startsWith("q=")) {
                    queryPath = decodeURIComponent(param.split("=")[1]);
                    params.splice(i, 1);
                    break;
                }
            }
            assetBaseURL = params.length > 0 ? baseUrl + "?" + params.join("&") : baseUrl;
        }
        return {
            assetBaseURL: assetBaseURL,
            queryPath: queryPath
        };
    };
    _proto._parseQueryPath = function _parseQueryPath(string) {
        var result = [];
        if (string.charCodeAt(0) === charCodeOfDot) {
            result.push("");
        }
        string.replace(rePropName, function(match, expression, quote, subString) {
            var key = match;
            if (quote) {
                key = subString.replace(reEscapeChar, "$1");
            } else if (expression) {
                key = expression.trim();
            }
            result.push(key);
        });
        return result;
    };
    _proto._releaseSubAssetPromiseCallback = function _releaseSubAssetPromiseCallback(assetBaseURL) {
        delete this._subAssetPromiseCallbacks[assetBaseURL];
    };
    /**
   * @internal
   * @beta Just for internal editor, not recommended for developers.
   */ _proto.getResourceByRef = function getResourceByRef(ref) {
        var refId = ref.refId, key = ref.key, isClone = ref.isClone;
        var obj = this._objectPool[refId];
        var promise;
        if (obj) {
            promise = AssetPromise.resolve(obj);
        } else {
            var resourceConfig = this._idResourceMap[refId];
            if (!resourceConfig) {
                Logger.warn("refId:" + refId + " is not find in this._idResourceMap.");
                return AssetPromise.resolve(null);
            }
            var url = resourceConfig.virtualPath;
            if (key) {
                url += "?q=" + key;
            }
            promise = this.load({
                url: url,
                type: resourceConfig.type
            });
        }
        return promise.then(function(item) {
            return isClone ? item.clone() : item;
        });
    };
    /**
   * @internal
   * @beta Just for internal editor, not recommended for developers.
   */ _proto.initVirtualResources = function initVirtualResources(config) {
        var _this = this;
        config.forEach(function(element) {
            _this._virtualPathResourceMap[element.virtualPath] = element;
            _this._idResourceMap[element.id] = element;
            if (element.dependentAssetMap) {
                _this._virtualPathResourceMap[element.virtualPath].dependentAssetMap = element.dependentAssetMap;
            }
        });
    };
    /**
   * @internal
   */ ResourceManager._addLoader = function _addLoader(type, loader, extNames) {
        this._loaders[type] = loader;
        for(var i = 0, len = extNames.length; i < len; i++){
            this._extTypeMapping[extNames[i].toLowerCase()] = type;
        }
    };
    ResourceManager._getTypeByUrl = function _getTypeByUrl(url) {
        var path = url.split("?")[0];
        return this._extTypeMapping[path.substring(path.lastIndexOf(".") + 1).toLowerCase()];
    };
    return ResourceManager;
}();
/** @internal */ ResourceManager._loaders = {};
ResourceManager._extTypeMapping = {};
/**
 * Declare ResourceLoader's decorator.
 * @param assetType - Type of asset
 * @param extNames - Name of file extension
 */ function resourceLoader(assetType, extNames, useCache) {
    if (useCache === void 0) useCache = true;
    return function(Target) {
        var loader = new Target(useCache);
        ResourceManager._addLoader(assetType, loader, extNames);
    };
}
var charCodeOfDot = ".".charCodeAt(0);
var reEscapeChar = /\\(\\)?/g;
var rePropName = RegExp(// Match anything that isn't a dot or bracket.
"[^.[\\]]+" + "|" + // Or match property names within brackets.
"\\[(?:" + // Match a non-string expression.
"([^\"'][^[]*)" + "|" + // Or match strings (supports escaping characters).
"([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2" + ")\\]" + "|" + // Or match "" as the space between consecutive dots or empty brackets.
"(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))", "g");

/**
 * Defines values that specify the buttons on a pointer device.
 * Refer to the W3C standards:
 * (https://www.w3.org/TR/uievents/#dom-mouseevent-button)
 * (https://www.w3.org/TR/uievents/#dom-mouseevent-buttons)
 * Refer to Microsoft's documentation.(https://docs.microsoft.com/en-us/dotnet/api/system.windows.input.mousebutton?view=windowsdesktop-6.0)
 */ var PointerButton = /*#__PURE__*/ function(PointerButton) {
    /** No button. */ PointerButton[PointerButton["None"] = 0] = "None";
    /** Indicate the primary pointer of the device (in general, the left button or the only button on single-button devices, used to activate a user interface control or select text) or the un-initialized value. */ PointerButton[PointerButton["Primary"] = 1] = "Primary";
    /** Indicate the secondary pointer (in general, the right button, often used to display a context menu). */ PointerButton[PointerButton["Secondary"] = 2] = "Secondary";
    /** Indicate the auxiliary pointer (in general, the middle button, often combined with a mouse wheel). */ PointerButton[PointerButton["Auxiliary"] = 4] = "Auxiliary";
    /** Indicate the X1 (back) pointer. */ PointerButton[PointerButton["XButton1"] = 8] = "XButton1";
    /** Indicate the X2 (forward) pointer. */ PointerButton[PointerButton["XButton2"] = 16] = "XButton2";
    /** Indicate the X3 pointer. */ PointerButton[PointerButton["XButton3"] = 32] = "XButton3";
    /** Indicate the X4 pointer. */ PointerButton[PointerButton["XButton4"] = 64] = "XButton4";
    /** Indicate the X5 pointer. */ PointerButton[PointerButton["XButton5"] = 128] = "XButton5";
    /** Indicate the X6 pointer. */ PointerButton[PointerButton["XButton6"] = 256] = "XButton6";
    /** Indicate the X7 pointer. */ PointerButton[PointerButton["XButton7"] = 512] = "XButton7";
    /** Indicate the X8 pointer. */ PointerButton[PointerButton["XButton8"] = 1024] = "XButton8";
    return PointerButton;
}({});
/**
 * @internal
 */ var _pointerDec2BinMap = [
    1,
    4,
    2,
    8,
    16,
    32,
    64,
    128,
    256,
    512,
    1024
];
/**
 * @internal
 */ var _pointerBin2DecMap = {
    /** Primary */ 0x1: 0,
    /** Secondary */ 0x2: 2,
    /** Auxiliary */ 0x4: 1,
    /** XButton1 */ 0x8: 3,
    /** XButton2 */ 0x10: 4,
    /** XButton3 */ 0x20: 5,
    /** XButton4 */ 0x40: 6,
    /** XButton5 */ 0x80: 7,
    /** XButton6 */ 0x100: 8,
    /** XButton7 */ 0x200: 9,
    /** XButton8 */ 0x400: 10
};

/**
 * The keys of the keyboard.
 * Keep up with W3C standards.(https://www.w3.org/TR/2017/CR-uievents-code-20170601/)
 */ var Keys = /*#__PURE__*/ function(Keys) {
    /** `~ on a US keyboard. This is the 半角/全角/漢字 (hankaku/zenkaku/kanji) key on Japanese keyboards. */ Keys[Keys["Backquote"] = 0] = "Backquote";
    /** Used for both the US \| (on the 101-key layout) and also for the key located between the " and Enter keys on row C of the 102-, 104- and 106-key layouts. Labelled #~ on a UK (102) keyboard. */ Keys[Keys["Backslash"] = 1] = "Backslash";
    /**	Backspace or ⌫. Labelled Delete on Apple keyboards. */ Keys[Keys["Backspace"] = 2] = "Backspace";
    /** [{ on a US keyboard. */ Keys[Keys["BracketLeft"] = 3] = "BracketLeft";
    /** ]} on a US keyboard. */ Keys[Keys["BracketRight"] = 4] = "BracketRight";
    /** ,< on a US keyboard. */ Keys[Keys["Comma"] = 5] = "Comma";
    /** 0) on a US keyboard. */ Keys[Keys["Digit0"] = 6] = "Digit0";
    /** 1! on a US keyboard. */ Keys[Keys["Digit1"] = 7] = "Digit1";
    /** 2@ on a US keyboard. */ Keys[Keys["Digit2"] = 8] = "Digit2";
    /** 3# on a US keyboard. */ Keys[Keys["Digit3"] = 9] = "Digit3";
    /** 4$ on a US keyboard. */ Keys[Keys["Digit4"] = 10] = "Digit4";
    /** 5% on a US keyboard. */ Keys[Keys["Digit5"] = 11] = "Digit5";
    /** 6^ on a US keyboard. */ Keys[Keys["Digit6"] = 12] = "Digit6";
    /** 7& on a US keyboard. */ Keys[Keys["Digit7"] = 13] = "Digit7";
    /** 8* on a US keyboard. */ Keys[Keys["Digit8"] = 14] = "Digit8";
    /** 9( on a US keyboard. */ Keys[Keys["Digit9"] = 15] = "Digit9";
    /** =+ on a US keyboard. */ Keys[Keys["Equal"] = 16] = "Equal";
    /** Located between the left Shift and Z keys. Labelled \| on a UK keyboard. */ Keys[Keys["IntlBackslash"] = 17] = "IntlBackslash";
    /** Located between the / and right Shift keys. Labelled \ろ (ro) on a Japanese keyboard. */ Keys[Keys["IntlRo"] = 18] = "IntlRo";
    /** Located between the = and Backspace keys. Labelled ¥ (yen) on a Japanese keyboard. \/ on a Russian keyboard. */ Keys[Keys["IntlYen"] = 19] = "IntlYen";
    /** a on a US keyboard. Labelled q on an AZERTY (e.g., French) keyboard. */ Keys[Keys["KeyA"] = 20] = "KeyA";
    /** b on a US keyboard. */ Keys[Keys["KeyB"] = 21] = "KeyB";
    /** c on a US keyboard. */ Keys[Keys["KeyC"] = 22] = "KeyC";
    /** d on a US keyboard. */ Keys[Keys["KeyD"] = 23] = "KeyD";
    /** e on a US keyboard. */ Keys[Keys["KeyE"] = 24] = "KeyE";
    /** f on a US keyboard. */ Keys[Keys["KeyF"] = 25] = "KeyF";
    /** g on a US keyboard. */ Keys[Keys["KeyG"] = 26] = "KeyG";
    /** h on a US keyboard. */ Keys[Keys["KeyH"] = 27] = "KeyH";
    /** i on a US keyboard. */ Keys[Keys["KeyI"] = 28] = "KeyI";
    /** j on a US keyboard. */ Keys[Keys["KeyJ"] = 29] = "KeyJ";
    /** k on a US keyboard. */ Keys[Keys["KeyK"] = 30] = "KeyK";
    /** l on a US keyboard. */ Keys[Keys["KeyL"] = 31] = "KeyL";
    /** m on a US keyboard. */ Keys[Keys["KeyM"] = 32] = "KeyM";
    /** n on a US keyboard. */ Keys[Keys["KeyN"] = 33] = "KeyN";
    /** o on a US keyboard. */ Keys[Keys["KeyO"] = 34] = "KeyO";
    /** p on a US keyboard. */ Keys[Keys["KeyP"] = 35] = "KeyP";
    /** q on a US keyboard. Labelled a on an AZERTY (e.g., French) keyboard. */ Keys[Keys["KeyQ"] = 36] = "KeyQ";
    /** r on a US keyboard. */ Keys[Keys["KeyR"] = 37] = "KeyR";
    /** s on a US keyboard. */ Keys[Keys["KeyS"] = 38] = "KeyS";
    /** t on a US keyboard. */ Keys[Keys["KeyT"] = 39] = "KeyT";
    /** u on a US keyboard. */ Keys[Keys["KeyU"] = 40] = "KeyU";
    /** v on a US keyboard. */ Keys[Keys["KeyV"] = 41] = "KeyV";
    /** w on a US keyboard. Labelled z on an AZERTY (e.g., French) keyboard. */ Keys[Keys["KeyW"] = 42] = "KeyW";
    /** x on a US keyboard. */ Keys[Keys["KeyX"] = 43] = "KeyX";
    /** y on a US keyboard. Labelled z on a QWERTZ (e.g., German) keyboard. */ Keys[Keys["KeyY"] = 44] = "KeyY";
    /** z on a US keyboard. Labelled w on an AZERTY (e.g., French) keyboard, and y on a QWERTZ (e.g., German) keyboard. */ Keys[Keys["KeyZ"] = 45] = "KeyZ";
    /** -_ on a US keyboard. */ Keys[Keys["Minus"] = 46] = "Minus";
    /** .> on a US keyboard. */ Keys[Keys["Period"] = 47] = "Period";
    /** '" on a US keyboard. */ Keys[Keys["Quote"] = 48] = "Quote";
    /** ;: on a US keyboard. */ Keys[Keys["Semicolon"] = 49] = "Semicolon";
    /** /? on a US keyboard. */ Keys[Keys["Slash"] = 50] = "Slash";
    /** Alt, Option or ⌥. */ Keys[Keys["AltLeft"] = 51] = "AltLeft";
    /** Alt, Option or ⌥. This is labelled AltGr key on many keyboard layouts. */ Keys[Keys["AltRight"] = 52] = "AltRight";
    /** CapsLock or ⇪. */ Keys[Keys["CapsLock"] = 53] = "CapsLock";
    /** The application context menu key, which is typically found between the right Meta key and the right Control key. */ Keys[Keys["ContextMenu"] = 54] = "ContextMenu";
    /** Control or ⌃. */ Keys[Keys["ControlLeft"] = 55] = "ControlLeft";
    /** Control or ⌃. */ Keys[Keys["ControlRight"] = 56] = "ControlRight";
    /** Enter or ↵. Labelled Return on Apple keyboards. */ Keys[Keys["Enter"] = 57] = "Enter";
    /** The Windows, ⌘, Command or other OS symbol key. */ Keys[Keys["MetaLeft"] = 58] = "MetaLeft";
    /** The Windows, ⌘, Command or other OS symbol key. */ Keys[Keys["MetaRight"] = 59] = "MetaRight";
    /** Shift or ⇧. */ Keys[Keys["ShiftLeft"] = 60] = "ShiftLeft";
    /** Shift or ⇧. */ Keys[Keys["ShiftRight"] = 61] = "ShiftRight";
    /** Space. */ Keys[Keys["Space"] = 62] = "Space";
    /** Tab or ⇥. */ Keys[Keys["Tab"] = 63] = "Tab";
    /** Japanese: 変換 (henkan). */ Keys[Keys["Convert"] = 64] = "Convert";
    /** Japanese: カタカナ/ひらがな/ローマ字 (katakana/hiragana/romaji). */ Keys[Keys["KanaMode"] = 65] = "KanaMode";
    /**
   * Korean: HangulMode 한/영 (han/yeong).
   * Japanese (Mac keyboard): かな (kana).
   * */ Keys[Keys["Lang1"] = 66] = "Lang1";
    /**
   * 	Korean: Hanja 한자 (hanja).
   *  Japanese (Mac keyboard): 英数 (eisu).
   */ Keys[Keys["Lang2"] = 67] = "Lang2";
    /** Japanese (word-processing keyboard): Katakana. */ Keys[Keys["Lang3"] = 68] = "Lang3";
    /** Japanese (word-processing keyboard): Hiragana. */ Keys[Keys["Lang4"] = 69] = "Lang4";
    /** Japanese (word-processing keyboard): Zenkaku/Hankaku. */ Keys[Keys["Lang5"] = 70] = "Lang5";
    /** Japanese: 無変換 (muhenkan). */ Keys[Keys["NonConvert"] = 71] = "NonConvert";
    /** ⌦. The forward delete key. Note that on Apple keyboards, the key labelled Delete on the main part of the keyboard should be encoded as "Backspace". */ Keys[Keys["Delete"] = 72] = "Delete";
    /** Page Down, End or ↘. */ Keys[Keys["End"] = 73] = "End";
    /** Help. Not present on standard PC keyboards. */ Keys[Keys["Help"] = 74] = "Help";
    /** Home or ↖. */ Keys[Keys["Home"] = 75] = "Home";
    /** Insert or Ins. Not present on Apple keyboards. */ Keys[Keys["Insert"] = 76] = "Insert";
    /** Page Down, PgDn or ⇟. */ Keys[Keys["PageDown"] = 77] = "PageDown";
    /** Page Up, PgUp or ⇞. */ Keys[Keys["PageUp"] = 78] = "PageUp";
    /** ↓ */ Keys[Keys["ArrowDown"] = 79] = "ArrowDown";
    /** ← */ Keys[Keys["ArrowLeft"] = 80] = "ArrowLeft";
    /** → */ Keys[Keys["ArrowRight"] = 81] = "ArrowRight";
    /** ↑ */ Keys[Keys["ArrowUp"] = 82] = "ArrowUp";
    /** On the Mac, the "NumLock" code should be used for the numpad Clear key. */ Keys[Keys["NumLock"] = 83] = "NumLock";
    /**
   * 0 Ins on a keyboard.
   * 0 on a phone or remote control.
   * */ Keys[Keys["Numpad0"] = 84] = "Numpad0";
    /**
   * 1 End on a keyboard.
   * 1 or 1 QZ on a phone or remote control.
   */ Keys[Keys["Numpad1"] = 85] = "Numpad1";
    /**
   * 2 ↓ on a keyboard.
   * 2 ABC on a phone or remote control.
   */ Keys[Keys["Numpad2"] = 86] = "Numpad2";
    /**
   * 3 PgDn on a keyboard.
   * 3 DEF on a phone or remote control.
   */ Keys[Keys["Numpad3"] = 87] = "Numpad3";
    /**
   * 4 ← on a keyboard.
   * 4 GHI on a phone or remote control.
   */ Keys[Keys["Numpad4"] = 88] = "Numpad4";
    /**
   * 5 on a keyboard.
   * 5 JKL on a phone or remote control.
   */ Keys[Keys["Numpad5"] = 89] = "Numpad5";
    /**
   * 6 → on a keyboard.
   * 6 MNO on a phone or remote control.
   */ Keys[Keys["Numpad6"] = 90] = "Numpad6";
    /**
   * 7 Home on a keyboard.
   * 7 PQRS or 7 PRS on a phone or remote control.
   */ Keys[Keys["Numpad7"] = 91] = "Numpad7";
    /**
   * 8 ↑ on a keyboard.
   * 8 TUV on a phone or remote control.
   */ Keys[Keys["Numpad8"] = 92] = "Numpad8";
    /**
   * 9 PgUp on a keyboard.
   * 9 WXYZ or 9 WXY on a phone or remote control.
   */ Keys[Keys["Numpad9"] = 93] = "Numpad9";
    /** + */ Keys[Keys["NumpadAdd"] = 94] = "NumpadAdd";
    /** Found on the Microsoft Natural Keyboard. */ Keys[Keys["NumpadBackspace"] = 95] = "NumpadBackspace";
    /** C or AC (All Clear). Also for use with numpads that have a Clear key that is separate from the NumLock key. On the Mac, the numpad Clear key should always be encoded as "NumLock". */ Keys[Keys["NumpadClear"] = 96] = "NumpadClear";
    /** CE (Clear Entry) */ Keys[Keys["NumpadClearEntry"] = 97] = "NumpadClearEntry";
    /** , (thousands separator). For locales where the thousands separator is a "." (e.g., Brazil), this key may generate a .. */ Keys[Keys["NumpadComma"] = 98] = "NumpadComma";
    /** . Del. For locales where the decimal separator is "," (e.g., Brazil), this key may generate a ,. */ Keys[Keys["NumpadDecimal"] = 99] = "NumpadDecimal";
    /** / */ Keys[Keys["NumpadDivide"] = 100] = "NumpadDivide";
    /** Numpad Enter */ Keys[Keys["NumpadEnter"] = 101] = "NumpadEnter";
    /** = */ Keys[Keys["NumpadEqual"] = 102] = "NumpadEqual";
    /** # on a phone or remote control device. This key is typically found below the 9 key and to the right of the 0 key. */ Keys[Keys["NumpadHash"] = 103] = "NumpadHash";
    /** M+ Add current entry to the value stored in memory. */ Keys[Keys["NumpadMemoryAdd"] = 104] = "NumpadMemoryAdd";
    /** MC Clear the value stored in memory. */ Keys[Keys["NumpadMemoryClear"] = 105] = "NumpadMemoryClear";
    /** MR Replace the current entry with the value stored in memory. */ Keys[Keys["NumpadMemoryRecall"] = 106] = "NumpadMemoryRecall";
    /** MS Replace the value stored in memory with the current entry. */ Keys[Keys["NumpadMemoryStore"] = 107] = "NumpadMemoryStore";
    /** M- Subtract current entry from the value stored in memory. */ Keys[Keys["NumpadMemorySubtract"] = 108] = "NumpadMemorySubtract";
    /**
   * * on a keyboard. For use with numpads that provide mathematical operations (+, -, * and /).
   * Use "NumpadStar" for the * key on phones and remote controls.
   */ Keys[Keys["NumpadMultiply"] = 109] = "NumpadMultiply";
    /** ( Found on the Microsoft Natural Keyboard. */ Keys[Keys["NumpadParenLeft"] = 110] = "NumpadParenLeft";
    /** ) Found on the Microsoft Natural Keyboard. */ Keys[Keys["NumpadParenRight"] = 111] = "NumpadParenRight";
    /**
   * * on a phone or remote control device. This key is typically found below the 7 key and to the left of the 0 key.
   * Use "NumpadMultiply" for the * key on numeric keypads.
   */ Keys[Keys["NumpadStar"] = 112] = "NumpadStar";
    /** - */ Keys[Keys["NumpadSubtract"] = 113] = "NumpadSubtract";
    /** Esc or ⎋. */ Keys[Keys["Escape"] = 114] = "Escape";
    /** F1 */ Keys[Keys["F1"] = 115] = "F1";
    /** F2 */ Keys[Keys["F2"] = 116] = "F2";
    /** F3 */ Keys[Keys["F3"] = 117] = "F3";
    /** F4 */ Keys[Keys["F4"] = 118] = "F4";
    /** F5 */ Keys[Keys["F5"] = 119] = "F5";
    /** F6 */ Keys[Keys["F6"] = 120] = "F6";
    /** F7 */ Keys[Keys["F7"] = 121] = "F7";
    /** F8 */ Keys[Keys["F8"] = 122] = "F8";
    /** F9 */ Keys[Keys["F9"] = 123] = "F9";
    /** F10 */ Keys[Keys["F10"] = 124] = "F10";
    /** F11 */ Keys[Keys["F11"] = 125] = "F11";
    /** F12 */ Keys[Keys["F12"] = 126] = "F12";
    /** F13 */ Keys[Keys["F13"] = 127] = "F13";
    /** F14 */ Keys[Keys["F14"] = 128] = "F14";
    /** F15 */ Keys[Keys["F15"] = 129] = "F15";
    /** Fn This is typically a hardware key that does not generate a separate code. Most keyboards do not place this key in the function section, but it is included here to keep it with related keys. */ Keys[Keys["Fn"] = 130] = "Fn";
    /** FLock or FnLock. Function Lock key. Found on the Microsoft Natural Keyboard. */ Keys[Keys["FnLock"] = 131] = "FnLock";
    /** PrtScr SysRq or Print Screen. */ Keys[Keys["PrintScreen"] = 132] = "PrintScreen";
    /** Scroll Lock */ Keys[Keys["ScrollLock"] = 133] = "ScrollLock";
    /** Pause Break */ Keys[Keys["Pause"] = 134] = "Pause";
    /** Some laptops place this key to the left of the ↑ key. */ Keys[Keys["BrowserBack"] = 135] = "BrowserBack";
    /** Browser Favorites */ Keys[Keys["BrowserFavorites"] = 136] = "BrowserFavorites";
    /** Some laptops place this key to the right of the ↑ key. */ Keys[Keys["BrowserForward"] = 137] = "BrowserForward";
    /** Browser Home */ Keys[Keys["BrowserHome"] = 138] = "BrowserHome";
    /** Browser Refresh */ Keys[Keys["BrowserRefresh"] = 139] = "BrowserRefresh";
    /** Browser Search */ Keys[Keys["BrowserSearch"] = 140] = "BrowserSearch";
    /** Browser Stop */ Keys[Keys["BrowserStop"] = 141] = "BrowserStop";
    /** Eject or ⏏. This key is placed in the function section on some Apple keyboards. */ Keys[Keys["Eject"] = 142] = "Eject";
    /** Sometimes labelled My Computer on the keyboard. */ Keys[Keys["LaunchApp1"] = 143] = "LaunchApp1";
    /** Sometimes labelled Calculator on the keyboard. */ Keys[Keys["LaunchApp2"] = 144] = "LaunchApp2";
    /** Launch Mail */ Keys[Keys["LaunchMail"] = 145] = "LaunchMail";
    /** Media Play/Pause */ Keys[Keys["MediaPlayPause"] = 146] = "MediaPlayPause";
    /** Media Select */ Keys[Keys["MediaSelect"] = 147] = "MediaSelect";
    /** Media Stop */ Keys[Keys["MediaStop"] = 148] = "MediaStop";
    /** Media Track Next */ Keys[Keys["MediaTrackNext"] = 149] = "MediaTrackNext";
    /** Media Track Previous */ Keys[Keys["MediaTrackPrevious"] = 150] = "MediaTrackPrevious";
    /** This key is placed in the function section on some Apple keyboards, replacing the Eject key. */ Keys[Keys["Power"] = 151] = "Power";
    /** Sleep */ Keys[Keys["Sleep"] = 152] = "Sleep";
    /** Audio Volume Down */ Keys[Keys["AudioVolumeDown"] = 153] = "AudioVolumeDown";
    /** Audio Volume Mute */ Keys[Keys["AudioVolumeMute"] = 154] = "AudioVolumeMute";
    /** Audio Volume Up */ Keys[Keys["AudioVolumeUp"] = 155] = "AudioVolumeUp";
    /** Wake Up */ Keys[Keys["WakeUp"] = 156] = "WakeUp";
    /** Hyper */ Keys[Keys["Hyper"] = 157] = "Hyper";
    /** Super */ Keys[Keys["Super"] = 158] = "Super";
    /** Turbo */ Keys[Keys["Turbo"] = 159] = "Turbo";
    /** Abort */ Keys[Keys["Abort"] = 160] = "Abort";
    /** Resume */ Keys[Keys["Resume"] = 161] = "Resume";
    /** Suspend */ Keys[Keys["Suspend"] = 162] = "Suspend";
    /** Found on Sun’s USB keyboard. */ Keys[Keys["Again"] = 163] = "Again";
    /** Found on Sun’s USB keyboard. */ Keys[Keys["Copy"] = 164] = "Copy";
    /** Found on Sun’s USB keyboard. */ Keys[Keys["Cut"] = 165] = "Cut";
    /** Found on Sun’s USB keyboard. */ Keys[Keys["Find"] = 166] = "Find";
    /** Found on Sun’s USB keyboard. */ Keys[Keys["Open"] = 167] = "Open";
    /** Found on Sun’s USB keyboard. */ Keys[Keys["Paste"] = 168] = "Paste";
    /** Found on Sun’s USB keyboard. */ Keys[Keys["Props"] = 169] = "Props";
    /** Found on Sun’s USB keyboard. */ Keys[Keys["Select"] = 170] = "Select";
    /** Found on Sun’s USB keyboard. */ Keys[Keys["Undo"] = 171] = "Undo";
    /** Use for dedicated ひらがな key found on some Japanese word processing keyboards. */ Keys[Keys["Hiragana"] = 172] = "Hiragana";
    /** Use for dedicated カタカナ key found on some Japanese word processing keyboards. */ Keys[Keys["Katakana"] = 173] = "Katakana";
    /** This value code should be used when no other value given in this specification is appropriate. */ Keys[Keys["Unidentified"] = 174] = "Unidentified";
    return Keys;
}({});

/**
 * Keyboard Manager.
 * @internal
 */ var KeyboardManager = /*#__PURE__*/ function() {
    function KeyboardManager(engine, target) {
        /** @internal */ this._curHeldDownKeyToIndexMap = [];
        /** @internal */ this._upKeyToFrameCountMap = [];
        /** @internal */ this._downKeyToFrameCountMap = [];
        /** @internal */ this._curFrameHeldDownList = new DisorderedArray();
        /** @internal */ this._curFrameDownList = new DisorderedArray();
        /** @internal */ this._curFrameUpList = new DisorderedArray();
        this._nativeEvents = [];
        this._engine = engine;
        this._onBlur = this._onBlur.bind(this);
        this._onKeyEvent = this._onKeyEvent.bind(this);
        this._target = target;
        this._addEventListener();
    }
    var _proto = KeyboardManager.prototype;
    /**
   * @internal
   */ _proto._update = function _update() {
        var _this = this, nativeEvents = _this._nativeEvents, curFrameDownList = _this._curFrameDownList, curFrameUpList = _this._curFrameUpList;
        curFrameDownList.length = 0;
        curFrameUpList.length = 0;
        if (nativeEvents.length > 0) {
            var frameCount = this._engine.time.frameCount;
            var _this1 = this, curHeldDownKeyToIndexMap = _this1._curHeldDownKeyToIndexMap, curFrameHeldDownList = _this1._curFrameHeldDownList, downKeyToFrameCountMap = _this1._downKeyToFrameCountMap, upKeyToFrameCountMap = _this1._upKeyToFrameCountMap;
            for(var i = 0, n = nativeEvents.length; i < n; i++){
                var evt = nativeEvents[i];
                var codeKey = Keys[evt.code];
                switch(evt.type){
                    case "keydown":
                        // Filter the repeated triggers of the keyboard.
                        if (curHeldDownKeyToIndexMap[codeKey] == null) {
                            curFrameDownList.add(codeKey);
                            curFrameHeldDownList.add(codeKey);
                            curHeldDownKeyToIndexMap[codeKey] = curFrameHeldDownList.length - 1;
                            downKeyToFrameCountMap[codeKey] = frameCount;
                        }
                        break;
                    case "keyup":
                        var delIndex = curHeldDownKeyToIndexMap[codeKey];
                        if (delIndex != null) {
                            curHeldDownKeyToIndexMap[codeKey] = null;
                            var swapCode = curFrameHeldDownList.deleteByIndex(delIndex);
                            swapCode && (curHeldDownKeyToIndexMap[swapCode] = delIndex);
                        }
                        curFrameUpList.add(codeKey);
                        upKeyToFrameCountMap[codeKey] = frameCount;
                        // Because on the mac, the keyup event is not responded to when the meta key is held down,
                        // in order to maintain the correct keystroke record, it is necessary to clear the record
                        // when the meta key is lifted.
                        // link: https://stackoverflow.com/questions/11818637/why-does-javascript-drop-keyup-events-when-the-metakey-is-pressed-on-mac-browser
                        if (SystemInfo.platform === Platform.Mac && (codeKey === Keys.MetaLeft || codeKey === Keys.MetaRight)) {
                            for(var i1 = 0, n1 = curFrameHeldDownList.length; i1 < n1; i1++){
                                curHeldDownKeyToIndexMap[curFrameHeldDownList.get(i1)] = null;
                            }
                            curFrameHeldDownList.length = 0;
                        }
                        break;
                }
            }
            nativeEvents.length = 0;
        }
    };
    /**
   * @internal
   */ _proto._destroy = function _destroy() {
        this._removeEventListener();
        this._curHeldDownKeyToIndexMap.length = 0;
        this._curHeldDownKeyToIndexMap = null;
        this._upKeyToFrameCountMap.length = 0;
        this._upKeyToFrameCountMap = null;
        this._downKeyToFrameCountMap.length = 0;
        this._downKeyToFrameCountMap = null;
        this._nativeEvents.length = 0;
        this._nativeEvents = null;
        this._curFrameHeldDownList.length = 0;
        this._curFrameHeldDownList = null;
        this._curFrameDownList.length = 0;
        this._curFrameDownList = null;
        this._curFrameUpList.length = 0;
        this._curFrameUpList = null;
        this._engine = null;
    };
    _proto._onBlur = function _onBlur() {
        this._curHeldDownKeyToIndexMap.length = 0;
        this._curFrameHeldDownList.length = 0;
        this._curFrameDownList.length = 0;
        this._curFrameUpList.length = 0;
        this._nativeEvents.length = 0;
    };
    _proto._onKeyEvent = function _onKeyEvent(evt) {
        this._nativeEvents.push(evt);
    };
    _proto._addEventListener = function _addEventListener() {
        var _this = this, target = _this._target;
        target.addEventListener("keydown", this._onKeyEvent);
        target.addEventListener("keyup", this._onKeyEvent);
        target.addEventListener("blur", this._onBlur);
    };
    _proto._removeEventListener = function _removeEventListener() {
        var _this = this, target = _this._target;
        target.removeEventListener("keydown", this._onKeyEvent);
        target.removeEventListener("keyup", this._onKeyEvent);
        target.removeEventListener("blur", this._onBlur);
    };
    return KeyboardManager;
}();

/**
 * Clearable Object Pool.
 */ var ClearableObjectPool = /*#__PURE__*/ function(ObjectPool) {
    _inherits$2(ClearableObjectPool, ObjectPool);
    function ClearableObjectPool(type) {
        var _this;
        _this = ObjectPool.call(this, type) || this, _this._usedElementCount = 0;
        _this._elements = [];
        return _this;
    }
    var _proto = ClearableObjectPool.prototype;
    /**
   * Get an object.
   */ _proto.get = function get() {
        var _this = this, usedElementCount = _this._usedElementCount, elements = _this._elements;
        this._usedElementCount++;
        if (elements.length === usedElementCount) {
            var element = new this._type();
            elements.push(element);
            return element;
        } else {
            return elements[usedElementCount];
        }
    };
    /**
   * Clear used object count to 0, not destroy any object, just change index.
   */ _proto.clear = function clear() {
        this._usedElementCount = 0;
    };
    return ClearableObjectPool;
}(ObjectPool);

/**
 *  The current phase of the pointer.
 */ var PointerPhase = /*#__PURE__*/ function(PointerPhase) {
    /** A Pointer pressed on the screen. */ PointerPhase[PointerPhase["Down"] = 0] = "Down";
    /** A pointer moved on the screen. */ PointerPhase[PointerPhase["Move"] = 1] = "Move";
    /** A Pointer pressed on the screen but hasn't moved. */ PointerPhase[PointerPhase["Stationary"] = 2] = "Stationary";
    /** A pointer was lifted from the screen. */ PointerPhase[PointerPhase["Up"] = 3] = "Up";
    /** The system cancelled tracking for the pointer. */ PointerPhase[PointerPhase["Leave"] = 4] = "Leave";
    return PointerPhase;
}({});

/**
 * Pointer.
 */ var Pointer = /*#__PURE__*/ function() {
    function Pointer(id) {
        /** The phase of pointer. */ this.phase = PointerPhase.Leave;
        /** The position of the pointer in screen space pixel coordinates. */ this.position = new Vector2();
        /** The change of the pointer. */ this.deltaPosition = new Vector2();
        /** @internal */ this._events = [];
        /** @internal */ this._upMap = [];
        /** @internal */ this._downMap = [];
        /** @internal */ this._upList = new DisorderedArray();
        /** @internal */ this._downList = new DisorderedArray();
        /** @internal */ this._frameEvents = 0;
        /** @internal */ this._emitters = [];
        this.id = id;
    }
    var _proto = Pointer.prototype;
    /**
   * @internal
   */ _proto._addEmitters = function _addEmitters(type, pool) {
        this._emitters.push(new type(pool));
    };
    /**
   * @internal
   */ _proto._resetOnFrameBegin = function _resetOnFrameBegin() {
        this._frameEvents = 0;
        this._events.length = this._upList.length = this._downList.length = 0;
    };
    /**
   * @internal
   */ _proto._dispose = function _dispose() {
        var emitters = this._emitters;
        for(var i = 0, n = emitters.length; i < n; i++){
            emitters[i].dispose();
        }
        this._events.length = this._upList.length = this._downList.length = 0;
    };
    return Pointer;
}();
var PointerEventType = /*#__PURE__*/ function(PointerEventType) {
    PointerEventType[PointerEventType["None"] = 0] = "None";
    PointerEventType[PointerEventType["Down"] = 1] = "Down";
    PointerEventType[PointerEventType["Up"] = 2] = "Up";
    PointerEventType[PointerEventType["Leave"] = 4] = "Leave";
    PointerEventType[PointerEventType["Move"] = 8] = "Move";
    PointerEventType[PointerEventType["Cancel"] = 16] = "Cancel";
    return PointerEventType;
}({});

/**
 * Pointer event data.
 */ var PointerEventData = /*#__PURE__*/ function() {
    function PointerEventData() {
        /** The position of the event trigger (in world space). */ this.worldPosition = new Vector3();
    }
    var _proto = PointerEventData.prototype;
    /**
   * @internal
   */ _proto.dispose = function dispose() {
        this.pointer = null;
    };
    return PointerEventData;
}();

var PointerEventEmitter = /*#__PURE__*/ function() {
    function PointerEventEmitter(pool) {
        this._pool = pool;
        this._init();
    }
    var _proto = PointerEventEmitter.prototype;
    _proto._createEventData = function _createEventData(pointer) {
        var data = this._pool.get();
        data.pointer = pointer;
        data.worldPosition.copyFrom(this._hitResult.point);
        return data;
    };
    _proto._fireDown = function _fireDown(entity, eventData) {
        // @ts-ignore
        entity._scripts.forEach(function(script) {
            script.onPointerDown == null ? void 0 : script.onPointerDown.call(script, eventData);
        }, function(script, index) {
            // @ts-ignore
            script._entityScriptsIndex = index;
        });
    };
    _proto._fireUp = function _fireUp(entity, eventData) {
        // @ts-ignore
        entity._scripts.forEach(function(script) {
            script.onPointerUp == null ? void 0 : script.onPointerUp.call(script, eventData);
        }, function(script, index) {
            // @ts-ignore
            script._entityScriptsIndex = index;
        });
    };
    _proto._fireClick = function _fireClick(entity, eventData) {
        // @ts-ignore
        entity._scripts.forEach(function(script) {
            script.onPointerClick == null ? void 0 : script.onPointerClick.call(script, eventData);
        }, function(script, index) {
            // @ts-ignore
            script._entityScriptsIndex = index;
        });
    };
    _proto._fireEnter = function _fireEnter(entity, eventData) {
        // @ts-ignore
        entity._scripts.forEach(function(script) {
            script.onPointerEnter == null ? void 0 : script.onPointerEnter.call(script, eventData);
        }, function(script, index) {
            // @ts-ignore
            script._entityScriptsIndex = index;
        });
    };
    _proto._fireExit = function _fireExit(entity, eventData) {
        // @ts-ignore
        entity._scripts.forEach(function(script) {
            script.onPointerExit == null ? void 0 : script.onPointerExit.call(script, eventData);
        }, function(script, index) {
            // @ts-ignore
            script._entityScriptsIndex = index;
        });
    };
    _proto._fireBeginDrag = function _fireBeginDrag(entity, eventData) {
        // @ts-ignore
        entity._scripts.forEach(function(script) {
            script.onPointerBeginDrag == null ? void 0 : script.onPointerBeginDrag.call(script, eventData);
        }, function(script, index) {
            // @ts-ignore
            script._entityScriptsIndex = index;
        });
    };
    _proto._fireDrag = function _fireDrag(entity, eventData) {
        // @ts-ignore
        entity._scripts.forEach(function(script) {
            script.onPointerDrag == null ? void 0 : script.onPointerDrag.call(script, eventData);
        }, function(script, index) {
            // @ts-ignore
            script._entityScriptsIndex = index;
        });
    };
    _proto._fireEndDrag = function _fireEndDrag(entity, eventData) {
        // @ts-ignore
        entity._scripts.forEach(function(script) {
            script.onPointerEndDrag == null ? void 0 : script.onPointerEndDrag.call(script, eventData);
        }, function(script, index) {
            // @ts-ignore
            script._entityScriptsIndex = index;
        });
    };
    _proto._fireDrop = function _fireDrop(entity, eventData) {
        // @ts-ignore
        entity._scripts.forEach(function(script) {
            script.onPointerDrop == null ? void 0 : script.onPointerDrop.call(script, eventData);
        }, function(script, index) {
            // @ts-ignore
            script._entityScriptsIndex = index;
        });
    };
    return PointerEventEmitter;
}();
PointerEventEmitter._tempRay = new Ray();

/**
 * @internal
 */ var PhysicsPointerEventEmitter = /*#__PURE__*/ function(PointerEventEmitter1) {
    _inherits$2(PhysicsPointerEventEmitter, PointerEventEmitter1);
    function PhysicsPointerEventEmitter() {
        return PointerEventEmitter1.apply(this, arguments) || this;
    }
    var _proto = PhysicsPointerEventEmitter.prototype;
    _proto.processRaycast = function processRaycast(scenes, pointer) {
        var ray = PointerEventEmitter._tempRay;
        var position = pointer.position;
        var x = position.x, y = position.y;
        var hitResult = this._hitResult;
        for(var i = scenes.length - 1; i >= 0; i--){
            var scene = scenes[i];
            if (!scene.isActive || scene.destroyed) {
                continue;
            }
            var cameras = scene._componentsManager._activeCameras;
            var scenePhysics = scene.physics;
            for(var j = cameras.length - 1; j >= 0; j--){
                var camera = cameras.get(j);
                if (camera.renderTarget) continue;
                var pixelViewport = camera.pixelViewport;
                if (x < pixelViewport.x || y < pixelViewport.y || x > pixelViewport.x + pixelViewport.width || y > pixelViewport.y + pixelViewport.height) {
                    continue;
                }
                camera.screenPointToRay(pointer.position, ray);
                if (scenePhysics.raycast(ray, camera.farClipPlane, camera.cullingMask, hitResult)) {
                    this._updateRaycast(hitResult.entity, pointer);
                    return;
                }
                if (camera.clearFlags & CameraClearFlags.Color) {
                    this._updateRaycast(null, pointer);
                    return;
                }
            }
        }
        this._updateRaycast(null, pointer);
    };
    _proto.processDrag = function processDrag(pointer) {
        var entity = this._draggedEntity;
        entity && this._fireDrag(entity, this._createEventData(pointer));
    };
    _proto.processDown = function processDown(pointer) {
        var entity = this._pressedEntity = this._draggedEntity = this._enteredEntity;
        if (entity) {
            var eventData = this._createEventData(pointer);
            this._fireDown(entity, eventData);
            this._fireBeginDrag(entity, eventData);
        }
    };
    _proto.processUp = function processUp(pointer) {
        var _this = this, enteredEntity = _this._enteredEntity, draggedEntity = _this._draggedEntity;
        if (enteredEntity) {
            var sameTarget = this._pressedEntity === enteredEntity;
            var eventData = this._createEventData(pointer);
            this._fireUp(enteredEntity, eventData);
            sameTarget && this._fireClick(enteredEntity, eventData);
            this._fireDrop(enteredEntity, eventData);
        }
        this._pressedEntity = null;
        if (draggedEntity) {
            this._fireEndDrag(draggedEntity, this._createEventData(pointer));
            this._draggedEntity = null;
        }
    };
    _proto.processLeave = function processLeave(pointer) {
        var enteredEntity = this._enteredEntity;
        if (enteredEntity) {
            this._fireExit(enteredEntity, this._createEventData(pointer));
            this._enteredEntity = null;
        }
        var draggedEntity = this._draggedEntity;
        if (draggedEntity) {
            this._fireEndDrag(draggedEntity, this._createEventData(pointer));
            this._draggedEntity = null;
        }
        this._pressedEntity = null;
    };
    _proto.dispose = function dispose() {
        this._enteredEntity = this._pressedEntity = this._draggedEntity = null;
    };
    _proto._init = function _init() {
        this._hitResult = new HitResult();
    };
    _proto._updateRaycast = function _updateRaycast(entity, pointer) {
        var enteredEntity = this._enteredEntity;
        if (entity !== enteredEntity) {
            if (enteredEntity) {
                this._fireExit(enteredEntity, this._createEventData(pointer));
            }
            if (entity) {
                this._fireEnter(entity, this._createEventData(pointer));
            }
            this._enteredEntity = entity;
        }
    };
    return PhysicsPointerEventEmitter;
}(PointerEventEmitter);

/**
 * Pointer Manager.
 * @internal
 */ var PointerManager = /*#__PURE__*/ function() {
    function PointerManager(engine, target) {
        /** @internal */ this._pointers = [];
        /** @internal */ this._multiPointerEnabled = true;
        /** @internal */ this._buttons = PointerButton.None;
        /** @internal */ this._upMap = [];
        /** @internal */ this._downMap = [];
        /** @internal */ this._upList = new DisorderedArray();
        /** @internal */ this._downList = new DisorderedArray();
        this._nativeEvents = [];
        this._eventPool = new ClearableObjectPool(PointerEventData);
        // Temporary solution for mini program, window does not exist
        if (typeof Window !== "undefined" && _instanceof$3(target, Window)) {
            throw "Do not set window as target because window cannot listen to pointer leave event.";
        }
        this._engine = engine;
        this._target = target;
        this._canvas = engine.canvas;
        // @ts-ignore
        this._htmlCanvas = engine._canvas._webCanvas;
        // If there are no compatibility issues, navigator.maxTouchPoints should be used here
        this._pointerPool = new Array(11);
        this._onPointerEvent = this._onPointerEvent.bind(this);
        this._addEventListener();
    }
    var _proto = PointerManager.prototype;
    /**
   * @internal
   */ _proto._update = function _update() {
        var _this, _loop = function(i1, n) {
            var evt = nativeEvents[i1];
            var pointerId = evt.pointerId;
            var pointer = _this._getPointerByID(pointerId);
            if (pointer) {
                pointer._events.push(evt);
            } else {
                var lastCount = pointers.length;
                if (lastCount === 0 || _this._multiPointerEnabled) {
                    var _this1 = _this, pointerPool = _this1._pointerPool;
                    // Get Pointer smallest index
                    var j = 0;
                    for(; j < lastCount; j++){
                        if (pointers[j].id > j) {
                            break;
                        }
                    }
                    pointer = pointerPool[j];
                    if (!pointer) {
                        pointer = pointerPool[j] = new Pointer(j);
                        engine._physicsInitialized && pointer._addEmitters(PhysicsPointerEventEmitter, eventPool);
                        PointerManager._pointerEventEmitters.forEach(function(emitter) {
                            pointer._addEmitters(emitter, eventPool);
                        });
                    }
                    pointer._uniqueID = pointerId;
                    pointer._events.push(evt);
                    pointer.position.set((evt.clientX - left) * widthDPR, (evt.clientY - top) * heightDPR);
                    pointers.splice(j, 0, pointer);
                }
            }
        };
        var _this1 = this, pointers = _this1._pointers, nativeEvents = _this1._nativeEvents, htmlCanvas = _this1._htmlCanvas, engine = _this1._engine, eventPool = _this1._eventPool;
        var _this__canvas = this._canvas, width = _this__canvas.width, height = _this__canvas.height;
        var clientWidth = htmlCanvas.clientWidth, clientHeight = htmlCanvas.clientHeight;
        var _htmlCanvas_getBoundingClientRect = htmlCanvas.getBoundingClientRect(), left = _htmlCanvas_getBoundingClientRect.left, top = _htmlCanvas_getBoundingClientRect.top;
        var widthDPR = width / clientWidth;
        var heightDPR = height / clientHeight;
        // Clear the pointer event data pool
        eventPool.clear();
        // Clean up the pointer released in the previous frame
        for(var i = pointers.length - 1; i >= 0; i--){
            var pointer = pointers[i];
            if (pointer.phase === PointerPhase.Leave) {
                pointer._dispose();
                pointers.splice(i, 1);
            } else {
                pointer._resetOnFrameBegin();
            }
        }
        // Generate the pointer received for this frame
        for(var i1 = 0, n = nativeEvents.length; i1 < n; i1++)_this = this, _loop(i1);
        nativeEvents.length = 0;
        this._upList.length = this._downList.length = 0;
        this._buttons = PointerButton.None;
        // Pointer handles its own events
        var frameCount = engine.time.frameCount;
        for(var i2 = 0, n1 = pointers.length; i2 < n1; i2++){
            var pointer1 = pointers[i2];
            this._updatePointerInfo(frameCount, pointer1, left, top, widthDPR, heightDPR);
            this._buttons |= pointer1.pressedButtons;
        }
    };
    /**
   * @internal
   */ _proto._firePointerScript = function _firePointerScript(scenes) {
        var _this = this, pointers = _this._pointers;
        for(var i = 0, n = pointers.length; i < n; i++){
            var pointer = pointers[i];
            var events = pointer._events, emitters = pointer._emitters;
            var emittersLength = emitters.length;
            for(var k = 0; k < emittersLength; k++){
                emitters[k].processRaycast(scenes, pointer);
            }
            var length = events.length;
            if (length > 0) {
                if (pointer._frameEvents & PointerEventType.Move) {
                    // `Drag` must be processed first, otherwise `EndDrag` may be triggered first.
                    pointer.phase = PointerPhase.Move;
                    for(var k1 = 0; k1 < emittersLength; k1++){
                        emitters[k1].processDrag(pointer);
                    }
                }
                for(var j = 0; j < length; j++){
                    var event = events[j];
                    pointer.button = _pointerDec2BinMap[event.button] || PointerButton.None;
                    pointer.pressedButtons = event.buttons;
                    switch(event.type){
                        case "pointerdown":
                            pointer.phase = PointerPhase.Down;
                            for(var k2 = 0; k2 < emittersLength; k2++){
                                emitters[k2].processDown(pointer);
                            }
                            break;
                        case "pointerup":
                            pointer.phase = PointerPhase.Up;
                            for(var k3 = 0; k3 < emittersLength; k3++){
                                emitters[k3].processUp(pointer);
                            }
                            break;
                        case "pointerleave":
                        case "pointercancel":
                            pointer.phase = PointerPhase.Leave;
                            for(var k4 = 0; k4 < emittersLength; k4++){
                                emitters[k4].processLeave(pointer);
                            }
                            break;
                    }
                }
                events.length = 0;
            }
        }
    };
    /**
   * @internal
   */ _proto._destroy = function _destroy() {
        this._removeEventListener();
        this._pointerPool.length = 0;
    };
    _proto._onPointerEvent = function _onPointerEvent(evt) {
        this._nativeEvents.push(evt);
    };
    _proto._getPointerByID = function _getPointerByID(pointerId) {
        var _this = this, pointers = _this._pointers;
        for(var i = pointers.length - 1; i >= 0; i--){
            if (pointers[i]._uniqueID === pointerId) {
                return pointers[i];
            }
        }
        return null;
    };
    _proto._updatePointerInfo = function _updatePointerInfo(frameCount, pointer, left, top, widthPixelRatio, heightPixelRatio) {
        var events = pointer._events, position = pointer.position;
        var length = events.length;
        if (length > 0) {
            var _this = this, _upList = _this._upList, _upMap = _this._upMap, _downList = _this._downList, _downMap = _this._downMap;
            var latestEvent = events[length - 1];
            var currX = (latestEvent.clientX - left) * widthPixelRatio;
            var currY = (latestEvent.clientY - top) * heightPixelRatio;
            pointer.deltaPosition.set(currX - position.x, currY - position.y);
            position.set(currX, currY);
            pointer.button = _pointerDec2BinMap[latestEvent.button] || PointerButton.None;
            pointer.pressedButtons = latestEvent.buttons;
            for(var i = 0; i < length; i++){
                var event = events[i];
                switch(event.type){
                    case "pointerdown":
                        {
                            var button = event.button;
                            _downList.add(button);
                            _downMap[button] = frameCount;
                            pointer._downList.add(button);
                            pointer._downMap[button] = frameCount;
                            pointer._frameEvents |= PointerEventType.Down;
                            pointer.phase = PointerPhase.Down;
                            break;
                        }
                    case "pointerup":
                        {
                            var button1 = event.button;
                            _upList.add(button1);
                            _upMap[button1] = frameCount;
                            pointer._upList.add(button1);
                            pointer._upMap[button1] = frameCount;
                            pointer._frameEvents |= PointerEventType.Up;
                            pointer.phase = PointerPhase.Up;
                            break;
                        }
                    case "pointermove":
                        pointer._frameEvents |= PointerEventType.Move;
                        pointer.phase = PointerPhase.Move;
                        break;
                    case "pointerleave":
                        pointer._frameEvents |= PointerEventType.Leave;
                        pointer.phase = PointerPhase.Leave;
                        break;
                    case "pointercancel":
                        pointer._frameEvents |= PointerEventType.Cancel;
                        pointer.phase = PointerPhase.Leave;
                        break;
                }
            }
        } else {
            pointer.deltaPosition.set(0, 0);
            pointer.phase = PointerPhase.Stationary;
        }
    };
    _proto._addEventListener = function _addEventListener() {
        var _this = this, target = _this._target, onPointerEvent = _this._onPointerEvent;
        target.addEventListener("pointerdown", onPointerEvent);
        target.addEventListener("pointerup", onPointerEvent);
        target.addEventListener("pointerleave", onPointerEvent);
        target.addEventListener("pointermove", onPointerEvent);
        target.addEventListener("pointercancel", onPointerEvent);
    };
    _proto._removeEventListener = function _removeEventListener() {
        var _this = this, target = _this._target, onPointerEvent = _this._onPointerEvent;
        target.removeEventListener("pointerdown", onPointerEvent);
        target.removeEventListener("pointerup", onPointerEvent);
        target.removeEventListener("pointerleave", onPointerEvent);
        target.removeEventListener("pointermove", onPointerEvent);
        target.removeEventListener("pointercancel", onPointerEvent);
        this._eventPool.garbageCollection();
        this._nativeEvents.length = 0;
        this._pointers.length = 0;
        this._downList.length = 0;
        this._downMap.length = 0;
        this._upList.length = 0;
        this._upMap.length = 0;
    };
    return PointerManager;
}();
/** @internal */ PointerManager._pointerEventEmitters = [];
/**
 * Declare pointer event emitter decorator.
 */ function registerPointerEventEmitter() {
    return function(Target) {
        PointerManager._pointerEventEmitters.push(Target);
    };
}

/**
 * Wheel Manager.
 * @internal
 */ var WheelManager = /*#__PURE__*/ function() {
    function WheelManager(engine, target) {
        /** @internal */ this._delta = new Vector3();
        this._nativeEvents = [];
        this._onWheelEvent = this._onWheelEvent.bind(this);
        this._target = target;
        this._addEventListener();
    }
    var _proto = WheelManager.prototype;
    /**
   * @internal
   */ _proto._update = function _update() {
        var _this = this, delta = _this._delta;
        delta.set(0, 0, 0);
        var _this1 = this, nativeEvents = _this1._nativeEvents;
        if (nativeEvents.length > 0) {
            for(var i = nativeEvents.length - 1; i >= 0; i--){
                var evt = nativeEvents[i];
                delta.x += evt.deltaX;
                delta.y += evt.deltaY;
                delta.z += evt.deltaZ;
            }
            nativeEvents.length = 0;
        }
    };
    /**
   * @internal
   */ _proto._addEventListener = function _addEventListener() {
        this._target.addEventListener("wheel", this._onWheelEvent);
    };
    /**
   * @internal
   */ _proto._removeEventListener = function _removeEventListener() {
        this._target.removeEventListener("wheel", this._onWheelEvent);
        this._nativeEvents.length = 0;
        this._delta.set(0, 0, 0);
    };
    /**
   * @internal
   */ _proto._destroy = function _destroy() {
        this._removeEventListener();
        this._nativeEvents = null;
        this._delta = null;
    };
    _proto._onWheelEvent = function _onWheelEvent(evt) {
        this._nativeEvents.push(evt);
    };
    return WheelManager;
}();

/**
 * InputManager manages device input such as mouse, touch, keyboard, etc.
 */ var InputManager = /*#__PURE__*/ function() {
    function InputManager(engine, inputOptions) {
        /** Sometimes the input module will not be initialized, such as off-screen rendering. */ this._initialized = false;
        this._engine = engine;
        // @ts-ignore
        var canvas = engine._canvas._webCanvas;
        if (typeof OffscreenCanvas === "undefined" || !_instanceof$3(canvas, OffscreenCanvas)) {
            var _inputOptions_wheelTarget;
            this._wheelManager = new WheelManager(engine, (_inputOptions_wheelTarget = inputOptions == null ? void 0 : inputOptions.wheelTarget) != null ? _inputOptions_wheelTarget : canvas);
            var _inputOptions_pointerTarget;
            this._pointerManager = new PointerManager(engine, (_inputOptions_pointerTarget = inputOptions == null ? void 0 : inputOptions.pointerTarget) != null ? _inputOptions_pointerTarget : canvas);
            var _inputOptions_keyboardTarget;
            this._keyboardManager = new KeyboardManager(engine, (_inputOptions_keyboardTarget = inputOptions == null ? void 0 : inputOptions.keyboardTarget) != null ? _inputOptions_keyboardTarget : window);
            this._initialized = true;
        }
    }
    var _proto = InputManager.prototype;
    /**
   * Whether the key is being held down, if there is no parameter, return whether any key is being held down.
   * @param key - The keys of the keyboard
   * @returns Whether the key is being held down
   */ _proto.isKeyHeldDown = function isKeyHeldDown(key) {
        if (this._initialized) {
            if (key === undefined) {
                return this._keyboardManager._curFrameHeldDownList.length > 0;
            } else {
                return this._keyboardManager._curHeldDownKeyToIndexMap[key] != null;
            }
        } else {
            return false;
        }
    };
    /**
   * Whether the key starts to be pressed down during the current frame, if there is no parameter, return whether any key starts to be pressed down during the current frame.
   * @param key - The keys of the keyboard
   * @returns Whether the key starts to be pressed down during the current frame
   */ _proto.isKeyDown = function isKeyDown(key) {
        if (this._initialized) {
            if (key === undefined) {
                return this._keyboardManager._curFrameDownList.length > 0;
            } else {
                return this._keyboardManager._downKeyToFrameCountMap[key] === this._engine.time.frameCount;
            }
        } else {
            return false;
        }
    };
    /**
   * Whether the key is released during the current frame, if there is no parameter, return whether any key released during the current frame.
   * @param key - The keys of the keyboard
   * @returns Whether the key is released during the current frame
   */ _proto.isKeyUp = function isKeyUp(key) {
        if (this._initialized) {
            if (key === undefined) {
                return this._keyboardManager._curFrameUpList.length > 0;
            } else {
                return this._keyboardManager._upKeyToFrameCountMap[key] === this._engine.time.frameCount;
            }
        } else {
            return false;
        }
    };
    /**
   * Whether the pointer is being held down, if there is no parameter, return whether any pointer is being held down.
   * @param pointerButton - The pointerButton on a pointer device
   * @returns Whether the pointer is being held down
   */ _proto.isPointerHeldDown = function isPointerHeldDown(pointerButton) {
        if (this._initialized) {
            if (pointerButton === undefined) {
                return this._pointerManager._buttons !== 0;
            } else {
                return (this._pointerManager._buttons & pointerButton) !== 0;
            }
        } else {
            return false;
        }
    };
    /**
   * Whether the pointer starts to be pressed down during the current frame, if there is no parameter, return whether any pointer starts to be pressed down during the current frame.
   * @param pointerButton - The pointerButton on a pointer device
   * @returns Whether the pointer starts to be pressed down during the current frame
   */ _proto.isPointerDown = function isPointerDown(pointerButton) {
        if (this._initialized) {
            if (pointerButton === undefined) {
                return this._pointerManager._downList.length > 0;
            } else {
                return this._pointerManager._downMap[_pointerBin2DecMap[pointerButton]] === this._engine.time.frameCount;
            }
        } else {
            return false;
        }
    };
    /**
   * Whether the pointer is released during the current frame, if there is no parameter, return whether any pointer released during the current frame.
   * @param pointerButton - The pointerButtons on a mouse device
   * @returns Whether the pointer is released during the current frame
   */ _proto.isPointerUp = function isPointerUp(pointerButton) {
        if (this._initialized) {
            if (pointerButton === undefined) {
                return this._pointerManager._upList.length > 0;
            } else {
                return this._pointerManager._upMap[_pointerBin2DecMap[pointerButton]] === this._engine.time.frameCount;
            }
        } else {
            return false;
        }
    };
    /**
   * @internal
   */ _proto._update = function _update() {
        if (this._initialized) {
            this._wheelManager._update();
            this._pointerManager._update();
            this._keyboardManager._update();
        }
    };
    /**
   * @internal
   */ _proto._firePointerScript = function _firePointerScript(scenes) {
        this._initialized && this._pointerManager._firePointerScript(scenes);
    };
    /**
   * @internal
   */ _proto._destroy = function _destroy() {
        if (this._initialized) {
            this._wheelManager._destroy();
            this._wheelManager = null;
            this._pointerManager._destroy();
            this._pointerManager = null;
            this._keyboardManager._destroy();
            this._keyboardManager = null;
        }
    };
    _create_class$2(InputManager, [
        {
            key: "pointers",
            get: /**
   * Pointer list.
   */ function get() {
                return this._initialized ? this._pointerManager._pointers : [];
            }
        },
        {
            key: "multiPointerEnabled",
            get: /**
   *  Whether to handle multi-pointer.
   */ function get() {
                return this._initialized ? this._pointerManager._multiPointerEnabled : false;
            },
            set: function set(enabled) {
                this._initialized && (this._pointerManager._multiPointerEnabled = enabled);
            }
        },
        {
            key: "wheelDelta",
            get: /**
   * Get the change of the scroll wheel on the x-axis.
   * @returns Change value
   */ function get() {
                return this._initialized ? this._wheelManager._delta : null;
            }
        }
    ]);
    return InputManager;
}();

/**
 * @internal
 */ var ParticleBillboardVertexAttribute = /*#__PURE__*/ function(ParticleBillboardVertexAttribute) {
    ParticleBillboardVertexAttribute["cornerTextureCoordinate"] = "a_CornerTextureCoordinate";
    return ParticleBillboardVertexAttribute;
}({});

/**
 * @internal
 */ var ParticleInstanceVertexAttribute = /*#__PURE__*/ function(ParticleInstanceVertexAttribute) {
    ParticleInstanceVertexAttribute["ShapePositionStartLifeTime"] = "a_ShapePositionStartLifeTime";
    ParticleInstanceVertexAttribute["DirectionTime"] = "a_DirectionTime";
    ParticleInstanceVertexAttribute["StartColor"] = "a_StartColor";
    ParticleInstanceVertexAttribute["StartSize"] = "a_StartSize";
    ParticleInstanceVertexAttribute["StartRotation0"] = "a_StartRotation0";
    ParticleInstanceVertexAttribute["StartSpeed"] = "a_StartSpeed";
    ParticleInstanceVertexAttribute["Random0"] = "a_Random0";
    ParticleInstanceVertexAttribute["Random1"] = "a_Random1";
    ParticleInstanceVertexAttribute["SimulationWorldPosition"] = "a_SimulationWorldPosition";
    ParticleInstanceVertexAttribute["SimulationWorldRotation"] = "a_SimulationWorldRotation";
    ParticleInstanceVertexAttribute["SimulationUV"] = "a_SimulationUV";
    ParticleInstanceVertexAttribute["Random2"] = "a_Random2";
    return ParticleInstanceVertexAttribute;
}({});

/**
 * @internal
 */ var ParticleBufferUtils = function ParticleBufferUtils(engine) {
    this.billboardVertexElement = new VertexElement(ParticleBillboardVertexAttribute.cornerTextureCoordinate, 0, VertexElementFormat.Vector4, 0);
    this.instanceVertexElements = [
        new VertexElement(ParticleInstanceVertexAttribute.ShapePositionStartLifeTime, 0, VertexElementFormat.Vector4, 1, 1),
        new VertexElement(ParticleInstanceVertexAttribute.DirectionTime, 16, VertexElementFormat.Vector4, 1, 1),
        new VertexElement(ParticleInstanceVertexAttribute.StartColor, 32, VertexElementFormat.Vector4, 1, 1),
        new VertexElement(ParticleInstanceVertexAttribute.StartSize, 48, VertexElementFormat.Vector3, 1, 1),
        new VertexElement(ParticleInstanceVertexAttribute.StartRotation0, 60, VertexElementFormat.Vector3, 1, 1),
        new VertexElement(ParticleInstanceVertexAttribute.StartSpeed, 72, VertexElementFormat.Float, 1, 1),
        new VertexElement(ParticleInstanceVertexAttribute.Random0, 76, VertexElementFormat.Vector4, 1, 1),
        new VertexElement(ParticleInstanceVertexAttribute.Random1, 92, VertexElementFormat.Vector4, 1, 1),
        new VertexElement(ParticleInstanceVertexAttribute.SimulationWorldPosition, 108, VertexElementFormat.Vector3, 1, 1),
        new VertexElement(ParticleInstanceVertexAttribute.SimulationWorldRotation, 120, VertexElementFormat.Vector4, 1, 1),
        new VertexElement(ParticleInstanceVertexAttribute.SimulationUV, 136, VertexElementFormat.Vector4, 1, 1),
        new VertexElement(ParticleInstanceVertexAttribute.Random2, 152, VertexElementFormat.Vector4, 1, 1)
    ];
    var stride = 16;
    var billboardGeometryBuffer = new Buffer(engine, BufferBindFlag.VertexBuffer, stride * 4, BufferUsage.Static, false);
    billboardGeometryBuffer.isGCIgnored = true;
    this.billboardVertexBufferBinding = new VertexBufferBinding(billboardGeometryBuffer, stride);
    var indexBuffer = new Buffer(engine, BufferBindFlag.IndexBuffer, ParticleBufferUtils.billboardIndexCount, BufferUsage.Static, false);
    indexBuffer.isGCIgnored = true;
    this.billboardIndexBufferBinding = new IndexBufferBinding(indexBuffer, IndexFormat.UInt8);
    var billboardGeometryData = new Float32Array([
        -0.5,
        -0.5,
        0,
        1,
        0.5,
        -0.5,
        1,
        1,
        0.5,
        0.5,
        1,
        0,
        -0.5,
        0.5,
        0,
        0
    ]);
    var indexData = new Uint8Array([
        0,
        2,
        3,
        0,
        1,
        2
    ]);
    billboardGeometryBuffer.setData(billboardGeometryData);
    indexBuffer.setData(indexData);
    // Register content restorer
    engine.resourceManager.addContentRestorer(new (/*#__PURE__*/ function(ContentRestorer) {
        _inherits$2(_class, ContentRestorer);
        function _class() {
            return ContentRestorer.call(this, billboardGeometryBuffer) || this;
        }
        var _proto = _class.prototype;
        _proto.restoreContent = function restoreContent() {
            billboardGeometryBuffer.setData(billboardGeometryData);
        };
        return _class;
    }(ContentRestorer))());
    engine.resourceManager.addContentRestorer(new (/*#__PURE__*/ function(ContentRestorer) {
        _inherits$2(_class, ContentRestorer);
        function _class() {
            return ContentRestorer.call(this, indexBuffer) || this;
        }
        var _proto = _class.prototype;
        _proto.restoreContent = function restoreContent() {
        };
        return _class;
    }(ContentRestorer))());
};
ParticleBufferUtils.instanceVertexStride = 168;
ParticleBufferUtils.instanceVertexFloatStride = ParticleBufferUtils.instanceVertexStride / 4;
ParticleBufferUtils.startLifeTimeOffset = 3;
ParticleBufferUtils.timeOffset = 7;
ParticleBufferUtils.simulationUVOffset = 34;
ParticleBufferUtils.billboardIndexCount = 6;
ParticleBufferUtils.boundsFloatStride = 8;
ParticleBufferUtils.boundsTimeOffset = 6;
ParticleBufferUtils.boundsMaxLifetimeOffset = 7;

var blitFs = "#define GLSLIFY 1\n#include <common>\n\nuniform mediump sampler2D renderer_BlitTexture;\n#ifdef HAS_TEX_LOD\n\tuniform float renderer_BlitMipLevel;\n#endif\n\nuniform vec4 renderer_SourceScaleOffset;\n\nvarying vec2 v_uv;\n\nvoid main() {\n\tvec2 uv = v_uv;\n\tuv = uv * renderer_SourceScaleOffset.xy + renderer_SourceScaleOffset.zw;\n\n\t#ifdef HAS_TEX_LOD\n\t\tgl_FragColor = texture2DLodSRGB( renderer_BlitTexture, uv, renderer_BlitMipLevel );\n\t#else\n\t\tgl_FragColor = texture2DSRGB( renderer_BlitTexture, uv );\n\t#endif\n}\n\n"; // eslint-disable-line

var blitScreenFs = "#define GLSLIFY 1\n#include <common>\n\nuniform mediump sampler2D renderer_BlitTexture;\n#ifdef HAS_TEX_LOD\n\tuniform float renderer_BlitMipLevel;\n#endif\n\nvarying vec2 v_uv;\n\nvoid main() {\n\tvec2 uv = v_uv;\n\t// Screen uv is flipped\n\tuv.y = 1.0 - uv.y;\n\n\t#ifdef HAS_TEX_LOD\n\t\tgl_FragColor = texture2DLodSRGB( renderer_BlitTexture, uv, renderer_BlitMipLevel );\n\t#else\n\t\tgl_FragColor = texture2D( renderer_BlitTexture, uv );\n\t#endif\n\n\t// Color space in screen is in gamma space but without sRGB texture, so we need to convert it to linear space manually\n\tgl_FragColor = sRGBToLinear(gl_FragColor);\n}\n\n"; // eslint-disable-line

var skyProceduralFs = "#define GLSLIFY 1\n// This code uses the Unity skybox-Procedural shader algorithm, developed by Unity and licensed under the Unity Companion License. \n// The original implementation can be found at unity build-in shader(DefaultResourcesExtra/Skybox-Procedural.shader)\n\n#include <common>\n\nconst float MIE_G = -0.990;\nconst float MIE_G2 = 0.9801;\nconst float SKY_GROUND_THRESHOLD = 0.02;\n\nuniform float material_SunSize;\nuniform float material_SunSizeConvergence;\nuniform vec4 scene_SunlightColor;\nuniform vec3 scene_SunlightDirection;\n\nvarying vec3 v_GroundColor;\nvarying vec3 v_SkyColor;\n\n#ifdef MATERIAL_SUN_HIGH_QUALITY\n\tvarying vec3 v_Vertex;\n#elif defined(MATERIAL_SUN_SIMPLE)\n\tvarying vec3 v_RayDir;\n#else\n\tvarying float v_SkyGroundFactor;\n#endif\n\n#if defined(MATERIAL_SUN_HIGH_QUALITY)||defined(MATERIAL_SUN_SIMPLE)\n\tvarying vec3 v_SunColor;\n#endif\n\n// Calculates the Mie phase function\nfloat getMiePhase(float eyeCos, float eyeCos2) {\n\tfloat temp = 1.0 + MIE_G2 - 2.0 * MIE_G * eyeCos;\n\ttemp = pow(temp, pow(material_SunSize,0.65) * 10.0);\n\ttemp = max(temp,1.0e-4); // prevent division by zero, esp. in half precision\n\ttemp = 1.5 * ((1.0 - MIE_G2) / (2.0 + MIE_G2)) * (1.0 + eyeCos2) / temp;\n\treturn temp;\n}\n\n// Calculates the sun shape\nfloat calcSunAttenuation(vec3 lightPos, vec3 ray) {\n\t#ifdef MATERIAL_SUN_HIGH_QUALITY\n\t\tfloat focusedEyeCos = pow(clamp(dot(lightPos, ray),0.0,1.0), material_SunSizeConvergence);\n\t\treturn getMiePhase(-focusedEyeCos, focusedEyeCos * focusedEyeCos);\n\t#else //MATERIAL_SUN_SIMPLE\n\t\tvec3 delta = lightPos - ray;\n\t\tfloat dist = length(delta);\n\t\tfloat spot = 1.0 - smoothstep(0.0, material_SunSize, dist);\n\t\treturn spot * spot;\n\t#endif\n}\n\nvoid main() {\n\t// if y > 1 [eyeRay.y < -SKY_GROUND_THRESHOLD] - ground\n\t// if y >= 0 and < 1 [eyeRay.y <= 0 and > -SKY_GROUND_THRESHOLD] - horizon\n\t// if y < 0 [eyeRay.y > 0] - sky\n\tvec3 col = vec3(0.0, 0.0, 0.0);\n\n\t#ifdef MATERIAL_SUN_HIGH_QUALITY\n\t\tvec3 ray = normalize(v_Vertex);\n\t\tfloat y = ray.y / SKY_GROUND_THRESHOLD;\n\t#elif defined(MATERIAL_SUN_SIMPLE) \n\t\tvec3 ray = v_RayDir;\n\t\tfloat y = ray.y / SKY_GROUND_THRESHOLD;\t\n\t#else\n\t\tfloat y = v_SkyGroundFactor;\n\t#endif\n\n\t// if we did precalculate color in vprog: just do lerp between them\n\tcol = mix(v_SkyColor, v_GroundColor, clamp(y,0.0,1.0));\n\n\t#if defined(MATERIAL_SUN_HIGH_QUALITY)||defined(MATERIAL_SUN_SIMPLE)\n\t\tif (y < 0.0)\n\t\t\tcol += v_SunColor * calcSunAttenuation(-scene_SunlightDirection, -ray);\n\t#endif\n\n\tgl_FragColor = vec4(col, 1.0);\n}\n\n"; // eslint-disable-line

var skyProceduralVs = "#define GLSLIFY 1\n// This code uses the Unity skybox-Procedural shader algorithm, developed by Unity and licensed under the Unity Companion License. \n// The original implementation can be found at unity build-in shader(DefaultResourcesExtra/Skybox-Procedural.shader)\n\n#define OUTER_RADIUS 1.025\n#define RAYLEIGH (mix(0.0, 0.0025, pow(material_AtmosphereThickness,2.5)))\t// Rayleigh constant\n#define MIE 0.0010\t// Mie constant\n#define SUN_BRIGHTNESS 20.0\t// Sun brightness\n#define MAX_SCATTER 50.0 // Maximum scattering value, to prevent math overflows on Adrenos\n\nconst float SKY_GROUND_THRESHOLD = 0.02;\nconst float outerRadius = OUTER_RADIUS;\nconst float outerRadius2 = OUTER_RADIUS*OUTER_RADIUS;\nconst float innerRadius = 1.0;\nconst float innerRadius2 = 1.0;\nconst float cameraHeight = 0.0001;\n\nconst float HDSundiskIntensityFactor = 15.0;\nconst float simpleSundiskIntensityFactor = 27.0;\n\nconst float sunScale = 400.0 * SUN_BRIGHTNESS;\nconst float kmESun = MIE * SUN_BRIGHTNESS;\nconst float km4PI = MIE * 4.0 * 3.14159265;\nconst float scale = 1.0 / (OUTER_RADIUS - 1.0);\nconst float scaleDepth = 0.25;\nconst float scaleOverScaleDepth = (1.0 / (OUTER_RADIUS - 1.0)) / 0.25;\nconst float samples = 2.0; // THIS IS UNROLLED MANUALLY, DON'T TOUCH\n\n// RGB wavelengths        .35 (.62=158), .43 (.68=174), .525 (.75=190)\nconst vec3 c_DefaultScatteringWavelength = vec3(0.65, 0.57, 0.475);\nconst vec3 c_VariableRangeForScatteringWavelength = vec3(0.15, 0.15, 0.15);\n\nattribute vec4 POSITION;\n\nuniform mat4 camera_VPMat;\nuniform vec3 material_SkyTint;\nuniform vec3 material_GroundTint;\nuniform float material_Exposure;\nuniform float material_AtmosphereThickness;\nuniform vec4 scene_SunlightColor;\nuniform vec3 scene_SunlightDirection;\n\nvarying vec3 v_GroundColor;\nvarying vec3 v_SkyColor;\n\n#ifdef MATERIAL_SUN_HIGH_QUALITY\n\tvarying vec3 v_Vertex;\n#elif defined(MATERIAL_SUN_SIMPLE)\n\tvarying vec3 v_RayDir;\n#else\n\tvarying float v_SkyGroundFactor;\n#endif\n\n#if defined(MATERIAL_SUN_HIGH_QUALITY)||defined(MATERIAL_SUN_SIMPLE)\n\tvarying vec3 v_SunColor;\n#endif\n\n#define GAMMA 2.2\n#define COLOR_2_GAMMA(color) pow(color,vec3(1.0/GAMMA))\n#define COLOR_2_LINEAR(color) color\n\n// Calculates the Rayleigh phase function\nfloat getRayleighPhase(vec3 light, vec3 ray) \n{\n\tfloat eyeCos = dot(light, ray);\n\treturn 0.75 + 0.75 * eyeCos * eyeCos;\n}\n\nfloat scaleAngle(float inCos)\n{\n\tfloat x = 1.0 - inCos;\n\treturn 0.25 * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n}\n\nvoid main () {\n\tgl_Position = camera_VPMat*vec4(POSITION.xyz,1.0);\n\n \tvec3 skyTintInGammaSpace = COLOR_2_GAMMA(material_SkyTint);\n\tvec3 scatteringWavelength = mix(c_DefaultScatteringWavelength-c_VariableRangeForScatteringWavelength,c_DefaultScatteringWavelength+c_VariableRangeForScatteringWavelength,vec3(1.0) - skyTintInGammaSpace); // using Tint in sRGB+ gamma allows for more visually linear interpolation and to keep (0.5) at (128, gray in sRGB) point\n\tvec3 invWavelength = 1.0 / pow(scatteringWavelength, vec3(4.0));\n\n\tfloat krESun = RAYLEIGH * SUN_BRIGHTNESS;\n\tfloat kr4PI = RAYLEIGH * 4.0 * 3.14159265;\n\n\tvec3 cameraPos = vec3(0.0,innerRadius + cameraHeight,0.0); // The camera's current position\n\n\t// Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\n\tvec3 eyeRay = normalize(POSITION.xyz);\n\n\tfloat far = 0.0;\n\tvec3 cIn, cOut;\n\tif (eyeRay.y >= 0.0) {\n\t\t// Sky \n\t\t// Calculate the length of the \"atmosphere\"\n\t\tfar = sqrt(outerRadius2 + innerRadius2 * eyeRay.y * eyeRay.y - innerRadius2) - innerRadius * eyeRay.y;\n\n\t\t// Calculate the ray's starting position, then calculate its scattering offset\n\t\tfloat height = innerRadius + cameraHeight;\n\t\tfloat depth = exp(scaleOverScaleDepth * -cameraHeight);\n\t\tfloat startAngle = dot(eyeRay, cameraPos) / height;\n\t\tfloat startOffset = depth*scaleAngle(startAngle);\n\n\t\t// Initialize the scattering loop variables\n\t\tfloat sampleLength = far / samples;\n\t\tfloat scaledLength = sampleLength * scale;\n\t\tvec3 sampleRay = eyeRay * sampleLength;\n\t\tvec3 samplePoint = cameraPos + sampleRay * 0.5;\n\n\t\tvec3 frontColor = vec3(0.0);\n\t\t//unrolling this manually to avoid some platform for loop slow\n\t\t{\n\t\t\tfloat height = length(samplePoint);\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\n\t\t\tfloat lightAngle = dot(-scene_SunlightDirection, samplePoint) / height;\n\t\t\tfloat cameraAngle = dot(eyeRay, samplePoint) / height;\n\t\t\tfloat scatter = (startOffset + depth*(scaleAngle(lightAngle) - scaleAngle(cameraAngle)));\n\t\t\tvec3 attenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\n\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\n\t\t\tsamplePoint += sampleRay;\n\t\t}\n\t\t{\n\t\t\tfloat height = length(samplePoint);\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\n\t\t\tfloat lightAngle = dot(-scene_SunlightDirection, samplePoint) / height;\n\t\t\tfloat cameraAngle = dot(eyeRay, samplePoint) / height;\n\t\t\tfloat scatter = (startOffset + depth*(scaleAngle(lightAngle) - scaleAngle(cameraAngle)));\n\t\t\tvec3 attenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\n\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\n\t\t\tsamplePoint += sampleRay;\n\t\t}\n\n\t\t// Finally, scale the Mie and Rayleigh colors and set up the varying variables for the pixel shader\n\t\tcIn = frontColor * (invWavelength * krESun);\n\t\tcOut = frontColor * kmESun;\n\t} else {\n\t\t// Ground\n\t\tfar = (-cameraHeight) / (min(-0.001, eyeRay.y));\n\t\tvec3 pos = cameraPos + far * eyeRay;\n\n\t\t// Calculate the ray's starting position, then calculate its scattering offset\n\t\tfloat depth = exp((-cameraHeight) * (1.0/scaleDepth));\n\t\tfloat cameraAngle = dot(-eyeRay, pos);\n\t\tfloat lightAngle = dot(-scene_SunlightDirection, pos);\n\t\tfloat cameraScale = scaleAngle(cameraAngle);\n\t\tfloat lightScale = scaleAngle(lightAngle);\n\t\tfloat cameraOffset = depth*cameraScale;\n\t\tfloat temp = lightScale + cameraScale;\n\n\t\t// Initialize the scattering loop variables\n\t\tfloat sampleLength = far / samples;\n\t\tfloat scaledLength = sampleLength * scale;\n\t\tvec3 sampleRay = eyeRay * sampleLength;\n\t\tvec3 samplePoint = cameraPos + sampleRay * 0.5;\n\n\t\t// Now loop through the sample rays\n\t\tvec3 frontColor = vec3(0.0, 0.0, 0.0);\n\t\tvec3 attenuate;\n\n\t\t// Loop removed because we kept hitting SM2.0 temp variable limits. Doesn't affect the image too much\n\t\t{\n\t\t\tfloat height = length(samplePoint);\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\n\t\t\tfloat scatter = depth*temp - cameraOffset;\n\t\t\tattenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\n\t\t\tsamplePoint += sampleRay;\n\t\t}\n\n\t\tcIn = frontColor * (invWavelength * krESun + kmESun);\n\t\tcOut = clamp(attenuate, 0.0, 1.0);\n\t}\n\n\t#ifdef MATERIAL_SUN_HIGH_QUALITY\n\t\tv_Vertex = -POSITION.xyz;\n\t#elif defined(MATERIAL_SUN_SIMPLE) \n\t\tv_RayDir = -eyeRay;\n\t#else\n\t\tv_SkyGroundFactor = -eyeRay.y / SKY_GROUND_THRESHOLD;\n\t#endif\n\n\t// if we want to calculate color in vprog:\n\t// 1. in case of linear: multiply by _Exposure in here (even in case of lerp it will be common multiplier, so we can skip mul in fshader)\n\t// 2. in case of gamma: do sqrt right away instead of doing that in fshader\n\t\n\tv_GroundColor = material_Exposure * (cIn + COLOR_2_LINEAR(material_GroundTint) * cOut);\n\tv_SkyColor    = material_Exposure * (cIn * getRayleighPhase(-scene_SunlightDirection, -eyeRay));\n\n\t\n\t// The sun should have a stable intensity in its course in the sky. Moreover it should match the highlight of a purely specular material.\n\t// This matching was done using the standard shader BRDF1 on the 5/31/2017\n\t// Finally we want the sun to be always bright even in LDR thus the normalization of the lightColor for low intensity.\n\tfloat lightColorIntensity = clamp(length(scene_SunlightColor.xyz), 0.25, 1.0);\n\n\t#ifdef MATERIAL_SUN_HIGH_QUALITY \n\t\tv_SunColor = HDSundiskIntensityFactor * clamp(cOut,0.0,1.0) * scene_SunlightColor.xyz / lightColorIntensity;\n\t#elif defined(MATERIAL_SUN_SIMPLE) \n\t\tv_SunColor = simpleSundiskIntensityFactor * clamp(cOut * sunScale,0.0,1.0) * scene_SunlightColor.xyz / lightColorIntensity;\n\t#endif\n}\n"; // eslint-disable-line

var backgroundTextureFs = "#define GLSLIFY 1\n#include <common>\nuniform sampler2D material_BaseTexture;\n\nvarying vec2 v_uv;\n\nvoid main() {\n  gl_FragColor = texture2DSRGB(material_BaseTexture, v_uv);\n}"; // eslint-disable-line

var backgroundTextureVs = "#define GLSLIFY 1\nattribute vec3 POSITION;\nattribute vec2 TEXCOORD_0;\nvarying vec2 v_uv;\nuniform vec4 camera_ProjectionParams;\n\nvoid main() {\n  gl_Position = vec4(POSITION, 1.0);\n  gl_Position.y *= camera_ProjectionParams.x;\n  \n  v_uv = TEXCOORD_0;\n}"; // eslint-disable-line

var blinnPhongFs = "#define GLSLIFY 1\n#include <common>\n#include <camera_declare>\n\n#include <uv_share>\n#include <normal_share>\n#include <color_share>\n#include <worldpos_share>\n\n#include <light_frag_define>\n#include <ShadowFragmentDeclaration>\n#include <mobile_material_frag>\n\n#include <FogFragmentDeclaration>\n#include <normal_get>\n\nvoid main() {\n\n    #include <begin_mobile_frag>\n    #include <begin_viewdir_frag>\n    #include <mobile_blinnphong_frag>\n\n    gl_FragColor = emission + ambient + diffuse + specular;\n\n    #ifdef MATERIAL_IS_TRANSPARENT\n        gl_FragColor.a = diffuse.a;\n    #else\n        gl_FragColor.a = 1.0;\n    #endif\n\n    #include <FogFragment>\n}\n"; // eslint-disable-line

var blinnPhongVs = "#define GLSLIFY 1\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\n#include <uv_share>\n#include <color_share>\n#include <normal_share>\n#include <worldpos_share>\n\n#include <ShadowVertexDeclaration>\n#include <FogVertexDeclaration>\n\nvoid main() {\n\n    #include <begin_position_vert>\n    #include <begin_normal_vert>\n    #include <blendShape_vert>\n    #include <skinning_vert>\n    #include <uv_vert>\n    #include <color_vert>\n    #include <normal_vert>\n    #include <worldpos_vert>\n    #include <position_vert>\n\n    #include <ShadowVertex>\n    #include <FogVertex>\n}\n"; // eslint-disable-line

var depthOnlyFs = "#define GLSLIFY 1\nvoid main() {\n}"; // eslint-disable-line

var depthOnlyVs = "#define GLSLIFY 1\n#define MATERIAL_OMIT_NORMAL\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\nuniform mat4 camera_VPMat;\n\nvoid main() {\n\n    #include <begin_position_vert>\n    #include <blendShape_vert>\n    #include <skinning_vert>\n    #include <position_vert>\n\n}\n"; // eslint-disable-line

var particleFs = "#define GLSLIFY 1\n#include <common>\n\nvarying vec4 v_Color;\nvarying vec2 v_TextureCoordinate;\nuniform sampler2D material_BaseTexture;\nuniform vec4 material_BaseColor;\n \nuniform mediump vec3 material_EmissiveColor;\n#ifdef MATERIAL_HAS_EMISSIVETEXTURE\n    uniform sampler2D material_EmissiveTexture;\n#endif\n\n#ifdef RENDERER_MODE_MESH\n\tvarying vec4 v_MeshColor;\n#endif\n\nvoid main() {\n\tvec4 color = material_BaseColor * v_Color;\n\n\t#ifdef RENDERER_MODE_MESH\n\t\tcolor *= v_MeshColor;\n\t#endif\n\n\t#ifdef MATERIAL_HAS_BASETEXTURE\n\t\tcolor *= texture2DSRGB(material_BaseTexture, v_TextureCoordinate);\n\t#endif\n\t\n\t// Emissive\n\tvec3 emissiveRadiance = material_EmissiveColor;\n\t#ifdef MATERIAL_HAS_EMISSIVETEXTURE\n\t\temissiveRadiance *= texture2DSRGB(material_EmissiveTexture, v_TextureCoordinate).rgb;\n\t#endif\n\n\tcolor.rgb += emissiveRadiance;\n\n\tgl_FragColor = color;\n}"; // eslint-disable-line

var particleVs = "#define GLSLIFY 1\n#if defined(RENDERER_MODE_SPHERE_BILLBOARD) || defined(RENDERER_MODE_STRETCHED_BILLBOARD) || defined(RENDERER_MODE_HORIZONTAL_BILLBOARD) || defined(RENDERER_MODE_VERTICAL_BILLBOARD)\n    attribute vec4 a_CornerTextureCoordinate;\n#endif\n\n#ifdef RENDERER_MODE_MESH\n    attribute vec3 a_MeshPosition;\n    attribute vec4 a_MeshColor;\n    attribute vec2 a_MeshTextureCoordinate;\n    varying vec4 v_MeshColor;\n#endif\n\nattribute vec4 a_ShapePositionStartLifeTime;\nattribute vec4 a_DirectionTime;\nattribute vec4 a_StartColor;\nattribute vec3 a_StartSize;\nattribute vec3 a_StartRotation0;\nattribute float a_StartSpeed;\n\n//#if defined(COLOR_OVER_LIFETIME) || defined(RENDERER_COL_RANDOM_GRADIENTS) || defined(RENDERER_SOL_RANDOM_CURVES) || defined(RENDERER_SOL_RANDOM_CURVES_SEPARATE) || defined(ROTATION_OVER_LIFE_TIME_RANDOM_CONSTANTS) || defined(ROTATION_OVER_LIFETIME_RANDOM_CURVES)\n    attribute vec4 a_Random0;\n//#endif\n\n#if defined(RENDERER_TSA_FRAME_RANDOM_CURVES) || defined(RENDERER_VOL_IS_RANDOM_TWO)\n    attribute vec4 a_Random1; // x:texture sheet animation random\n#endif\n\nattribute vec3 a_SimulationWorldPosition;\nattribute vec4 a_SimulationWorldRotation;\n\nvarying vec4 v_Color;\n#ifdef MATERIAL_HAS_BASETEXTURE\n    attribute vec4 a_SimulationUV;\n    varying vec2 v_TextureCoordinate;\n#endif\n\nuniform float renderer_CurrentTime;\nuniform vec3 renderer_Gravity;\nuniform vec2 u_DragConstant;\nuniform vec3 renderer_WorldPosition;\nuniform vec4 renderer_WorldRotation;\nuniform bool renderer_ThreeDStartRotation;\nuniform int renderer_ScalingMode;\nuniform vec3 renderer_PositionScale;\nuniform vec3 renderer_SizeScale;\nuniform vec3 renderer_PivotOffset;\n\nuniform mat4 camera_ViewMat;\nuniform mat4 camera_ProjMat;\n\n#ifdef RENDERER_MODE_STRETCHED_BILLBOARD\n    uniform vec3 camera_Position;\n#endif\nuniform vec3 camera_Forward; // TODO:只有几种广告牌模式需要用\nuniform vec3 camera_Up;\n\nuniform float renderer_StretchedBillboardLengthScale;\nuniform float renderer_StretchedBillboardSpeedScale;\nuniform int renderer_SimulationSpace;\n\n#include <particle_common>\n#include <velocity_over_lifetime_module>\n#include <force_over_lifetime_module>\n#include <color_over_lifetime_module>\n#include <size_over_lifetime_module>\n#include <rotation_over_lifetime_module>\n#include <texture_sheet_animation_module>\n\nvec3 getStartPosition(vec3 startVelocity, float age, vec3 dragData) {\n    vec3 startPosition;\n    float lastTime = min(startVelocity.x / dragData.x, age); // todo 0/0\n    startPosition = lastTime * (startVelocity - 0.5 * dragData * lastTime);\n    return startPosition;\n}\n\nvec3 computeParticlePosition(in vec3 startVelocity, in float age, in float normalizedAge, vec3 gravityVelocity, vec4 worldRotation, vec3 dragData, out vec3 localVelocity, out vec3 worldVelocity) {\n    vec3 startPosition = getStartPosition(startVelocity, age, dragData);\n\n    vec3 finalPosition;\n    vec3 localPositionOffset = startPosition;\n    vec3 worldPositionOffset;\n\n    #ifdef _VOL_MODULE_ENABLED\n        vec3 lifeVelocity;      \n        vec3 velocityPositionOffset = computeVelocityPositionOffset(normalizedAge, age, lifeVelocity);\n        if (renderer_VOLSpace == 0) {\n            localVelocity += lifeVelocity;\n            localPositionOffset += velocityPositionOffset;\n        } else {\n            worldVelocity += lifeVelocity;\n            worldPositionOffset += velocityPositionOffset;\n        }\n    #endif\n\n    #ifdef _FOL_MODULE_ENABLED\n        vec3 forceVelocity;\n        vec3 forcePositionOffset = computeForcePositionOffset(normalizedAge, age, forceVelocity);\n        if (renderer_FOLSpace == 0) {\n            localVelocity += forceVelocity;\n            localPositionOffset += forcePositionOffset;\n        } else {\n            worldVelocity += forceVelocity;\n            worldPositionOffset += forcePositionOffset;\n        }\n    #endif\n\n    finalPosition = rotationByQuaternions(a_ShapePositionStartLifeTime.xyz + localPositionOffset, worldRotation) + worldPositionOffset;\n\n    if (renderer_SimulationSpace == 0) {\n        finalPosition = finalPosition + renderer_WorldPosition;\n    } else if (renderer_SimulationSpace == 1) {\n\t    finalPosition = finalPosition + a_SimulationWorldPosition;\n\t}\n\n    finalPosition += 0.5 * gravityVelocity * age;\n\n    return finalPosition;\n}\n\nvoid main() {\n    float age = renderer_CurrentTime - a_DirectionTime.w;\n    float normalizedAge = age / a_ShapePositionStartLifeTime.w;\n    if (normalizedAge < 1.0) {\n        vec3 startVelocity = a_DirectionTime.xyz * a_StartSpeed;\n        vec3 gravityVelocity = renderer_Gravity * a_Random0.x * age;\n\n        vec4 worldRotation;\n        if (renderer_SimulationSpace == 0) {\n            worldRotation = renderer_WorldRotation;\n        } else {\n            worldRotation = a_SimulationWorldRotation;\n        }\n\n        vec3 localVelocity = startVelocity;\n        vec3 worldVelocity = gravityVelocity;\n\n        //drag\n        vec3 dragData = a_DirectionTime.xyz * mix(u_DragConstant.x, u_DragConstant.y, a_Random0.x);\n        vec3 center = computeParticlePosition(startVelocity, age, normalizedAge, gravityVelocity, worldRotation, dragData, localVelocity, worldVelocity);\n\n        #include <sphere_billboard>\n        #include <stretched_billboard>\n        #include <horizontal_billboard>\n        #include <vertical_billboard>\n        #include <particle_mesh>\n\n        gl_Position = camera_ProjMat * camera_ViewMat * vec4(center, 1.0);\n        v_Color = computeParticleColor(a_StartColor, normalizedAge);\n\n        #ifdef MATERIAL_HAS_BASETEXTURE\n            vec2 simulateUV;\n            #if defined(RENDERER_MODE_SPHERE_BILLBOARD) || defined(RENDERER_MODE_STRETCHED_BILLBOARD) || defined(RENDERER_MODE_HORIZONTAL_BILLBOARD) || defined(RENDERER_MODE_VERTICAL_BILLBOARD)\n                simulateUV = a_CornerTextureCoordinate.zw * a_SimulationUV.xy + a_SimulationUV.zw;\n                v_TextureCoordinate = computeParticleUV(simulateUV, normalizedAge);\n            #endif\n            #ifdef RENDERER_MODE_MESH\n                simulateUV = a_SimulationUV.xy + a_MeshTextureCoordinate * a_SimulationUV.zw;\n                v_TextureCoordinate = computeParticleUV(simulateUV, normalizedAge);\n            #endif\n        #endif\n    } else {\n\t    gl_Position = vec4(2.0, 2.0, 2.0, 1.0); // Discard use out of X(-1,1),Y(-1,1),Z(0,1)\n    }\n}"; // eslint-disable-line

var pbrSpecularFs = "#define GLSLIFY 1\n#include <common>\n#include <camera_declare>\n\n#include <FogFragmentDeclaration>\n\n#include <uv_share>\n#include <normal_share>\n#include <color_share>\n#include <worldpos_share>\n\n#include <light_frag_define>\n\n#include <pbr_frag_define>\n#include <pbr_helper>\n\nvoid main() {\n    #include <pbr_frag>\n    #include <FogFragment>\n}\n"; // eslint-disable-line

var pbrFs = "#define GLSLIFY 1\n#define IS_METALLIC_WORKFLOW\n#include <common>\n#include <camera_declare>\n#include <transform_declare>\n\n#include <FogFragmentDeclaration>\n\n#include <uv_share>\n#include <normal_share>\n#include <color_share>\n#include <worldpos_share>\n\n#include <light_frag_define>\n\n#include <pbr_frag_define>\n#include <pbr_helper>\n\nvoid main() {\n    #include <pbr_frag>\n    #include <FogFragment>\n}\n"; // eslint-disable-line

var pbrVs = "#define GLSLIFY 1\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\n#include <uv_share>\n#include <color_share>\n#include <normal_share>\n#include <worldpos_share>\n\n#include <ShadowVertexDeclaration>\n#include <FogVertexDeclaration>\n\nvoid main() {\n\n    #include <begin_position_vert>\n    #include <begin_normal_vert>\n    #include <blendShape_vert>\n    #include <skinning_vert>\n    #include <uv_vert>\n    #include <color_vert>\n    #include <normal_vert>\n    #include <worldpos_vert>\n    #include <position_vert>\n\n    #include <ShadowVertex>\n    #include <FogVertex>\n}\n"; // eslint-disable-line

var shadowMapFs = "#define GLSLIFY 1\n#ifdef ENGINE_NO_DEPTH_TEXTURE\n  /**\n   * Decompose and save depth value.\n  */\n  vec4 pack (float depth) {\n    // Use rgba 4 bytes with a total of 32 bits to store the z value, and the accuracy of 1 byte is 1/256.\n    const vec4 bitShift = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);\n    const vec4 bitMask = vec4(1.0/256.0, 1.0/256.0, 1.0/256.0, 0.0);\n\n    vec4 rgbaDepth = fract(depth * bitShift); // Calculate the z value of each point\n\n    // Cut off the value which do not fit in 8 bits\n    rgbaDepth -= rgbaDepth.gbaa * bitMask;\n\n    return rgbaDepth;\n  }\n#endif\n\nuniform vec4 material_BaseColor;\nuniform sampler2D material_BaseTexture;\nuniform float material_AlphaCutoff;\nvarying vec2 v_uv;\n\nvoid main() {\n  #if defined(MATERIAL_IS_ALPHA_CUTOFF) || (defined(SCENE_ENABLE_TRANSPARENT_SHADOW) && defined(MATERIAL_IS_TRANSPARENT))\n    float alpha = material_BaseColor.a;\n    #ifdef MATERIAL_HAS_BASETEXTURE\n        alpha *= texture2D(material_BaseTexture, v_uv).a;\n    #endif\n  \n    #ifdef MATERIAL_IS_ALPHA_CUTOFF\n      if(alpha < material_AlphaCutoff){\n        discard;\n      }\n    #endif\n  \n    #if defined(SCENE_ENABLE_TRANSPARENT_SHADOW) && defined(MATERIAL_IS_TRANSPARENT)\n      // Interleaved gradient noise\n      float noise = fract(52.982919 * fract(dot(vec2(0.06711, 0.00584), gl_FragCoord.xy)));\n      if (alpha <= noise) {\n        discard;\n      };\n    #endif\n  #endif\n\n  #ifdef ENGINE_NO_DEPTH_TEXTURE\n      gl_FragColor = pack(gl_FragCoord.z);\n  #else\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n  #endif\n}"; // eslint-disable-line

var shadowMapVs = "#define GLSLIFY 1\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\n#include <normal_share>\n#include <uv_share>\nuniform mat4 camera_VPMat;\nuniform vec2 scene_ShadowBias; // x: depth bias, y: normal bias\nuniform vec3 scene_LightDirection;\n\nvec3 applyShadowBias(vec3 positionWS) {\n    positionWS -= scene_LightDirection * scene_ShadowBias.x;\n    return positionWS;\n}\n\nvec3 applyShadowNormalBias(vec3 positionWS, vec3 normalWS) {\n    float invNdotL = 1.0 - clamp(dot(-scene_LightDirection, normalWS), 0.0, 1.0);\n    float scale = invNdotL * scene_ShadowBias.y;\n    positionWS += normalWS * vec3(scale);\n    return positionWS;\n}\n\nvoid main() {\n\n    #include <begin_position_vert>\n    #include <begin_normal_vert>\n    #include <blendShape_vert>\n    #include <skinning_vert>\n    #include <uv_vert>\n    \n    vec4 positionWS = renderer_ModelMat * position;\n\n    positionWS.xyz = applyShadowBias(positionWS.xyz);\n    #ifndef MATERIAL_OMIT_NORMAL\n        #ifdef RENDERER_HAS_NORMAL\n            vec3 normalWS = normalize( mat3(renderer_NormalMat) * normal );\n            positionWS.xyz = applyShadowNormalBias(positionWS.xyz, normalWS);\n        #endif\n    #endif\n\n    vec4 positionCS = camera_VPMat * positionWS;\n    positionCS.z = max(positionCS.z, -1.0);// clamp to min ndc z\n\n    gl_Position = positionCS;\n\n}\n"; // eslint-disable-line

var skyboxFs = "#define GLSLIFY 1\n#include <common>\nuniform samplerCube material_CubeTexture;\n\nvarying vec3 v_cubeUV;\nuniform float material_Exposure;\nuniform vec4 material_TintColor;\n\nvoid main() {\n    vec4 textureColor = textureCube( material_CubeTexture, v_cubeUV );\n\n    #ifdef MATERIAL_IS_DECODE_SKY_RGBM\n        textureColor = RGBMToLinear(textureColor, 5.0);\n    #elif defined(ENGINE_NO_SRGB)\n        textureColor = sRGBToLinear(textureColor);\n    #endif\n\n    textureColor.rgb *= material_Exposure * material_TintColor.rgb;\n    \n    gl_FragColor = textureColor;\n}\n"; // eslint-disable-line

var skyboxVs = "#define GLSLIFY 1\n#include <common_vert>\n\nuniform mat4 camera_VPMat;\n\nvarying vec3 v_cubeUV;\nuniform float material_Rotation;\n\nvec4 rotateY(vec4 v, float angle) {\n\tconst float deg2rad = 3.1415926 / 180.0;\n\tfloat radian = angle * deg2rad;\n\tfloat sina = sin(radian);\n\tfloat cosa = cos(radian);\n\tmat2 m = mat2(cosa, -sina, sina, cosa);\n\treturn vec4(m * v.xz, v.yw).xzyw;\n}\n\nvoid main() {\n    v_cubeUV = vec3( -POSITION.x, POSITION.yz ); // TextureCube is left-hand,so x need inverse\n    gl_Position = camera_VPMat * rotateY(vec4(POSITION, 1.0), material_Rotation);\n}\n"; // eslint-disable-line

var spriteMaskFs = "#define GLSLIFY 1\nuniform sampler2D renderer_MaskTexture;\nuniform float renderer_MaskAlphaCutoff;\nvarying vec2 v_uv;\n\nvoid main()\n{\n  vec4 color = texture2D(renderer_MaskTexture, v_uv);\n  if (color.a < renderer_MaskAlphaCutoff) {\n    discard;\n  }\n\n  gl_FragColor = color;\n}\n"; // eslint-disable-line

var spriteMaskVs = "#define GLSLIFY 1\nuniform mat4 camera_VPMat;\n\nattribute vec3 POSITION;\nattribute vec2 TEXCOORD_0;\n\nvarying vec2 v_uv;\n\nvoid main()\n{\n  gl_Position = camera_VPMat * vec4(POSITION, 1.0);\n  v_uv = TEXCOORD_0;\n}\n"; // eslint-disable-line

var spriteFs = "#define GLSLIFY 1\n#include <common>\nuniform sampler2D renderer_SpriteTexture;\n\nvarying vec2 v_uv;\nvarying vec4 v_color;\n\nvoid main()\n{\n  vec4 baseColor = texture2DSRGB(renderer_SpriteTexture, v_uv);\n  gl_FragColor = baseColor * v_color;\n}\n"; // eslint-disable-line

var spriteVs = "#define GLSLIFY 1\nuniform mat4 renderer_MVPMat;\n\nattribute vec3 POSITION;\nattribute vec2 TEXCOORD_0;\nattribute vec4 COLOR_0;\n\nvarying vec2 v_uv;\nvarying vec4 v_color;\n\nvoid main()\n{\n  gl_Position = renderer_MVPMat * vec4(POSITION, 1.0);\n\n  v_uv = TEXCOORD_0;\n  v_color = COLOR_0;\n}\n"; // eslint-disable-line

var textFs = "#define GLSLIFY 1\n#include <common>\nuniform sampler2D renderElement_TextTexture;\n\nvarying vec2 v_uv;\nvarying vec4 v_color;\n\nvoid main()\n{\n  vec4 baseColor = texture2DSRGB(renderElement_TextTexture, v_uv);\n  gl_FragColor = baseColor * v_color;\n}\n"; // eslint-disable-line

var textVs = "#define GLSLIFY 1\nuniform mat4 renderer_MVPMat;\n\nattribute vec3 POSITION;\nattribute vec2 TEXCOORD_0;\nattribute vec4 COLOR_0;\n\nvarying vec2 v_uv;\nvarying vec4 v_color;\n\nvoid main()\n{\n  gl_Position = renderer_MVPMat * vec4(POSITION, 1.0);\n\n  v_uv = TEXCOORD_0;\n  v_color = COLOR_0;\n}\n"; // eslint-disable-line

var unlitFs = "#define GLSLIFY 1\n#include <common>\n#include <uv_share>\n#include <FogFragmentDeclaration>\n\nuniform vec4 material_BaseColor;\nuniform float material_AlphaCutoff;\n\n#ifdef MATERIAL_HAS_BASETEXTURE\n    uniform sampler2D material_BaseTexture;\n#endif\n\nvoid main() {\n     vec4 baseColor = material_BaseColor;\n\n    #ifdef MATERIAL_HAS_BASETEXTURE\n        baseColor *= texture2DSRGB(material_BaseTexture, v_uv);\n    #endif\n\n    #ifdef MATERIAL_IS_ALPHA_CUTOFF\n        if( baseColor.a < material_AlphaCutoff ) {\n            discard;\n        }\n    #endif\n\n    gl_FragColor = baseColor;\n\n    #ifndef MATERIAL_IS_TRANSPARENT\n        gl_FragColor.a = 1.0;\n    #endif\n\n    #include <FogFragment>\n}\n"; // eslint-disable-line

var unlitVs = "#define GLSLIFY 1\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\n#include <uv_share>\n#include <FogVertexDeclaration>\n\nvoid main() {\n\n    #include <begin_position_vert>\n    #include <blendShape_vert>\n    #include <skinning_vert>\n    #include <uv_vert>\n    #include <position_vert>\n\n    #include <FogVertex>\n}\n"; // eslint-disable-line

/**
 * Internal shader pool.
 * @internal
 */ var ShaderPool = /*#__PURE__*/ function() {
    function ShaderPool() {}
    ShaderPool.init = function init() {
        var shadowCasterPass = new ShaderPass("ShadowCaster", shadowMapVs, shadowMapFs, {
            pipelineStage: PipelineStage.ShadowCaster
        });
        shadowCasterPass._renderState = new RenderState();
        shadowCasterPass._renderStateDataMap[RenderStateElementKey.RenderQueueType] = BaseMaterial._shadowCasterRenderQueueProp;
        var depthOnlyPass = new ShaderPass("DepthOnly", depthOnlyVs, depthOnlyFs, {
            pipelineStage: PipelineStage.DepthOnly
        });
        var basePasses = [
            shadowCasterPass,
            depthOnlyPass
        ];
        var forwardPassTags = {
            pipelineStage: PipelineStage.Forward
        };
        Shader.create("blinn-phong", [].concat([
            new ShaderPass("Forward", blinnPhongVs, blinnPhongFs, forwardPassTags)
        ], basePasses));
        Shader.create("pbr", [].concat([
            new ShaderPass("Forward", pbrVs, pbrFs, forwardPassTags)
        ], basePasses));
        Shader.create("pbr-specular", [].concat([
            new ShaderPass("Forward", pbrVs, pbrSpecularFs, forwardPassTags)
        ], basePasses));
        Shader.create("unlit", [].concat([
            new ShaderPass("Forward", unlitVs, unlitFs, forwardPassTags)
        ], basePasses));
        Shader.create("blit", [
            new ShaderPass("Forward", blitVs, blitFs, forwardPassTags)
        ]);
        Shader.create("blit-screen", [
            new ShaderPass("Forward", blitVs, blitScreenFs, forwardPassTags)
        ]);
        Shader.create("skybox", [
            new ShaderPass("Forward", skyboxVs, skyboxFs, forwardPassTags)
        ]);
        Shader.create("SkyProcedural", [
            new ShaderPass("Forward", skyProceduralVs, skyProceduralFs, forwardPassTags)
        ]);
        Shader.create("particle-shader", [
            new ShaderPass("Forward", particleVs, particleFs, forwardPassTags)
        ]);
        Shader.create("SpriteMask", [
            new ShaderPass("Forward", spriteMaskVs, spriteMaskFs, forwardPassTags)
        ]);
        Shader.create("Sprite", [
            new ShaderPass("Forward", spriteVs, spriteFs, forwardPassTags)
        ]);
        Shader.create("Text", [
            new ShaderPass("Forward", textVs, textFs, forwardPassTags)
        ]);
        Shader.create("background-texture", [
            new ShaderPass("Forward", backgroundTextureVs, backgroundTextureFs, forwardPassTags)
        ]);
    };
    return ShaderPool;
}();

/**
 * Shader program pool.
 * @internal
 */ var ShaderProgramPool = /*#__PURE__*/ function() {
    function ShaderProgramPool(engine) {
        this.engine = engine;
        this._cacheHierarchyDepth = 1;
        this._cacheMap = Object.create(null);
    }
    var _proto = ShaderProgramPool.prototype;
    /**
   * Get shader program by macro collection.
   * @param macros - macro collection
   * @returns shader program
   */ _proto.get = function get(macros) {
        var cacheMap = this._cacheMap;
        var maskLength = macros._length;
        var cacheHierarchyDepth = this._cacheHierarchyDepth;
        if (maskLength > cacheHierarchyDepth) {
            this._resizeCacheMapHierarchy(cacheMap, 0, cacheHierarchyDepth, maskLength - cacheHierarchyDepth);
            this._cacheHierarchyDepth = maskLength;
        }
        var mask = macros._mask;
        var endIndex = macros._length - 1;
        var maxEndIndex = this._cacheHierarchyDepth - 1;
        for(var i = 0; i < maxEndIndex; i++){
            var subMask = endIndex < i ? 0 : mask[i];
            var subCacheShaders = cacheMap[subMask];
            subCacheShaders || (cacheMap[subMask] = subCacheShaders = Object.create(null));
            cacheMap = subCacheShaders;
        }
        var cacheKey = endIndex < maxEndIndex ? 0 : mask[maxEndIndex];
        var shader = cacheMap[cacheKey];
        if (!shader) {
            this._lastQueryKey = cacheKey;
            this._lastQueryMap = cacheMap;
        }
        return shader;
    };
    /**
   * Cache the shader program.
   *
   * @remarks
   * The method must return an empty value after calling get() to run normally.
   *
   * @param shaderProgram - shader program
   */ _proto.cache = function cache(shaderProgram) {
        this._lastQueryMap[this._lastQueryKey] = shaderProgram;
    };
    /**
   * @internal
   */ _proto._destroy = function _destroy() {
        this._recursiveDestroy(0, this._cacheMap);
        this._cacheMap = Object.create(null);
    };
    _proto._recursiveDestroy = function _recursiveDestroy(hierarchy, cacheMap) {
        if (hierarchy === this._cacheHierarchyDepth - 1) {
            for(var k in cacheMap){
                cacheMap[k].destroy();
            }
            return;
        }
        ++hierarchy;
        for(var k1 in cacheMap){
            this._recursiveDestroy(hierarchy, cacheMap[k1]);
        }
    };
    _proto._resizeCacheMapHierarchy = function _resizeCacheMapHierarchy(cacheMap, hierarchy, currentHierarchy, increaseHierarchy) {
        // Only expand but not shrink
        if (hierarchy == currentHierarchy - 1) {
            for(var k in cacheMap){
                var shader = cacheMap[k];
                var subCacheMap = cacheMap;
                for(var i = 0; i < increaseHierarchy; i++){
                    subCacheMap[i == 0 ? k : 0] = subCacheMap = Object.create(null);
                }
                subCacheMap[0] = shader;
            }
        } else {
            hierarchy++;
            for(var k1 in cacheMap){
                this._resizeCacheMapHierarchy(cacheMap[k1], hierarchy, currentHierarchy, increaseHierarchy);
            }
        }
    };
    return ShaderProgramPool;
}();

var UIUtils = /*#__PURE__*/ function() {
    function UIUtils() {}
    UIUtils.renderOverlay = function renderOverlay(engine, scene, uiCanvases) {
        engine._macroCollection.enable(UIUtils._shouldSRGBCorrect);
        var canvas = engine.canvas; engine._hardwareRenderer; var renderContext = engine._renderContext, batcherManager = engine._batcherManager;
        var uiRenderQueue = this._renderQueue || (this._renderQueue = new RenderQueue(RenderQueueType.Transparent));
        var virtualCamera = this._virtualCamera || (this._virtualCamera = new VirtualCamera());
        var viewport = this._viewport || (this._viewport = new Vector4(0, 0, 1, 1));
        // @ts-ignore
        var camera = this._overlayCamera || (this._overlayCamera = new OverlayCamera());
        camera.engine = engine;
        camera.scene = scene;
        renderContext.camera = camera;
        var _virtualCamera_projectionMatrix = virtualCamera.projectionMatrix, projectE = _virtualCamera_projectionMatrix.elements;
        var _virtualCamera_viewMatrix = virtualCamera.viewMatrix, viewE = _virtualCamera_viewMatrix.elements;
        projectE[0] = 2 / canvas.width, projectE[5] = 2 / canvas.height, projectE[10] = 0;
        renderContext.setRenderTarget(null, viewport, 0);
        for(var i = 0, n = uiCanvases.length; i < n; i++){
            var uiCanvas = uiCanvases.get(i);
            if (uiCanvas) {
                var position = uiCanvas.entity.transform.position;
                viewE[12] = -position.x, viewE[13] = -position.y;
                Matrix.multiply(virtualCamera.projectionMatrix, virtualCamera.viewMatrix, virtualCamera.viewProjectionMatrix);
                renderContext.applyVirtualCamera(virtualCamera, false);
                renderContext.rendererUpdateFlag |= ContextRendererUpdateFlag.ProjectionMatrix;
                uiCanvas._prepareRender(renderContext);
                uiRenderQueue.pushRenderElement(uiCanvas._renderElement);
                uiRenderQueue.batch(batcherManager);
                batcherManager.uploadBuffer();
                uiRenderQueue.render(renderContext, "Forward");
                uiRenderQueue.clear();
                engine._renderCount++;
            }
        }
        renderContext.camera = null;
        engine._macroCollection.disable(UIUtils._shouldSRGBCorrect);
    };
    return UIUtils;
}();
UIUtils._shouldSRGBCorrect = ShaderMacro.getByName("ENGINE_SHOULD_SRGB_CORRECT");
var OverlayCamera = function OverlayCamera() {
    // @ts-ignore
    this.instanceId = ++EngineObject._instanceIdCounter;
    this.shaderData = new ShaderData(ShaderDataGroup.Camera);
    this.enableFrustumCulling = true;
    this.cullingMask = Layer.Everything;
    this._globalShaderMacro = new ShaderMacroCollection();
};

/**
 * XRManager located in the main package, its implementation logic is XRManagerExtended in the sub-package engine-xr.
 */ var XRManager = /*#__PURE__*/ function() {
    function XRManager() {}
    var _proto = XRManager.prototype;
    /**
   * @internal
   */ _proto._initialize = function _initialize(engine, xrDevice) {};
    /**
   * @internal
   */ _proto._update = function _update() {};
    /**
   * @internal
   */ _proto._destroy = function _destroy() {};
    /**
   * @internal
   */ _proto._getRequestAnimationFrame = function _getRequestAnimationFrame() {
        return null;
    };
    /**
   * @internal
   */ _proto._getCancelAnimationFrame = function _getCancelAnimationFrame() {
        return null;
    };
    /**
   * @internal
   */ _proto._getCameraIgnoreClearFlags = function _getCameraIgnoreClearFlags(type) {
        return CameraClearFlags.None;
    };
    return XRManager;
}();

ShaderPool.init();
/**
 * Engine.
 */ var Engine = /*#__PURE__*/ function(EventDispatcher) {
    _inherits$2(Engine, EventDispatcher);
    function Engine(canvas, hardwareRenderer, configuration) {
        var _this;
        _this = EventDispatcher.call(this) || this, /** @internal */ _this._physicsInitialized = false, /* @internal */ _this._lastRenderState = new RenderState(), /* @internal */ _this._renderElementPool = new ClearableObjectPool(RenderElement), /* @internal */ _this._subRenderElementPool = new ClearableObjectPool(SubRenderElement), /* @internal */ _this._textSubRenderElementPool = new ClearableObjectPool(SubRenderElement), /* @internal */ _this._charRenderInfoPool = new ReturnableObjectPool(CharRenderInfo, 50), /* @internal */ _this._renderContext = new RenderContext(), /* @internal */ _this._renderCount = 0, /* @internal */ _this._shaderProgramPools = [], /** @internal */ _this._fontMap = {}, /** @internal */ _this._macroCollection = new ShaderMacroCollection(), /** @internal */ _this._postProcessPassNeedRefresh = false, _this._settings = {}, _this._resourceManager = new ResourceManager(_this), _this._sceneManager = new SceneManager(_this), _this._vSyncCount = 1, _this._targetFrameRate = 60, _this._time = new Time(), _this._isPaused = true, _this._vSyncCounter = 1, _this._targetFrameInterval = 1000 / 60, _this._destroyed = false, _this._frameInProcess = false, _this._waitingDestroy = false, _this._isDeviceLost = false, _this._waitingGC = false, _this._postProcessPasses = new Array(), _this._activePostProcessPasses = new Array(), _this._animate = function() {
            if (_this._vSyncCount) {
                var _this_xrManager;
                var raf = ((_this_xrManager = _this.xrManager) == null ? void 0 : _this_xrManager._getRequestAnimationFrame()) || requestAnimationFrame;
                _this._requestId = raf(_this._animate);
                if (_this._vSyncCounter++ % _this._vSyncCount === 0) {
                    _this.update();
                    _this._vSyncCounter = 1;
                }
            } else {
                _this._timeoutId = window.setTimeout(_this._animate, _this._targetFrameInterval);
                _this.update();
            }
        };
        _this._hardwareRenderer = hardwareRenderer;
        _this._hardwareRenderer.init(canvas, _this._onDeviceLost.bind(_this), _this._onDeviceRestored.bind(_this));
        _this._canvas = canvas;
        _this._textDefaultFont = Font.createFromOS(_this, "Arial");
        _this._textDefaultFont.isGCIgnored = true;
        _this._batcherManager = new BatcherManager(_this);
        _this.inputManager = new InputManager(_this, configuration.input);
        var xrDevice = configuration.xrDevice;
        if (xrDevice) {
            _this.xrManager = new XRManager();
            _this.xrManager._initialize(_this, xrDevice);
        }
        if (!hardwareRenderer.canIUse(GLCapabilityType.depthTexture)) {
            _this._macroCollection.enable(Engine._noDepthTextureMacro);
        } else {
            var depthTexture2D = new Texture2D(_this, 1, 1, TextureFormat.Depth16, false, false);
            depthTexture2D.isGCIgnored = true;
            _this._depthTexture2D = depthTexture2D;
        }
        if (!hardwareRenderer.canIUse(GLCapabilityType.sRGB)) {
            _this._macroCollection.enable(Engine._noSRGBSupportMacro);
        }
        var meshMagentaMaterial = new Material(_this, Shader.find("unlit"));
        meshMagentaMaterial.isGCIgnored = true;
        meshMagentaMaterial.shaderData.setColor("material_BaseColor", new Color(1.0, 0.0, 1.01, 1.0));
        _this._meshMagentaMaterial = meshMagentaMaterial;
        var particleMagentaMaterial = new Material(_this, Shader.find("particle-shader"));
        particleMagentaMaterial.isGCIgnored = true;
        particleMagentaMaterial.shaderData.setColor("material_BaseColor", new Color(1.0, 0.0, 1.01, 1.0));
        _this._particleMagentaMaterial = particleMagentaMaterial;
        _this._basicResources = new BasicResources(_this);
        _this._particleBufferUtils = new ParticleBufferUtils(_this);
        var uberPass = new PostProcessUberPass(_this);
        _this.addPostProcessPass(uberPass);
        return _this;
    }
    var _proto = Engine.prototype;
    /**
   * Create an entity.
   * @param name - The name of the entity
   * @returns Entity
   */ _proto.createEntity = function createEntity(name) {
        return new Entity(this, name);
    };
    /**
   * Pause the engine.
   */ _proto.pause = function pause() {
        var _this_xrManager;
        this._isPaused = true;
        var caf = ((_this_xrManager = this.xrManager) == null ? void 0 : _this_xrManager._getCancelAnimationFrame()) || cancelAnimationFrame;
        caf(this._requestId);
        clearTimeout(this._timeoutId);
    };
    /**
   * Resume the engine.
   */ _proto.resume = function resume() {
        if (!this._isPaused) return;
        this._isPaused = false;
        this.time._reset();
        if (this._vSyncCount) {
            var _this_xrManager;
            var raf = ((_this_xrManager = this.xrManager) == null ? void 0 : _this_xrManager._getRequestAnimationFrame()) || requestAnimationFrame;
            this._requestId = raf(this._animate);
        } else {
            this._timeoutId = window.setTimeout(this._animate, this._targetFrameInterval);
        }
    };
    /**
   * Update the engine loop manually. If you call engine.run(), you generally don't need to call this function.
   */ _proto.update = function update() {
        var _this_xrManager;
        var time = this._time;
        time._update();
        var deltaTime = time.deltaTime;
        this._frameInProcess = true;
        this._subRenderElementPool.clear();
        this._textSubRenderElementPool.clear();
        this._renderElementPool.clear();
        (_this_xrManager = this.xrManager) == null ? void 0 : _this_xrManager._update();
        var _this = this, inputManager = _this.inputManager, physicsInitialized = _this._physicsInitialized;
        inputManager._update();
        this._refreshActivePostProcessPasses();
        var scenes = this._sceneManager._scenes.getLoopArray();
        var sceneCount = scenes.length;
        // Sort cameras and fire script `onStart`
        for(var i = 0; i < sceneCount; i++){
            var scene = scenes[i];
            if (!scene.isActive || scene.destroyed) continue;
            var componentsManager = scene._componentsManager;
            componentsManager.sortCameras();
            componentsManager.callScriptOnStart();
        }
        // Update physics and fire `onPhysicsUpdate`
        if (physicsInitialized) {
            for(var i1 = 0; i1 < sceneCount; i1++){
                var scene1 = scenes[i1];
                if (!scene1.isActive || scene1.destroyed) continue;
                scene1.physics._update(deltaTime);
            }
        }
        // Fire `onPointerXX`
        inputManager._firePointerScript(scenes);
        // Fire `onUpdate`
        for(var i2 = 0; i2 < sceneCount; i2++){
            var scene2 = scenes[i2];
            if (!scene2.isActive || scene2.destroyed) continue;
            scene2._componentsManager.callScriptOnUpdate(deltaTime);
        }
        // Update `Animator` logic
        for(var i3 = 0; i3 < sceneCount; i3++){
            var scene3 = scenes[i3];
            if (!scene3.isActive || scene3.destroyed) continue;
            scene3._componentsManager.callAnimationUpdate(deltaTime);
        }
        // Fire `onLateUpdate`
        for(var i4 = 0; i4 < sceneCount; i4++){
            var scene4 = scenes[i4];
            if (!scene4.isActive || scene4.destroyed) continue;
            scene4._componentsManager.callScriptOnLateUpdate(deltaTime);
        }
        // Render scene and fire `onBeginRender` and `onEndRender`
        if (!this._isDeviceLost) {
            this._render(scenes);
        }
        if (this._waitingDestroy) {
            this._destroy();
        } else {
            // Handling invalid scripts and fire `onDestroy`
            for(var i5 = 0; i5 < sceneCount; i5++){
                var scene5 = scenes[i5];
                if (!scene5.isActive || scene5.destroyed) continue;
                scene5._componentsManager.handlingInvalidScripts();
            }
        }
        if (this._waitingGC) {
            this._gc();
            this._waitingGC = false;
        }
        this._frameInProcess = false;
    };
    /**
   * Execution engine loop.
   */ _proto.run = function run() {
        this.resume();
        this.dispatch("run", this);
    };
    /**
   * Force lose graphic device.
   * @remarks Used to simulate the phenomenon after the real loss of device.
   */ _proto.forceLoseDevice = function forceLoseDevice() {
        this._hardwareRenderer.forceLoseDevice();
    };
    /**
   * Force restore graphic device.
   * @remarks Used to simulate the phenomenon after the real restore of device.
   */ _proto.forceRestoreDevice = function forceRestoreDevice() {
        this._hardwareRenderer.forceRestoreDevice();
    };
    /**
   * Add a post process pass.
   * @param pass - Post process pass to add
   */ _proto.addPostProcessPass = function addPostProcessPass(pass) {
        if (pass.engine !== this) {
            throw "The pass is not belong to this engine.";
        }
        var passes = this._postProcessPasses;
        if (passes.indexOf(pass) === -1) {
            passes.push(pass);
            pass.isActive && (this._postProcessPassNeedRefresh = true);
        }
    };
    /**
   * @internal
   */ _proto._removePostProcessPass = function _removePostProcessPass(pass) {
        var passes = this._postProcessPasses;
        var index = passes.indexOf(pass);
        if (index !== -1) {
            passes.splice(index, 1);
            pass.isActive && (this._postProcessPassNeedRefresh = true);
        }
    };
    /**
   * @internal
   */ _proto._refreshActivePostProcessPasses = function _refreshActivePostProcessPasses() {
        if (this._postProcessPassNeedRefresh) {
            this._postProcessPassNeedRefresh = false;
            var postProcessPasses = this._postProcessPasses;
            var activePostProcesses = this._activePostProcessPasses;
            activePostProcesses.length = 0;
            // Filter
            for(var i = 0, n = postProcessPasses.length; i < n; i++){
                var pass = postProcessPasses[i];
                if (pass.isActive) {
                    activePostProcesses.push(pass);
                }
            }
            // Sort
            if (activePostProcesses.length) {
                activePostProcesses.sort(function(a, b) {
                    return a.event - b.event;
                });
            }
        }
    };
    /**
   * @internal
   */ _proto._getActivePostProcessPasses = function _getActivePostProcessPasses() {
        this._refreshActivePostProcessPasses();
        return this._activePostProcessPasses;
    };
    _proto._destroy = function _destroy() {
        var _this_xrManager;
        this._sceneManager._destroyAllScene();
        this._resourceManager._destroy();
        this.inputManager._destroy();
        this._batcherManager.destroy();
        (_this_xrManager = this.xrManager) == null ? void 0 : _this_xrManager._destroy();
        this.dispatch("shutdown", this);
        // Cancel animation
        this.pause();
        Shader._clear(this);
        this._hardwareRenderer.destroy();
        this.removeAllEventListeners();
        this._waitingDestroy = false;
        this._destroyed = true;
    };
    /**
   * Destroy engine.
   * @remarks If call during frame execution will delay until the end of the frame
   */ _proto.destroy = function destroy() {
        if (this._destroyed) {
            return;
        }
        if (this._frameInProcess) {
            this._waitingDestroy = true;
        } else {
            this._destroy();
        }
    };
    /**
   * @internal
   */ _proto._getShaderProgramPool = function _getShaderProgramPool(shaderPass) {
        var index = shaderPass._shaderPassId;
        var shaderProgramPools = this._shaderProgramPools;
        var pool = shaderProgramPools[index];
        if (!pool) {
            var length = index + 1;
            if (length > shaderProgramPools.length) {
                shaderProgramPools.length = length;
            }
            shaderProgramPools[index] = pool = new ShaderProgramPool(this);
            shaderPass._shaderProgramPools.push(pool);
        }
        return pool;
    };
    /**
   * @internal
   */ _proto._render = function _render(scenes) {
        var _this, _loop = function(i1, n1) {
            var scene = scenes[i1];
            if (!scene.isActive || scene.destroyed) return "continue";
            var componentsManager = scene._componentsManager;
            var cameras = componentsManager._activeCameras;
            if (cameras.length === 0) {
                Logger.debug("No active camera in scene.");
            } else {
                cameras.forEach(function(camera) {
                    componentsManager.callCameraOnBeginRender(camera);
                    var pixelViewport = camera.pixelViewport;
                    // `pixelViewport` width or height is `0` will cause internal render target create error and return can save performance
                    if (pixelViewport.width !== 0 && pixelViewport.height !== 0) {
                        // Update post process manager
                        scene.postProcessManager._update(camera);
                        camera.render();
                    } else {
                        Logger.warn("Camera pixelViewport width or height is 0.");
                    }
                    componentsManager.callCameraOnEndRender(camera);
                    // Temp solution for webgl implement bug
                    if (_this1._hardwareRenderer._options._forceFlush) {
                        _this1._hardwareRenderer.flush();
                    }
                }, function(camera, index) {
                    camera._cameraIndex = index;
                });
            }
            var uiCanvas = componentsManager._overlayCanvases;
            if (uiCanvas.length > 0) {
                componentsManager.sortOverlayUICanvases();
                UIUtils.renderOverlay(_this, scene, uiCanvas);
            }
        };
        var _this1 = this;
        // Update `Renderer` logic and shader data
        var deltaTime = this.time.deltaTime;
        for(var i = 0, n = scenes.length; i < n; i++){
            var scene = scenes[i];
            if (!scene.isActive || scene.destroyed) continue;
            scene._componentsManager.callRendererOnUpdate(deltaTime);
            scene._updateShaderData();
        }
        // Fire script `onBeginRender` and `onEndRender`
        for(var i1 = 0, n1 = scenes.length; i1 < n1; i1++)_this = this, _loop(i1);
    };
    /**
   * @internal
   */ _proto._pendingGC = function _pendingGC() {
        if (this._frameInProcess) {
            this._waitingGC = true;
        } else {
            this._gc();
        }
    };
    /**
   * @internal
   */ _proto._initialize = function _initialize(configuration) {
        var _this = this;
        var shaderLab = configuration.shaderLab, physics = configuration.physics;
        if (shaderLab && !Shader._shaderLab) {
            Shader._shaderLab = shaderLab;
        }
        var initializePromises = new Array();
        if (physics) {
            initializePromises.push(physics.initialize().then(function() {
                if (Engine._nativePhysics) {
                    console.warn("A physics engine has already been configured. All physics operations will now be handled by the newly specified physics engine.");
                }
                Engine._nativePhysics = physics;
                _this._nativePhysicsManager = physics.createPhysicsManager();
                _this._physicsInitialized = true;
                return _this;
            }));
        }
        var loaders = ResourceManager._loaders;
        for(var key in loaders){
            var loader = loaders[key];
            if (loader.initialize) initializePromises.push(loader.initialize(this, configuration));
        }
        initializePromises.push(this._basicResources._initialize());
        return Promise.all(initializePromises).then(function() {
            return _this;
        });
    };
    _proto._onDeviceLost = function _onDeviceLost() {
        this._isDeviceLost = true;
        // Lose graphic resources
        this.resourceManager._lostGraphicResources();
        console.log("Device lost.");
        this.dispatch("devicelost", this);
    };
    _proto._onDeviceRestored = function _onDeviceRestored() {
        var _this = this;
        this._hardwareRenderer.resetState();
        this._lastRenderState = new RenderState();
        // Clear shader pools
        Shader._clear(this);
        this._shaderProgramPools.length = 0;
        var resourceManager = this.resourceManager;
        // Restore graphic resources
        resourceManager._restoreGraphicResources();
        console.log("Graphic resource restored.");
        // Restore resources content
        resourceManager._restoreResourcesContent().then(function() {
            console.log("Graphic resource content restored.\n\n" + "Device restored.");
            _this.dispatch("devicerestored", _this);
            _this._isDeviceLost = false;
        }).catch(function(error) {
            console.error(error);
        });
    };
    _proto._gc = function _gc() {
        this._subRenderElementPool.garbageCollection();
        this._textSubRenderElementPool.garbageCollection();
        this._renderElementPool.garbageCollection();
        this._renderContext.garbageCollection();
    };
    _create_class$2(Engine, [
        {
            key: "settings",
            get: /**
   * Settings of Engine.
   */ function get() {
                return this._settings;
            }
        },
        {
            key: "canvas",
            get: /**
   * The canvas to use for rendering.
   */ function get() {
                return this._canvas;
            }
        },
        {
            key: "resourceManager",
            get: /**
   * The resource manager.
   */ function get() {
                return this._resourceManager;
            }
        },
        {
            key: "sceneManager",
            get: /**
   * The scene manager.
   */ function get() {
                return this._sceneManager;
            }
        },
        {
            key: "time",
            get: /**
   * The time information of the engine.
   */ function get() {
                return this._time;
            }
        },
        {
            key: "isPaused",
            get: /**
   * Whether the engine is paused.
   */ function get() {
                return this._isPaused;
            }
        },
        {
            key: "vSyncCount",
            get: /**
   * The number of vertical synchronization means the number of vertical blanking for one frame.
   * @remarks 0 means that the vertical synchronization is turned off.
   */ function get() {
                return this._vSyncCount;
            },
            set: function set(value) {
                this._vSyncCount = Math.max(0, Math.floor(value));
            }
        },
        {
            key: "targetFrameRate",
            get: /**
   * Set the target frame rate you want to achieve.
   * @remarks
   * It only takes effect when vSyncCount = 0 (ie, vertical synchronization is turned off).
   * The larger the value, the higher the target frame rate, Number.POSITIVE_INFINITY represents the infinite target frame rate.
   */ function get() {
                return this._targetFrameRate;
            },
            set: function set(value) {
                value = Math.max(0.000001, value);
                this._targetFrameRate = value;
                this._targetFrameInterval = 1000 / value;
            }
        },
        {
            key: "postProcessPasses",
            get: /**
   * All post process passes.
   */ function get() {
                return this._postProcessPasses;
            }
        },
        {
            key: "destroyed",
            get: /**
   * Indicates whether the engine is destroyed.
   */ function get() {
                return this._destroyed;
            }
        },
        {
            key: "physicsManager",
            get: /**
   * @deprecated
   * The first scene physics manager.
   */ function get() {
                var _this_sceneManager_scenes_;
                return (_this_sceneManager_scenes_ = this.sceneManager.scenes[0]) == null ? void 0 : _this_sceneManager_scenes_.physics;
            }
        }
    ]);
    return Engine;
}(EventDispatcher);
/** @internal */ Engine._noDepthTextureMacro = ShaderMacro.getByName("ENGINE_NO_DEPTH_TEXTURE");
/** @internal */ Engine._noSRGBSupportMacro = ShaderMacro.getByName("ENGINE_NO_SRGB");
/** @internal */ Engine._outputSRGBCorrectMacro = ShaderMacro.getByName("ENGINE_OUTPUT_SRGB_CORRECT");
/** @internal Conversion of space units to pixel units for 2D. */ Engine._pixelsPerUnit = 100;
/** @internal */ Engine._physicalObjectsMap = {};

/**
 * Canvas.
 */ var Canvas = /*#__PURE__*/ function() {
    function Canvas() {
        /* @internal */ this._sizeUpdateFlagManager = new UpdateFlagManager();
    }
    _create_class$2(Canvas, [
        {
            key: "width",
            get: /**
   * The width of the canvas.
   */ function get() {
                return this._width;
            },
            set: function set(value) {
                if (this._width !== value) {
                    this._width = value;
                    this._onWidthChanged(value);
                    this._sizeUpdateFlagManager.dispatch();
                }
            }
        },
        {
            key: "height",
            get: /**
   *The height of the canvas.
   */ function get() {
                return this._height;
            },
            set: function set(value) {
                if (this._height !== value) {
                    this._height = value;
                    this._onHeightChange(value);
                    this._sizeUpdateFlagManager.dispatch();
                }
            }
        }
    ]);
    return Canvas;
}();

/**
 * The manager of the components.
 */ var ComponentsManager = /*#__PURE__*/ function() {
    function ComponentsManager() {
        /* @internal */ this._cameraNeedSorting = false;
        /** @internal */ this._activeCameras = new DisorderedArray();
        /** @internal */ this._renderers = new DisorderedArray();
        /** @internal */ this._overlayCanvases = new DisorderedArray();
        /* @internal */ this._overlayCanvasesSortingDirty = false;
        /** @internal */ this._canvases = new DisorderedArray();
        // Script
        this._onStartScripts = new DisorderedArray();
        this._onUpdateScripts = new DisorderedArray();
        this._onLateUpdateScripts = new DisorderedArray();
        this._onPhysicsUpdateScripts = new DisorderedArray();
        this._pendingDestroyScripts = [];
        this._disposeDestroyScripts = [];
        // Animation
        this._onUpdateAnimations = new DisorderedArray();
        // Render
        this._onUpdateRenderers = new DisorderedArray();
        // Delay dispose active/inActive Pool
        this._componentsContainerPool = [];
    }
    var _proto = ComponentsManager.prototype;
    _proto.addCamera = function addCamera(camera) {
        camera._cameraIndex = this._activeCameras.length;
        this._activeCameras.add(camera);
        this._cameraNeedSorting = true;
    };
    _proto.removeCamera = function removeCamera(camera) {
        var replaced = this._activeCameras.deleteByIndex(camera._cameraIndex);
        replaced && (replaced._cameraIndex = camera._cameraIndex);
        camera._cameraIndex = -1;
        this._cameraNeedSorting = true;
    };
    _proto.sortCameras = function sortCameras() {
        if (this._cameraNeedSorting) {
            var activeCameras = this._activeCameras;
            activeCameras.sort(function(a, b) {
                return a.priority - b.priority;
            });
            for(var i = 0, n = activeCameras.length; i < n; i++){
                activeCameras.get(i)._cameraIndex = i;
            }
            this._cameraNeedSorting = false;
        }
    };
    _proto.addRenderer = function addRenderer(renderer) {
        renderer._rendererIndex = this._renderers.length;
        this._renderers.add(renderer);
    };
    _proto.removeRenderer = function removeRenderer(renderer) {
        var replaced = this._renderers.deleteByIndex(renderer._rendererIndex);
        replaced && (replaced._rendererIndex = renderer._rendererIndex);
        renderer._rendererIndex = -1;
    };
    _proto.addUICanvas = function addUICanvas(uiCanvas, isOverlay) {
        var canvases;
        if (isOverlay) {
            canvases = this._overlayCanvases;
            this._overlayCanvasesSortingDirty = true;
        } else {
            canvases = this._canvases;
        }
        uiCanvas._canvasIndex = canvases.length;
        canvases.add(uiCanvas);
    };
    _proto.removeUICanvas = function removeUICanvas(uiCanvas, isOverlay) {
        var canvases;
        if (isOverlay) {
            canvases = this._overlayCanvases;
            this._overlayCanvasesSortingDirty = true;
        } else {
            canvases = this._canvases;
        }
        var replaced = canvases.deleteByIndex(uiCanvas._canvasIndex);
        replaced && (replaced._canvasIndex = uiCanvas._canvasIndex);
        uiCanvas._canvasIndex = -1;
    };
    _proto.sortOverlayUICanvases = function sortOverlayUICanvases() {
        if (this._overlayCanvasesSortingDirty) {
            var overlayCanvases = this._overlayCanvases;
            overlayCanvases.sort(function(a, b) {
                return a.sortOrder - b.sortOrder;
            });
            for(var i = 0, n = overlayCanvases.length; i < n; i++){
                overlayCanvases.get(i)._canvasIndex = i;
            }
            this._overlayCanvasesSortingDirty = false;
        }
    };
    _proto.addOnStartScript = function addOnStartScript(script) {
        script._onStartIndex = this._onStartScripts.length;
        this._onStartScripts.add(script);
    };
    _proto.removeOnStartScript = function removeOnStartScript(script) {
        var replaced = this._onStartScripts.deleteByIndex(script._onStartIndex);
        replaced && (replaced._onStartIndex = script._onStartIndex);
        script._onStartIndex = -1;
    };
    _proto.addOnUpdateScript = function addOnUpdateScript(script) {
        script._onUpdateIndex = this._onUpdateScripts.length;
        this._onUpdateScripts.add(script);
    };
    _proto.removeOnUpdateScript = function removeOnUpdateScript(script) {
        var replaced = this._onUpdateScripts.deleteByIndex(script._onUpdateIndex);
        replaced && (replaced._onUpdateIndex = script._onUpdateIndex);
        script._onUpdateIndex = -1;
    };
    _proto.addOnLateUpdateScript = function addOnLateUpdateScript(script) {
        script._onLateUpdateIndex = this._onLateUpdateScripts.length;
        this._onLateUpdateScripts.add(script);
    };
    _proto.removeOnLateUpdateScript = function removeOnLateUpdateScript(script) {
        var replaced = this._onLateUpdateScripts.deleteByIndex(script._onLateUpdateIndex);
        replaced && (replaced._onLateUpdateIndex = script._onLateUpdateIndex);
        script._onLateUpdateIndex = -1;
    };
    _proto.addOnPhysicsUpdateScript = function addOnPhysicsUpdateScript(script) {
        script._onPhysicsUpdateIndex = this._onPhysicsUpdateScripts.length;
        this._onPhysicsUpdateScripts.add(script);
    };
    _proto.removeOnPhysicsUpdateScript = function removeOnPhysicsUpdateScript(script) {
        var replaced = this._onPhysicsUpdateScripts.deleteByIndex(script._onPhysicsUpdateIndex);
        replaced && (replaced._onPhysicsUpdateIndex = script._onPhysicsUpdateIndex);
        script._onPhysicsUpdateIndex = -1;
    };
    _proto.addOnUpdateAnimations = function addOnUpdateAnimations(animation) {
        animation._onUpdateIndex = this._onUpdateAnimations.length;
        this._onUpdateAnimations.add(animation);
    };
    _proto.removeOnUpdateAnimations = function removeOnUpdateAnimations(animation) {
        var replaced = this._onUpdateAnimations.deleteByIndex(animation._onUpdateIndex);
        replaced && (replaced._onUpdateIndex = animation._onUpdateIndex);
        animation._onUpdateIndex = -1;
    };
    _proto.addOnUpdateRenderers = function addOnUpdateRenderers(renderer) {
        renderer._onUpdateIndex = this._onUpdateRenderers.length;
        this._onUpdateRenderers.add(renderer);
    };
    _proto.removeOnUpdateRenderers = function removeOnUpdateRenderers(renderer) {
        var replaced = this._onUpdateRenderers.deleteByIndex(renderer._onUpdateIndex);
        replaced && (replaced._onUpdateIndex = renderer._onUpdateIndex);
        renderer._onUpdateIndex = -1;
    };
    _proto.addPendingDestroyScript = function addPendingDestroyScript(component) {
        this._pendingDestroyScripts.push(component);
    };
    _proto.callScriptOnStart = function callScriptOnStart() {
        var _this = this;
        var onStartScripts = this._onStartScripts;
        if (onStartScripts.length > 0) {
            // The 'onStartScripts.length' maybe add if you add some Script with addComponent() in some Script's onStart()
            onStartScripts.forEachAndClean(function(script) {
                script._started = true;
                _this.removeOnStartScript(script);
                script.onStart();
            }, function(element, index) {
                element._onStartIndex = index;
            });
        }
    };
    _proto.callScriptOnUpdate = function callScriptOnUpdate(deltaTime) {
        this._onUpdateScripts.forEach(function(element) {
            element._started && element.onUpdate(deltaTime);
        }, function(element, index) {
            element._onUpdateIndex = index;
        });
    };
    _proto.callScriptOnLateUpdate = function callScriptOnLateUpdate(deltaTime) {
        this._onLateUpdateScripts.forEach(function(element) {
            element._started && element.onLateUpdate(deltaTime);
        }, function(element, index) {
            element._onLateUpdateIndex = index;
        });
    };
    _proto.callScriptOnPhysicsUpdate = function callScriptOnPhysicsUpdate() {
        this._onPhysicsUpdateScripts.forEach(function(element) {
            element._started && element.onPhysicsUpdate();
        }, function(element, index) {
            element._onPhysicsUpdateIndex = index;
        });
    };
    _proto.callAnimationUpdate = function callAnimationUpdate(deltaTime) {
        this._onUpdateAnimations.forEach(function(element) {
            element.update(deltaTime);
        }, function(element, index) {
            element._onUpdateIndex = index;
        });
    };
    _proto.callRendererOnUpdate = function callRendererOnUpdate(deltaTime) {
        this._onUpdateRenderers.forEach(function(element) {
            element.update(deltaTime);
        }, function(element, index) {
            element._onUpdateIndex = index;
        });
    };
    _proto.handlingInvalidScripts = function handlingInvalidScripts() {
        var _this = this, pendingDestroyScripts = _this._disposeDestroyScripts, disposeDestroyScripts = _this._pendingDestroyScripts;
        this._disposeDestroyScripts = disposeDestroyScripts;
        this._pendingDestroyScripts = pendingDestroyScripts;
        var length = disposeDestroyScripts.length;
        if (length > 0) {
            for(var i = length - 1; i >= 0; i--){
                disposeDestroyScripts[i].onDestroy();
            }
            disposeDestroyScripts.length = 0;
        }
    };
    _proto.callCameraOnBeginRender = function callCameraOnBeginRender(camera) {
        camera.entity._scripts.forEach(function(element) {
            element.onBeginRender(camera);
        }, function(element, index) {
            element._entityScriptsIndex = index;
        });
    };
    _proto.callCameraOnEndRender = function callCameraOnEndRender(camera) {
        camera.entity._scripts.forEach(function(element) {
            element.onEndRender(camera);
        }, function(element, index) {
            element._entityScriptsIndex = index;
        });
    };
    _proto.getActiveChangedTempList = function getActiveChangedTempList() {
        return this._componentsContainerPool.length ? this._componentsContainerPool.pop() : [];
    };
    _proto.putActiveChangedTempList = function putActiveChangedTempList(componentContainer) {
        componentContainer.length = 0;
        this._componentsContainerPool.push(componentContainer);
    };
    /**
   * @internal
   */ _proto._gc = function _gc() {
        this._renderers.garbageCollection();
        this._onStartScripts.garbageCollection();
        this._onUpdateScripts.garbageCollection();
        this._onLateUpdateScripts.garbageCollection();
        this._onPhysicsUpdateScripts.garbageCollection();
        this._onUpdateAnimations.garbageCollection();
        this._onUpdateRenderers.garbageCollection();
        this._activeCameras.garbageCollection();
        this._overlayCanvases.garbageCollection();
        this._canvases.garbageCollection();
    };
    return ComponentsManager;
}();

/**
 * @internal
 */ var MaskManager = /*#__PURE__*/ function() {
    function MaskManager() {
        this.hasStencilWritten = false;
        this._preMaskLayer = SpriteMaskLayer.Nothing;
        this._allSpriteMasks = new DisorderedArray();
    }
    var _proto = MaskManager.prototype;
    _proto.addSpriteMask = function addSpriteMask(mask) {
        mask._maskIndex = this._allSpriteMasks.length;
        this._allSpriteMasks.add(mask);
    };
    _proto.removeSpriteMask = function removeSpriteMask(mask) {
        var replaced = this._allSpriteMasks.deleteByIndex(mask._maskIndex);
        replaced && (replaced._maskIndex = mask._maskIndex);
        mask._maskIndex = -1;
    };
    _proto.drawMask = function drawMask(context, pipelineStageTagValue, maskLayer) {
        var incrementMaskQueue = MaskManager.getMaskIncrementRenderQueue();
        var decrementMaskQueue = MaskManager.getMaskDecrementRenderQueue();
        this._buildMaskRenderElement(maskLayer, incrementMaskQueue, decrementMaskQueue);
        var batcherManager = context.camera.engine._batcherManager;
        incrementMaskQueue.batch(batcherManager);
        batcherManager.uploadBuffer();
        incrementMaskQueue.render(context, pipelineStageTagValue, RenderQueueMaskType.Increment);
        incrementMaskQueue.clear();
        decrementMaskQueue.batch(batcherManager);
        batcherManager.uploadBuffer();
        decrementMaskQueue.render(context, pipelineStageTagValue, RenderQueueMaskType.Decrement);
        decrementMaskQueue.clear();
    };
    _proto.clearMask = function clearMask(context, pipelineStageTagValue) {
        var preMaskLayer = this._preMaskLayer;
        if (preMaskLayer !== SpriteMaskLayer.Nothing) {
            if (this.hasStencilWritten) {
                var decrementMaskQueue = MaskManager.getMaskDecrementRenderQueue();
                var masks = this._allSpriteMasks;
                for(var i = 0, n = masks.length; i < n; i++){
                    var mask = masks.get(i);
                    mask.influenceLayers & preMaskLayer && decrementMaskQueue.pushRenderElement(mask._renderElement);
                }
                var batcherManager = context.camera.engine._batcherManager;
                decrementMaskQueue.batch(batcherManager);
                batcherManager.uploadBuffer();
                decrementMaskQueue.render(context, pipelineStageTagValue, RenderQueueMaskType.Decrement);
                decrementMaskQueue.clear();
            } else {
                var engine = context.camera.engine;
                engine._hardwareRenderer.clearRenderTarget(engine, CameraClearFlags.Stencil, null);
            }
            this._preMaskLayer = SpriteMaskLayer.Nothing;
        }
    };
    _proto.isStencilWritten = function isStencilWritten(material) {
        var stencilState = material.renderState.stencilState;
        var stencilOperation = StencilOperation.Keep;
        if (stencilState.enabled && stencilState.writeMask !== 0x00 && (stencilState.passOperationFront !== stencilOperation || stencilState.passOperationBack !== stencilOperation || stencilState.failOperationFront !== stencilOperation || stencilState.failOperationBack !== stencilOperation || stencilState.zFailOperationFront !== stencilOperation || stencilState.zFailOperationBack !== stencilOperation)) {
            return true;
        }
        return false;
    };
    _proto.isReadStencil = function isReadStencil(material) {
        var _material_renderState_stencilState = material.renderState.stencilState, enabled = _material_renderState_stencilState.enabled, mask = _material_renderState_stencilState.mask, compareFunctionFront = _material_renderState_stencilState.compareFunctionFront, compareFunctionBack = _material_renderState_stencilState.compareFunctionBack;
        if (enabled && mask !== 0x00 && (compareFunctionFront !== CompareFunction.Always && compareFunctionFront !== CompareFunction.Never || compareFunctionBack !== CompareFunction.Always && compareFunctionBack !== CompareFunction.Never)) {
            return true;
        }
        return false;
    };
    _proto.destroy = function destroy() {
        var allSpriteMasks = this._allSpriteMasks;
        allSpriteMasks.length = 0;
        allSpriteMasks.garbageCollection();
    };
    _proto._buildMaskRenderElement = function _buildMaskRenderElement(curMaskLayer, incrementMaskQueue, decrementMaskQueue) {
        var preMaskLayer = this._preMaskLayer;
        if (preMaskLayer !== curMaskLayer) {
            var masks = this._allSpriteMasks;
            var commonLayer = preMaskLayer & curMaskLayer;
            var reduceLayer = preMaskLayer & ~curMaskLayer;
            var maskElements = masks._elements;
            for(var i = 0, n = masks.length; i < n; i++){
                var mask = maskElements[i];
                var influenceLayers = mask.influenceLayers;
                if (influenceLayers & commonLayer) {
                    continue;
                }
                if (influenceLayers & curMaskLayer) {
                    incrementMaskQueue.pushRenderElement(mask._renderElement);
                } else if (influenceLayers & reduceLayer) {
                    decrementMaskQueue.pushRenderElement(mask._renderElement);
                }
            }
            this._preMaskLayer = curMaskLayer;
        }
    };
    MaskManager.getMaskIncrementRenderQueue = function getMaskIncrementRenderQueue() {
        var _MaskManager;
        return (_MaskManager = MaskManager)._maskIncrementRenderQueue || (_MaskManager._maskIncrementRenderQueue = new RenderQueue(RenderQueueType.Transparent));
    };
    MaskManager.getMaskDecrementRenderQueue = function getMaskDecrementRenderQueue() {
        var _MaskManager;
        return (_MaskManager = MaskManager)._maskDecrementRenderQueue || (_MaskManager._maskDecrementRenderQueue = new RenderQueue(RenderQueueType.Transparent));
    };
    return MaskManager;
}();

/**
 * Fog Mode.
 */ var FogMode = /*#__PURE__*/ function(FogMode) {
    /** Disable fog. */ FogMode[FogMode["None"] = 0] = "None";
    /** Linear fog. */ FogMode[FogMode["Linear"] = 1] = "Linear";
    /** Exponential fog. */ FogMode[FogMode["Exponential"] = 2] = "Exponential";
    /** Exponential squared fog. */ FogMode[FogMode["ExponentialSquared"] = 3] = "ExponentialSquared";
    return FogMode;
}({});

/**
 * Diffuse mode.
 */ var DiffuseMode = /*#__PURE__*/ function(DiffuseMode) {
    /** Solid color mode. */ DiffuseMode[DiffuseMode["SolidColor"] = 0] = "SolidColor";
    /**
   * SH mode
   * @remarks
   * Use SH3 to represent irradiance environment maps efficiently, allowing for interactive rendering of diffuse objects under distant illumination.
   */ DiffuseMode[DiffuseMode["SphericalHarmonics"] = 1] = "SphericalHarmonics";
    return DiffuseMode;
}({});

/**
 * Ambient light.
 */ var AmbientLight = /*#__PURE__*/ function(ReferResource) {
    _inherits$2(AmbientLight, ReferResource);
    function AmbientLight(engine) {
        var _this;
        _this = ReferResource.call(this, engine) || this, _this._diffuseSolidColor = new Color(0.03696758874771872, 0.0421494543549785, 0.05455383078270364), _this._diffuseIntensity = 1.0, _this._specularIntensity = 1.0, _this._diffuseMode = DiffuseMode.SolidColor, _this._shArray = new Float32Array(27), _this._scenes = [], _this._specularTextureDecodeRGBM = false;
        return _this;
    }
    var _proto = AmbientLight.prototype;
    /**
   * @internal
   */ _proto._addToScene = function _addToScene(scene) {
        this._addReferCount(1);
        this._scenes.push(scene);
        var shaderData = scene.shaderData;
        shaderData.setColor(AmbientLight._diffuseColorProperty, this._diffuseSolidColor);
        shaderData.setFloat(AmbientLight._diffuseIntensityProperty, this._diffuseIntensity);
        shaderData.setFloat(AmbientLight._specularIntensityProperty, this._specularIntensity);
        shaderData.setFloatArray(AmbientLight._diffuseSHProperty, this._shArray);
        this._setDiffuseMode(shaderData);
        this._setSpecularTextureDecodeRGBM(shaderData);
        this._setSpecularTexture(shaderData);
    };
    /**
   * @internal
   */ _proto._removeFromScene = function _removeFromScene(scene) {
        this._addReferCount(-1);
        var scenes = this._scenes;
        var index = scenes.indexOf(scene);
        scenes.splice(index, 1);
        var shaderData = scene.shaderData;
        shaderData.setTexture(AmbientLight._specularTextureProperty, null);
        shaderData.disableMacro(AmbientLight._specularMacro);
    };
    _proto._setDiffuseMode = function _setDiffuseMode(sceneShaderData) {
        if (this._diffuseMode === DiffuseMode.SphericalHarmonics) {
            sceneShaderData.enableMacro(AmbientLight._shMacro);
        } else {
            sceneShaderData.disableMacro(AmbientLight._shMacro);
        }
    };
    _proto._setSpecularTexture = function _setSpecularTexture(sceneShaderData) {
        if (this._specularTexture) {
            sceneShaderData.setTexture(AmbientLight._specularTextureProperty, this._specularTexture);
            sceneShaderData.setFloat(AmbientLight._mipLevelProperty, this._specularTexture.mipmapCount - 1);
            sceneShaderData.enableMacro(AmbientLight._specularMacro);
        } else {
            sceneShaderData.disableMacro(AmbientLight._specularMacro);
        }
    };
    _proto._setSpecularTextureDecodeRGBM = function _setSpecularTextureDecodeRGBM(sceneShaderData) {
        if (this._specularTextureDecodeRGBM) {
            sceneShaderData.enableMacro(AmbientLight._decodeRGBMMacro);
        } else {
            sceneShaderData.disableMacro(AmbientLight._decodeRGBMMacro);
        }
    };
    _proto._preComputeSH = function _preComputeSH(sh, out) {
        /**
     * Basis constants
     *
     * 0: 1/2 * Math.sqrt(1 / Math.PI)
     *
     * 1: -1/2 * Math.sqrt(3 / Math.PI)
     * 2: 1/2 * Math.sqrt(3 / Math.PI)
     * 3: -1/2 * Math.sqrt(3 / Math.PI)
     *
     * 4: 1/2 * Math.sqrt(15 / Math.PI)
     * 5: -1/2 * Math.sqrt(15 / Math.PI)
     * 6: 1/4 * Math.sqrt(5 / Math.PI)
     * 7: -1/2 * Math.sqrt(15 / Math.PI)
     * 8: 1/4 * Math.sqrt(15 / Math.PI)
     */ /**
     * Convolution kernel
     *
     * 0: Math.PI
     * 1: (2 * Math.PI) / 3
     * 2: Math.PI / 4
     */ var src = sh.coefficients;
        // l0
        out[0] = src[0] * 0.886227; // kernel0 * basis0 = 0.886227
        out[1] = src[1] * 0.886227;
        out[2] = src[2] * 0.886227;
        // l1
        out[3] = src[3] * -1.023327; // kernel1 * basis1 = -1.023327;
        out[4] = src[4] * -1.023327;
        out[5] = src[5] * -1.023327;
        out[6] = src[6] * 1.023327; // kernel1 * basis2 = 1.023327
        out[7] = src[7] * 1.023327;
        out[8] = src[8] * 1.023327;
        out[9] = src[9] * -1.023327; // kernel1 * basis3 = -1.023327
        out[10] = src[10] * -1.023327;
        out[11] = src[11] * -1.023327;
        // l2
        out[12] = src[12] * 0.858086; // kernel2 * basis4 = 0.858086
        out[13] = src[13] * 0.858086;
        out[14] = src[14] * 0.858086;
        out[15] = src[15] * -0.858086; // kernel2 * basis5 = -0.858086
        out[16] = src[16] * -0.858086;
        out[17] = src[17] * -0.858086;
        out[18] = src[18] * 0.247708; // kernel2 * basis6 = 0.247708
        out[19] = src[19] * 0.247708;
        out[20] = src[20] * 0.247708;
        out[21] = src[21] * -0.858086; // kernel2 * basis7 = -0.858086
        out[22] = src[22] * -0.858086;
        out[23] = src[23] * -0.858086;
        out[24] = src[24] * 0.429042; // kernel2 * basis8 = 0.429042
        out[25] = src[25] * 0.429042;
        out[26] = src[26] * 0.429042;
    };
    _create_class$2(AmbientLight, [
        {
            key: "specularTextureDecodeRGBM",
            get: /**
   * Whether to decode from specularTexture with RGBM format.
   */ function get() {
                return this._specularTextureDecodeRGBM;
            },
            set: function set(value) {
                this._specularTextureDecodeRGBM = value;
                var scenes = this._scenes;
                for(var i = 0, n = scenes.length; i < n; i++){
                    this._setSpecularTextureDecodeRGBM(scenes[i].shaderData);
                }
            }
        },
        {
            key: "diffuseMode",
            get: /**
   * Diffuse mode of ambient light.
   */ function get() {
                return this._diffuseMode;
            },
            set: function set(value) {
                this._diffuseMode = value;
                var scenes = this._scenes;
                for(var i = 0, n = scenes.length; i < n; i++){
                    this._setDiffuseMode(scenes[i].shaderData);
                }
            }
        },
        {
            key: "diffuseSolidColor",
            get: /**
   * Diffuse reflection solid color.
   * @remarks Effective when diffuse reflection mode is `DiffuseMode.SolidColor`.
   */ function get() {
                return this._diffuseSolidColor;
            },
            set: function set(value) {
                if (value !== this._diffuseSolidColor) {
                    this._diffuseSolidColor.copyFrom(value);
                }
            }
        },
        {
            key: "diffuseSphericalHarmonics",
            get: /**
   * Diffuse reflection spherical harmonics 3.
   * @remarks Effective when diffuse reflection mode is `DiffuseMode.SphericalHarmonics`.
   */ function get() {
                return this._diffuseSphericalHarmonics;
            },
            set: function set(value) {
                this._diffuseSphericalHarmonics = value;
                if (value) {
                    this._preComputeSH(value, this._shArray);
                    var scenes = this._scenes;
                    for(var i = 0, n = scenes.length; i < n; i++){
                        scenes[i].shaderData.setFloatArray(AmbientLight._diffuseSHProperty, this._shArray);
                    }
                }
            }
        },
        {
            key: "diffuseIntensity",
            get: /**
   * Diffuse reflection intensity.
   */ function get() {
                return this._diffuseIntensity;
            },
            set: function set(value) {
                this._diffuseIntensity = value;
                var scenes = this._scenes;
                for(var i = 0, n = scenes.length; i < n; i++){
                    scenes[i].shaderData.setFloat(AmbientLight._diffuseIntensityProperty, value);
                }
            }
        },
        {
            key: "specularTexture",
            get: /**
   * Specular reflection texture.
   */ function get() {
                return this._specularTexture;
            },
            set: function set(value) {
                this._specularTexture = value;
                var scenes = this._scenes;
                for(var i = 0, n = scenes.length; i < n; i++){
                    this._setSpecularTexture(scenes[i].shaderData);
                }
            }
        },
        {
            key: "specularIntensity",
            get: /**
   * Specular reflection intensity.
   */ function get() {
                return this._specularIntensity;
            },
            set: function set(value) {
                this._specularIntensity = value;
                for(var i = 0, n = this._scenes.length; i < n; i++){
                    this._scenes[i].shaderData.setFloat(AmbientLight._specularIntensityProperty, value);
                }
            }
        }
    ]);
    return AmbientLight;
}(ReferResource);
AmbientLight._shMacro = ShaderMacro.getByName("SCENE_USE_SH");
AmbientLight._specularMacro = ShaderMacro.getByName("SCENE_USE_SPECULAR_ENV");
AmbientLight._decodeRGBMMacro = ShaderMacro.getByName("SCENE_IS_DECODE_ENV_RGBM");
AmbientLight._diffuseColorProperty = ShaderProperty.getByName("scene_EnvMapLight.diffuse");
AmbientLight._diffuseSHProperty = ShaderProperty.getByName("scene_EnvSH");
AmbientLight._diffuseIntensityProperty = ShaderProperty.getByName("scene_EnvMapLight.diffuseIntensity");
AmbientLight._specularTextureProperty = ShaderProperty.getByName("scene_EnvSpecularSampler");
AmbientLight._specularIntensityProperty = ShaderProperty.getByName("scene_EnvMapLight.specularIntensity");
AmbientLight._mipLevelProperty = ShaderProperty.getByName("scene_EnvMapLight.mipMapLevel");

/**
 * Light base class.
 */ var Light = /*#__PURE__*/ function(Component) {
    _inherits$2(Light, Component);
    function Light() {
        var _this;
        _this = Component.apply(this, arguments) || this, /**
   * Culling mask - which layers the light affect.
   * @remarks Support bit manipulation, corresponding to `Layer`.
   */ _this.cullingMask = Layer.Everything, /** How this light casts shadows. */ _this.shadowType = ShadowType.None, /** Shadow bias.*/ _this.shadowBias = 1, /** Shadow mapping normal-based bias. */ _this.shadowNormalBias = 1, /**
   * @deprecated
   * Please use `shadowNearPlaneOffset` instead.
   */ _this.shadowNearPlane = 0.1, /** @internal */ _this._lightIndex = -1, /** @internal */ _this._lightColor = new Color(), _this._shadowStrength = 1.0, _this._color = new Color(1, 1, 1, 1);
        return _this;
    }
    _create_class$2(Light, [
        {
            key: "shadowStrength",
            get: /** Shadow intensity, the larger the value, the clearer and darker the shadow, range [0,1]. */ function get() {
                return this._shadowStrength;
            },
            set: function set(value) {
                this._shadowStrength = MathUtil.clamp(value, 0, 1);
            }
        },
        {
            key: "color",
            get: /**
   * Light Color.
   */ function get() {
                return this._color;
            },
            set: function set(value) {
                if (this._color !== value) {
                    this._color.copyFrom(value);
                }
            }
        },
        {
            key: "viewMatrix",
            get: /**
   * View matrix.
   */ function get() {
                if (!this._viewMat) this._viewMat = new Matrix();
                Matrix.invert(this.entity.transform.worldMatrix, this._viewMat);
                return this._viewMat;
            }
        },
        {
            key: "inverseViewMatrix",
            get: /**
   * Inverse view matrix.
   */ function get() {
                if (!this._inverseViewMat) this._inverseViewMat = new Matrix();
                Matrix.invert(this.viewMatrix, this._inverseViewMat);
                return this._inverseViewMat;
            }
        }
    ]);
    return Light;
}(Component);
__decorate$1([
    ignoreClone
], Light.prototype, "_lightIndex", void 0);

/**
 * Directional light.
 */ var DirectLight = /*#__PURE__*/ function(Light) {
    _inherits$2(DirectLight, Light);
    function DirectLight() {
        var _this;
        _this = Light.apply(this, arguments) || this, /**
   * The offset distance in the opposite direction of light direction when generating shadows.
   * @remarks Increasing this value can avoid the holes in the shadow caused by low polygon models.
   */ _this.shadowNearPlaneOffset = 0.1, _this._reverseDirection = new Vector3();
        return _this;
    }
    var _proto = DirectLight.prototype;
    /**
   * @internal
   */ _proto._appendData = function _appendData(lightIndex, data) {
        var cullingMaskStart = lightIndex * 2;
        var colorStart = lightIndex * 3;
        var directionStart = lightIndex * 3;
        var _this = this, color = _this.color, direction = _this.direction;
        var cullingMask = this.cullingMask;
        data.cullingMask[cullingMaskStart] = cullingMask & 65535;
        data.cullingMask[cullingMaskStart + 1] = cullingMask >>> 16 & 65535;
        data.color[colorStart] = color.r;
        data.color[colorStart + 1] = color.g;
        data.color[colorStart + 2] = color.b;
        data.direction[directionStart] = direction.x;
        data.direction[directionStart + 1] = direction.y;
        data.direction[directionStart + 2] = direction.z;
    };
    /**
   * @internal
   */ _proto._onEnableInScene = function _onEnableInScene() {
        this.scene._lightManager._attachDirectLight(this);
    };
    /**
   * @internal
   */ _proto._onDisableInScene = function _onDisableInScene() {
        this.scene._lightManager._detachDirectLight(this);
    };
    /**
   * @internal
   */ DirectLight._updateShaderData = function _updateShaderData(shaderData, data) {
        shaderData.setIntArray(DirectLight._cullingMaskProperty, data.cullingMask);
        shaderData.setFloatArray(DirectLight._colorProperty, data.color);
        shaderData.setFloatArray(DirectLight._directionProperty, data.direction);
    };
    _create_class$2(DirectLight, [
        {
            key: "direction",
            get: /**
   * Get direction.
   */ function get() {
                return this.entity.transform.worldForward;
            }
        },
        {
            key: "reverseDirection",
            get: /**
   * Get the opposite direction of the directional light direction.
   */ function get() {
                Vector3.scale(this.direction, -1, this._reverseDirection);
                return this._reverseDirection;
            }
        }
    ]);
    return DirectLight;
}(Light);
DirectLight._cullingMaskProperty = ShaderProperty.getByName("scene_DirectLightCullingMask");
DirectLight._colorProperty = ShaderProperty.getByName("scene_DirectLightColor");
DirectLight._directionProperty = ShaderProperty.getByName("scene_DirectLightDirection");

/**
 * Point light.
 */ var PointLight = /*#__PURE__*/ function(Light) {
    _inherits$2(PointLight, Light);
    function PointLight() {
        var _this;
        _this = Light.apply(this, arguments) || this, /** Defines a distance cutoff at which the light's intensity must be considered zero. */ _this.distance = 100;
        return _this;
    }
    var _proto = PointLight.prototype;
    /**
   * @internal
   */ _proto._appendData = function _appendData(lightIndex, data) {
        var cullingMaskStart = lightIndex * 2;
        var colorStart = lightIndex * 3;
        var positionStart = lightIndex * 3;
        var distanceStart = lightIndex;
        var _this = this, color = _this.color, position = _this.position;
        var cullingMask = this.cullingMask;
        data.cullingMask[cullingMaskStart] = cullingMask & 65535;
        data.cullingMask[cullingMaskStart + 1] = cullingMask >>> 16 & 65535;
        data.color[colorStart] = color.r;
        data.color[colorStart + 1] = color.g;
        data.color[colorStart + 2] = color.b;
        data.position[positionStart] = position.x;
        data.position[positionStart + 1] = position.y;
        data.position[positionStart + 2] = position.z;
        data.distance[distanceStart] = this.distance;
    };
    /**
   * @internal
   */ _proto._onEnableInScene = function _onEnableInScene() {
        this.scene._lightManager._attachPointLight(this);
    };
    /**
   * @internal
   */ _proto._onDisableInScene = function _onDisableInScene() {
        this.scene._lightManager._detachPointLight(this);
    };
    /**
   * @internal
   */ PointLight._updateShaderData = function _updateShaderData(shaderData, data) {
        shaderData.setIntArray(PointLight._cullingMaskProperty, data.cullingMask);
        shaderData.setFloatArray(PointLight._colorProperty, data.color);
        shaderData.setFloatArray(PointLight._positionProperty, data.position);
        shaderData.setFloatArray(PointLight._distanceProperty, data.distance);
    };
    _create_class$2(PointLight, [
        {
            key: "position",
            get: /**
   * Get light position.
   */ function get() {
                return this.entity.transform.worldPosition;
            }
        }
    ]);
    return PointLight;
}(Light);
PointLight._cullingMaskProperty = ShaderProperty.getByName("scene_PointLightCullingMask");
PointLight._colorProperty = ShaderProperty.getByName("scene_PointLightColor");
PointLight._positionProperty = ShaderProperty.getByName("scene_PointLightPosition");
PointLight._distanceProperty = ShaderProperty.getByName("scene_PointLightDistance");

/**
 * Spot light.
 */ var SpotLight = /*#__PURE__*/ function(Light) {
    _inherits$2(SpotLight, Light);
    function SpotLight() {
        var _this;
        _this = Light.apply(this, arguments) || this, /** Defines a distance cutoff at which the light's intensity must be considered zero. */ _this.distance = 100, /** Angle, in radians, from centre of spotlight where falloff begins. */ _this.angle = Math.PI / 6, /** Angle, in radians, from falloff begins to ends. */ _this.penumbra = Math.PI / 12, _this._inverseDirection = new Vector3(), _this._projectMatrix = new Matrix();
        return _this;
    }
    var _proto = SpotLight.prototype;
    /**
   * @internal
   */ _proto._appendData = function _appendData(lightIndex, data) {
        var cullingMaskStart = lightIndex * 2;
        var colorStart = lightIndex * 3;
        var positionStart = lightIndex * 3;
        var directionStart = lightIndex * 3;
        var distanceStart = lightIndex;
        var penumbraCosStart = lightIndex;
        var angleCosStart = lightIndex;
        var _this = this, color = _this.color, position = _this.position, direction = _this.direction;
        var cullingMask = this.cullingMask;
        data.cullingMask[cullingMaskStart] = cullingMask & 65535;
        data.cullingMask[cullingMaskStart + 1] = cullingMask >>> 16 & 65535;
        data.color[colorStart] = color.r;
        data.color[colorStart + 1] = color.g;
        data.color[colorStart + 2] = color.b;
        data.position[positionStart] = position.x;
        data.position[positionStart + 1] = position.y;
        data.position[positionStart + 2] = position.z;
        data.direction[directionStart] = direction.x;
        data.direction[directionStart + 1] = direction.y;
        data.direction[directionStart + 2] = direction.z;
        data.distance[distanceStart] = this.distance;
        data.angleCos[angleCosStart] = Math.cos(this.angle);
        data.penumbraCos[penumbraCosStart] = Math.cos(this.angle + this.penumbra);
    };
    /**
   * @internal
   */ _proto._onEnableInScene = function _onEnableInScene() {
        this.scene._lightManager._attachSpotLight(this);
    };
    /**
   * @internal
   */ _proto._onDisableInScene = function _onDisableInScene() {
        this.scene._lightManager._detachSpotLight(this);
    };
    /**
   * @internal
   */ SpotLight._updateShaderData = function _updateShaderData(shaderData, data) {
        shaderData.setIntArray(SpotLight._cullingMaskProperty, data.cullingMask);
        shaderData.setFloatArray(SpotLight._colorProperty, data.color);
        shaderData.setFloatArray(SpotLight._positionProperty, data.position);
        shaderData.setFloatArray(SpotLight._directionProperty, data.direction);
        shaderData.setFloatArray(SpotLight._distanceProperty, data.distance);
        shaderData.setFloatArray(SpotLight._angleCosProperty, data.angleCos);
        shaderData.setFloatArray(SpotLight._penumbraCosProperty, data.penumbraCos);
    };
    _create_class$2(SpotLight, [
        {
            key: "position",
            get: /**
   * Get light position.
   */ function get() {
                return this.entity.transform.worldPosition;
            }
        },
        {
            key: "direction",
            get: /**
   * Get light direction.
   */ function get() {
                return this.entity.transform.worldForward;
            }
        },
        {
            key: "reverseDirection",
            get: /**
   * Get the opposite direction of the spotlight.
   */ function get() {
                Vector3.scale(this.direction, -1, this._inverseDirection);
                return this._inverseDirection;
            }
        }
    ]);
    return SpotLight;
}(Light);
SpotLight._cullingMaskProperty = ShaderProperty.getByName("scene_SpotLightCullingMask");
SpotLight._colorProperty = ShaderProperty.getByName("scene_SpotLightColor");
SpotLight._positionProperty = ShaderProperty.getByName("scene_SpotLightPosition");
SpotLight._directionProperty = ShaderProperty.getByName("scene_SpotLightDirection");
SpotLight._distanceProperty = ShaderProperty.getByName("scene_SpotLightDistance");
SpotLight._angleCosProperty = ShaderProperty.getByName("scene_SpotLightAngleCos");
SpotLight._penumbraCosProperty = ShaderProperty.getByName("scene_SpotLightPenumbraCos");

/**
 * Light manager.
 */ var LightManager = /*#__PURE__*/ function() {
    function LightManager() {
        /** @internal */ this._spotLights = new DisorderedArray();
        /** @internal */ this._pointLights = new DisorderedArray();
        /** @internal */ this._directLights = new DisorderedArray();
        this._directData = {
            cullingMask: new Int32Array(LightManager._maxLight * 2),
            color: new Float32Array(LightManager._maxLight * 3),
            direction: new Float32Array(LightManager._maxLight * 3)
        };
        this._pointData = {
            cullingMask: new Int32Array(LightManager._maxLight * 2),
            color: new Float32Array(LightManager._maxLight * 3),
            position: new Float32Array(LightManager._maxLight * 3),
            distance: new Float32Array(LightManager._maxLight)
        };
        this._spotData = {
            cullingMask: new Int32Array(LightManager._maxLight * 2),
            color: new Float32Array(LightManager._maxLight * 3),
            position: new Float32Array(LightManager._maxLight * 3),
            direction: new Float32Array(LightManager._maxLight * 3),
            distance: new Float32Array(LightManager._maxLight),
            angleCos: new Float32Array(LightManager._maxLight),
            penumbraCos: new Float32Array(LightManager._maxLight)
        };
    }
    var _proto = LightManager.prototype;
    /**
   * @internal
   */ _proto._attachSpotLight = function _attachSpotLight(light) {
        light._lightIndex = this._spotLights.length;
        this._spotLights.add(light);
    };
    /**
   * @internal
   */ _proto._detachSpotLight = function _detachSpotLight(light) {
        var replaced = this._spotLights.deleteByIndex(light._lightIndex);
        replaced && (replaced._lightIndex = light._lightIndex);
        light._lightIndex = -1;
    };
    /**
   * @internal
   */ _proto._attachPointLight = function _attachPointLight(light) {
        light._lightIndex = this._pointLights.length;
        this._pointLights.add(light);
    };
    /**
   * @internal
   */ _proto._detachPointLight = function _detachPointLight(light) {
        var replaced = this._pointLights.deleteByIndex(light._lightIndex);
        replaced && (replaced._lightIndex = light._lightIndex);
        light._lightIndex = -1;
    };
    /**
   * @internal
   */ _proto._attachDirectLight = function _attachDirectLight(light) {
        light._lightIndex = this._directLights.length;
        this._directLights.add(light);
    };
    /**
   * @internal
   */ _proto._detachDirectLight = function _detachDirectLight(light) {
        var replaced = this._directLights.deleteByIndex(light._lightIndex);
        replaced && (replaced._lightIndex = light._lightIndex);
        light._lightIndex = -1;
    };
    /**
   * @internal
   */ _proto._updateShaderData = function _updateShaderData(shaderData) {
        var _this = this, spotLight = _this._spotLights, pointLight = _this._pointLights, directLight = _this._directLights;
        var _this1 = this, spotData = _this1._spotData, pointData = _this1._pointData, directData = _this1._directData;
        var maxLight = LightManager._maxLight;
        var spotLightCount = Math.min(spotLight.length, maxLight);
        var pointLightCount = Math.min(pointLight.length, maxLight);
        var directLightCount = Math.min(directLight.length, maxLight);
        for(var i = 0; i < spotLightCount; i++){
            spotLight.get(i)._appendData(i, spotData);
        }
        for(var i1 = 0; i1 < pointLightCount; i1++){
            pointLight.get(i1)._appendData(i1, pointData);
        }
        for(var i2 = 0; i2 < directLightCount; i2++){
            directLight.get(i2)._appendData(i2, directData);
        }
        if (directLightCount) {
            DirectLight._updateShaderData(shaderData, directData);
            shaderData.enableMacro("SCENE_DIRECT_LIGHT_COUNT", directLightCount.toString());
        } else {
            shaderData.disableMacro("SCENE_DIRECT_LIGHT_COUNT");
        }
        if (pointLightCount) {
            PointLight._updateShaderData(shaderData, pointData);
            shaderData.enableMacro("SCENE_POINT_LIGHT_COUNT", pointLightCount.toString());
        } else {
            shaderData.disableMacro("SCENE_POINT_LIGHT_COUNT");
        }
        if (spotLightCount) {
            SpotLight._updateShaderData(shaderData, spotData);
            shaderData.enableMacro("SCENE_SPOT_LIGHT_COUNT", spotLightCount.toString());
        } else {
            shaderData.disableMacro("SCENE_SPOT_LIGHT_COUNT");
        }
    };
    /**
   * @internal
   */ _proto._gc = function _gc() {
        this._spotLights.garbageCollection();
        this._pointLights.garbageCollection();
        this._directLights.garbageCollection();
    };
    /**
   * @internal
   */ _proto._updateSunlightIndex = function _updateSunlightIndex(light) {
        var directLights = this._directLights;
        var index = light._lightIndex;
        // -1 means no sun light, 0 means the first direct light already is sun light
        if (index > 0) {
            var firstLight = directLights.get(0);
            var sunlight = directLights.get(index);
            directLights.set(0, sunlight);
            directLights.set(index, firstLight);
            sunlight._lightIndex = 0;
            firstLight._lightIndex = index;
        }
    };
    /**
   * @internal
   */ _proto._getMaxBrightestSunlight = function _getMaxBrightestSunlight() {
        var directLights = this._directLights;
        var sunlight = null;
        var maxIntensity = Number.NEGATIVE_INFINITY;
        var hasShadowLight = false;
        for(var i = 0, n = directLights.length; i < n; i++){
            var currentLight = directLights.get(i);
            if (currentLight.shadowType !== ShadowType.None && !hasShadowLight) {
                maxIntensity = Number.NEGATIVE_INFINITY;
                hasShadowLight = true;
            }
            var brightness = currentLight.color.getBrightness();
            if (hasShadowLight) {
                if (currentLight.shadowType !== ShadowType.None && maxIntensity < brightness) {
                    maxIntensity = brightness;
                    sunlight = currentLight;
                }
            } else {
                if (maxIntensity < brightness) {
                    maxIntensity = brightness;
                    sunlight = currentLight;
                }
            }
        }
        return sunlight;
    };
    return LightManager;
}();
/** @internal */ LightManager._sunlightColorProperty = ShaderProperty.getByName("scene_SunlightColor");
/** @internal */ LightManager._sunlightDirectionProperty = ShaderProperty.getByName("scene_SunlightDirection");
/**
   * Each type of light source is at most 10, beyond which it will not take effect.
   * */ LightManager._maxLight = 10;

/**
 * Scene.
 */ var Scene = /*#__PURE__*/ function(EngineObject) {
    _inherits$2(Scene, EngineObject);
    function Scene(engine, name) {
        var _this;
        _this = EngineObject.call(this, engine) || this, /** Physics. */ _this.physics = new PhysicsScene(_this), /** If cast shadows. */ _this.castShadows = true, /** The resolution of the shadow maps. */ _this.shadowResolution = ShadowResolution.Medium, /** The splits of two cascade distribution. */ _this.shadowTwoCascadeSplits = 1.0 / 3.0, /** The splits of four cascade distribution. */ _this.shadowFourCascadeSplits = new Vector3(1.0 / 15, 3.0 / 15.0, 7.0 / 15.0), /** Max Shadow distance. */ _this.shadowDistance = 50, /**
   * Last shadow fade distance in percentage, range [0,1].
   * @remarks Value 0 is used for no shadow fade.
   */ _this.shadowFadeBorder = 0.1, /** Post process manager. */ _this.postProcessManager = new PostProcessManager(_this), /* @internal */ _this._lightManager = new LightManager(), /* @internal */ _this._componentsManager = new ComponentsManager(), /** @internal */ _this._maskManager = new MaskManager(), /** @internal */ _this._isActiveInEngine = false, /** @internal */ _this._rootEntities = [], _this._background = new Background(_this._engine), _this._shaderData = new ShaderData(ShaderDataGroup.Scene), _this._shadowCascades = ShadowCascadesMode.NoCascades, _this._fogMode = FogMode.None, _this._fogColor = new Color(0.21404114048223255, 0.21404114048223255, 0.21404114048223255, 1.0), _this._fogStart = 0, _this._fogEnd = 300, _this._fogDensity = 0.01, _this._fogParams = new Vector4(), _this._isActive = true, _this._enableTransparentShadow = false;
        _this.name = name || "";
        var shaderData = _this.shaderData;
        shaderData._addReferCount(1);
        _this.ambientLight = new AmbientLight(engine);
        engine.sceneManager._allCreatedScenes.push(_this);
        shaderData.enableMacro("SCENE_FOG_MODE", _this._fogMode.toString());
        shaderData.enableMacro("SCENE_SHADOW_CASCADED_COUNT", _this.shadowCascades.toString());
        shaderData.setColor(Scene._fogColorProperty, _this._fogColor);
        shaderData.setVector4(Scene._fogParamsProperty, _this._fogParams);
        shaderData.setTexture(Scene._prefilterdDFGProperty, engine._basicResources.prefilteredDFGTexture);
        _this._computeLinearFogParams(_this._fogStart, _this._fogEnd);
        _this._computeExponentialFogParams(_this._fogDensity);
        return _this;
    }
    var _proto = Scene.prototype;
    /**
   * Create root entity.
   * @param name - Entity name
   * @returns Entity
   */ _proto.createRootEntity = function createRootEntity(name) {
        var entity = new Entity(this._engine, name);
        this.addRootEntity(entity);
        return entity;
    };
    _proto.addRootEntity = function addRootEntity(indexOrChild, entity) {
        var index;
        if (typeof indexOrChild === "number") {
            index = indexOrChild;
        } else {
            index = undefined;
            entity = indexOrChild;
        }
        var isRoot = entity._isRoot;
        // Let entity become root
        if (!isRoot) {
            entity._isRoot = true;
            entity._removeFromParent();
            entity._setParentChange();
        }
        // Add or remove from scene's rootEntities
        var oldScene = entity._scene;
        if (oldScene !== this) {
            if (oldScene && isRoot) {
                Entity._removeFromChildren(oldScene._rootEntities, entity);
            }
            Entity._addToChildren(this._rootEntities, entity, index);
        } else if (!isRoot) {
            Entity._addToChildren(this._rootEntities, entity, index);
        }
        // Process entity active/inActive
        var inActiveChangeFlag = ActiveChangeFlag.None;
        if (entity._isActiveInHierarchy) {
            this._isActiveInEngine || (inActiveChangeFlag |= ActiveChangeFlag.Hierarchy);
        }
        // Cross scene should inActive first and then active
        entity._isActiveInScene && oldScene !== this && (inActiveChangeFlag |= ActiveChangeFlag.Scene);
        inActiveChangeFlag && entity._processInActive(inActiveChangeFlag);
        if (oldScene !== this) {
            Entity._traverseSetOwnerScene(entity, this);
        }
        var activeChangeFlag = ActiveChangeFlag.None;
        if (entity._isActive) {
            if (this._isActiveInEngine) {
                !entity._isActiveInHierarchy && (activeChangeFlag |= ActiveChangeFlag.Hierarchy);
            }
            (!entity._isActiveInScene || oldScene !== this) && (activeChangeFlag |= ActiveChangeFlag.Scene);
        }
        activeChangeFlag && entity._processActive(activeChangeFlag);
    };
    /**
   * Remove an entity.
   * @param entity - The root entity to remove
   */ _proto.removeRootEntity = function removeRootEntity(entity) {
        if (entity._isRoot && entity._scene == this) {
            Entity._removeFromChildren(this._rootEntities, entity);
            entity._isRoot = false;
            var inActiveChangeFlag = ActiveChangeFlag.None;
            this._isActiveInEngine && entity._isActiveInHierarchy && (inActiveChangeFlag |= ActiveChangeFlag.Hierarchy);
            entity._isActiveInScene && (inActiveChangeFlag |= ActiveChangeFlag.Scene);
            inActiveChangeFlag && entity._processInActive(inActiveChangeFlag);
            Entity._traverseSetOwnerScene(entity, null);
        }
    };
    /**
   * Get root entity from index.
   * @param index - Index
   * @returns Entity
   */ _proto.getRootEntity = function getRootEntity(index) {
        if (index === void 0) index = 0;
        return this._rootEntities[index];
    };
    /**
   * Find entity globally by name.
   * @param name - Entity name
   * @returns Entity
   */ _proto.findEntityByName = function findEntityByName(name) {
        var rootEntities = this._rootEntities;
        for(var i = 0, n = rootEntities.length; i < n; i++){
            var entity = rootEntities[i].findByName(name);
            if (entity) {
                return entity;
            }
        }
        return null;
    };
    /**
   * Find entity globally by name,use ‘/’ symbol as a path separator.
   * @param path - Entity's path
   * @returns Entity
   */ _proto.findEntityByPath = function findEntityByPath(path) {
        var splits = path.split("/").filter(Boolean);
        if (!splits.length) {
            return null;
        }
        var searchRootName = splits.shift();
        for(var i = 0, n = this.rootEntitiesCount; i < n; i++){
            var findEntity = this.getRootEntity(i);
            if (findEntity.name !== searchRootName) {
                continue;
            }
            if (splits.length) {
                findEntity = Entity._findChildByName(findEntity, 0, splits, 0);
                if (!findEntity) {
                    continue;
                }
            }
            return findEntity;
        }
        return null;
    };
    /**
   * @internal
   */ _proto._processActive = function _processActive(active) {
        this._isActiveInEngine = active;
        var rootEntities = this._rootEntities;
        for(var i = rootEntities.length - 1; i >= 0; i--){
            var entity = rootEntities[i];
            if (entity._isActive) {
                if (active) {
                    entity._processActive(ActiveChangeFlag.Hierarchy);
                } else {
                    entity._processInActive(ActiveChangeFlag.Hierarchy);
                }
            }
        }
    };
    /**
   * @internal
   */ _proto._updateShaderData = function _updateShaderData() {
        var shaderData = this.shaderData;
        var engine = this._engine;
        var lightManager = this._lightManager;
        engine.time._updateSceneShaderData(shaderData);
        lightManager._updateShaderData(this.shaderData);
        var sunlight = this._lightManager._sunlight = this._getSunlight();
        if (sunlight) {
            lightManager._updateSunlightIndex(sunlight);
            shaderData.setColor(LightManager._sunlightColorProperty, sunlight._lightColor);
            shaderData.setVector3(LightManager._sunlightDirectionProperty, sunlight.direction);
        } else {
            // @ts-ignore
            shaderData.setVector3(LightManager._sunlightDirectionProperty, Vector3._zero);
        }
        if (this.castShadows && sunlight && sunlight.shadowType !== ShadowType.None) {
            shaderData.enableMacro("SCENE_SHADOW_TYPE", sunlight.shadowType.toString());
        } else {
            shaderData.disableMacro("SCENE_SHADOW_TYPE");
        }
    };
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        EngineObject.prototype._onDestroy.call(this);
        // Remove from sceneManager
        var sceneManager = this._engine.sceneManager;
        sceneManager.removeScene(this);
        while(this.rootEntitiesCount > 0){
            this._rootEntities[0].destroy();
        }
        this.background.destroy();
        this._ambientLight && this._ambientLight._removeFromScene(this);
        this.shaderData._addReferCount(-1);
        this._componentsManager.handlingInvalidScripts();
        this._maskManager.destroy();
        var allCreatedScenes = sceneManager._allCreatedScenes;
        allCreatedScenes.splice(allCreatedScenes.indexOf(this), 1);
        this.physics._destroy();
    };
    _proto._computeLinearFogParams = function _computeLinearFogParams(fogStart, fogEnd) {
        var fogRange = fogEnd - fogStart;
        var fogParams = this._fogParams;
        fogParams.x = -1 / fogRange;
        fogParams.y = fogEnd / fogRange;
    };
    _proto._computeExponentialFogParams = function _computeExponentialFogParams(density) {
        this._fogParams.z = density / Math.LN2;
        this._fogParams.w = density / Math.sqrt(Math.LN2);
    };
    _proto._getSunlight = function _getSunlight() {
        var sunlight = null;
        if (this._sun) {
            sunlight = this._sun.enabled ? this._sun : null;
        } else {
            sunlight = this._lightManager._getMaxBrightestSunlight();
        }
        return sunlight;
    };
    _create_class$2(Scene, [
        {
            key: "isActive",
            get: /**
   * Whether the scene is active.
   */ function get() {
                return this._isActive;
            },
            set: function set(value) {
                if (this._isActive !== value) {
                    this._isActive = value;
                    if (value) {
                        this._sceneManager && this._processActive(true);
                    } else {
                        this._sceneManager && this._processActive(false);
                    }
                }
            }
        },
        {
            key: "shaderData",
            get: /**
   * Scene-related shader data.
   */ function get() {
                return this._shaderData;
            }
        },
        {
            key: "background",
            get: /**
   * The background of the scene.
   */ function get() {
                return this._background;
            }
        },
        {
            key: "shadowCascades",
            get: /**
   *  Number of cascades to use for directional light shadows.
   */ function get() {
                return this._shadowCascades;
            },
            set: function set(value) {
                if (this._shadowCascades !== value) {
                    this.shaderData.enableMacro("SCENE_SHADOW_CASCADED_COUNT", value.toString());
                    this._shadowCascades = value;
                }
            }
        },
        {
            key: "ambientLight",
            get: /**
   * Ambient light.
   */ function get() {
                return this._ambientLight;
            },
            set: function set(value) {
                if (!value) {
                    Logger.warn("The scene must have one ambient light");
                    return;
                }
                var lastAmbientLight = this._ambientLight;
                if (lastAmbientLight !== value) {
                    lastAmbientLight && lastAmbientLight._removeFromScene(this);
                    value._addToScene(this);
                    this._ambientLight = value;
                }
            }
        },
        {
            key: "fogMode",
            get: /**
   * Fog mode.
   * @remarks
   * If set to `FogMode.None`, the fog will be disabled.
   * If set to `FogMode.Linear`, the fog will be linear and controlled by `fogStart` and `fogEnd`.
   * If set to `FogMode.Exponential`, the fog will be exponential and controlled by `fogDensity`.
   * If set to `FogMode.ExponentialSquared`, the fog will be exponential squared and controlled by `fogDensity`.
   */ function get() {
                return this._fogMode;
            },
            set: function set(value) {
                if (this._fogMode !== value) {
                    this.shaderData.enableMacro("SCENE_FOG_MODE", value.toString());
                    this._fogMode = value;
                }
            }
        },
        {
            key: "fogColor",
            get: /**
   * Fog color.
   */ function get() {
                return this._fogColor;
            },
            set: function set(value) {
                if (this._fogColor !== value) {
                    this._fogColor.copyFrom(value);
                }
            }
        },
        {
            key: "fogStart",
            get: /**
   * Fog start.
   */ function get() {
                return this._fogStart;
            },
            set: function set(value) {
                if (this._fogStart !== value) {
                    this._computeLinearFogParams(value, this._fogEnd);
                    this._fogStart = value;
                }
            }
        },
        {
            key: "fogEnd",
            get: /**
   * Fog end.
   */ function get() {
                return this._fogEnd;
            },
            set: function set(value) {
                if (this._fogEnd !== value) {
                    this._computeLinearFogParams(this._fogStart, value);
                    this._fogEnd = value;
                }
            }
        },
        {
            key: "fogDensity",
            get: /**
   * Fog density.
   */ function get() {
                return this._fogDensity;
            },
            set: function set(value) {
                if (this._fogDensity !== value) {
                    this._computeExponentialFogParams(value);
                    this._fogDensity = value;
                }
            }
        },
        {
            key: "rootEntitiesCount",
            get: /**
   * Count of root entities.
   */ function get() {
                return this._rootEntities.length;
            }
        },
        {
            key: "rootEntities",
            get: /**
   * Root entity collection.
   */ function get() {
                return this._rootEntities;
            }
        },
        {
            key: "sun",
            get: /**
   * Sun light source.
   * @remarks If set this to null, scene will use the brightest directional light.
   */ function get() {
                return this._sun;
            },
            set: function set(light) {
                this._sun = light;
            }
        },
        {
            key: "enableTransparentShadow",
            get: /**
   * Whether to enable transparent shadow.
   */ function get() {
                return this._enableTransparentShadow;
            },
            set: function set(value) {
                if (value !== this._enableTransparentShadow) {
                    this._enableTransparentShadow = value;
                    if (value) {
                        this.shaderData.enableMacro("SCENE_ENABLE_TRANSPARENT_SHADOW");
                    } else {
                        this.shaderData.disableMacro("SCENE_ENABLE_TRANSPARENT_SHADOW");
                    }
                }
            }
        }
    ]);
    return Scene;
}(EngineObject);
Scene._fogColorProperty = ShaderProperty.getByName("scene_FogColor");
Scene._fogParamsProperty = ShaderProperty.getByName("scene_FogParams");
Scene._prefilterdDFGProperty = ShaderProperty.getByName("scene_PrefilteredDFG");

/**
 * Script class, used for logic writing.
 */ var Script = /*#__PURE__*/ function(Component) {
    _inherits$2(Script, Component);
    function Script() {
        var _this;
        _this = Component.apply(this, arguments) || this, /** @internal */ _this._started = false, /** @internal */ _this._onStartIndex = -1, /** @internal */ _this._onUpdateIndex = -1, /** @internal */ _this._onLateUpdateIndex = -1, /** @internal */ _this._onPhysicsUpdateIndex = -1, /** @internal */ _this._onPreRenderIndex = -1, /** @internal */ _this._onPostRenderIndex = -1, /** @internal */ _this._entityScriptsIndex = -1;
        return _this;
    }
    var _proto = Script.prototype;
    /**
   * Called when be enabled first time, only once.
   */ _proto.onAwake = function onAwake() {};
    /**
   * Called when be enabled.
   */ _proto.onEnable = function onEnable() {};
    /**
   * Called before the frame-level loop start for the first time, only once.
   */ _proto.onStart = function onStart() {};
    /**
   * The main loop, called frame by frame.
   * @param deltaTime - The delta time since last frame in seconds
   */ _proto.onUpdate = function onUpdate(deltaTime) {};
    /**
   * Called after the onUpdate finished, called frame by frame.
   * @param deltaTime - The delta time since last frame in seconds
   */ _proto.onLateUpdate = function onLateUpdate(deltaTime) {};
    /**
   * Called before camera rendering, called per camera.
   * @param camera - Current camera.
   */ _proto.onBeginRender = function onBeginRender(camera) {};
    /**
   * Called after camera rendering, called per camera.
   * @param camera - Current camera.
   */ _proto.onEndRender = function onEndRender(camera) {};
    /**
   * Called before physics calculations, the number of times is related to the physical update frequency.
   */ _proto.onPhysicsUpdate = function onPhysicsUpdate() {};
    /**
   * Called when the trigger enter.
   * @param other - ColliderShape
   */ _proto.onTriggerEnter = function onTriggerEnter(other) {};
    /**
   * Called when the trigger exit.
   * @param other - ColliderShape
   */ _proto.onTriggerExit = function onTriggerExit(other) {};
    /**
   * Called when the trigger stay.
   * @remarks onTriggerStay is called every frame while the trigger stay.
   * @param other - ColliderShape
   */ _proto.onTriggerStay = function onTriggerStay(other) {};
    /**
   * Called when the collision enter.
   * @param other - The Collision data associated with this collision event
   * @remarks The Collision data will be invalid after this call, you should copy the data if needed.
   */ _proto.onCollisionEnter = function onCollisionEnter(other) {};
    /**
   * Called when the collision exit.
   * @param other - The Collision data associated with this collision event
   * @remarks The Collision data will be invalid after this call, you should copy the data if needed.
   */ _proto.onCollisionExit = function onCollisionExit(other) {};
    /**
   * Called when the collision stay.
   * @param other - The Collision data associated with this collision event
   * @remarks The Collision data will be invalid after this call, you should copy the data if needed.
   */ _proto.onCollisionStay = function onCollisionStay(other) {};
    /**
   * Called when the pointer is down while over the ColliderShape.
   * @param eventData - The pointer event data that triggered this callback
   */ _proto.onPointerDown = function onPointerDown(eventData) {};
    /**
   * Called when the pointer is up while over the ColliderShape.
   * @param eventData - The pointer event data that triggered this callback
   */ _proto.onPointerUp = function onPointerUp(eventData) {};
    /**
   * Called when the pointer is down and up with the same collider.
   * @param eventData - The pointer event data that triggered this callback
   */ _proto.onPointerClick = function onPointerClick(eventData) {};
    /**
   *  Called when the pointer enters the ColliderShape.
   * @param eventData - The pointer event data that triggered this callback
   */ _proto.onPointerEnter = function onPointerEnter(eventData) {};
    /**
   * Called when the pointer exits the ColliderShape.
   * @param eventData - The pointer event data that triggered this callback
   */ _proto.onPointerExit = function onPointerExit(eventData) {};
    /**
   * This function will be called when the pointer is pressed on the collider.
   * @param eventData - The pointer event data that triggered this callback
   */ _proto.onPointerBeginDrag = function onPointerBeginDrag(eventData) {};
    /**
   *  When a drag collision occurs on the pointer, this function will be called every time it moves.
   * @param eventData - The pointer event data that triggered this callback
   */ _proto.onPointerDrag = function onPointerDrag(eventData) {};
    /**
   *  When dragging ends, this function will be called (Dragged object).
   * @param eventData - The pointer event data that triggered this callback
   */ _proto.onPointerEndDrag = function onPointerEndDrag(eventData) {};
    /**
   *  When dragging ends, this function will be called (Receiving object).
   * @param eventData - The pointer event data that triggered this callback
   */ _proto.onPointerDrop = function onPointerDrop(eventData) {};
    /**
   * Called when be disabled.
   */ _proto.onDisable = function onDisable() {};
    /**
   * Called at the end of the destroyed frame.
   */ _proto.onDestroy = function onDestroy() {};
    /**
   * @internal
   */ _proto._onAwake = function _onAwake() {
        this.onAwake();
    };
    /**
   * @internal
   */ _proto._onEnable = function _onEnable() {
        this.onEnable();
    };
    /**
   * @internal
   */ _proto._onDisable = function _onDisable() {
        this.onDisable();
    };
    /**
   * @internal
   */ _proto._onEnableInScene = function _onEnableInScene() {
        var _this_scene = this.scene, componentsManager = _this_scene._componentsManager;
        var prototype = Script.prototype;
        if (!this._started) {
            componentsManager.addOnStartScript(this);
        }
        if (this.onUpdate !== prototype.onUpdate) {
            componentsManager.addOnUpdateScript(this);
        }
        if (this.onLateUpdate !== prototype.onLateUpdate) {
            componentsManager.addOnLateUpdateScript(this);
        }
        if (this.onPhysicsUpdate !== prototype.onPhysicsUpdate) {
            componentsManager.addOnPhysicsUpdateScript(this);
        }
        for(var _iterator = _create_for_of_iterator_helper_loose$1(Object.values(PointerMethods)), _step; !(_step = _iterator()).done;){
            var pointerMethod = _step.value;
            if (this[pointerMethod] === prototype[pointerMethod]) {
                this[pointerMethod] = null;
            }
        }
        this._entity._addScript(this);
    };
    /**
   * @internal
   */ _proto._onDisableInScene = function _onDisableInScene() {
        var componentsManager = this.scene._componentsManager;
        var prototype = Script.prototype;
        if (!this._started) {
            componentsManager.removeOnStartScript(this);
        }
        if (this.onUpdate !== prototype.onUpdate) {
            componentsManager.removeOnUpdateScript(this);
        }
        if (this.onLateUpdate !== prototype.onLateUpdate) {
            componentsManager.removeOnLateUpdateScript(this);
        }
        if (this.onPhysicsUpdate !== prototype.onPhysicsUpdate) {
            componentsManager.removeOnPhysicsUpdateScript(this);
        }
        this._entity._removeScript(this);
    };
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        Component.prototype._onDestroy.call(this);
        if (this.scene) {
            this.scene._componentsManager.addPendingDestroyScript(this);
        } else {
            this.onDestroy();
        }
    };
    return Script;
}(Component);
__decorate$1([
    ignoreClone
], Script.prototype, "_started", void 0);
__decorate$1([
    ignoreClone
], Script.prototype, "_onStartIndex", void 0);
__decorate$1([
    ignoreClone
], Script.prototype, "_onUpdateIndex", void 0);
__decorate$1([
    ignoreClone
], Script.prototype, "_onLateUpdateIndex", void 0);
__decorate$1([
    ignoreClone
], Script.prototype, "_onPhysicsUpdateIndex", void 0);
__decorate$1([
    ignoreClone
], Script.prototype, "_onPreRenderIndex", void 0);
__decorate$1([
    ignoreClone
], Script.prototype, "_onPostRenderIndex", void 0);
__decorate$1([
    ignoreClone
], Script.prototype, "_entityScriptsIndex", void 0);
var PointerMethods = /*#__PURE__*/ function(PointerMethods) {
    PointerMethods["onPointerDown"] = "onPointerDown";
    PointerMethods["onPointerUp"] = "onPointerUp";
    PointerMethods["onPointerClick"] = "onPointerClick";
    PointerMethods["onPointerEnter"] = "onPointerEnter";
    PointerMethods["onPointerExit"] = "onPointerExit";
    PointerMethods["onPointerBeginDrag"] = "onPointerBeginDrag";
    PointerMethods["onPointerDrag"] = "onPointerDrag";
    PointerMethods["onPointerEndDrag"] = "onPointerEndDrag";
    PointerMethods["onPointerDrop"] = "onPointerDrop";
    return PointerMethods;
}({});

/**
 * Loader abstract class.
 */ var Loader = /*#__PURE__*/ function() {
    function Loader(useCache) {
        this.useCache = useCache;
    }
    /**
   * Register a class with a string name for serialization and deserialization.
   * @param key - class name
   * @param obj - class object
   */ Loader.registerClass = function registerClass(className, classDefine) {
        this._engineObjects[className] = classDefine;
        this._classNameMap.set(classDefine, className);
    };
    /**
   * Get the class object by class name.
   * @param key - class name
   * @returns class object
   */ Loader.getClass = function getClass(className) {
        return this._engineObjects[className];
    };
    /**
   * Get the class name by class object.
   * @param obj - class object
   * @returns class name
   */ Loader.getClassName = function getClassName(obj) {
        return this._classNameMap.get(obj);
    };
    return Loader;
}();
Loader._engineObjects = {};
Loader._classNameMap = new Map();

/**
 * @internal
 */ var UniversalAnimationCurveOwnerAssembler = /*#__PURE__*/ function() {
    function UniversalAnimationCurveOwnerAssembler() {}
    var _proto = UniversalAnimationCurveOwnerAssembler.prototype;
    _proto.initialize = function initialize(owner) {
        var mounted = owner.component;
        var setProperties = owner.property.split(".");
        if (owner.getProperty) {
            var getProperties = owner.getProperty.split(".");
            this._initializeMounted(mounted, getProperties, 1);
            this._initializeMounted(mounted, setProperties, 2);
        } else {
            this._initializeMounted(mounted, setProperties, 3);
        }
    };
    _proto.getTargetValue = function getTargetValue() {
        switch(this._getType){
            case 2:
                return this._getMounted[this._getArrayIndex];
            case 1:
                return this._getMounted[this._getValueName].apply(this._getMounted, this._getArgs);
            case 0:
                return this._getMounted[this._getValueName];
        }
    };
    _proto.setTargetValue = function setTargetValue(value) {
        switch(this._setType){
            case 2:
                this._setMounted[this._setArrayIndex] = value;
                break;
            case 1:
                var args = this._setArgs;
                args[this._replaceValueIndex] = value;
                this._setMounted[this._setValueName].apply(this._setMounted, args);
                break;
            case 0:
                this._setMounted[this._setValueName] = value;
                break;
        }
    };
    _proto._initializeMounted = function _initializeMounted(mounted, properties, parseFlag) {
        var endIndex = properties.length - 1;
        for(var i = 0; i < endIndex; i++){
            var property = properties[i];
            if (property.indexOf("[") > -1) {
                // is array
                var indexPos = property.indexOf("[");
                mounted = mounted[property.slice(0, indexPos)];
                mounted = mounted[parseInt(property.slice(indexPos + 1, -1))];
            } else if (property.endsWith(")")) {
                // is method
                var methodName = property.slice(0, property.indexOf("("));
                var args = property.match(/\w+\(([^)]*)\)/)[1].split(",").map(function(arg) {
                    return arg.trim().replace(/['"]+/g, "");
                }).filter(function(arg) {
                    return arg !== "";
                });
                mounted = mounted[methodName].apply(mounted, args);
            } else {
                // is property
                mounted = mounted[property];
            }
        }
        var property1 = properties[endIndex];
        var handleType;
        var arrayIndex;
        var methodName1;
        var args1;
        if (property1.indexOf("[") > -1) {
            var indexPos1 = property1.indexOf("[");
            handleType = 2;
            mounted = mounted[property1.slice(0, indexPos1)];
            arrayIndex = parseInt(property1.slice(indexPos1 + 1, -1));
        } else if (property1.endsWith(")")) {
            methodName1 = property1.slice(0, property1.indexOf("("));
            args1 = property1.match(/\w+\(([^)]*)\)/)[1].split(",").map(function(arg) {
                return arg.trim().replace(/['"]+/g, "");
            }).filter(function(arg) {
                return arg !== "";
            });
            handleType = 1;
            if (parseFlag & 2) {
                var index = args1.indexOf("$value");
                this._replaceValueIndex = index > -1 ? index : args1.length;
            }
        } else {
            handleType = 0;
        }
        if (parseFlag & 2) {
            this._setMounted = mounted;
            this._setType = handleType;
            this._setArrayIndex = arrayIndex;
            this._setValueName = property1;
            methodName1 && (this._setValueName = methodName1);
            this._setArgs = args1;
        }
        if (parseFlag & 1) {
            this._getMounted = mounted;
            this._getType = handleType;
            this._getArrayIndex = arrayIndex;
            this._getValueName = property1;
            methodName1 && (this._getValueName = methodName1);
            this._getArgs = args1;
        }
    };
    return UniversalAnimationCurveOwnerAssembler;
}();

/**
 * @internal
 */ var AnimationCurveOwner = /*#__PURE__*/ function() {
    function AnimationCurveOwner(target, type, component, property, getProperty, cureType) {
        this.baseEvaluateData = {
            curKeyframeIndex: 0,
            value: null
        };
        this.crossEvaluateData = {
            curKeyframeIndex: 0,
            value: null
        };
        this.updateMark = 0;
        this.target = target;
        this.property = property;
        this.getProperty = getProperty;
        this.component = component;
        this.cureType = cureType;
        var assemblerType = AnimationCurveOwner.getAssemblerType(type, property);
        this._assembler = new assemblerType();
        this._assembler.initialize(this);
        if (cureType._isCopyMode) {
            this.referenceTargetValue = this._assembler.getTargetValue();
        }
    }
    var _proto = AnimationCurveOwner.prototype;
    _proto.evaluateValue = function evaluateValue(curve, time, additive) {
        return additive ? curve._evaluateAdditive(time, this.baseEvaluateData) : curve._evaluate(time, this.baseEvaluateData);
    };
    _proto.evaluateCrossFadeValue = function evaluateCrossFadeValue(srcCurve, destCurve, srcTime, destTime, crossWeight, additive) {
        if (!this.cureType._supportInterpolationMode) {
            return this.evaluateValue(destCurve, destTime, false);
        }
        var srcValue = srcCurve && srcCurve.keys.length ? additive ? srcCurve._evaluateAdditive(srcTime, this.baseEvaluateData) : srcCurve._evaluate(srcTime, this.baseEvaluateData) : additive ? this.cureType._getZeroValue(this.baseEvaluateData.value) : this.defaultValue;
        var destValue = destCurve && destCurve.keys.length ? additive ? destCurve._evaluateAdditive(destTime, this.crossEvaluateData) : destCurve._evaluate(destTime, this.crossEvaluateData) : additive ? this.cureType._getZeroValue(this.crossEvaluateData.value) : this.defaultValue;
        return this._lerpValue(srcValue, destValue, crossWeight);
    };
    _proto.crossFadeFromPoseAndApplyValue = function crossFadeFromPoseAndApplyValue(destCurve, destTime, crossWeight, additive) {
        if (!this.cureType._supportInterpolationMode) {
            return this.evaluateValue(destCurve, destTime, false);
        }
        var srcValue = additive ? this.cureType._subtractValue(this.fixedPoseValue, this.defaultValue, this.baseEvaluateData.value) : this.fixedPoseValue;
        var destValue = destCurve && destCurve.keys.length ? additive ? destCurve._evaluateAdditive(destTime, this.crossEvaluateData) : destCurve._evaluate(destTime, this.crossEvaluateData) : additive ? this.cureType._getZeroValue(this.crossEvaluateData.value) : this.defaultValue;
        return this._lerpValue(srcValue, destValue, crossWeight);
    };
    _proto.revertDefaultValue = function revertDefaultValue() {
        this._assembler.setTargetValue(this.defaultValue);
    };
    _proto.getEvaluateValue = function getEvaluateValue(out) {
        if (this.cureType._isCopyMode) {
            this.cureType._setValue(this.baseEvaluateData.value, out);
            return out;
        } else {
            return this.baseEvaluateData.value;
        }
    };
    _proto.saveDefaultValue = function saveDefaultValue() {
        if (this.cureType._isCopyMode) {
            this.cureType._setValue(this.referenceTargetValue, this.defaultValue);
        } else {
            this.defaultValue = this._assembler.getTargetValue();
        }
    };
    _proto.saveFixedPoseValue = function saveFixedPoseValue() {
        if (this.cureType._isCopyMode) {
            this.cureType._setValue(this.referenceTargetValue, this.fixedPoseValue);
        } else {
            this.fixedPoseValue = this._assembler.getTargetValue();
        }
    };
    _proto.applyValue = function applyValue(value, weight, additive) {
        var cureType = this.cureType;
        if (additive) {
            var assembler = this._assembler;
            if (cureType._isCopyMode) {
                cureType._additiveValue(value, weight, this.referenceTargetValue);
            } else {
                var originValue = assembler.getTargetValue();
                var additiveValue = cureType._additiveValue(value, weight, originValue);
                assembler.setTargetValue(additiveValue);
            }
        } else {
            if (weight === 1.0) {
                if (cureType._isCopyMode) {
                    cureType._setValue(value, this.referenceTargetValue);
                } else {
                    this._assembler.setTargetValue(value);
                }
            } else {
                if (cureType._isCopyMode) {
                    var targetValue = this.referenceTargetValue;
                    cureType._lerpValue(targetValue, value, weight, targetValue);
                } else {
                    var originValue1 = this._assembler.getTargetValue();
                    var lerpValue = cureType._lerpValue(originValue1, value, weight);
                    this._assembler.setTargetValue(lerpValue);
                }
            }
        }
    };
    _proto._lerpValue = function _lerpValue(srcValue, destValue, crossWeight) {
        if (this.cureType._isCopyMode) {
            return this.cureType._lerpValue(srcValue, destValue, crossWeight, this.baseEvaluateData.value);
        } else {
            this.baseEvaluateData.value = this.cureType._lerpValue(srcValue, destValue, crossWeight);
            return this.baseEvaluateData.value;
        }
    };
    AnimationCurveOwner.registerAssembler = function registerAssembler(componentType, property, assemblerType) {
        var subMap = AnimationCurveOwner._assemblerMap.get(componentType);
        if (!subMap) {
            subMap = {};
            AnimationCurveOwner._assemblerMap.set(componentType, subMap);
        }
        subMap[property] = assemblerType;
    };
    AnimationCurveOwner.getAssemblerType = function getAssemblerType(componentType, property) {
        var subMap = AnimationCurveOwner._assemblerMap.get(componentType);
        var assemblerType = subMap ? subMap[property] : undefined;
        return assemblerType != null ? assemblerType : UniversalAnimationCurveOwnerAssembler;
    };
    return AnimationCurveOwner;
}();
/** @internal */ AnimationCurveOwner._components = [];
AnimationCurveOwner._assemblerMap = new Map();

/**
 * @internal
 */ var PositionAnimationCurveOwnerAssembler = /*#__PURE__*/ function() {
    function PositionAnimationCurveOwnerAssembler() {}
    var _proto = PositionAnimationCurveOwnerAssembler.prototype;
    _proto.initialize = function initialize(owner) {
        this._transform = owner.target.transform;
    };
    _proto.getTargetValue = function getTargetValue() {
        return this._transform.position;
    };
    _proto.setTargetValue = function setTargetValue(value) {
        this._transform.position = value;
    };
    return PositionAnimationCurveOwnerAssembler;
}();
AnimationCurveOwner.registerAssembler(Transform, "position", PositionAnimationCurveOwnerAssembler);

/**
 * @internal
 */ var RotationAnimationCurveOwnerAssembler = /*#__PURE__*/ function() {
    function RotationAnimationCurveOwnerAssembler() {}
    var _proto = RotationAnimationCurveOwnerAssembler.prototype;
    _proto.initialize = function initialize(owner) {
        this._transform = owner.target.transform;
    };
    _proto.getTargetValue = function getTargetValue() {
        return this._transform.rotationQuaternion;
    };
    _proto.setTargetValue = function setTargetValue(value) {
        this._transform.rotationQuaternion = value;
    };
    return RotationAnimationCurveOwnerAssembler;
}();
AnimationCurveOwner.registerAssembler(Transform, "rotationQuaternion", RotationAnimationCurveOwnerAssembler);

/**
 * @internal
 */ var ScaleAnimationCurveOwnerAssembler = /*#__PURE__*/ function() {
    function ScaleAnimationCurveOwnerAssembler() {}
    var _proto = ScaleAnimationCurveOwnerAssembler.prototype;
    _proto.initialize = function initialize(owner) {
        this._transform = owner.target.transform;
    };
    _proto.getTargetValue = function getTargetValue() {
        return this._transform.scale;
    };
    _proto.setTargetValue = function setTargetValue(value) {
        this._transform.scale = value;
    };
    return ScaleAnimationCurveOwnerAssembler;
}();
AnimationCurveOwner.registerAssembler(Transform, "scale", ScaleAnimationCurveOwnerAssembler);

/**
 * @internal
 */ var BlendShapeWeightsAnimationCurveOwnerAssembler = /*#__PURE__*/ function() {
    function BlendShapeWeightsAnimationCurveOwnerAssembler() {}
    var _proto = BlendShapeWeightsAnimationCurveOwnerAssembler.prototype;
    _proto.initialize = function initialize(owner) {
        this._skinnedMeshRenderer = owner.component;
    };
    _proto.getTargetValue = function getTargetValue() {
        return this._skinnedMeshRenderer.blendShapeWeights;
    };
    _proto.setTargetValue = function setTargetValue(value) {
        this._skinnedMeshRenderer.blendShapeWeights = value;
    };
    return BlendShapeWeightsAnimationCurveOwnerAssembler;
}();
AnimationCurveOwner.registerAssembler(SkinnedMeshRenderer, "blendShapeWeights", BlendShapeWeightsAnimationCurveOwnerAssembler);

/**
 * @internal
 */ var AnimationCurveLayerOwner = /*#__PURE__*/ function() {
    function AnimationCurveLayerOwner() {
        this.crossCurveMark = 0;
        this.isActive = true;
    }
    var _proto = AnimationCurveLayerOwner.prototype;
    _proto.initFinalValue = function initFinalValue() {
        var _this_curveOwner = this.curveOwner, cureType = _this_curveOwner.cureType, defaultValue = _this_curveOwner.defaultValue;
        if (cureType._isCopyMode) {
            cureType._setValue(defaultValue, this.finalValue);
        } else {
            this.finalValue = defaultValue;
        }
    };
    _proto.saveFinalValue = function saveFinalValue() {
        this.finalValue = this.curveOwner.getEvaluateValue(this.finalValue);
    };
    return AnimationCurveLayerOwner;
}();

/**
 * Associate AnimationCurve and the Entity
 */ var AnimationClipCurveBinding = /*#__PURE__*/ function() {
    function AnimationClipCurveBinding() {
        /** The index of the component that is animated. */ this.typeIndex = 0;
        this._tempCurveOwner = {};
    }
    var _proto = AnimationClipCurveBinding.prototype;
    /**
   * @internal
   */ _proto._createCurveOwner = function _createCurveOwner(entity, component) {
        var curveType = this.curve.constructor;
        var owner = new AnimationCurveOwner(entity, this.type, component, this.property, this.getProperty, curveType);
        curveType._initializeOwner(owner);
        owner.saveDefaultValue();
        return owner;
    };
    /**
   * @internal
   */ _proto._createCurveLayerOwner = function _createCurveLayerOwner(owner) {
        var curveType = this.curve.constructor;
        var layerOwner = new AnimationCurveLayerOwner();
        layerOwner.curveOwner = owner;
        curveType._initializeLayerOwner(layerOwner);
        // If curve.keys.length is 0, updateFinishedState will assign 0 to the target, causing an error, so initialize by assigning defaultValue to finalValue.
        layerOwner.initFinalValue();
        return layerOwner;
    };
    /**
   * @internal
   */ _proto._getTempCurveOwner = function _getTempCurveOwner(entity, component) {
        var instanceId = entity.instanceId;
        if (!this._tempCurveOwner[instanceId]) {
            this._tempCurveOwner[instanceId] = this._createCurveOwner(entity, component);
        }
        return this._tempCurveOwner[instanceId];
    };
    return AnimationClipCurveBinding;
}();

/**
 * AnimationEvent lets you call a script function similar to SendMessage as part of playing back an animation.
 */ var AnimationEvent = function AnimationEvent() {
};

/**
 * Stores keyframe based animations.
 */ var AnimationClip = /*#__PURE__*/ function(EngineObject) {
    _inherits$2(AnimationClip, EngineObject);
    function AnimationClip(name) {
        var _this;
        _this = EngineObject.call(this, null) || this, _this.name = name, _this./** @internal */ _curveBindings = [], _this./** @internal */ _updateFlagManager = new UpdateFlagManager(), _this._length = 0, _this._events = [];
        return _this;
    }
    var _proto = AnimationClip.prototype;
    _proto.addEvent = function addEvent(param, time, parameter) {
        var newEvent;
        if (typeof param === "string") {
            var event = new AnimationEvent();
            event.functionName = param;
            event.time = time;
            event.parameter = parameter;
            newEvent = event;
        } else {
            newEvent = param;
        }
        var events = this._events;
        var count = events.length;
        var eventTime = newEvent.time;
        var maxEventTime = count ? events[count - 1].time : 0;
        if (eventTime >= maxEventTime) {
            events.push(newEvent);
        } else {
            var index = count;
            while(--index >= 0 && eventTime < events[index].time);
            events.splice(index + 1, 0, newEvent);
        }
        this._updateFlagManager.dispatch();
    };
    /**
   * Clears all events from the clip.
   */ _proto.clearEvents = function clearEvents() {
        this._events.length = 0;
        this._updateFlagManager.dispatch();
    };
    _proto.addCurveBinding = function addCurveBinding(entityPath, componentType, propertyOrSetPropertyPathOrComponentIndex, curveOrSetPropertyPathOrGetPropertyPath, curveOrGetPropertyPath, curve) {
        var curveBinding = new AnimationClipCurveBinding();
        curveBinding.relativePath = entityPath;
        curveBinding.type = componentType;
        if (typeof propertyOrSetPropertyPathOrComponentIndex === "number") {
            curveBinding.typeIndex = propertyOrSetPropertyPathOrComponentIndex;
            curveBinding.property = curveOrSetPropertyPathOrGetPropertyPath;
            if (typeof curveOrGetPropertyPath === "string") {
                curveBinding.getProperty = curveOrGetPropertyPath;
                curveBinding.curve = curve;
            } else {
                curveBinding.curve = curveOrGetPropertyPath;
            }
        } else {
            curveBinding.property = propertyOrSetPropertyPathOrComponentIndex;
            if (typeof curveOrSetPropertyPathOrGetPropertyPath === "string") {
                curveBinding.getProperty = curveOrSetPropertyPathOrGetPropertyPath;
                curveBinding.curve = curveOrGetPropertyPath;
            } else {
                curveBinding.curve = curveOrSetPropertyPathOrGetPropertyPath;
            }
        }
        this._length = Math.max(this._length, curveBinding.curve.length);
        this._curveBindings.push(curveBinding);
    };
    /**
   * Clears all curve bindings from the clip.
   */ _proto.clearCurveBindings = function clearCurveBindings() {
        this._curveBindings.length = 0;
        this._length = 0;
    };
    /**
   * @internal
   * Samples an animation at a given time.
   * @param entity - The animated entity
   * @param time - The time to sample an animation
   */ _proto._sampleAnimation = function _sampleAnimation(entity, time) {
        var _this = this, curveBindings = _this._curveBindings;
        var components = AnimationCurveOwner._components;
        for(var i = curveBindings.length - 1; i >= 0; i--){
            var curve = curveBindings[i];
            var targetEntity = entity.findByPath(curve.relativePath);
            if (targetEntity) {
                var component = curve.typeIndex > 0 ? targetEntity.getComponents(curve.type, components)[curve.typeIndex] : targetEntity.getComponent(curve.type);
                components.length = 0;
                if (!component) {
                    continue;
                }
                var curveOwner = curve._getTempCurveOwner(targetEntity, component);
                if (curveOwner && curve.curve.keys.length) {
                    var value = curveOwner.evaluateValue(curve.curve, time, false);
                    curveOwner.applyValue(value, 1, false);
                }
            }
        }
    };
    _create_class$2(AnimationClip, [
        {
            key: "events",
            get: /**
   * Animation events for this animation clip.
   */ function get() {
                return this._events;
            }
        },
        {
            key: "curveBindings",
            get: /**
   * Animation curve bindings for this animation clip.
   */ function get() {
                return this._curveBindings;
            }
        },
        {
            key: "length",
            get: /**
   * Animation length in seconds.
   */ function get() {
                return this._length;
            }
        }
    ]);
    return AnimationClip;
}(EngineObject);

/**
 * Animation interpolation method.
 */ var InterpolationType = /*#__PURE__*/ function(InterpolationType) {
    /** Linear interpolation */ InterpolationType[InterpolationType["Linear"] = 0] = "Linear";
    /** Cubic spline interpolation */ InterpolationType[InterpolationType["CubicSpine"] = 1] = "CubicSpine";
    /** Stepped interpolation */ InterpolationType[InterpolationType["Step"] = 2] = "Step";
    /** Hermite interpolation */ InterpolationType[InterpolationType["Hermite"] = 3] = "Hermite";
    return InterpolationType;
}({});

/**
 * Store a collection of Keyframes that can be evaluated over time.
 */ var AnimationCurve = /*#__PURE__*/ function() {
    function AnimationCurve() {
        /** All keys defined in the animation curve. */ this.keys = [];
        this._evaluateData = {
            curKeyframeIndex: 0,
            value: null
        };
        this._length = 0;
        var type = this.constructor;
        this._interpolation = type._supportInterpolationMode ? InterpolationType.Linear : InterpolationType.Step;
        this._type = type;
    }
    var _proto = AnimationCurve.prototype;
    /**
   * Add a new key to the curve.
   * @param key - The keyframe
   */ _proto.addKey = function addKey(key) {
        var time = key.time;
        var keys = this.keys;
        if (time >= this._length) {
            keys.push(key);
            this._length = time;
        } else {
            var index = keys.length;
            while(--index >= 0 && time < keys[index].time);
            keys.splice(index + 1, 0, key);
        }
    };
    /**
   * Evaluate the curve at time.
   * @param time - The time within the curve you want to evaluate
   */ _proto.evaluate = function evaluate(time) {
        return this._evaluate(time, this._evaluateData);
    };
    /**
   * Removes a key.
   * @param index - The index of the key to remove
   */ _proto.removeKey = function removeKey(index) {
        this.keys.splice(index, 1);
        var keys = this.keys;
        var newLength = 0;
        for(var i = keys.length - 1; i >= 0; i--){
            var key = keys[i];
            if (key.time > this._length) {
                newLength = key.time;
            }
        }
        this._length = newLength;
    };
    /**
   * @internal
   */ _proto._evaluate = function _evaluate(time, evaluateData) {
        var length = this.keys.length;
        if (!length) {
            console.warn("This curve don't have any keyframes: ", this);
            return;
        }
        var _this = this, keys = _this.keys, interpolation = _this.interpolation;
        // Compute curIndex and nextIndex.
        var curIndex = evaluateData.curKeyframeIndex;
        // Reset loop,if delete keyfranme may cause `curIndex >= length`
        if (curIndex !== -1 && (curIndex >= length || time < keys[curIndex].time)) {
            curIndex = -1;
        }
        var nextIndex = curIndex + 1;
        while(nextIndex < length){
            if (time < keys[nextIndex].time) {
                break;
            }
            curIndex++;
            nextIndex++;
        }
        evaluateData.curKeyframeIndex = curIndex;
        // Evaluate value.
        var value;
        if (curIndex === -1) {
            value = this._type._setValue(keys[0].value, evaluateData.value);
        } else if (nextIndex === length) {
            value = this._type._setValue(keys[curIndex].value, evaluateData.value);
        } else {
            // Time between first frame and end frame.
            var curFrame = keys[curIndex];
            var nextFrame = keys[nextIndex];
            var curFrameTime = curFrame.time;
            var duration = nextFrame.time - curFrameTime;
            var t = (time - curFrameTime) / duration;
            switch(interpolation){
                case InterpolationType.Linear:
                    value = this._type._lerpValue(curFrame.value, nextFrame.value, t, evaluateData.value);
                    break;
                case InterpolationType.Step:
                    value = this._type._setValue(curFrame.value, evaluateData.value);
                    break;
                case InterpolationType.CubicSpine:
                case InterpolationType.Hermite:
                    value = this._type._hermiteInterpolationValue(curFrame, nextFrame, t, duration, evaluateData.value);
                    break;
            }
        }
        evaluateData.value = value;
        return value;
    };
    /**
   * @internal
   */ _proto._evaluateAdditive = function _evaluateAdditive(time, evaluateData) {
        var result = this._evaluate(time, evaluateData);
        return this._type._subtractValue(result, this.keys[0].value, evaluateData.value);
    };
    _create_class$2(AnimationCurve, [
        {
            key: "interpolation",
            get: /**
   * The interpolationType of the animation curve.
   */ function get() {
                return this._interpolation;
            },
            set: function set(value) {
                if (!this._type._supportInterpolationMode && value !== InterpolationType.Step) {
                    this._interpolation = InterpolationType.Step;
                    console.warn("The interpolation type must be `InterpolationType.Step`.");
                } else {
                    this._interpolation = value;
                }
            }
        },
        {
            key: "length",
            get: /**
   * Animation curve length in seconds.
   */ function get() {
                return this._length;
            }
        }
    ]);
    return AnimationCurve;
}();

var AnimationArrayCurve = /*#__PURE__*/ function(AnimationCurve) {
    _inherits$2(AnimationArrayCurve, AnimationCurve);
    function AnimationArrayCurve() {
        var _this;
        _this = AnimationCurve.call(this) || this;
        _this._evaluateData.value = [];
        return _this;
    }
    /**
   * @internal
   */ AnimationArrayCurve._initializeOwner = function _initializeOwner(owner) {
        owner.defaultValue = [];
        owner.fixedPoseValue = [];
        owner.baseEvaluateData.value = [];
        owner.crossEvaluateData.value = [];
    };
    /**
   * @internal
   */ AnimationArrayCurve._initializeLayerOwner = function _initializeLayerOwner(owner) {
        owner.finalValue = [];
    };
    /**
   * @internal
   */ AnimationArrayCurve._lerpValue = function _lerpValue(srcValue, destValue, weight, out) {
        for(var i = 0, n = out.length; i < n; ++i){
            var src = srcValue[i];
            out[i] = src + (destValue[i] - src) * weight;
        }
        return out;
    };
    /**
   * @internal
   */ AnimationArrayCurve._subtractValue = function _subtractValue(src, base, out) {
        for(var i = 0, n = src.length; i < n; i++){
            out[i] = src[i] - base[i];
        }
        return out;
    };
    /**
   * @internal
   */ AnimationArrayCurve._getZeroValue = function _getZeroValue(out) {
        for(var i = 0, n = out.length; i < n; i++){
            out[i] = 0;
        }
        return out;
    };
    /**
   * @internal
   */ AnimationArrayCurve._additiveValue = function _additiveValue(value, weight, out) {
        for(var i = 0, n = out.length; i < n; ++i){
            out[i] += value[i] * weight;
        }
        return out;
    };
    /**
   * @internal
   */ AnimationArrayCurve._setValue = function _setValue(source, out) {
        for(var i = 0, n = out.length; i < n; ++i){
            out[i] = source[i];
        }
        return out;
    };
    /**
   * @internal
   */ AnimationArrayCurve._hermiteInterpolationValue = function _hermiteInterpolationValue(frame, nextFrame, t, duration, out) {
        var t0 = frame.outTangent;
        var t1 = nextFrame.inTangent;
        var p0 = frame.value;
        var p1 = nextFrame.value;
        var t2 = t * t;
        var t3 = t2 * t;
        var a = 2.0 * t3 - 3.0 * t2 + 1.0;
        var b = t3 - 2.0 * t2 + t;
        var c = t3 - t2;
        var d = -2 * t3 + 3.0 * t2;
        for(var i = 0, n = p0.length; i < n; ++i){
            if (Number.isFinite(t0[i]) && Number.isFinite(t1[i])) {
                out[i] = a * p0[i] + b * t0[i] * duration + c * t1[i] * duration + d * p1[i];
            } else {
                out[i] = frame.value[i];
            }
        }
        return out;
    };
    return AnimationArrayCurve;
}(AnimationCurve);
/** @internal */ AnimationArrayCurve._isCopyMode = true;
/** @internal */ AnimationArrayCurve._supportInterpolationMode = true;
AnimationArrayCurve = __decorate$1([
    StaticInterfaceImplement()
], AnimationArrayCurve);

var AnimationBoolCurve = /*#__PURE__*/ function(AnimationCurve) {
    _inherits$2(AnimationBoolCurve, AnimationCurve);
    function AnimationBoolCurve() {
        var _this;
        _this = AnimationCurve.call(this) || this;
        _this._evaluateData.value = false;
        return _this;
    }
    /**
   * @internal
   */ AnimationBoolCurve._initializeOwner = function _initializeOwner(owner) {
        owner.defaultValue = false;
        owner.fixedPoseValue = false;
        owner.baseEvaluateData.value = false;
        owner.crossEvaluateData.value = false;
    };
    /**
   * @internal
   */ AnimationBoolCurve._initializeLayerOwner = function _initializeLayerOwner(owner) {
        owner.finalValue = false;
    };
    /**
   * @internal
   */ AnimationBoolCurve._lerpValue = function _lerpValue(srcValue, destValue) {
        return srcValue;
    };
    /**
   * @internal
   */ AnimationBoolCurve._subtractValue = function _subtractValue(src, base, out) {
        return src;
    };
    /**
   * @internal
   */ AnimationBoolCurve._getZeroValue = function _getZeroValue() {
        return false;
    };
    /**
   * @internal
   */ AnimationBoolCurve._additiveValue = function _additiveValue(value, weight, source) {
        return value;
    };
    /**
   * @internal
   */ AnimationBoolCurve._setValue = function _setValue(value) {
        return value;
    };
    /**
   * @internal
   */ AnimationBoolCurve._hermiteInterpolationValue = function _hermiteInterpolationValue(frame) {
        return frame.value;
    };
    return AnimationBoolCurve;
}(AnimationCurve);
/** @internal */ AnimationBoolCurve._isCopyMode = false;
/** @internal */ AnimationBoolCurve._supportInterpolationMode = false;
AnimationBoolCurve = __decorate$1([
    StaticInterfaceImplement()
], AnimationBoolCurve);

var AnimationColorCurve = /*#__PURE__*/ function(AnimationCurve) {
    _inherits$2(AnimationColorCurve, AnimationCurve);
    function AnimationColorCurve() {
        var _this;
        _this = AnimationCurve.call(this) || this;
        _this._evaluateData.value = new Color();
        return _this;
    }
    /**
   * @internal
   */ AnimationColorCurve._initializeOwner = function _initializeOwner(owner) {
        owner.defaultValue = new Color();
        owner.fixedPoseValue = new Color();
        owner.baseEvaluateData.value = new Color();
        owner.crossEvaluateData.value = new Color();
    };
    /**
   * @internal
   */ AnimationColorCurve._initializeLayerOwner = function _initializeLayerOwner(owner) {
        owner.finalValue = new Color();
    };
    /**
   * @internal
   */ AnimationColorCurve._lerpValue = function _lerpValue(srcValue, destValue, weight, out) {
        Color.lerp(srcValue, destValue, weight, out);
        return out;
    };
    /**
   * @internal
   */ AnimationColorCurve._subtractValue = function _subtractValue(src, base, out) {
        Color.subtract(src, base, out);
        return out;
    };
    /**
   * @internal
   */ AnimationColorCurve._getZeroValue = function _getZeroValue(out) {
        out.set(0, 0, 0, 0);
        return out;
    };
    /**
   * @internal
   */ AnimationColorCurve._additiveValue = function _additiveValue(value, weight, out) {
        Color.scale(value, weight, value);
        Color.add(out, value, out);
        return out;
    };
    /**
   * @internal
   */ AnimationColorCurve._setValue = function _setValue(source, out) {
        out.copyFrom(source);
        return out;
    };
    /**
   * @internal
   */ AnimationColorCurve._hermiteInterpolationValue = function _hermiteInterpolationValue(frame, nextFrame, t, dur, out) {
        var p0 = frame.value;
        var tan0 = frame.outTangent;
        var p1 = nextFrame.value;
        var tan1 = nextFrame.inTangent;
        var t2 = t * t;
        var t3 = t2 * t;
        var a = 2.0 * t3 - 3.0 * t2 + 1.0;
        var b = t3 - 2.0 * t2 + t;
        var c = t3 - t2;
        var d = -2 * t3 + 3.0 * t2;
        var t0 = tan0.x, t1 = tan1.x;
        if (Number.isFinite(t0) && Number.isFinite(t1)) {
            out.r = a * p0.r + b * t0 * dur + c * t1 * dur + d * p1.r;
        } else {
            out.r = p0.r;
        }
        t0 = tan0.y, t1 = tan1.y;
        if (Number.isFinite(t0) && Number.isFinite(t1)) {
            out.g = a * p0.g + b * t0 * dur + c * t1 * dur + d * p1.g;
        } else {
            out.g = p0.g;
        }
        t0 = tan0.z, t1 = tan1.z;
        if (Number.isFinite(t0) && Number.isFinite(t1)) {
            out.b = a * p0.b + b * t0 * dur + c * t1 * dur + d * p1.b;
        } else {
            out.b = p0.b;
        }
        t0 = tan0.w, t1 = tan1.w;
        if (Number.isFinite(t0) && Number.isFinite(t1)) {
            out.a = a * p0.a + b * t0 * dur + c * t1 * dur + d * p1.a;
        } else {
            out.a = p0.a;
        }
        return out;
    };
    return AnimationColorCurve;
}(AnimationCurve);
/** @internal */ AnimationColorCurve._isCopyMode = true;
/** @internal */ AnimationColorCurve._supportInterpolationMode = true;
AnimationColorCurve = __decorate$1([
    StaticInterfaceImplement()
], AnimationColorCurve);

var AnimationFloatArrayCurve = /*#__PURE__*/ function(AnimationCurve) {
    _inherits$2(AnimationFloatArrayCurve, AnimationCurve);
    function AnimationFloatArrayCurve() {
        return AnimationCurve.apply(this, arguments) || this;
    }
    var _proto = AnimationFloatArrayCurve.prototype;
    /**
   * @inheritdoc
   */ _proto.addKey = function addKey(key) {
        AnimationCurve.prototype.addKey.call(this, key);
        var evaluateData = this._evaluateData;
        if (!evaluateData.value || evaluateData.value.length !== key.value.length) {
            var size = key.value.length;
            evaluateData.value = new Float32Array(size);
        }
    };
    /**
   * @internal
   */ AnimationFloatArrayCurve._initializeOwner = function _initializeOwner(owner) {
        var size = owner.referenceTargetValue.length;
        owner.defaultValue = new Float32Array(size);
        owner.fixedPoseValue = new Float32Array(size);
        owner.baseEvaluateData.value = new Float32Array(size);
        owner.crossEvaluateData.value = new Float32Array(size);
    };
    /**
   * @internal
   */ AnimationFloatArrayCurve._initializeLayerOwner = function _initializeLayerOwner(owner) {
        var size = owner.curveOwner.referenceTargetValue.length;
        owner.finalValue = new Float32Array(size);
    };
    /**
   * @internal
   */ AnimationFloatArrayCurve._lerpValue = function _lerpValue(srcValue, destValue, weight, out) {
        for(var i = 0, n = out.length; i < n; ++i){
            var src = srcValue[i];
            out[i] = src + (destValue[i] - src) * weight;
        }
        return out;
    };
    /**
   * @internal
   */ AnimationFloatArrayCurve._subtractValue = function _subtractValue(src, base, out) {
        for(var i = 0, n = src.length; i < n; i++){
            out[i] = src[i] - base[i];
        }
        return out;
    };
    /**
   * @internal
   */ AnimationFloatArrayCurve._getZeroValue = function _getZeroValue(out) {
        for(var i = 0, n = out.length; i < n; i++){
            out[i] = 0;
        }
        return out;
    };
    /**
   * @internal
   */ AnimationFloatArrayCurve._additiveValue = function _additiveValue(value, weight, out) {
        for(var i = 0, n = out.length; i < n; ++i){
            out[i] += value[i] * weight;
        }
        return out;
    };
    /**
   * @internal
   */ AnimationFloatArrayCurve._setValue = function _setValue(source, out) {
        for(var i = 0, n = out.length; i < n; ++i){
            out[i] = source[i];
        }
        return out;
    };
    /**
   * @internal
   */ AnimationFloatArrayCurve._hermiteInterpolationValue = function _hermiteInterpolationValue(frame, nextFrame, t, dur, out) {
        var t0 = frame.outTangent;
        var t1 = nextFrame.inTangent;
        var p0 = frame.value;
        var p1 = nextFrame.value;
        var t2 = t * t;
        var t3 = t2 * t;
        var a = 2.0 * t3 - 3.0 * t2 + 1.0;
        var b = t3 - 2.0 * t2 + t;
        var c = t3 - t2;
        var d = -2 * t3 + 3.0 * t2;
        for(var i = 0, n = p0.length; i < n; ++i){
            if (Number.isFinite(t0[i]) && Number.isFinite(t1[i])) {
                out[i] = a * p0[i] + b * t0[i] * dur + c * t1[i] * dur + d * p1[i];
            } else {
                out[i] = frame.value[i];
            }
        }
        return out;
    };
    return AnimationFloatArrayCurve;
}(AnimationCurve);
/** @internal */ AnimationFloatArrayCurve._isCopyMode = true;
/** @internal */ AnimationFloatArrayCurve._supportInterpolationMode = true;
AnimationFloatArrayCurve = __decorate$1([
    StaticInterfaceImplement()
], AnimationFloatArrayCurve);

var AnimationFloatCurve = /*#__PURE__*/ function(AnimationCurve) {
    _inherits$2(AnimationFloatCurve, AnimationCurve);
    function AnimationFloatCurve() {
        var _this;
        _this = AnimationCurve.call(this) || this;
        _this._evaluateData.value = 0;
        return _this;
    }
    /**
   * @internal
   */ AnimationFloatCurve._initializeOwner = function _initializeOwner(owner) {
        owner.defaultValue = 0;
        owner.fixedPoseValue = 0;
        owner.baseEvaluateData.value = 0;
        owner.crossEvaluateData.value = 0;
    };
    /**
   * @internal
   */ AnimationFloatCurve._initializeLayerOwner = function _initializeLayerOwner(owner) {
        owner.finalValue = 0;
    };
    /**
   * @internal
   */ AnimationFloatCurve._lerpValue = function _lerpValue(srcValue, destValue, crossWeight) {
        return srcValue + (destValue - srcValue) * crossWeight;
    };
    /**
   * @internal
   */ AnimationFloatCurve._additiveValue = function _additiveValue(value, weight, source) {
        return source += value * weight;
    };
    /**
   * @internal
   */ AnimationFloatCurve._subtractValue = function _subtractValue(src, base) {
        return src - base;
    };
    /**
   * @internal
   */ AnimationFloatCurve._getZeroValue = function _getZeroValue() {
        return 0;
    };
    /**
   * @internal
   */ AnimationFloatCurve._setValue = function _setValue(source) {
        return source;
    };
    /**
   * @internal
   */ AnimationFloatCurve._hermiteInterpolationValue = function _hermiteInterpolationValue(frame, nextFrame, t, dur) {
        var t0 = frame.outTangent;
        var t1 = nextFrame.inTangent;
        if (Number.isFinite(t0) && Number.isFinite(t1)) {
            var t2 = t * t;
            var t3 = t2 * t;
            var a = 2.0 * t3 - 3.0 * t2 + 1.0;
            var b = t3 - 2.0 * t2 + t;
            var c = t3 - t2;
            var d = -2 * t3 + 3.0 * t2;
            return a * frame.value + b * t0 * dur + c * t1 * dur + d * nextFrame.value;
        } else {
            return frame.value;
        }
    };
    return AnimationFloatCurve;
}(AnimationCurve);
/** @internal */ AnimationFloatCurve._isCopyMode = false;
/** @internal */ AnimationFloatCurve._supportInterpolationMode = true;
AnimationFloatCurve = __decorate$1([
    StaticInterfaceImplement()
], AnimationFloatCurve);

var AnimationQuaternionCurve = /*#__PURE__*/ function(AnimationCurve) {
    _inherits$2(AnimationQuaternionCurve, AnimationCurve);
    function AnimationQuaternionCurve() {
        var _this;
        _this = AnimationCurve.call(this) || this;
        _this._evaluateData.value = new Quaternion();
        return _this;
    }
    /**
   * @internal
   */ AnimationQuaternionCurve._initializeOwner = function _initializeOwner(owner) {
        owner.defaultValue = new Quaternion();
        owner.fixedPoseValue = new Quaternion();
        owner.baseEvaluateData.value = new Quaternion();
        owner.crossEvaluateData.value = new Quaternion();
    };
    /**
   * @internal
   */ AnimationQuaternionCurve._initializeLayerOwner = function _initializeLayerOwner(owner) {
        owner.finalValue = new Quaternion();
    };
    /**
   * @internal
   */ AnimationQuaternionCurve._lerpValue = function _lerpValue(src, dest, weight, out) {
        Quaternion.slerp(src, dest, weight, out);
        return out;
    };
    /**
   * @internal
   */ AnimationQuaternionCurve._additiveValue = function _additiveValue(value, weight, out) {
        value.x = value.x * weight;
        value.y = value.y * weight;
        value.z = value.z * weight;
        value.normalize();
        out.multiply(value);
        return out;
    };
    /**
   * @internal
   */ AnimationQuaternionCurve._subtractValue = function _subtractValue(src, base, out) {
        var conjugate = AnimationQuaternionCurve._tempConjugateQuat;
        Quaternion.conjugate(base, conjugate);
        Quaternion.multiply(conjugate, src, out);
        return out;
    };
    /**
   * @internal
   */ AnimationQuaternionCurve._getZeroValue = function _getZeroValue(out) {
        out.set(0, 0, 0, 1);
        return out;
    };
    /**
   * @internal
   */ AnimationQuaternionCurve._setValue = function _setValue(source, out) {
        out.copyFrom(source);
        return out;
    };
    /**
   * @internal
   */ AnimationQuaternionCurve._hermiteInterpolationValue = function _hermiteInterpolationValue(frame, nextFrame, t, dur, out) {
        var p0 = frame.value;
        var tan0 = frame.outTangent;
        var p1 = nextFrame.value;
        var tan1 = nextFrame.inTangent;
        var t2 = t * t;
        var t3 = t2 * t;
        var a = 2.0 * t3 - 3.0 * t2 + 1.0;
        var b = t3 - 2.0 * t2 + t;
        var c = t3 - t2;
        var d = -2 * t3 + 3.0 * t2;
        var t0 = tan0.x, t1 = tan1.x;
        if (Number.isFinite(t0) && Number.isFinite(t1)) {
            out.x = a * p0.x + b * t0 * dur + c * t1 * dur + d * p1.x;
        } else {
            out.x = p0.x;
        }
        t0 = tan0.y, t1 = tan1.y;
        if (Number.isFinite(t0) && Number.isFinite(t1)) {
            out.y = a * p0.y + b * t0 * dur + c * t1 * dur + d * p1.y;
        } else {
            out.y = p0.y;
        }
        t0 = tan0.z, t1 = tan1.z;
        if (Number.isFinite(t0) && Number.isFinite(t1)) {
            out.z = a * p0.z + b * t0 * dur + c * t1 * dur + d * p1.z;
        } else {
            out.z = p0.z;
        }
        t0 = tan0.w, t1 = tan1.w;
        if (Number.isFinite(t0) && Number.isFinite(t1)) {
            out.w = a * p0.w + b * t0 * dur + c * t1 * dur + d * p1.w;
        } else {
            out.w = p0.w;
        }
        return out;
    };
    return AnimationQuaternionCurve;
}(AnimationCurve);
/** @internal */ AnimationQuaternionCurve._supportInterpolationMode = true;
/** @internal */ AnimationQuaternionCurve._isCopyMode = true;
/** @internal */ AnimationQuaternionCurve._tempConjugateQuat = new Quaternion();
AnimationQuaternionCurve = __decorate$1([
    StaticInterfaceImplement()
], AnimationQuaternionCurve);

var AnimationVector2Curve = /*#__PURE__*/ function(AnimationCurve) {
    _inherits$2(AnimationVector2Curve, AnimationCurve);
    function AnimationVector2Curve() {
        var _this;
        _this = AnimationCurve.call(this) || this;
        _this._evaluateData.value = new Vector2();
        return _this;
    }
    /**
   * @internal
   */ AnimationVector2Curve._initializeOwner = function _initializeOwner(owner) {
        owner.defaultValue = new Vector2();
        owner.fixedPoseValue = new Vector2();
        owner.baseEvaluateData.value = new Vector2();
        owner.crossEvaluateData.value = new Vector2();
    };
    /**
   * @internal
   */ AnimationVector2Curve._initializeLayerOwner = function _initializeLayerOwner(owner) {
        owner.finalValue = new Vector2();
    };
    /**
   * @internal
   */ AnimationVector2Curve._lerpValue = function _lerpValue(srcValue, destValue, weight, out) {
        Vector2.lerp(srcValue, destValue, weight, out);
        return out;
    };
    /**
   * @internal
   */ AnimationVector2Curve._additiveValue = function _additiveValue(value, weight, out) {
        Vector2.scale(value, weight, value);
        Vector2.add(out, value, out);
        return out;
    };
    /**
   * @internal
   */ AnimationVector2Curve._subtractValue = function _subtractValue(src, base, out) {
        Vector2.subtract(src, base, out);
        return out;
    };
    /**
   * @internal
   */ AnimationVector2Curve._getZeroValue = function _getZeroValue(out) {
        out.set(0, 0);
        return out;
    };
    /**
   * @internal
   */ AnimationVector2Curve._setValue = function _setValue(source, out) {
        out.copyFrom(source);
        return out;
    };
    /**
   * @internal
   */ AnimationVector2Curve._hermiteInterpolationValue = function _hermiteInterpolationValue(frame, nextFrame, t, dur, out) {
        var p0 = frame.value;
        var tan0 = frame.outTangent;
        var p1 = nextFrame.value;
        var tan1 = nextFrame.inTangent;
        var t2 = t * t;
        var t3 = t2 * t;
        var a = 2.0 * t3 - 3.0 * t2 + 1.0;
        var b = t3 - 2.0 * t2 + t;
        var c = t3 - t2;
        var d = -2 * t3 + 3.0 * t2;
        var t0 = tan0.x, t1 = tan1.x;
        if (Number.isFinite(t0) && Number.isFinite(t1)) {
            out.x = a * p0.x + b * t0 * dur + c * t1 * dur + d * p1.x;
        } else {
            out.x = p0.x;
        }
        t0 = tan0.y, t1 = tan1.y;
        if (Number.isFinite(t0) && Number.isFinite(t1)) {
            out.y = a * p0.y + b * t0 * dur + c * t1 * dur + d * p1.y;
        } else {
            out.y = p0.y;
        }
        return out;
    };
    return AnimationVector2Curve;
}(AnimationCurve);
/** @internal */ AnimationVector2Curve._isCopyMode = true;
/** @internal */ AnimationVector2Curve._supportInterpolationMode = true;
AnimationVector2Curve = __decorate$1([
    StaticInterfaceImplement()
], AnimationVector2Curve);

var AnimationVector3Curve = /*#__PURE__*/ function(AnimationCurve) {
    _inherits$2(AnimationVector3Curve, AnimationCurve);
    function AnimationVector3Curve() {
        var _this;
        _this = AnimationCurve.call(this) || this;
        _this._evaluateData.value = new Vector3();
        return _this;
    }
    /**
   * @internal
   */ AnimationVector3Curve._initializeOwner = function _initializeOwner(owner) {
        owner.defaultValue = new Vector3();
        owner.fixedPoseValue = new Vector3();
        owner.baseEvaluateData.value = new Vector3();
        owner.crossEvaluateData.value = new Vector3();
    };
    /**
   * @internal
   */ AnimationVector3Curve._initializeLayerOwner = function _initializeLayerOwner(owner) {
        owner.finalValue = new Vector3();
    };
    /**
   * @internal
   */ AnimationVector3Curve._lerpValue = function _lerpValue(srcValue, destValue, weight, out) {
        Vector3.lerp(srcValue, destValue, weight, out);
        return out;
    };
    /**
   * @internal
   */ AnimationVector3Curve._relativeBaseValue = function _relativeBaseValue(base, out) {
        Vector3.subtract(out, base, out);
        return out;
    };
    /**
   * @internal
   */ AnimationVector3Curve._additiveValue = function _additiveValue(value, weight, out) {
        Vector3.scale(value, weight, value);
        Vector3.add(out, value, out);
        return out;
    };
    /**
   * @internal
   */ AnimationVector3Curve._subtractValue = function _subtractValue(src, base, out) {
        Vector3.subtract(src, base, out);
        return out;
    };
    /**
   * @internal
   */ AnimationVector3Curve._getZeroValue = function _getZeroValue(out) {
        out.set(0, 0, 0);
        return out;
    };
    /**
   * @internal
   */ AnimationVector3Curve._setValue = function _setValue(source, out) {
        out.copyFrom(source);
        return out;
    };
    /**
   * @internal
   */ AnimationVector3Curve._hermiteInterpolationValue = function _hermiteInterpolationValue(frame, nextFrame, t, dur, out) {
        var p0 = frame.value;
        var tan0 = frame.outTangent;
        var p1 = nextFrame.value;
        var tan1 = nextFrame.inTangent;
        var t2 = t * t;
        var t3 = t2 * t;
        var a = 2.0 * t3 - 3.0 * t2 + 1.0;
        var b = t3 - 2.0 * t2 + t;
        var c = t3 - t2;
        var d = -2 * t3 + 3.0 * t2;
        var t0 = tan0.x, t1 = tan1.x;
        if (Number.isFinite(t0) && Number.isFinite(t1)) {
            out.x = a * p0.x + b * t0 * dur + c * t1 * dur + d * p1.x;
        } else {
            out.x = p0.x;
        }
        t0 = tan0.y, t1 = tan1.y;
        if (Number.isFinite(t0) && Number.isFinite(t1)) {
            out.y = a * p0.y + b * t0 * dur + c * t1 * dur + d * p1.y;
        } else {
            out.y = p0.y;
        }
        t0 = tan0.z, t1 = tan1.z;
        if (Number.isFinite(t0) && Number.isFinite(t1)) {
            out.z = a * p0.z + b * t0 * dur + c * t1 * dur + d * p1.z;
        } else {
            out.z = p0.z;
        }
        return out;
    };
    return AnimationVector3Curve;
}(AnimationCurve);
/** @internal */ AnimationVector3Curve._isCopyMode = true;
/** @internal */ AnimationVector3Curve._supportInterpolationMode = true;
AnimationVector3Curve = __decorate$1([
    StaticInterfaceImplement()
], AnimationVector3Curve);

var AnimationVector4Curve = /*#__PURE__*/ function(AnimationCurve) {
    _inherits$2(AnimationVector4Curve, AnimationCurve);
    function AnimationVector4Curve() {
        var _this;
        _this = AnimationCurve.call(this) || this;
        _this._evaluateData.value = new Vector4();
        return _this;
    }
    /**
   * @internal
   */ AnimationVector4Curve._initializeOwner = function _initializeOwner(owner) {
        owner.defaultValue = new Vector4();
        owner.fixedPoseValue = new Vector4();
        owner.baseEvaluateData.value = new Vector4();
        owner.crossEvaluateData.value = new Vector4();
    };
    /**
   * @internal
   */ AnimationVector4Curve._initializeLayerOwner = function _initializeLayerOwner(owner) {
        owner.finalValue = new Vector4();
    };
    /**
   * @internal
   */ AnimationVector4Curve._lerpValue = function _lerpValue(srcValue, destValue, weight, out) {
        Vector4.lerp(srcValue, destValue, weight, out);
        return out;
    };
    /**
   * @internal
   */ AnimationVector4Curve._additiveValue = function _additiveValue(value, weight, out) {
        Vector4.scale(value, weight, value);
        Vector4.add(out, value, out);
        return out;
    };
    /**
   * @internal
   */ AnimationVector4Curve._subtractValue = function _subtractValue(src, base, out) {
        Vector4.subtract(src, base, out);
        return out;
    };
    /**
   * @internal
   */ AnimationVector4Curve._getZeroValue = function _getZeroValue(out) {
        out.set(0, 0, 0, 0);
        return out;
    };
    /**
   * @internal
   */ AnimationVector4Curve._setValue = function _setValue(source, out) {
        out.copyFrom(source);
        return out;
    };
    /**
   * @internal
   */ AnimationVector4Curve._hermiteInterpolationValue = function _hermiteInterpolationValue(frame, nextFrame, t, dur, out) {
        var p0 = frame.value;
        var tan0 = frame.outTangent;
        var p1 = nextFrame.value;
        var tan1 = nextFrame.inTangent;
        var t2 = t * t;
        var t3 = t2 * t;
        var a = 2.0 * t3 - 3.0 * t2 + 1.0;
        var b = t3 - 2.0 * t2 + t;
        var c = t3 - t2;
        var d = -2 * t3 + 3.0 * t2;
        var t0 = tan0.x, t1 = tan1.x;
        if (Number.isFinite(t0) && Number.isFinite(t1)) {
            out.x = a * p0.x + b * t0 * dur + c * t1 * dur + d * p1.x;
        } else {
            out.x = p0.x;
        }
        t0 = tan0.y, t1 = tan1.y;
        if (Number.isFinite(t0) && Number.isFinite(t1)) {
            out.y = a * p0.y + b * t0 * dur + c * t1 * dur + d * p1.y;
        } else {
            out.y = p0.y;
        }
        t0 = tan0.z, t1 = tan1.z;
        if (Number.isFinite(t0) && Number.isFinite(t1)) {
            out.z = a * p0.z + b * t0 * dur + c * t1 * dur + d * p1.z;
        } else {
            out.z = p0.z;
        }
        t0 = tan0.w, t1 = tan1.w;
        if (Number.isFinite(t0) && Number.isFinite(t1)) {
            out.w = a * p0.w + b * t0 * dur + c * t1 * dur + d * p1.w;
        } else {
            out.w = p0.w;
        }
        return out;
    };
    return AnimationVector4Curve;
}(AnimationCurve);
/** @internal */ AnimationVector4Curve._isCopyMode = true;
/** @internal */ AnimationVector4Curve._supportInterpolationMode = true;
AnimationVector4Curve = __decorate$1([
    StaticInterfaceImplement()
], AnimationVector4Curve);

var AnimationRefCurve = /*#__PURE__*/ function(AnimationCurve) {
    _inherits$2(AnimationRefCurve, AnimationCurve);
    function AnimationRefCurve() {
        return AnimationCurve.call(this) || this;
    }
    /**
   * @internal
   */ AnimationRefCurve._initializeOwner = function _initializeOwner(owner) {};
    /**
   * @internal
   */ AnimationRefCurve._initializeLayerOwner = function _initializeLayerOwner(owner) {};
    /**
   * @internal
   */ AnimationRefCurve._setValue = function _setValue(value) {
        return value;
    };
    return AnimationRefCurve;
}(AnimationCurve);
/** @internal */ AnimationRefCurve._isCopyMode = false;
/** @internal */ AnimationRefCurve._supportInterpolationMode = false;
AnimationRefCurve = __decorate$1([
    StaticInterfaceImplement()
], AnimationRefCurve);

var AnimationRectCurve = /*#__PURE__*/ function(AnimationCurve) {
    _inherits$2(AnimationRectCurve, AnimationCurve);
    function AnimationRectCurve() {
        var _this;
        _this = AnimationCurve.call(this) || this;
        _this._evaluateData.value = new Rect();
        return _this;
    }
    /**
   * @internal
   */ AnimationRectCurve._initializeOwner = function _initializeOwner(owner) {
        owner.defaultValue = new Rect();
        owner.fixedPoseValue = new Rect();
        owner.baseEvaluateData.value = new Rect();
        owner.crossEvaluateData.value = new Rect();
    };
    /**
   * @internal
   */ AnimationRectCurve._initializeLayerOwner = function _initializeLayerOwner(owner) {
        owner.finalValue = new Rect();
    };
    /**
   * @internal
   */ AnimationRectCurve._setValue = function _setValue(source, out) {
        out.copyFrom(source);
        return out;
    };
    return AnimationRectCurve;
}(AnimationCurve);
/** @internal */ AnimationRectCurve._isCopyMode = true;
/** @internal */ AnimationRectCurve._supportInterpolationMode = false;
AnimationRectCurve = __decorate$1([
    StaticInterfaceImplement()
], AnimationRectCurve);

var AnimationStringCurve = /*#__PURE__*/ function(AnimationCurve) {
    _inherits$2(AnimationStringCurve, AnimationCurve);
    function AnimationStringCurve() {
        var _this;
        _this = AnimationCurve.call(this) || this;
        _this._evaluateData.value = "";
        return _this;
    }
    /**
   * @internal
   */ AnimationStringCurve._initializeOwner = function _initializeOwner(owner) {
        owner.defaultValue = "";
        owner.fixedPoseValue = "";
        owner.baseEvaluateData.value = "";
        owner.crossEvaluateData.value = "";
    };
    /**
   * @internal
   */ AnimationStringCurve._initializeLayerOwner = function _initializeLayerOwner(owner) {
        owner.finalValue = "";
    };
    /**
   * @internal
   */ AnimationStringCurve._lerpValue = function _lerpValue(srcValue, destValue) {
        return srcValue;
    };
    /**
   * @internal
   */ AnimationStringCurve._subtractValue = function _subtractValue(src, base, out) {
        return src;
    };
    /**
   * @internal
   */ AnimationStringCurve._getZeroValue = function _getZeroValue() {
        return "";
    };
    /**
   * @internal
   */ AnimationStringCurve._additiveValue = function _additiveValue(value, weight, source) {
        return value;
    };
    /**
   * @internal
   */ AnimationStringCurve._setValue = function _setValue(value) {
        return value;
    };
    /**
   * @internal
   */ AnimationStringCurve._hermiteInterpolationValue = function _hermiteInterpolationValue(frame) {
        return frame.value;
    };
    return AnimationStringCurve;
}(AnimationCurve);
/** @internal */ AnimationStringCurve._isCopyMode = false;
/** @internal */ AnimationStringCurve._supportInterpolationMode = false;
AnimationStringCurve = __decorate$1([
    StaticInterfaceImplement()
], AnimationStringCurve);

/**
 * The mode of the animator condition.
 */ var AnimatorConditionMode = /*#__PURE__*/ function(AnimatorConditionMode) {
    /** The condition is true when the parameter value is true. */ AnimatorConditionMode[AnimatorConditionMode["If"] = 0] = "If";
    /** The condition is true when the parameter value is false. */ AnimatorConditionMode[AnimatorConditionMode["IfNot"] = 1] = "IfNot";
    /** The condition is true when the parameter value is greater than the threshold. */ AnimatorConditionMode[AnimatorConditionMode["Greater"] = 2] = "Greater";
    /** The condition is true when the parameter value is less than the threshold. */ AnimatorConditionMode[AnimatorConditionMode["Less"] = 3] = "Less";
    /** The condition is true when the parameter value is equal to the threshold. */ AnimatorConditionMode[AnimatorConditionMode["Equals"] = 4] = "Equals";
    /** The condition is true when the parameter value is not equal to the threshold. */ AnimatorConditionMode[AnimatorConditionMode["NotEquals"] = 5] = "NotEquals";
    return AnimatorConditionMode;
}({});

/**
 * Animator culling mode.
 */ var AnimatorCullingMode = /*#__PURE__*/ function(AnimatorCullingMode) {
    /** Disable Culling. */ AnimatorCullingMode[AnimatorCullingMode["None"] = 0] = "None";
    /** Completely disabled when renderers are all culled. */ AnimatorCullingMode[AnimatorCullingMode["Complete"] = 1] = "Complete";
    return AnimatorCullingMode;
}({});

var AnimatorLayerBlendingMode = /*#__PURE__*/ function(AnimatorLayerBlendingMode) {
    AnimatorLayerBlendingMode[AnimatorLayerBlendingMode["Override"] = 0] = "Override";
    AnimatorLayerBlendingMode[AnimatorLayerBlendingMode["Additive"] = 1] = "Additive";
    return AnimatorLayerBlendingMode;
}({});

/**
 * @internal
 */ var AnimatorStatePlayState = /*#__PURE__*/ function(AnimatorStatePlayState) {
    AnimatorStatePlayState[AnimatorStatePlayState["UnStarted"] = 0] = "UnStarted";
    AnimatorStatePlayState[AnimatorStatePlayState["Playing"] = 1] = "Playing";
    AnimatorStatePlayState[AnimatorStatePlayState["Finished"] = 2] = "Finished";
    return AnimatorStatePlayState;
}({});

/**
 * Layer state.
 */ var LayerState = /*#__PURE__*/ function(LayerState) {
    /** Standby state. */ LayerState[LayerState["Standby"] = 0] = "Standby";
    /** Playing state. */ LayerState[LayerState["Playing"] = 1] = "Playing";
    /** CrossFading state. */ LayerState[LayerState["CrossFading"] = 2] = "CrossFading";
    /** FixedCrossFading state. */ LayerState[LayerState["FixedCrossFading"] = 3] = "FixedCrossFading";
    /** Finished state. */ LayerState[LayerState["Finished"] = 4] = "Finished";
    return LayerState;
}({});

/**
 * @internal
 */ var AnimationEventHandler = /*#__PURE__*/ function() {
    function AnimationEventHandler() {
        this.handlers = [];
    }
    var _proto = AnimationEventHandler.prototype;
    _proto.dispose = function dispose() {};
    return AnimationEventHandler;
}();

function _type_of$1(obj) {
    "@swc/helpers - typeof";

    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}

/**
 * Condition that is used to determine if a transition must be taken.
 */ var AnimatorCondition = function AnimatorCondition() {
};

/**
 * Transitions define when and how the state machine switch from on state to another. AnimatorTransition always originate from a StateMachine or a StateMachine entry.
 */ var AnimatorStateTransition = /*#__PURE__*/ function() {
    function AnimatorStateTransition() {
        /** The duration of the transition. The duration is in normalized time by default. To set it to be in seconds, set isFixedDuration to true. */ this.duration = 0;
        /** The time at which the destination state will start. This is represented in normalized time. */ this.offset = 0;
        /** ExitTime represents the exact time at which the transition can take effect. This is represented in normalized time. */ this.exitTime = 1.0;
        /** Mutes the transition. The transition will never occur. */ this.mute = false;
        /** Determines whether the duration of the transition is reported in a fixed duration in seconds or as a normalized time. */ this.isFixedDuration = false;
        /** @internal */ this._isExit = false;
        this._conditions = [];
        this._solo = false;
        this._hasExitTime = true;
    }
    var _proto = AnimatorStateTransition.prototype;
    _proto.addCondition = function addCondition(param, mode, threshold) {
        if ((typeof param === "undefined" ? "undefined" : _type_of$1(param)) === "object") {
            this._conditions.push(param);
            return param;
        } else {
            var condition = new AnimatorCondition();
            condition.parameterName = param;
            condition.mode = mode != null ? mode : AnimatorConditionMode.If;
            condition.threshold = threshold;
            this._conditions.push(condition);
            return condition;
        }
    };
    /**
   * Remove a condition from the transition.
   * @param condition - The condition to remove
   */ _proto.removeCondition = function removeCondition(condition) {
        var index = this._conditions.indexOf(condition);
        index !== -1 && this._conditions.splice(index, 1);
    };
    /**
   * @internal
   */ _proto._getFixedDuration = function _getFixedDuration() {
        return this.isFixedDuration ? this.duration : this.duration * this.destinationState._getDuration();
    };
    _create_class$2(AnimatorStateTransition, [
        {
            key: "isExit",
            get: /**
   * Is the transition destination the exit of the current state machine.
   */ function get() {
                return this._isExit;
            }
        },
        {
            key: "solo",
            get: /**
   * Mutes all other transitions in the source state.
   */ function get() {
                return this._solo;
            },
            set: function set(value) {
                var _this__collection;
                if (this._solo === value) return;
                this._solo = value;
                (_this__collection = this._collection) == null ? void 0 : _this__collection.updateTransitionSolo(value);
            }
        },
        {
            key: "conditions",
            get: /**
   * The conditions in the transition.
   */ function get() {
                return this._conditions;
            }
        },
        {
            key: "hasExitTime",
            get: /**
   * When active the transition will have an exit time condition.
   */ function get() {
                return this._hasExitTime;
            },
            set: function set(value) {
                var _this__collection;
                if (this._hasExitTime === value) return;
                this._hasExitTime = value;
                (_this__collection = this._collection) == null ? void 0 : _this__collection.updateTransitionsIndex(this, value);
            }
        }
    ]);
    return AnimatorStateTransition;
}();

/**
 * Animation wrap mode.
 */ var WrapMode = /*#__PURE__*/ function(WrapMode) {
    /** Play once */ WrapMode[WrapMode["Once"] = 0] = "Once";
    /** Loop play */ WrapMode[WrapMode["Loop"] = 1] = "Loop";
    return WrapMode;
}({});

/**
 * @internal
 */ var AnimatorStatePlayData = /*#__PURE__*/ function() {
    function AnimatorStatePlayData() {
        this.isForward = true;
        this._changedOrientation = false;
    }
    var _proto = AnimatorStatePlayData.prototype;
    _proto.reset = function reset(state, stateData, offsetFrameTime) {
        this.state = state;
        this.playedTime = 0;
        this.offsetFrameTime = offsetFrameTime;
        this.stateData = stateData;
        this.playState = AnimatorStatePlayState.UnStarted;
        this.clipTime = state.clipStartTime * state.clip.length;
        this.currentEventIndex = 0;
        this.isForward = true;
        this.state._transitionCollection.needResetCurrentCheckIndex = true;
    };
    _proto.updateOrientation = function updateOrientation(deltaTime) {
        if (deltaTime !== 0) {
            var lastIsForward = this.isForward;
            this.isForward = deltaTime > 0;
            if (this.isForward !== lastIsForward) {
                this._changedOrientation = true;
                this.isForward || this._correctTime();
            }
        }
    };
    _proto.update = function update(deltaTime) {
        this.playedTime += deltaTime;
        var state = this.state;
        var time = this.playedTime + this.offsetFrameTime;
        var duration = state._getDuration();
        this.playState = AnimatorStatePlayState.Playing;
        if (state.wrapMode === WrapMode.Loop) {
            time = duration ? time % duration : 0;
        } else {
            if (Math.abs(time) >= duration) {
                time = time < 0 ? -duration : duration;
                this.playState = AnimatorStatePlayState.Finished;
            }
        }
        time < 0 && (time += duration);
        this.clipTime = time + state.clipStartTime * state.clip.length;
        if (this._changedOrientation) {
            !this.isForward && this._correctTime();
            this._changedOrientation = false;
        }
    };
    _proto._correctTime = function _correctTime() {
        var state = this.state;
        if (this.clipTime === 0) {
            this.clipTime = state.clipEndTime * state.clip.length;
        }
    };
    return AnimatorStatePlayData;
}();

/**
 * @internal
 */ var AnimatorLayerData = /*#__PURE__*/ function() {
    function AnimatorLayerData() {
        this.curveOwnerPool = Object.create(null);
        this.animatorStateDataMap = {};
        this.srcPlayData = new AnimatorStatePlayData();
        this.destPlayData = new AnimatorStatePlayData();
        this.layerState = LayerState.Standby;
        this.crossCurveMark = 0;
        this.manuallyTransition = new AnimatorStateTransition();
        this.crossLayerOwnerCollection = [];
    }
    var _proto = AnimatorLayerData.prototype;
    _proto.switchPlayData = function switchPlayData() {
        var srcPlayData = this.destPlayData;
        var switchTemp = this.srcPlayData;
        this.srcPlayData = srcPlayData;
        this.destPlayData = switchTemp;
    };
    _proto.resetCurrentCheckIndex = function resetCurrentCheckIndex() {
        this.layer.stateMachine._entryTransitionCollection.needResetCurrentCheckIndex = true;
        this.layer.stateMachine._anyStateTransitionCollection.needResetCurrentCheckIndex = true;
    };
    return AnimatorLayerData;
}();

/**
 * @internal
 */ var AnimatorStateData = function AnimatorStateData() {
    this.curveLayerOwner = [];
    this.eventHandlers = [];
};

/**
 * The controller of the animation system.
 */ var Animator = /*#__PURE__*/ function(Component) {
    _inherits$2(Animator, Component);
    function Animator(entity) {
        var _this;
        _this = Component.call(this, entity) || this, /** Culling mode of this Animator. */ _this.cullingMode = AnimatorCullingMode.None, /** The playback speed of the Animator, 1.0 is normal playback speed. */ _this.speed = 1.0, /** @internal */ _this._playFrameCount = -1, /** @internal */ _this._onUpdateIndex = -1, _this._updateMark = 0, _this._animatorLayersData = new Array(), _this._curveOwnerPool = Object.create(null), _this._animationEventHandlerPool = new ClearableObjectPool(AnimationEventHandler), _this._parametersValueMap = Object.create(null), _this._tempAnimatorStateInfo = {
            layerIndex: -1,
            state: null
        }, _this._controlledRenderers = new Array();
        return _this;
    }
    var _proto = Animator.prototype;
    /**
   * Play a state by name.
   * @param stateName - The state name
   * @param layerIndex - The layer index(default -1). If layer is -1, play the first state with the given state name
   * @param normalizedTimeOffset - The normalized time offset (between 0 and 1, default 0) to start the state's animation from
   */ _proto.play = function play(stateName, layerIndex, normalizedTimeOffset) {
        if (layerIndex === void 0) layerIndex = -1;
        if (normalizedTimeOffset === void 0) normalizedTimeOffset = 0;
        var _this__controllerUpdateFlag;
        if ((_this__controllerUpdateFlag = this._controllerUpdateFlag) == null ? void 0 : _this__controllerUpdateFlag.flag) {
            this._reset();
        }
        var stateInfo = this._getAnimatorStateInfo(stateName, layerIndex);
        var state = stateInfo.state;
        if (!state) {
            return;
        }
        if (this._preparePlay(state, stateInfo.layerIndex, normalizedTimeOffset)) {
            this._playFrameCount = this.engine.time.frameCount;
        }
    };
    /**
   * Create a cross fade from the current state to another state with a normalized duration.
   * @param stateName - The state name
   * @param normalizedDuration - The normalized duration of the transition, relative to the destination state's duration (range: 0 to 1)
   * @param layerIndex - The layer index(default -1). If layer is -1, play the first state with the given state name
   * @param normalizedTimeOffset - The normalized time offset (between 0 and 1, default 0) to start the destination state's animation from
   */ _proto.crossFade = function crossFade(stateName, normalizedDuration, layerIndex, normalizedTimeOffset) {
        if (layerIndex === void 0) layerIndex = -1;
        if (normalizedTimeOffset === void 0) normalizedTimeOffset = 0;
        this._crossFade(stateName, normalizedDuration, layerIndex, normalizedTimeOffset, false);
    };
    /**
   * Create a cross fade from the current state to another state with a fixed duration.
   * @param stateName - The state name
   * @param fixedDuration - The duration of the transition in seconds
   * @param layerIndex - The layer index(default -1). If layer is -1, play the first state with the given state name
   * @param normalizedTimeOffset - The normalized time offset (between 0 and 1, default 0) to start the destination state's animation from
   */ _proto.crossFadeInFixedDuration = function crossFadeInFixedDuration(stateName, fixedDuration, layerIndex, normalizedTimeOffset) {
        if (layerIndex === void 0) layerIndex = -1;
        if (normalizedTimeOffset === void 0) normalizedTimeOffset = 0;
        this._crossFade(stateName, fixedDuration, layerIndex, normalizedTimeOffset, true);
    };
    /**
   * Evaluates the animator component based on deltaTime.
   * @param deltaTime - The deltaTime when the animation update
   */ _proto.update = function update(deltaTime) {
        var _this__controllerUpdateFlag;
        // Play or crossFade in script, animation playing from the first frame, deltaTime should be 0
        if (this._playFrameCount === this.engine.time.frameCount) {
            deltaTime = 0;
        }
        var animationUpdate;
        if (this.cullingMode === AnimatorCullingMode.Complete) {
            animationUpdate = false;
            var controlledRenderers = this._controlledRenderers;
            for(var i = 0, n = controlledRenderers.length; i < n; i++){
                if (!controlledRenderers[i].isCulled) {
                    animationUpdate = true;
                    break;
                }
            }
        } else {
            animationUpdate = true;
        }
        var animatorController = this._animatorController;
        if (!animatorController) {
            return;
        }
        if ((_this__controllerUpdateFlag = this._controllerUpdateFlag) == null ? void 0 : _this__controllerUpdateFlag.flag) {
            this._reset();
        }
        this._updateMark++;
        var layers = animatorController.layers;
        for(var i1 = 0, n1 = layers.length; i1 < n1; i1++){
            var layerData = this._getAnimatorLayerData(i1);
            this._updateState(layerData, deltaTime, animationUpdate);
        }
    };
    /**
   * Get the playing state from the target layerIndex.
   * @param layerIndex - The layer index
   */ _proto.getCurrentAnimatorState = function getCurrentAnimatorState(layerIndex) {
        var _this__animatorLayersData_layerIndex_srcPlayData, _this__animatorLayersData_layerIndex;
        return (_this__animatorLayersData_layerIndex = this._animatorLayersData[layerIndex]) == null ? void 0 : (_this__animatorLayersData_layerIndex_srcPlayData = _this__animatorLayersData_layerIndex.srcPlayData) == null ? void 0 : _this__animatorLayersData_layerIndex_srcPlayData.state;
    };
    /**
   * Get the state by name.
   * @param stateName - The state name
   * @param layerIndex - The layer index(default -1). If layer is -1, find the first state with the given state name
   */ _proto.findAnimatorState = function findAnimatorState(stateName, layerIndex) {
        if (layerIndex === void 0) layerIndex = -1;
        return this._getAnimatorStateInfo(stateName, layerIndex).state;
    };
    /**
   * Get the layer by name.
   * @param name - The layer's name.
   */ _proto.findLayerByName = function findLayerByName(name) {
        var _this__animatorController;
        return (_this__animatorController = this._animatorController) == null ? void 0 : _this__animatorController._layersMap[name];
    };
    /**
   * Get the parameter by name from animatorController.
   * @param name - The name of the parameter
   */ _proto.getParameter = function getParameter(name) {
        var _this__animatorController;
        var _this__animatorController__parametersMap_name;
        return (_this__animatorController__parametersMap_name = (_this__animatorController = this._animatorController) == null ? void 0 : _this__animatorController._parametersMap[name]) != null ? _this__animatorController__parametersMap_name : null;
    };
    /**
   * Get the value of the given parameter.
   * @param name - The name of the parameter
   * @param value - The value of the parameter
   */ _proto.getParameterValue = function getParameterValue(name) {
        var _this__animatorController;
        var parameter = (_this__animatorController = this._animatorController) == null ? void 0 : _this__animatorController._parametersMap[name];
        if (parameter) {
            var _this__parametersValueMap_name;
            return (_this__parametersValueMap_name = this._parametersValueMap[name]) != null ? _this__parametersValueMap_name : parameter.defaultValue;
        }
        return undefined;
    };
    /**
   * Set the value of the given parameter.
   * @param name - The name of the parameter
   * @param value - The value of the parameter
   */ _proto.setParameterValue = function setParameterValue(name, value) {
        var _this__animatorController;
        var parameter = (_this__animatorController = this._animatorController) == null ? void 0 : _this__animatorController._parametersMap[name];
        if (parameter) {
            this._parametersValueMap[name] = value;
        }
    };
    /**
   * Activate the trigger parameter by name.
   * @param name - The name of the trigger parameter
   */ _proto.activateTriggerParameter = function activateTriggerParameter(name) {
        var _this__animatorController;
        var parameter = (_this__animatorController = this._animatorController) == null ? void 0 : _this__animatorController._parametersMap[name];
        if (parameter == null ? void 0 : parameter._isTrigger) {
            this._parametersValueMap[name] = true;
        }
    };
    /**
   * Reset the trigger parameter to deactivate it by name.
   * @param name - The name of the trigger parameter
   */ _proto.deactivateTriggerParameter = function deactivateTriggerParameter(name) {
        var _this__animatorController;
        var parameter = (_this__animatorController = this._animatorController) == null ? void 0 : _this__animatorController._parametersMap[name];
        if (parameter == null ? void 0 : parameter._isTrigger) {
            this._parametersValueMap[name] = false;
        }
    };
    /**
   * @internal
   */ _proto._onEnable = function _onEnable() {
        this._reset();
        this._entity.getComponentsIncludeChildren(Renderer, this._controlledRenderers);
    };
    /**
   * @internal
   */ _proto._onEnableInScene = function _onEnableInScene() {
        this.scene._componentsManager.addOnUpdateAnimations(this);
    };
    /**
   * @internal
   */ _proto._onDisableInScene = function _onDisableInScene() {
        this.scene._componentsManager.removeOnUpdateAnimations(this);
    };
    /**
   * @internal
   */ _proto._reset = function _reset() {
        var _this = this, animationCurveOwners = _this._curveOwnerPool;
        for(var instanceId in animationCurveOwners){
            var propertyOwners = animationCurveOwners[instanceId];
            for(var property in propertyOwners){
                var owner = propertyOwners[property];
                owner.revertDefaultValue();
            }
        }
        this._animatorLayersData.length = 0;
        this._curveOwnerPool = Object.create(null);
        this._parametersValueMap = Object.create(null);
        this._animationEventHandlerPool.clear();
        if (this._controllerUpdateFlag) {
            this._controllerUpdateFlag.flag = false;
        }
    };
    _proto._crossFade = function _crossFade(stateName, duration, layerIndex, normalizedTimeOffset, isFixedDuration) {
        var _this__controllerUpdateFlag;
        if ((_this__controllerUpdateFlag = this._controllerUpdateFlag) == null ? void 0 : _this__controllerUpdateFlag.flag) {
            this._reset();
        }
        var _this__getAnimatorStateInfo = this._getAnimatorStateInfo(stateName, layerIndex), state = _this__getAnimatorStateInfo.state, playLayerIndex = _this__getAnimatorStateInfo.layerIndex;
        var manuallyTransition = this._getAnimatorLayerData(playLayerIndex).manuallyTransition;
        manuallyTransition.duration = duration;
        manuallyTransition.offset = normalizedTimeOffset;
        manuallyTransition.isFixedDuration = isFixedDuration;
        manuallyTransition.destinationState = state;
        if (this._prepareCrossFadeByTransition(manuallyTransition, playLayerIndex)) {
            this._playFrameCount = this.engine.time.frameCount;
        }
    };
    _proto._getAnimatorStateInfo = function _getAnimatorStateInfo(stateName, layerIndex) {
        var _this = this, animatorController = _this._animatorController, stateInfo = _this._tempAnimatorStateInfo;
        var state = null;
        if (animatorController) {
            var layers = animatorController.layers;
            if (layerIndex === -1) {
                for(var i = 0, n = layers.length; i < n; i++){
                    state = layers[i].stateMachine.findStateByName(stateName);
                    if (state) {
                        layerIndex = i;
                        break;
                    }
                }
            } else {
                state = layers[layerIndex].stateMachine.findStateByName(stateName);
            }
        }
        stateInfo.layerIndex = layerIndex;
        stateInfo.state = state;
        return stateInfo;
    };
    _proto._getAnimatorStateData = function _getAnimatorStateData(stateName, animatorState, animatorLayerData, layerIndex) {
        var animatorStateDataMap = animatorLayerData.animatorStateDataMap;
        var animatorStateData = animatorStateDataMap[stateName];
        if (!animatorStateData) {
            animatorStateData = new AnimatorStateData();
            animatorStateDataMap[stateName] = animatorStateData;
            this._saveAnimatorStateData(animatorState, animatorStateData, animatorLayerData, layerIndex);
            this._saveAnimatorEventHandlers(animatorState, animatorStateData);
        }
        return animatorStateData;
    };
    _proto._saveAnimatorStateData = function _saveAnimatorStateData(animatorState, animatorStateData, animatorLayerData, layerIndex) {
        var _this = this, entity = _this.entity, curveOwnerPool = _this._curveOwnerPool;
        var mask = this._animatorController.layers[layerIndex].mask;
        var curveLayerOwner = animatorStateData.curveLayerOwner;
        var _animatorState_clip = animatorState.clip, curves = _animatorState_clip._curveBindings;
        var layerCurveOwnerPool = animatorLayerData.curveOwnerPool;
        var components = AnimationCurveOwner._components;
        for(var i = curves.length - 1; i >= 0; i--){
            var curve = curves[i];
            var relativePath = curve.relativePath;
            var targetEntity = curve.relativePath === "" ? entity : entity.findByPath(curve.relativePath);
            if (targetEntity) {
                var _curveOwnerPool, _instanceId, _propertyOwners, _property, _layerCurveOwnerPool, _instanceId1, _layerPropertyOwners, _property1;
                var component = curve.typeIndex > 0 ? targetEntity.getComponents(curve.type, components)[curve.typeIndex] : targetEntity.getComponent(curve.type);
                components.length = 0;
                if (!component) {
                    continue;
                }
                var property = curve.property;
                var instanceId = component.instanceId;
                // Get owner
                var propertyOwners = (_curveOwnerPool = curveOwnerPool)[_instanceId = instanceId] || (_curveOwnerPool[_instanceId] = Object.create(null));
                var owner = (_propertyOwners = propertyOwners)[_property = property] || (_propertyOwners[_property] = curve._createCurveOwner(targetEntity, component));
                // Get layer owner
                var layerPropertyOwners = (_layerCurveOwnerPool = layerCurveOwnerPool)[_instanceId1 = instanceId] || (_layerCurveOwnerPool[_instanceId1] = Object.create(null));
                var layerOwner = (_layerPropertyOwners = layerPropertyOwners)[_property1 = property] || (_layerPropertyOwners[_property1] = curve._createCurveLayerOwner(owner));
                if (mask && mask.pathMasks.length) {
                    var _mask_getPathMask;
                    var _mask_getPathMask_active;
                    layerOwner.isActive = (_mask_getPathMask_active = (_mask_getPathMask = mask.getPathMask(relativePath)) == null ? void 0 : _mask_getPathMask.active) != null ? _mask_getPathMask_active : true;
                }
                curveLayerOwner[i] = layerOwner;
            } else {
                curveLayerOwner[i] = null;
                Logger.warn("The entity don't have the child entity which path is " + curve.relativePath + ".");
            }
        }
    };
    _proto._saveAnimatorEventHandlers = function _saveAnimatorEventHandlers(state, animatorStateData) {
        var _this = this;
        var eventHandlerPool = this._animationEventHandlerPool;
        var scripts = [];
        var eventHandlers = animatorStateData.eventHandlers;
        var clipChangedListener = function() {
            _this._entity.getComponents(Script, scripts);
            var scriptCount = scripts.length;
            var events = state.clip.events;
            eventHandlers.length = 0;
            for(var i = 0, n = events.length; i < n; i++){
                var event = events[i];
                var eventHandler = eventHandlerPool.get();
                var funcName = event.functionName;
                var handlers = eventHandler.handlers;
                eventHandler.event = event;
                handlers.length = 0;
                for(var j = scriptCount - 1; j >= 0; j--){
                    var _script_funcName;
                    var script = scripts[j];
                    var handler = (_script_funcName = script[funcName]) == null ? void 0 : _script_funcName.bind(script);
                    handler && handlers.push(handler);
                }
                eventHandlers.push(eventHandler);
            }
        };
        clipChangedListener();
        state._updateFlagManager.addListener(clipChangedListener);
    };
    _proto._clearCrossData = function _clearCrossData(animatorLayerData) {
        animatorLayerData.crossCurveMark++;
        animatorLayerData.crossLayerOwnerCollection.length = 0;
    };
    _proto._addCrossOwner = function _addCrossOwner(animatorLayerData, layerOwner, curCurveIndex, nextCurveIndex) {
        layerOwner.crossSrcCurveIndex = curCurveIndex;
        layerOwner.crossDestCurveIndex = nextCurveIndex;
        animatorLayerData.crossLayerOwnerCollection.push(layerOwner);
    };
    _proto._prepareCrossFading = function _prepareCrossFading(animatorLayerData) {
        // Add src cross curve data
        this._prepareSrcCrossData(animatorLayerData, false);
        // Add dest cross curve data
        this._prepareDestCrossData(animatorLayerData, false);
    };
    _proto._prepareStandbyCrossFading = function _prepareStandbyCrossFading(animatorLayerData) {
        // Standby have two sub state, one is never play, one is finished, never play srcPlayData.state is null
        animatorLayerData.srcPlayData.state && this._prepareSrcCrossData(animatorLayerData, true);
        // Add dest cross curve data
        this._prepareDestCrossData(animatorLayerData, true);
    };
    _proto._prepareFixedPoseCrossFading = function _prepareFixedPoseCrossFading(animatorLayerData) {
        var crossLayerOwnerCollection = animatorLayerData.crossLayerOwnerCollection;
        // Save current cross curve data owner fixed pose
        for(var i = crossLayerOwnerCollection.length - 1; i >= 0; i--){
            var layerOwner = crossLayerOwnerCollection[i];
            if (!layerOwner) continue;
            layerOwner.curveOwner.saveFixedPoseValue();
            // Reset destCurveIndex When fixed pose crossFading again
            layerOwner.crossDestCurveIndex = -1;
        }
        // Prepare dest AnimatorState cross data
        this._prepareDestCrossData(animatorLayerData, true);
    };
    _proto._prepareSrcCrossData = function _prepareSrcCrossData(animatorLayerData, saveFixed) {
        var curveLayerOwner = animatorLayerData.srcPlayData.stateData.curveLayerOwner;
        for(var i = curveLayerOwner.length - 1; i >= 0; i--){
            var layerOwner = curveLayerOwner[i];
            if (!layerOwner) continue;
            layerOwner.crossCurveMark = animatorLayerData.crossCurveMark;
            saveFixed && layerOwner.curveOwner.saveFixedPoseValue();
            this._addCrossOwner(animatorLayerData, layerOwner, i, -1);
        }
    };
    _proto._prepareDestCrossData = function _prepareDestCrossData(animatorLayerData, saveFixed) {
        var curveLayerOwner = animatorLayerData.destPlayData.stateData.curveLayerOwner;
        for(var i = curveLayerOwner.length - 1; i >= 0; i--){
            var layerOwner = curveLayerOwner[i];
            if (!layerOwner) continue;
            if (layerOwner.crossCurveMark === animatorLayerData.crossCurveMark) {
                layerOwner.crossDestCurveIndex = i;
            } else {
                var owner = layerOwner.curveOwner;
                saveFixed && owner.saveFixedPoseValue();
                layerOwner.crossCurveMark = animatorLayerData.crossCurveMark;
                this._addCrossOwner(animatorLayerData, layerOwner, -1, i);
            }
        }
    };
    _proto._getAnimatorLayerData = function _getAnimatorLayerData(layerIndex) {
        var animatorLayerData = this._animatorLayersData[layerIndex];
        if (!animatorLayerData) {
            animatorLayerData = new AnimatorLayerData();
            animatorLayerData.layerIndex = layerIndex;
            animatorLayerData.layer = this._animatorController.layers[layerIndex];
            this._animatorLayersData[layerIndex] = animatorLayerData;
        }
        return animatorLayerData;
    };
    _proto._updateState = function _updateState(layerData, deltaTime, aniUpdate) {
        var layer = layerData.layer;
        var weight = layer.weight;
        var additive = layer.blendingMode === AnimatorLayerBlendingMode.Additive;
        layerData.layerIndex === 0 && (weight = 1.0);
        switch(layerData.layerState){
            case LayerState.Standby:
                this._checkAnyAndEntryState(layerData, deltaTime, aniUpdate);
                break;
            case LayerState.Playing:
                this._updatePlayingState(layerData, weight, additive, deltaTime, aniUpdate);
                break;
            case LayerState.Finished:
                this._updateFinishedState(layerData, weight, additive, deltaTime, aniUpdate);
                break;
            case LayerState.CrossFading:
                this._updateCrossFadeState(layerData, weight, additive, deltaTime, aniUpdate);
                break;
            case LayerState.FixedCrossFading:
                this._updateCrossFadeFromPoseState(layerData, weight, additive, deltaTime, aniUpdate);
                break;
        }
    };
    _proto._updatePlayingState = function _updatePlayingState(layerData, weight, additive, deltaTime, aniUpdate) {
        var srcPlayData = layerData.srcPlayData;
        var state = srcPlayData.state;
        var playSpeed = state.speed * this.speed;
        var playDeltaTime = playSpeed * deltaTime;
        srcPlayData.updateOrientation(playDeltaTime);
        var lastClipTime = srcPlayData.clipTime, lastPlayState = srcPlayData.playState;
        // Precalculate to get the transition
        srcPlayData.update(playDeltaTime);
        var clipTime = srcPlayData.clipTime, isForward = srcPlayData.isForward;
        var transitions = state._transitionCollection;
        var _layerData_layer_stateMachine = layerData.layer.stateMachine, anyStateTransitions = _layerData_layer_stateMachine._anyStateTransitionCollection;
        var transition = anyStateTransitions.count && this._applyStateTransitions(layerData, isForward, srcPlayData, anyStateTransitions, lastClipTime, clipTime, playDeltaTime, aniUpdate) || transitions.count && this._applyStateTransitions(layerData, isForward, srcPlayData, transitions, lastClipTime, clipTime, playDeltaTime, aniUpdate);
        var playCostTime;
        if (transition) {
            var clipEndTime = state._getClipActualEndTime();
            if (transition.hasExitTime) {
                var exitTime = transition.exitTime * state._getDuration() + state._getClipActualStartTime();
                if (isForward) {
                    if (exitTime < lastClipTime) {
                        playCostTime = exitTime + clipEndTime - lastClipTime;
                    } else {
                        playCostTime = exitTime - lastClipTime;
                    }
                } else {
                    var startTime = state._getClipActualStartTime();
                    if (lastClipTime < exitTime) {
                        playCostTime = clipEndTime - exitTime + lastClipTime - startTime;
                    } else {
                        playCostTime = lastClipTime - exitTime;
                    }
                    playCostTime = -playCostTime;
                }
            } else {
                playCostTime = 0;
            }
            // Revert actualDeltaTime and update playCostTime
            srcPlayData.update(playCostTime - playDeltaTime);
        } else {
            playCostTime = playDeltaTime;
            if (srcPlayData.playState === AnimatorStatePlayState.Finished) {
                layerData.layerState = LayerState.Finished;
            }
        }
        this._evaluatePlayingState(srcPlayData, weight, additive, aniUpdate);
        this._fireAnimationEventsAndCallScripts(layerData.layerIndex, srcPlayData, state, lastClipTime, lastPlayState, playCostTime);
        if (transition) {
            // Remove speed factor, use actual cost time
            var remainDeltaTime = deltaTime - playCostTime / playSpeed;
            remainDeltaTime > 0 && this._updateState(layerData, remainDeltaTime, aniUpdate);
        }
    };
    _proto._evaluatePlayingState = function _evaluatePlayingState(playData, weight, additive, aniUpdate) {
        var curveBindings = playData.state.clip._curveBindings;
        var finished = playData.playState === AnimatorStatePlayState.Finished;
        if (aniUpdate || finished) {
            var curveLayerOwner = playData.stateData.curveLayerOwner;
            for(var i = curveBindings.length - 1; i >= 0; i--){
                var layerOwner = curveLayerOwner[i];
                var owner = layerOwner == null ? void 0 : layerOwner.curveOwner;
                if (!owner || !layerOwner.isActive) {
                    continue;
                }
                var curve = curveBindings[i].curve;
                if (curve.keys.length) {
                    this._checkRevertOwner(owner, additive);
                    var value = owner.evaluateValue(curve, playData.clipTime, additive);
                    aniUpdate && owner.applyValue(value, weight, additive);
                    finished && layerOwner.saveFinalValue();
                }
            }
        }
    };
    _proto._updateCrossFadeState = function _updateCrossFadeState(layerData, weight, additive, deltaTime, aniUpdate) {
        var srcPlayData = layerData.srcPlayData, destPlayData = layerData.destPlayData, layerIndex = layerData.layerIndex;
        var speed = this.speed;
        var srcState = srcPlayData.state;
        var destState = destPlayData.state;
        var transitionDuration = layerData.crossFadeTransition._getFixedDuration();
        var srcPlaySpeed = srcState.speed * speed;
        var dstPlaySpeed = destState.speed * speed;
        var dstPlayDeltaTime = dstPlaySpeed * deltaTime;
        srcPlayData && srcPlayData.updateOrientation(srcPlaySpeed * deltaTime);
        destPlayData && destPlayData.updateOrientation(dstPlayDeltaTime);
        var lastSrcClipTime = srcPlayData.clipTime, lastSrcPlayState = srcPlayData.playState;
        var lastDestClipTime = destPlayData.clipTime, lastDstPlayState = destPlayData.playState;
        var dstPlayCostTime;
        if (destPlayData.isForward) {
            // The time that has been played
            var playedTime = destPlayData.playedTime;
            dstPlayCostTime = playedTime + dstPlayDeltaTime > transitionDuration ? transitionDuration - playedTime : dstPlayDeltaTime;
        } else {
            // The time that has been played
            var playedTime1 = destPlayData.playedTime;
            dstPlayCostTime = // -dstPlayDeltaTime: The time that will be played, negative are meant to make it be a periods
            // > transition: The time that will be played is enough to finish the transition
            playedTime1 - dstPlayDeltaTime > transitionDuration ? // -(transitionDuration - playedTime)
            playedTime1 - transitionDuration : dstPlayDeltaTime;
        }
        var actualCostTime = dstPlaySpeed === 0 ? deltaTime : dstPlayCostTime / dstPlaySpeed;
        var srcPlayCostTime = actualCostTime * srcPlaySpeed;
        srcPlayData.update(srcPlayCostTime);
        destPlayData.update(dstPlayCostTime);
        var crossWeight = Math.abs(destPlayData.playedTime) / transitionDuration;
        (crossWeight >= 1.0 - MathUtil.zeroTolerance || transitionDuration === 0) && (crossWeight = 1.0);
        var crossFadeFinished = crossWeight === 1.0;
        if (crossFadeFinished) {
            srcPlayData.playState = AnimatorStatePlayState.Finished;
            this._preparePlayOwner(layerData, destState);
            this._evaluatePlayingState(destPlayData, weight, additive, aniUpdate);
        } else {
            this._evaluateCrossFadeState(layerData, srcPlayData, destPlayData, weight, crossWeight, additive, aniUpdate);
        }
        this._fireAnimationEventsAndCallScripts(layerIndex, srcPlayData, srcState, lastSrcClipTime, lastSrcPlayState, srcPlayCostTime);
        this._fireAnimationEventsAndCallScripts(layerIndex, destPlayData, destState, lastDestClipTime, lastDstPlayState, dstPlayCostTime);
        if (crossFadeFinished) {
            this._updateCrossFadeData(layerData);
            var remainDeltaTime = deltaTime - actualCostTime;
            remainDeltaTime > 0 && this._updateState(layerData, remainDeltaTime, aniUpdate);
        }
    };
    _proto._evaluateCrossFadeState = function _evaluateCrossFadeState(layerData, srcPlayData, destPlayData, weight, crossWeight, additive, aniUpdate) {
        var crossLayerOwnerCollection = layerData.crossLayerOwnerCollection;
        var _srcPlayData_state_clip = srcPlayData.state.clip, srcCurves = _srcPlayData_state_clip._curveBindings;
        var destState = destPlayData.state;
        var _destState_clip = destState.clip, destCurves = _destState_clip._curveBindings;
        var finished = destPlayData.playState === AnimatorStatePlayState.Finished;
        if (aniUpdate || finished) {
            for(var i = crossLayerOwnerCollection.length - 1; i >= 0; i--){
                var layerOwner = crossLayerOwnerCollection[i];
                var owner = layerOwner == null ? void 0 : layerOwner.curveOwner;
                if (!owner) continue;
                var srcCurveIndex = layerOwner.crossSrcCurveIndex;
                var destCurveIndex = layerOwner.crossDestCurveIndex;
                this._checkRevertOwner(owner, additive);
                var value = owner.evaluateCrossFadeValue(srcCurveIndex >= 0 ? srcCurves[srcCurveIndex].curve : null, destCurveIndex >= 0 ? destCurves[destCurveIndex].curve : null, srcPlayData.clipTime, destPlayData.clipTime, crossWeight, additive);
                aniUpdate && owner.applyValue(value, weight, additive);
                finished && layerOwner.saveFinalValue();
            }
        }
    };
    _proto._updateCrossFadeFromPoseState = function _updateCrossFadeFromPoseState(layerData, weight, additive, deltaTime, aniUpdate) {
        var destPlayData = layerData.destPlayData;
        var state = destPlayData.state;
        var transitionDuration = layerData.crossFadeTransition._getFixedDuration();
        var playSpeed = state.speed * this.speed;
        var playDeltaTime = playSpeed * deltaTime;
        destPlayData.updateOrientation(playDeltaTime);
        var lastDestClipTime = destPlayData.clipTime, lastPlayState = destPlayData.playState;
        var dstPlayCostTime;
        if (destPlayData.isForward) {
            // The time that has been played
            var playedTime = destPlayData.playedTime;
            dstPlayCostTime = playedTime + playDeltaTime > transitionDuration ? transitionDuration - playedTime : playDeltaTime;
        } else {
            // The time that has been played
            var playedTime1 = destPlayData.playedTime;
            dstPlayCostTime = // -playDeltaTime: The time that will be played, negative are meant to make it be a periods
            // > transition: The time that will be played is enough to finish the transition
            playedTime1 - playDeltaTime > transitionDuration ? // -(transitionDuration - playedTime)
            playedTime1 - transitionDuration : playDeltaTime;
        }
        var actualCostTime = playSpeed === 0 ? deltaTime : dstPlayCostTime / playSpeed;
        destPlayData.update(dstPlayCostTime);
        var crossWeight = Math.abs(destPlayData.playedTime) / transitionDuration;
        (crossWeight >= 1.0 - MathUtil.zeroTolerance || transitionDuration === 0) && (crossWeight = 1.0);
        var crossFadeFinished = crossWeight === 1.0;
        if (crossFadeFinished) {
            this._preparePlayOwner(layerData, state);
            this._evaluatePlayingState(destPlayData, weight, additive, aniUpdate);
        } else {
            this._evaluateCrossFadeFromPoseState(layerData, destPlayData, weight, crossWeight, additive, aniUpdate);
        }
        this._fireAnimationEventsAndCallScripts(layerData.layerIndex, destPlayData, state, lastDestClipTime, lastPlayState, dstPlayCostTime);
        if (crossFadeFinished) {
            this._updateCrossFadeData(layerData);
            var remainDeltaTime = deltaTime - actualCostTime;
            remainDeltaTime > 0 && this._updateState(layerData, remainDeltaTime, aniUpdate);
        }
    };
    _proto._evaluateCrossFadeFromPoseState = function _evaluateCrossFadeFromPoseState(layerData, destPlayData, weight, crossWeight, additive, aniUpdate) {
        var crossLayerOwnerCollection = layerData.crossLayerOwnerCollection;
        var state = destPlayData.state;
        var _state_clip = state.clip, curveBindings = _state_clip._curveBindings;
        var destClipTime = destPlayData.clipTime, playState = destPlayData.playState;
        var finished = playState === AnimatorStatePlayState.Finished;
        // When the animator is culled (aniUpdate=false), if the play state has finished, the final value needs to be calculated and saved to be applied directly
        if (aniUpdate || finished) {
            for(var i = crossLayerOwnerCollection.length - 1; i >= 0; i--){
                var layerOwner = crossLayerOwnerCollection[i];
                var owner = layerOwner == null ? void 0 : layerOwner.curveOwner;
                if (!owner) continue;
                var curveIndex = layerOwner.crossDestCurveIndex;
                this._checkRevertOwner(owner, additive);
                var value = layerOwner.curveOwner.crossFadeFromPoseAndApplyValue(curveIndex >= 0 ? curveBindings[curveIndex].curve : null, destClipTime, crossWeight, additive);
                aniUpdate && owner.applyValue(value, weight, additive);
                finished && layerOwner.saveFinalValue();
            }
        }
    };
    _proto._updateFinishedState = function _updateFinishedState(layerData, weight, additive, deltaTime, aniUpdate) {
        var playData = layerData.srcPlayData;
        var state = playData.state;
        var actualSpeed = state.speed * this.speed;
        var actualDeltaTime = actualSpeed * deltaTime;
        playData.updateOrientation(actualDeltaTime);
        var clipTime = playData.clipTime, isForward = playData.isForward;
        var transitions = state._transitionCollection;
        var _layerData_layer_stateMachine = layerData.layer.stateMachine, anyStateTransitions = _layerData_layer_stateMachine._anyStateTransitionCollection;
        var transition = anyStateTransitions.count && this._applyTransitionsByCondition(layerData, anyStateTransitions, aniUpdate) || transitions.count && this._applyStateTransitions(layerData, isForward, playData, transitions, clipTime, clipTime, actualDeltaTime, aniUpdate);
        if (transition) {
            this._updateState(layerData, deltaTime, aniUpdate);
        } else {
            this._evaluateFinishedState(playData, weight, additive, aniUpdate);
        }
    };
    _proto._evaluateFinishedState = function _evaluateFinishedState(playData, weight, additive, aniUpdate) {
        if (!aniUpdate) {
            return;
        }
        var curveLayerOwner = playData.stateData.curveLayerOwner;
        var _playData_state_clip = playData.state.clip, curveBindings = _playData_state_clip._curveBindings;
        for(var i = curveBindings.length - 1; i >= 0; i--){
            var layerOwner = curveLayerOwner[i];
            var owner = layerOwner == null ? void 0 : layerOwner.curveOwner;
            if (!owner) continue;
            this._checkRevertOwner(owner, additive);
            owner.applyValue(layerOwner.finalValue, weight, additive);
        }
    };
    _proto._updateCrossFadeData = function _updateCrossFadeData(layerData) {
        var destPlayData = layerData.destPlayData;
        if (destPlayData.playState === AnimatorStatePlayState.Finished) {
            layerData.layerState = LayerState.Finished;
        } else {
            layerData.layerState = LayerState.Playing;
        }
        layerData.switchPlayData();
        layerData.crossFadeTransition = null;
    };
    _proto._preparePlayOwner = function _preparePlayOwner(layerData, playState) {
        if (layerData.layerState === LayerState.Playing) {
            var srcPlayData = layerData.srcPlayData;
            if (srcPlayData.state !== playState) {
                var curveLayerOwner = srcPlayData.stateData.curveLayerOwner;
                for(var i = curveLayerOwner.length - 1; i >= 0; i--){
                    var _curveLayerOwner_i;
                    (_curveLayerOwner_i = curveLayerOwner[i]) == null ? void 0 : _curveLayerOwner_i.curveOwner.revertDefaultValue();
                }
            }
        } else {
            var crossLayerOwnerCollection = layerData.crossLayerOwnerCollection;
            for(var i1 = crossLayerOwnerCollection.length - 1; i1 >= 0; i1--){
                crossLayerOwnerCollection[i1].curveOwner.revertDefaultValue();
            }
        }
    };
    _proto._applyStateTransitions = function _applyStateTransitions(layerData, isForward, playData, transitionCollection, lastClipTime, clipTime, deltaTime, aniUpdate) {
        var state = playData.state;
        var clipDuration = state.clip.length;
        var targetTransition = null;
        var startTime = state.clipStartTime * clipDuration;
        var endTime = state.clipEndTime * clipDuration;
        if (transitionCollection.noExitTimeCount) {
            targetTransition = this._checkNoExitTimeTransition(layerData, transitionCollection, aniUpdate);
            if (targetTransition) {
                return targetTransition;
            }
        }
        if (isForward) {
            if (lastClipTime + deltaTime >= endTime) {
                targetTransition = this._checkSubTransition(layerData, state, transitionCollection, lastClipTime, endTime, aniUpdate);
                if (!targetTransition) {
                    transitionCollection.needResetCurrentCheckIndex = true;
                    targetTransition = this._checkSubTransition(layerData, state, transitionCollection, startTime, clipTime, aniUpdate);
                }
            } else {
                targetTransition = this._checkSubTransition(layerData, state, transitionCollection, lastClipTime, clipTime, aniUpdate);
            }
        } else {
            //@todo backwards play currentIndex should not be 0
            if (lastClipTime + deltaTime <= startTime) {
                targetTransition = this._checkBackwardsSubTransition(layerData, state, transitionCollection, lastClipTime, startTime, aniUpdate);
                if (!targetTransition) {
                    transitionCollection.needResetCurrentCheckIndex = true;
                    targetTransition = this._checkBackwardsSubTransition(layerData, state, transitionCollection, clipTime, endTime, aniUpdate);
                }
            } else {
                targetTransition = this._checkBackwardsSubTransition(layerData, state, transitionCollection, lastClipTime, clipTime, aniUpdate);
            }
        }
        return targetTransition;
    };
    _proto._checkNoExitTimeTransition = function _checkNoExitTimeTransition(layerData, transitionCollection, aniUpdate) {
        for(var i = 0, n = transitionCollection.count; i < n; ++i){
            var transition = transitionCollection.get(i);
            if (transition.mute || transitionCollection.isSoloMode && !transition.solo || !this._checkConditions(transition)) continue;
            return this._applyTransition(layerData, transition, aniUpdate);
        }
        return null;
    };
    _proto._checkSubTransition = function _checkSubTransition(layerData, state, transitionCollection, lastClipTime, curClipTime, aniUpdate) {
        if (transitionCollection.needResetCurrentCheckIndex) transitionCollection.resetCurrentCheckIndex(true);
        var transitions = transitionCollection.transitions;
        var transitionIndex = transitionCollection.noExitTimeCount + transitionCollection.currentCheckIndex;
        for(var n = transitions.length; transitionIndex < n; transitionIndex++){
            var transition = transitions[transitionIndex];
            var exitTime = transition.exitTime * state._getDuration() + state._getClipActualStartTime();
            if (exitTime > curClipTime) {
                break;
            }
            if (exitTime < lastClipTime) continue;
            transitionCollection.updateCurrentCheckIndex(true);
            if (transition.mute || transitionCollection.isSoloMode && !transition.solo || !this._checkConditions(transition)) {
                continue;
            }
            return this._applyTransition(layerData, transition, aniUpdate);
        }
        return null;
    };
    _proto._checkBackwardsSubTransition = function _checkBackwardsSubTransition(layerData, state, transitionCollection, lastClipTime, curClipTime, aniUpdate) {
        if (transitionCollection.needResetCurrentCheckIndex) transitionCollection.resetCurrentCheckIndex(false);
        var transitions = transitionCollection.transitions, noExitTimeCount = transitionCollection.noExitTimeCount;
        var transitionIndex = transitionCollection.currentCheckIndex + noExitTimeCount;
        for(; transitionIndex >= noExitTimeCount; transitionIndex--){
            var transition = transitions[transitionIndex];
            var exitTime = transition.exitTime * state._getDuration() + state._getClipActualStartTime();
            if (exitTime < curClipTime) {
                break;
            }
            if (exitTime > lastClipTime) continue;
            transitionCollection.updateCurrentCheckIndex(false);
            if (transition.mute || transitionCollection.isSoloMode && !transition.solo || !this._checkConditions(transition)) {
                continue;
            }
            return this._applyTransition(layerData, transition, aniUpdate);
        }
        return null;
    };
    _proto._applyTransitionsByCondition = function _applyTransitionsByCondition(layerData, transitionCollection, aniUpdate) {
        for(var i = 0, n = transitionCollection.count; i < n; i++){
            var transition = transitionCollection.get(i);
            if (transition.mute) continue;
            if (transitionCollection.isSoloMode && !transition.solo) continue;
            if (this._checkConditions(transition)) {
                return this._applyTransition(layerData, transition, aniUpdate);
            }
        }
    };
    _proto._preparePlay = function _preparePlay(state, layerIndex, normalizedTimeOffset) {
        if (normalizedTimeOffset === void 0) normalizedTimeOffset = 0;
        var name = state.name;
        if (!state.clip) {
            Logger.warn("The state named " + name + " has no AnimationClip data.");
            return false;
        }
        var animatorLayerData = this._getAnimatorLayerData(layerIndex);
        var animatorStateData = this._getAnimatorStateData(name, state, animatorLayerData, layerIndex);
        this._preparePlayOwner(animatorLayerData, state);
        animatorLayerData.layerState = LayerState.Playing;
        animatorLayerData.srcPlayData.reset(state, animatorStateData, state._getClipActualEndTime() * normalizedTimeOffset);
        animatorLayerData.resetCurrentCheckIndex();
        return true;
    };
    _proto._applyTransition = function _applyTransition(layerData, transition, aniUpdate) {
        if (transition.isExit) {
            this._checkAnyAndEntryState(layerData, 0, aniUpdate);
            return null;
        }
        return this._prepareCrossFadeByTransition(transition, layerData.layerIndex) ? transition : null;
    };
    _proto._checkConditions = function _checkConditions(transition) {
        var conditions = transition.conditions;
        var allPass = true;
        for(var i = 0, n = conditions.length; i < n; ++i){
            var pass = false;
            var _conditions_i = conditions[i], mode = _conditions_i.mode, name = _conditions_i.parameterName, threshold = _conditions_i.threshold;
            var parameterValue = this.getParameterValue(name);
            if (parameterValue === undefined) {
                return false;
            }
            if (parameterValue === true) {
                var parameter = this.getParameter(name);
                if (parameter == null ? void 0 : parameter._isTrigger) {
                    Animator._passedTriggerParameterNames.push(name);
                    pass = true;
                }
            }
            if (!pass) {
                switch(mode){
                    case AnimatorConditionMode.Equals:
                        if (parameterValue === threshold) {
                            pass = true;
                        }
                        break;
                    case AnimatorConditionMode.Greater:
                        if (parameterValue > threshold) {
                            pass = true;
                        }
                        break;
                    case AnimatorConditionMode.Less:
                        if (parameterValue < threshold) {
                            pass = true;
                        }
                        break;
                    case AnimatorConditionMode.NotEquals:
                        if (parameterValue !== threshold) {
                            pass = true;
                        }
                        break;
                    case AnimatorConditionMode.If:
                        if (parameterValue === true) {
                            pass = true;
                        }
                        break;
                    case AnimatorConditionMode.IfNot:
                        if (parameterValue === false) {
                            pass = true;
                        }
                        break;
                }
            }
            if (!pass) {
                allPass = false;
                break;
            }
        }
        if (allPass) {
            this._deactivateTriggeredParameters();
        }
        Animator._passedTriggerParameterNames.length = 0;
        return allPass;
    };
    _proto._prepareCrossFadeByTransition = function _prepareCrossFadeByTransition(transition, layerIndex) {
        var crossState = transition.destinationState;
        if (!crossState) {
            return false;
        }
        if (!crossState.clip) {
            Logger.warn("The state named " + crossState.name + " has no AnimationClip data.");
            return false;
        }
        var animatorLayerData = this._getAnimatorLayerData(layerIndex);
        var animatorStateData = this._getAnimatorStateData(crossState.name, crossState, animatorLayerData, layerIndex);
        animatorLayerData.destPlayData.reset(crossState, animatorStateData, transition.offset * crossState._getClipActualEndTime());
        animatorLayerData.resetCurrentCheckIndex();
        switch(animatorLayerData.layerState){
            case LayerState.Standby:
            case LayerState.Finished:
                animatorLayerData.layerState = LayerState.FixedCrossFading;
                this._clearCrossData(animatorLayerData);
                this._prepareStandbyCrossFading(animatorLayerData);
                break;
            case LayerState.Playing:
                animatorLayerData.layerState = LayerState.CrossFading;
                this._clearCrossData(animatorLayerData);
                this._prepareCrossFading(animatorLayerData);
                break;
            case LayerState.CrossFading:
                animatorLayerData.layerState = LayerState.FixedCrossFading;
                this._prepareFixedPoseCrossFading(animatorLayerData);
                break;
            case LayerState.FixedCrossFading:
                this._prepareFixedPoseCrossFading(animatorLayerData);
                break;
        }
        animatorLayerData.crossFadeTransition = transition;
        return true;
    };
    _proto._fireAnimationEvents = function _fireAnimationEvents(playData, eventHandlers, lastClipTime, deltaTime) {
        var state = playData.state, isForward = playData.isForward, clipTime = playData.clipTime;
        var startTime = state._getClipActualStartTime();
        var endTime = state._getClipActualEndTime();
        if (isForward) {
            if (lastClipTime + deltaTime >= endTime) {
                this._fireSubAnimationEvents(playData, eventHandlers, lastClipTime, endTime);
                playData.currentEventIndex = 0;
                this._fireSubAnimationEvents(playData, eventHandlers, startTime, clipTime);
            } else {
                this._fireSubAnimationEvents(playData, eventHandlers, lastClipTime, clipTime);
            }
        } else {
            if (lastClipTime + deltaTime <= startTime) {
                this._fireBackwardSubAnimationEvents(playData, eventHandlers, lastClipTime, startTime);
                playData.currentEventIndex = eventHandlers.length - 1;
                this._fireBackwardSubAnimationEvents(playData, eventHandlers, endTime, clipTime);
            } else {
                this._fireBackwardSubAnimationEvents(playData, eventHandlers, lastClipTime, clipTime);
            }
        }
    };
    _proto._fireSubAnimationEvents = function _fireSubAnimationEvents(playState, eventHandlers, lastClipTime, curClipTime) {
        var eventIndex = playState.currentEventIndex;
        for(var n = eventHandlers.length; eventIndex < n; eventIndex++){
            var eventHandler = eventHandlers[eventIndex];
            var _eventHandler_event = eventHandler.event, time = _eventHandler_event.time, parameter = _eventHandler_event.parameter;
            if (time > curClipTime) {
                break;
            }
            var handlers = eventHandler.handlers;
            if (time >= lastClipTime) {
                for(var j = handlers.length - 1; j >= 0; j--){
                    handlers[j](parameter);
                }
                playState.currentEventIndex = Math.min(eventIndex + 1, n - 1);
            }
        }
    };
    _proto._fireBackwardSubAnimationEvents = function _fireBackwardSubAnimationEvents(playState, eventHandlers, lastClipTime, curClipTime) {
        var eventIndex = playState.currentEventIndex;
        for(; eventIndex >= 0; eventIndex--){
            var eventHandler = eventHandlers[eventIndex];
            var _eventHandler_event = eventHandler.event, time = _eventHandler_event.time, parameter = _eventHandler_event.parameter;
            if (time < curClipTime) {
                break;
            }
            if (time <= lastClipTime) {
                var handlers = eventHandler.handlers;
                for(var j = handlers.length - 1; j >= 0; j--){
                    handlers[j](parameter);
                }
                playState.currentEventIndex = Math.max(eventIndex - 1, 0);
            }
        }
    };
    _proto._callAnimatorScriptOnEnter = function _callAnimatorScriptOnEnter(state, layerIndex) {
        var scripts = state._onStateEnterScripts;
        for(var i = 0, n = scripts.length; i < n; i++){
            scripts[i].onStateEnter(this, state, layerIndex);
        }
    };
    _proto._callAnimatorScriptOnUpdate = function _callAnimatorScriptOnUpdate(state, layerIndex) {
        var scripts = state._onStateUpdateScripts;
        for(var i = 0, n = scripts.length; i < n; i++){
            scripts[i].onStateUpdate(this, state, layerIndex);
        }
    };
    _proto._callAnimatorScriptOnExit = function _callAnimatorScriptOnExit(state, layerIndex) {
        var scripts = state._onStateExitScripts;
        for(var i = 0, n = scripts.length; i < n; i++){
            scripts[i].onStateExit(this, state, layerIndex);
        }
    };
    _proto._checkAnyAndEntryState = function _checkAnyAndEntryState(layerData, remainDeltaTime, aniUpdate) {
        var stateMachine = layerData.layer.stateMachine;
        var anyStateTransitions = stateMachine._anyStateTransitionCollection, entryTransitions = stateMachine._entryTransitionCollection;
        var transition;
        transition = anyStateTransitions.count && this._applyTransitionsByCondition(layerData, anyStateTransitions, aniUpdate);
        if (!transition) {
            transition = entryTransitions.count && this._applyTransitionsByCondition(layerData, entryTransitions, aniUpdate);
        }
        if (transition) {
            this._updateState(layerData, remainDeltaTime, aniUpdate);
        } else {
            var defaultState = stateMachine.defaultState;
            if (defaultState) {
                this._preparePlay(defaultState, layerData.layerIndex);
                this._updateState(layerData, remainDeltaTime, aniUpdate);
            }
        }
    };
    _proto._checkRevertOwner = function _checkRevertOwner(owner, additive) {
        if (additive && owner.updateMark !== this._updateMark) {
            owner.revertDefaultValue();
        }
        owner.updateMark = this._updateMark;
    };
    _proto._fireAnimationEventsAndCallScripts = function _fireAnimationEventsAndCallScripts(layerIndex, playData, state, lastClipTime, lastPlayState, deltaTime) {
        var eventHandlers = playData.stateData.eventHandlers;
        eventHandlers.length && this._fireAnimationEvents(playData, eventHandlers, lastClipTime, deltaTime);
        if (lastPlayState === AnimatorStatePlayState.UnStarted) {
            this._callAnimatorScriptOnEnter(state, layerIndex);
        }
        if (lastPlayState !== AnimatorStatePlayState.Finished && playData.playState === AnimatorStatePlayState.Finished) {
            this._callAnimatorScriptOnExit(state, layerIndex);
        } else {
            this._callAnimatorScriptOnUpdate(state, layerIndex);
        }
    };
    _proto._deactivateTriggeredParameters = function _deactivateTriggeredParameters() {
        var passedTriggerParameterNames = Animator._passedTriggerParameterNames;
        for(var i = 0, n = passedTriggerParameterNames.length; i < n; i++){
            this._parametersValueMap[passedTriggerParameterNames[i]] = false;
        }
    };
    _create_class$2(Animator, [
        {
            key: "animatorController",
            get: /**
   * All layers from the AnimatorController which belongs this Animator.
   */ function get() {
                return this._animatorController;
            },
            set: function set(animatorController) {
                if (animatorController !== this._animatorController) {
                    this._reset();
                    this._controllerUpdateFlag && this._controllerUpdateFlag.destroy();
                    this._controllerUpdateFlag = animatorController && animatorController._registerChangeFlag();
                    this._animatorController = animatorController;
                }
            }
        },
        {
            key: "layers",
            get: /**
   * The layers in the animator's controller.
   */ function get() {
                var _this__animatorController;
                return (_this__animatorController = this._animatorController) == null ? void 0 : _this__animatorController._layers;
            }
        },
        {
            key: "parameters",
            get: /**
   * The parameters in the animator's controller.
   */ function get() {
                var _this__animatorController;
                return (_this__animatorController = this._animatorController) == null ? void 0 : _this__animatorController._parameters;
            }
        }
    ]);
    return Animator;
}(Component);
Animator._passedTriggerParameterNames = new Array();
__decorate$1([
    assignmentClone
], Animator.prototype, "speed", void 0);
__decorate$1([
    ignoreClone
], Animator.prototype, "_controllerUpdateFlag", void 0);
__decorate$1([
    ignoreClone
], Animator.prototype, "_updateMark", void 0);
__decorate$1([
    ignoreClone
], Animator.prototype, "_animatorLayersData", void 0);
__decorate$1([
    ignoreClone
], Animator.prototype, "_curveOwnerPool", void 0);
__decorate$1([
    ignoreClone
], Animator.prototype, "_animationEventHandlerPool", void 0);
__decorate$1([
    ignoreClone
], Animator.prototype, "_parametersValueMap", void 0);
__decorate$1([
    ignoreClone
], Animator.prototype, "_tempAnimatorStateInfo", void 0);
__decorate$1([
    ignoreClone
], Animator.prototype, "_controlledRenderers", void 0);

function _assert_this_initialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");

    return self;
}

/**
 * Used to communicate between scripting and the controller, parameters can be set in scripting and used by the controller.
 */ var AnimatorControllerParameter = /*#__PURE__*/ function() {
    function AnimatorControllerParameter() {
        /** @internal */ this._onNameChanged = null;
        /** @internal */ this._isTrigger = false;
    }
    _create_class$2(AnimatorControllerParameter, [
        {
            key: "name",
            get: /**
   * The name of the parameter.
   */ function get() {
                return this._name;
            },
            set: function set(name) {
                if (this._name === name) {
                    return;
                }
                var oldName = this._name;
                this._name = name;
                this._onNameChanged == null ? void 0 : this._onNameChanged.call(this, oldName, name);
            }
        }
    ]);
    return AnimatorControllerParameter;
}();

/**
 * Store the data for Animator playback.
 */ var AnimatorController = /*#__PURE__*/ function(ReferResource) {
    _inherits$2(AnimatorController, ReferResource);
    function AnimatorController(engine) {
        var _this;
        engine && [
            _this = ReferResource.call(this, engine) || this,
            /** @internal */ _this._parameters = [],
            /** @internal */ _this._parametersMap = {},
            /** @internal */ _this._layers = [],
            /** @internal */ _this._layersMap = {},
            _this._updateFlagManager = new UpdateFlagManager()
        ][0];
        return _assert_this_initialized(_this);
    }
    var _proto = AnimatorController.prototype;
    /**
   * Add a parameter to the controller.
   * @param name - The name of the parameter
   * @param defaultValue - The default value of the parameter
   */ _proto.addParameter = function addParameter(name, defaultValue) {
        return this._addParameter(name, defaultValue, false);
    };
    /**
   * Add a trigger parameter to the controller.
   * @param name - The name of the parameter
   */ _proto.addTriggerParameter = function addTriggerParameter(name) {
        return this._addParameter(name, false, true);
    };
    /**
   * Remove a parameter from the controller by name, including trigger parameters.
   * @param name - The name of the parameter
   */ _proto.removeParameter = function removeParameter(name) {
        var parameter = this._parametersMap[name];
        var index = this._parameters.indexOf(parameter);
        if (index !== -1) {
            this._parameters.splice(index, 1);
            delete this._parametersMap[parameter.name];
        }
    };
    /**
   * Clear all parameters, including trigger parameters.
   */ _proto.clearParameters = function clearParameters() {
        this._parameters.length = 0;
        for(var name in this._parametersMap){
            delete this._parametersMap[name];
        }
    };
    /**
   * Get the parameter by name.
   * @param name - The name of the parameter
   */ _proto.getParameter = function getParameter(name) {
        return this._parametersMap[name] || null;
    };
    /**
   * Get the layer by name.
   * @param name - The layer's name.
   */ _proto.findLayerByName = function findLayerByName(name) {
        return this._layersMap[name];
    };
    /**
   * Add a layer to the controller.
   * @param layer - The layer to add
   */ _proto.addLayer = function addLayer(layer) {
        this._layers.push(layer);
        this._layersMap[layer.name] = layer;
        this._updateFlagManager.dispatch();
    };
    /**
   * Remove a layer from the controller.
   * @param layerIndex - The index of the AnimatorLayer
   */ _proto.removeLayer = function removeLayer(layerIndex) {
        var theLayer = this.layers[layerIndex];
        this._layers.splice(layerIndex, 1);
        delete this._layersMap[theLayer.name];
        this._updateFlagManager.dispatch();
    };
    /**
   * Clear layers.
   */ _proto.clearLayers = function clearLayers() {
        this._layers.length = 0;
        for(var name in this._layersMap){
            delete this._layersMap[name];
        }
        this._updateFlagManager.dispatch();
    };
    /**
   * @internal
   */ _proto._registerChangeFlag = function _registerChangeFlag() {
        return this._updateFlagManager.createFlag(BoolUpdateFlag);
    };
    _proto._addParameter = function _addParameter(name, defaultValue, isTrigger) {
        var _this = this;
        if (isTrigger === void 0) isTrigger = false;
        if (this._parametersMap[name]) {
            console.warn("Parameter " + name + " already exists.");
            return null;
        }
        var param = new AnimatorControllerParameter();
        param.name = name;
        param.defaultValue = defaultValue;
        param._isTrigger = isTrigger;
        param._onNameChanged = function(oldName, newName) {
            delete _this._parametersMap[oldName];
            _this._parametersMap[newName] = param;
        };
        this._parametersMap[name] = param;
        this._parameters.push(param);
        return param;
    };
    _create_class$2(AnimatorController, [
        {
            key: "layers",
            get: /**
   * The layers in the controller.
   */ function get() {
                return this._layers;
            }
        },
        {
            key: "parameters",
            get: /**
   * The parameters in the controller.
   */ function get() {
                return this._parameters;
            }
        }
    ]);
    return AnimatorController;
}(ReferResource);

/**
 * @internal
 */ var AnimatorStateTransitionCollection = /*#__PURE__*/ function() {
    function AnimatorStateTransitionCollection() {
        this.transitions = new Array();
        this.noExitTimeCount = 0;
        this.needResetCurrentCheckIndex = true;
        this._soloCount = 0;
    }
    var _proto = AnimatorStateTransitionCollection.prototype;
    _proto.get = function get(index) {
        return this.transitions[index];
    };
    _proto.add = function add(transitionOrAnimatorState) {
        var transition;
        if (_instanceof$3(transitionOrAnimatorState, AnimatorState)) {
            transition = new AnimatorStateTransition();
            transition.hasExitTime = false;
            transition.destinationState = transitionOrAnimatorState;
        } else {
            transition = transitionOrAnimatorState;
        }
        this._addTransition(transition);
        transition._collection = this;
        if (transition.solo) {
            this._soloCount++;
        }
        return transition;
    };
    _proto.remove = function remove(transition) {
        var transitions = this.transitions;
        var index = transitions.indexOf(transition);
        if (index !== -1) {
            transitions.splice(index, 1);
            if (!transition.hasExitTime) {
                this.noExitTimeCount--;
            }
        }
        transition._collection = null;
        if (transition.solo) {
            this._soloCount--;
        }
    };
    _proto.clear = function clear() {
        var transitions = this.transitions;
        for(var i = 0, n = transitions.length; i < n; i++){
            var transition = transitions[i];
            transition._collection = null;
        }
        transitions.length = 0;
        this._soloCount = 0;
        this.noExitTimeCount = 0;
    };
    _proto.updateTransitionSolo = function updateTransitionSolo(isModifiedSolo) {
        this._soloCount += isModifiedSolo ? 1 : -1;
    };
    _proto.updateTransitionsIndex = function updateTransitionsIndex(transition, hasExitTime) {
        var transitions = this.transitions;
        transitions.splice(transitions.indexOf(transition), 1);
        this._addTransition(transition);
    };
    _proto.updateCurrentCheckIndex = function updateCurrentCheckIndex(isForward) {
        this.currentCheckIndex = isForward ? Math.min(this.currentCheckIndex + 1, this.count - this.noExitTimeCount - 1) : Math.max(this.currentCheckIndex - 1, 0);
    };
    _proto.resetCurrentCheckIndex = function resetCurrentCheckIndex(isForward) {
        this.currentCheckIndex = isForward ? 0 : this.count - this.noExitTimeCount - 1;
        this.needResetCurrentCheckIndex = false;
    };
    _proto._addTransition = function _addTransition(transition) {
        var transitions = this.transitions;
        if (!transition.hasExitTime) {
            transitions.unshift(transition);
            this.noExitTimeCount++;
            return;
        }
        var exitTime = transition.exitTime;
        var count = transitions.length;
        var maxExitTime = count ? transitions[count - 1].exitTime : 0;
        if (exitTime >= maxExitTime) {
            transitions.push(transition);
        } else {
            var index = count;
            while(--index >= 0 && exitTime < transitions[index].exitTime);
            transitions.splice(index + 1, 0, transition);
        }
    };
    _create_class$2(AnimatorStateTransitionCollection, [
        {
            key: "isSoloMode",
            get: function get() {
                return this._soloCount > 0;
            }
        },
        {
            key: "count",
            get: function get() {
                return this.transitions.length;
            }
        }
    ]);
    return AnimatorStateTransitionCollection;
}();

/**
 * StateMachineScript is a component that can be added to a animator state. It's the base class every script on a state derives from.
 */ var StateMachineScript = /*#__PURE__*/ function() {
    function StateMachineScript() {
        /** @internal */ this._destroyed = false;
    }
    var _proto = StateMachineScript.prototype;
    /**
   * onStateEnter is called when a transition starts and the state machine starts to evaluate this state.
   * @param animator - The animator
   * @param animatorState - The state be evaluated
   * @param layerIndex - The index of the layer where the state is located
   */ _proto.onStateEnter = function onStateEnter(animator, animatorState, layerIndex) {};
    /**
   * onStateUpdate is called on each Update frame between onStateEnter and onStateExit callbacks.
   * @param animator - The animator
   * @param animatorState - The state be evaluated
   * @param layerIndex - The index of the layer where the state is located
   */ _proto.onStateUpdate = function onStateUpdate(animator, animatorState, layerIndex) {};
    /**
   * onStateExit is called when a transition ends and the state machine finishes evaluating this state.
   * @param animator - The animator
   * @param animatorState - The state be evaluated
   * @param layerIndex - The index of the layer where the state is located
   */ _proto.onStateExit = function onStateExit(animator, animatorState, layerIndex) {};
    /**
   * Destroy this instance.
   */ _proto.destroy = function destroy() {
        if (this._destroyed) {
            return;
        }
        this._state._removeStateMachineScript(this);
        this._destroyed = true;
    };
    return StateMachineScript;
}();

/**
 * States are the basic building blocks of a state machine. Each state contains a AnimationClip which will play while the character is in that state.
 */ var AnimatorState = /*#__PURE__*/ function() {
    function AnimatorState(name) {
        this.name = name;
        this./** The speed of the clip. 1 is normal speed, default 1. */ speed = 1.0;
        this./** The wrap mode used in the state. */ wrapMode = WrapMode.Loop;
        this./** @internal */ _onStateEnterScripts = [];
        this./** @internal */ _onStateUpdateScripts = [];
        this./** @internal */ _onStateExitScripts = [];
        this./** @internal */ _updateFlagManager = new UpdateFlagManager();
        this./** @internal */ _transitionCollection = new AnimatorStateTransitionCollection();
        this._clipStartTime = 0;
        this._clipEndTime = 1;
        this._onClipChanged = this._onClipChanged.bind(this);
    }
    var _proto = AnimatorState.prototype;
    _proto.addTransition = function addTransition(transitionOrAnimatorState) {
        return this._transitionCollection.add(transitionOrAnimatorState);
    };
    /**
   * Add an outgoing transition to exit of the stateMachine.
   * @param exitTime - The time at which the transition can take effect. This is represented in normalized time.
   */ _proto.addExitTransition = function addExitTransition(exitTime) {
        if (exitTime === void 0) exitTime = 1.0;
        var transition = new AnimatorStateTransition();
        transition._isExit = true;
        transition.exitTime = exitTime;
        return this._transitionCollection.add(transition);
    };
    /**
   * Remove a transition from the state.
   * @param transition - The transition
   */ _proto.removeTransition = function removeTransition(transition) {
        this._transitionCollection.remove(transition);
        if (transition._isExit) {
            transition._isExit = false;
        }
    };
    /**
   * Adds a state machine script class of type T to the AnimatorState.
   * @param scriptType - The state machine script class of type T
   */ _proto.addStateMachineScript = function addStateMachineScript(scriptType) {
        var script = new scriptType();
        script._state = this;
        var prototype = StateMachineScript.prototype;
        if (script.onStateEnter !== prototype.onStateEnter) {
            this._onStateEnterScripts.push(script);
        }
        if (script.onStateUpdate !== prototype.onStateUpdate) {
            this._onStateUpdateScripts.push(script);
        }
        if (script.onStateExit !== prototype.onStateExit) {
            this._onStateExitScripts.push(script);
        }
        return script;
    };
    /**
   * Clears all transitions from the state.
   */ _proto.clearTransitions = function clearTransitions() {
        this._transitionCollection.clear();
    };
    /**
   * @internal
   */ _proto._getDuration = function _getDuration() {
        if (this.clip) {
            return (this._clipEndTime - this._clipStartTime) * this.clip.length;
        }
        return null;
    };
    /**
   * @internal
   */ _proto._removeStateMachineScript = function _removeStateMachineScript(script) {
        var prototype = StateMachineScript.prototype;
        if (script.onStateEnter !== prototype.onStateEnter) {
            var index = this._onStateEnterScripts.indexOf(script);
            index !== -1 && this._onStateEnterScripts.splice(index, 1);
        }
        if (script.onStateUpdate !== prototype.onStateUpdate) {
            var index1 = this._onStateUpdateScripts.indexOf(script);
            index1 !== -1 && this._onStateUpdateScripts.splice(index1, 1);
        }
        if (script.onStateExit !== prototype.onStateExit) {
            var index2 = this._onStateExitScripts.indexOf(script);
            index2 !== -1 && this._onStateExitScripts.splice(index2, 1);
        }
    };
    /**
   * @internal
   */ _proto._onClipChanged = function _onClipChanged() {
        this._updateFlagManager.dispatch();
    };
    /**
   * @internal
   */ _proto._getClipActualStartTime = function _getClipActualStartTime() {
        return this._clipStartTime * this.clip.length;
    };
    /**
   * @internal
   */ _proto._getClipActualEndTime = function _getClipActualEndTime() {
        return this._clipEndTime * this.clip.length;
    };
    _create_class$2(AnimatorState, [
        {
            key: "transitions",
            get: /**
   * The transitions that are going out of the state.
   */ function get() {
                return this._transitionCollection.transitions;
            }
        },
        {
            key: "clip",
            get: /**
   * The clip that is being played by this animator state.
   */ function get() {
                return this._clip;
            },
            set: function set(clip) {
                var lastClip = this._clip;
                if (lastClip === clip) {
                    return;
                }
                if (lastClip) {
                    lastClip._updateFlagManager.removeListener(this._onClipChanged);
                }
                this._clip = clip;
                this._clipEndTime = Math.min(this._clipEndTime, 1);
                this._onClipChanged();
                clip && clip._updateFlagManager.addListener(this._onClipChanged);
            }
        },
        {
            key: "clipStartTime",
            get: /**
   * The normalized start time of the clip, the range is 0 to 1, default is 0.
   */ function get() {
                return this._clipStartTime;
            },
            set: function set(time) {
                this._clipStartTime = Math.max(time, 0);
            }
        },
        {
            key: "clipEndTime",
            get: /**
   * The normalized end time of the clip, the range is 0 to 1, default is 1.
   */ function get() {
                return this._clipEndTime;
            },
            set: function set(time) {
                this._clipEndTime = Math.min(time, 1);
            }
        }
    ]);
    return AnimatorState;
}();

/**
 * A graph controlling the interaction of states. Each state references a motion.
 */ var AnimatorStateMachine = /*#__PURE__*/ function() {
    function AnimatorStateMachine() {
        /** The list of states. */ this.states = [];
        /** @internal */ this._entryTransitionCollection = new AnimatorStateTransitionCollection();
        /** @internal */ this._anyStateTransitionCollection = new AnimatorStateTransitionCollection();
        this._statesMap = {};
    }
    var _proto = AnimatorStateMachine.prototype;
    /**
   * Add a state to the state machine.
   * @param name - The name of the new state
   */ _proto.addState = function addState(name) {
        var state = this.findStateByName(name);
        if (!state) {
            state = new AnimatorState(name);
            this.states.push(state);
            this._statesMap[name] = state;
        } else {
            console.warn("The state named " + name + " has existed.");
        }
        return state;
    };
    /**
   * Remove a state from the state machine.
   * @param state - The state
   */ _proto.removeState = function removeState(state) {
        var name = state.name;
        var index = this.states.indexOf(state);
        if (index > -1) {
            this.states.splice(index, 1);
        }
        delete this._statesMap[name];
    };
    /**
   * Get the state by name.
   * @param name - The layer's name
   */ _proto.findStateByName = function findStateByName(name) {
        return this._statesMap[name];
    };
    /**
   * Makes a unique state name in the state machine.
   * @param name - Desired name for the state.
   * @returns Unique name.
   */ _proto.makeUniqueStateName = function makeUniqueStateName(name) {
        var _statesMap = this._statesMap;
        var originName = name;
        var index = 0;
        while(_statesMap[name]){
            name = originName + " " + index;
            index++;
        }
        return name;
    };
    _proto.addEntryStateTransition = function addEntryStateTransition(transitionOrAnimatorState) {
        return this._entryTransitionCollection.add(transitionOrAnimatorState);
    };
    /**
   * Remove an entry transition.
   * @param transition - The transition
   */ _proto.removeEntryStateTransition = function removeEntryStateTransition(transition) {
        this._entryTransitionCollection.remove(transition);
    };
    _proto.addAnyStateTransition = function addAnyStateTransition(transitionOrAnimatorState) {
        return this._anyStateTransitionCollection.add(transitionOrAnimatorState);
    };
    /**
   * Remove an any transition.
   * @param transition - The transition
   */ _proto.removeAnyStateTransition = function removeAnyStateTransition(transition) {
        this._anyStateTransitionCollection.remove(transition);
    };
    /**
   * Clear all entry state transitions.
   */ _proto.clearEntryStateTransitions = function clearEntryStateTransitions() {
        this._entryTransitionCollection.clear();
    };
    /**
   * Clear all any state transitions.
   */ _proto.clearAnyStateTransitions = function clearAnyStateTransitions() {
        this._anyStateTransitionCollection.clear();
    };
    _create_class$2(AnimatorStateMachine, [
        {
            key: "entryTransitions",
            get: /**
   * The list of entry transitions in the state machine.
   */ function get() {
                return this._entryTransitionCollection.transitions;
            }
        },
        {
            key: "anyStateTransitions",
            get: /**
   * The list of AnyState transitions.
   */ function get() {
                return this._anyStateTransitionCollection.transitions;
            }
        }
    ]);
    return AnimatorStateMachine;
}();

/**
 * The Animation Layer contains a state machine that controls animations of a model or part of it.
 */ var AnimatorControllerLayer = function AnimatorControllerLayer(name) {
    this.name = name;
    this./** The blending weight that the layers has. It is not taken into account for the first layer. */ weight = 1.0;
    this./** The blending mode used by the layer. It is not taken into account for the first layer. */ blendingMode = AnimatorLayerBlendingMode.Override;
    this.stateMachine = new AnimatorStateMachine();
};

/**
 * Keyframe.
 * @typeParam V - Type of Keyframe value
 */ var Keyframe = function Keyframe() {
};

/**
 * LayerPathMask represents a mask for a specific entity in an animation layer.
 * It is used to control the animation whether to be applied to the entity or not.
 */ var LayerPathMask = function LayerPathMask() {
};

/**
 * AnimatorLayerMask is used to mask out certain entities from being animated by an AnimatorLayer.
 */ var AnimatorLayerMask = /*#__PURE__*/ function() {
    function AnimatorLayerMask() {
        this._pathMasks = [];
        this._pathMaskMap = {};
    }
    var _proto = AnimatorLayerMask.prototype;
    /**
   * Adds a path mask to the AnimatorLayerMask, the root path is "".
   * @param path - The path to add a mask for
   * @returns The created or existing LayerPathMask
   */ _proto.addPathMask = function addPathMask(path) {
        var existed = this._pathMaskMap[path];
        if (existed) {
            return existed;
        }
        var pathMask = new LayerPathMask();
        pathMask.path = path;
        pathMask.active = true;
        this._pathMasks.push(pathMask);
        this._pathMaskMap[path] = pathMask;
        return pathMask;
    };
    /**
   * Removes a path mask from the AnimatorLayerMask.
   * @param path - The path of the mask to remove
   */ _proto.removePathMask = function removePathMask(path) {
        var _this = this, pathMasks = _this._pathMasks;
        for(var i = 0, n = this._pathMasks.length; i < n; ++i){
            if (pathMasks[i].path === path) {
                pathMasks.splice(i, 1);
                delete this._pathMaskMap[path];
                break;
            }
        }
    };
    /**
   * Get a path mask based on the given path.
   * @param path - The path of the mask to get
   * @returns The LayerPathMask for the given path
   */ _proto.getPathMask = function getPathMask(path) {
        return this._pathMaskMap[path];
    };
    /**
   * Sets the active state of a path mask.
   * If recursive is true, it also sets the active state of all child path masks.
   * @param path - The path of the mask to modify
   * @param active - The active state to set
   * @param withChildren - Whether to apply the active state recursively to child paths
   */ _proto.setPathMaskActive = function setPathMaskActive(path, active, withChildren) {
        if (withChildren === void 0) withChildren = false;
        var pathMask = this._pathMaskMap[path];
        if (pathMask) {
            pathMask.active = active;
        }
        if (withChildren) {
            for(var p in this._pathMaskMap){
                if (p.startsWith(path)) {
                    this._pathMaskMap[p].active = active;
                }
            }
        }
    };
    /**
   * Creates an AnimatorLayerMask instance by specifying an entity.
   * This will automatically add path masks for the entity and all its children.
   * @param entity - The root entity to create path masks for
   */ AnimatorLayerMask.createByEntity = function createByEntity(entity) {
        var mask = new AnimatorLayerMask();
        mask.addPathMask("");
        AnimatorLayerMask._addPathMaskWithChildren(mask, entity, "");
        return mask;
    };
    AnimatorLayerMask._addPathMaskWithChildren = function _addPathMaskWithChildren(mask, entity, parentPath) {
        var children = entity.children;
        for(var i = 0, n = children.length; i < n; ++i){
            var child = children[i];
            var childPath = parentPath ? parentPath + "/" + child.name : child.name;
            mask.addPathMask(childPath);
            AnimatorLayerMask._addPathMaskWithChildren(mask, child, childPath);
        }
    };
    _create_class$2(AnimatorLayerMask, [
        {
            key: "pathMasks",
            get: /**
   * The list of path masks.
   */ function get() {
                return this._pathMasks;
            }
        }
    ]);
    return AnimatorLayerMask;
}();

/**
 * SkyBoxMaterial.
 */ var SkyBoxMaterial = /*#__PURE__*/ function(Material) {
    _inherits$2(SkyBoxMaterial, Material);
    function SkyBoxMaterial(engine) {
        var _this;
        _this = Material.call(this, engine, Shader.find("skybox")) || this, _this._textureDecodeRGBM = false, _this._tintColor = new Color(1, 1, 1, 1);
        _this.renderState.rasterState.cullMode = CullMode.Off;
        _this.renderState.depthState.compareFunction = CompareFunction.LessEqual;
        _this.shaderData.setFloat(SkyBoxMaterial._rotationProp, 0);
        _this.shaderData.setFloat(SkyBoxMaterial._exposureProp, 1);
        _this.shaderData.setColor(SkyBoxMaterial._tintColorProp, _this._tintColor);
        return _this;
    }
    var _proto = SkyBoxMaterial.prototype;
    _proto.clone = function clone() {
        var dest = new SkyBoxMaterial(this._engine);
        this._cloneToAndModifyName(dest);
        return dest;
    };
    _create_class$2(SkyBoxMaterial, [
        {
            key: "textureDecodeRGBM",
            get: /**
   * Whether to decode texture with RGBM format.
   */ function get() {
                return this._textureDecodeRGBM;
            },
            set: function set(value) {
                this._textureDecodeRGBM = value;
                if (value) {
                    this.shaderData.enableMacro(SkyBoxMaterial._decodeSkyRGBMMacro);
                } else {
                    this.shaderData.disableMacro(SkyBoxMaterial._decodeSkyRGBMMacro);
                }
            }
        },
        {
            key: "texture",
            get: /**
   * Texture of the sky box material.
   */ function get() {
                return this.shaderData.getTexture(SkyBoxMaterial._textureCubeProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(SkyBoxMaterial._textureCubeProp, value);
            }
        },
        {
            key: "rotation",
            get: /**
   * The angle to rotate around the y-axis, unit is degree.
   */ function get() {
                return this.shaderData.getFloat(SkyBoxMaterial._rotationProp);
            },
            set: function set(value) {
                this.shaderData.setFloat(SkyBoxMaterial._rotationProp, value);
            }
        },
        {
            key: "exposure",
            get: /**
   * The exposure value of this material.
   */ function get() {
                return this.shaderData.getFloat(SkyBoxMaterial._exposureProp);
            },
            set: function set(value) {
                this.shaderData.setFloat(SkyBoxMaterial._exposureProp, value);
            }
        },
        {
            key: "tintColor",
            get: /**
   * The Tint color of this material.
   */ function get() {
                return this._tintColor;
            },
            set: function set(value) {
                if (this._tintColor != value) {
                    this._tintColor.copyFrom(value);
                }
            }
        }
    ]);
    return SkyBoxMaterial;
}(Material);
SkyBoxMaterial._tintColorProp = ShaderProperty.getByName("material_TintColor");
SkyBoxMaterial._textureCubeProp = ShaderProperty.getByName("material_CubeTexture");
SkyBoxMaterial._rotationProp = ShaderProperty.getByName("material_Rotation");
SkyBoxMaterial._exposureProp = ShaderProperty.getByName("material_Exposure");
SkyBoxMaterial._decodeSkyRGBMMacro = ShaderMacro.getByName("MATERIAL_IS_DECODE_SKY_RGBM");

/**
 * Sun mode.
 */ var SunMode = /*#__PURE__*/ function(SunMode) {
    /** None */ SunMode[SunMode["None"] = 0] = "None";
    /** Simple sun. */ SunMode[SunMode["Simple"] = 1] = "Simple";
    /** High quality sun. */ SunMode[SunMode["HighQuality"] = 2] = "HighQuality";
    return SunMode;
}({});
/**
 * Sky procedural material.
 */ var SkyProceduralMaterial = /*#__PURE__*/ function(Material) {
    _inherits$2(SkyProceduralMaterial, Material);
    function SkyProceduralMaterial(engine) {
        var _this;
        _this = Material.call(this, engine, Shader.find("SkyProcedural")) || this;
        _this.sunMode = 2;
        _this.sunSize = 0.04;
        _this.sunSizeConvergence = 5;
        _this.atmosphereThickness = 1.0;
        _this.skyTint = new Color(0.21404114048223255, 0.21404114048223255, 0.21404114048223255, 1.0);
        _this.groundTint = new Color(0.11216882039252905, 0.09988709277986121, 0.09520561068319185, 1.0);
        _this.exposure = 1.3;
        _this.renderState.rasterState.cullMode = CullMode.Off;
        _this.renderState.depthState.compareFunction = CompareFunction.LessEqual;
        return _this;
    }
    var _proto = SkyProceduralMaterial.prototype;
    /**
   * @inheritDoc
   */ _proto.clone = function clone() {
        var dest = new SkyProceduralMaterial(this._engine);
        this._cloneToAndModifyName(dest);
        return dest;
    };
    _create_class$2(SkyProceduralMaterial, [
        {
            key: "sunMode",
            get: /**
   * Sun mode.
   */ function get() {
                return this._sunDisk;
            },
            set: function set(value) {
                var shaderData = this.shaderData;
                switch(value){
                    case 2:
                        shaderData.disableMacro(SkyProceduralMaterial._sunSimpleMacro);
                        shaderData.enableMacro(SkyProceduralMaterial._sunHighQualityMacro);
                        break;
                    case 1:
                        shaderData.disableMacro(SkyProceduralMaterial._sunHighQualityMacro);
                        shaderData.enableMacro(SkyProceduralMaterial._sunSimpleMacro);
                        break;
                    case 0:
                        shaderData.disableMacro(SkyProceduralMaterial._sunHighQualityMacro);
                        shaderData.disableMacro(SkyProceduralMaterial._sunSimpleMacro);
                        break;
                    default:
                        throw "SkyBoxProceduralMaterial: unknown sun value.";
                }
                this._sunDisk = value;
            }
        },
        {
            key: "sunSize",
            get: /**
   * Sun size, range is 0 to 1.
   */ function get() {
                return this.shaderData.getFloat(SkyProceduralMaterial._sunSizeProp);
            },
            set: function set(value) {
                this.shaderData.setFloat(SkyProceduralMaterial._sunSizeProp, Math.min(Math.max(0.0, value), 1.0));
            }
        },
        {
            key: "sunSizeConvergence",
            get: /**
   * Sun size convergence, range is 0 to 20.
   */ function get() {
                return this.shaderData.getFloat(SkyProceduralMaterial._sunSizeConvergenceProp);
            },
            set: function set(value) {
                this.shaderData.setFloat(SkyProceduralMaterial._sunSizeConvergenceProp, Math.min(Math.max(0.0, value), 20.0));
            }
        },
        {
            key: "atmosphereThickness",
            get: /**
   * Atmosphere thickness, range is 0 to 5.
   */ function get() {
                return this.shaderData.getFloat(SkyProceduralMaterial._atmosphereThicknessProp);
            },
            set: function set(value) {
                this.shaderData.setFloat(SkyProceduralMaterial._atmosphereThicknessProp, Math.min(Math.max(0.0, value), 5.0));
            }
        },
        {
            key: "skyTint",
            get: /**
   * Sky tint.
   */ function get() {
                return this.shaderData.getColor(SkyProceduralMaterial._skyTintProp);
            },
            set: function set(value) {
                this.shaderData.setColor(SkyProceduralMaterial._skyTintProp, value);
            }
        },
        {
            key: "groundTint",
            get: /**
   * Ground tint.
   */ function get() {
                return this.shaderData.getColor(SkyProceduralMaterial._groundTintProp);
            },
            set: function set(value) {
                this.shaderData.setColor(SkyProceduralMaterial._groundTintProp, value);
            }
        },
        {
            key: "exposure",
            get: /**
   * Exposure, range is 0 to 8.
   */ function get() {
                return this.shaderData.getFloat(SkyProceduralMaterial._exposureProp);
            },
            set: function set(value) {
                this.shaderData.setFloat(SkyProceduralMaterial._exposureProp, Math.min(Math.max(0.0, value), 8.0));
            }
        }
    ]);
    return SkyProceduralMaterial;
}(Material);
SkyProceduralMaterial._sunSizeProp = ShaderProperty.getByName("material_SunSize");
SkyProceduralMaterial._sunSizeConvergenceProp = ShaderProperty.getByName("material_SunSizeConvergence");
SkyProceduralMaterial._atmosphereThicknessProp = ShaderProperty.getByName("material_AtmosphereThickness");
SkyProceduralMaterial._skyTintProp = ShaderProperty.getByName("material_SkyTint");
SkyProceduralMaterial._groundTintProp = ShaderProperty.getByName("material_GroundTint");
SkyProceduralMaterial._exposureProp = ShaderProperty.getByName("material_Exposure");
SkyProceduralMaterial._sunHighQualityMacro = ShaderMacro.getByName("MATERIAL_SUN_HIGH_QUALITY");
SkyProceduralMaterial._sunSimpleMacro = ShaderMacro.getByName("MATERIAL_SUN_SIMPLE");

/**
 * The rendering mode for particle renderer.
 */ var ParticleRenderMode = /*#__PURE__*/ function(ParticleRenderMode) {
    /** Render particles as billboards facing the active camera. */ ParticleRenderMode[ParticleRenderMode["Billboard"] = 0] = "Billboard";
    /** Stretch particles in the direction of motion. */ ParticleRenderMode[ParticleRenderMode["StretchBillboard"] = 1] = "StretchBillboard";
    /** Render particles as billboards always facing up along the y-Axis. */ ParticleRenderMode[ParticleRenderMode["HorizontalBillboard"] = 2] = "HorizontalBillboard";
    /** Render particles as billboards always facing the player, but not pitching along the x-Axis. */ ParticleRenderMode[ParticleRenderMode["VerticalBillboard"] = 3] = "VerticalBillboard";
    /** Render particles as meshes. */ ParticleRenderMode[ParticleRenderMode["Mesh"] = 4] = "Mesh";
    /** Do not render particles. */ ParticleRenderMode[ParticleRenderMode["None"] = 5] = "None";
    return ParticleRenderMode;
}({});

/**
 * The space to simulate particles in.
 */ var ParticleSimulationSpace = /*#__PURE__*/ function(ParticleSimulationSpace) {
    /** Simulate particles in local space. */ ParticleSimulationSpace[ParticleSimulationSpace["Local"] = 0] = "Local";
    /** Simulate particles in world space. */ ParticleSimulationSpace[ParticleSimulationSpace["World"] = 1] = "World";
    return ParticleSimulationSpace;
}({});

var ParticleStopMode = /*#__PURE__*/ function(ParticleStopMode) {
    /** Stop emitting new particles and clear existing particles immediately. */ ParticleStopMode[ParticleStopMode["StopEmittingAndClear"] = 0] = "StopEmittingAndClear";
    /** Stop emitting new particles, but keep existing particles until they expire. */ ParticleStopMode[ParticleStopMode["StopEmitting"] = 1] = "StopEmitting";
    return ParticleStopMode;
}({});

/**
 * Particle Renderer Component.
 */ var ParticleRenderer = /*#__PURE__*/ function(Renderer) {
    _inherits$2(ParticleRenderer, Renderer);
    function ParticleRenderer(entity) {
        var _this;
        _this = Renderer.call(this, entity) || this, /** Specifies how much particles stretch depending on their velocity. */ _this.velocityScale = 0, /** How much are the particles stretched in their direction of motion, defined as the length of the particle compared to its width. */ _this.lengthScale = 2, /** The pivot of particle. */ _this.pivot = new Vector3(), /** @internal */ _this._generatorBounds = new BoundingBox(), /** @internal */ _this._transformedBounds = new BoundingBox();
        _this._onGeneratorParamsChanged = _this._onGeneratorParamsChanged.bind(_this);
        _this.generator = new ParticleGenerator(_this);
        _this._currentRenderModeMacro = ParticleRenderer._billboardModeMacro;
        _this.shaderData.enableMacro(ParticleRenderer._billboardModeMacro);
        _this._supportInstancedArrays = _this.engine._hardwareRenderer.canIUse(GLCapabilityType.instancedArrays);
        _this._onGeneratorParamsChanged();
        return _this;
    }
    var _proto = ParticleRenderer.prototype;
    /**
   * @internal
   */ _proto._onEnable = function _onEnable() {
        if (this.generator.main.playOnEnabled) {
            this.generator.play(false);
        }
    };
    /**
   * @internal
   */ _proto._onDisable = function _onDisable() {
        this.generator.stop(false, ParticleStopMode.StopEmittingAndClear);
    };
    /**
   * @internal
   */ _proto._prepareRender = function _prepareRender(context) {
        if (!this._supportInstancedArrays) {
            return;
        }
        Renderer.prototype._prepareRender.call(this, context);
    };
    /**
   * @internal
   */ _proto._updateTransformShaderData = function _updateTransformShaderData(context, onlyMVP, batched) {
        //@todo: Don't need to update transform shader data, temp solution
        Renderer.prototype._updateTransformShaderData.call(this, context, onlyMVP, true);
    };
    _proto._updateBounds = function _updateBounds(worldBounds) {
        var generator = this.generator;
        // Using `isAlive` instead of `firstActiveElement !== firstFreeElement`
        // Because `firstActiveElement !== firstFreeElement` will cause bounds is merely a point, and cannot be culled forever
        // Must generate bounds even when there is no particle but in play state
        if (!generator.isAlive) {
            var worldPosition = this.entity.transform.worldPosition;
            worldBounds.min.copyFrom(worldPosition);
            worldBounds.max.copyFrom(worldPosition);
            return;
        }
        if (generator.main.simulationSpace === ParticleSimulationSpace.Local) {
            generator._updateBoundsSimulationLocal(worldBounds);
        } else {
            if (this._isContainDirtyFlag(2)) {
                generator._generateTransformedBounds();
                this._setDirtyFlagFalse(2);
            }
            generator._updateBoundsSimulationWorld(worldBounds);
        }
    };
    _proto._update = function _update(context) {
        var generator = this.generator;
        generator._update(this.engine.time.deltaTime);
        // No particles to render
        if (generator._firstActiveElement === generator._firstFreeElement) {
            return;
        }
        var shaderData = this.shaderData;
        shaderData.setFloat(ParticleRenderer._lengthScale, this.lengthScale);
        shaderData.setFloat(ParticleRenderer._speedScale, this.velocityScale);
        shaderData.setFloat(ParticleRenderer._currentTime, this.generator._playTime);
        shaderData.setVector3(ParticleRenderer._pivotOffsetProperty, this.pivot);
        this.generator._updateShaderData(shaderData);
    };
    _proto._render = function _render(context) {
        var generator = this.generator;
        // Don't need to render when no particles
        var aliveParticleCount = generator._getAliveParticleCount();
        if (!aliveParticleCount) {
            return;
        }
        generator._primitive.instanceCount = aliveParticleCount;
        var material = this.getMaterial();
        if (!material) {
            return;
        }
        if (material.destroyed || material.shader.destroyed) {
            material = this.engine._particleMagentaMaterial;
        }
        var engine = this._engine;
        var renderElement = engine._renderElementPool.get();
        renderElement.set(this.priority, this._distanceForSort);
        var subRenderElement = engine._subRenderElementPool.get();
        subRenderElement.set(this, material, generator._primitive, generator._subPrimitive);
        renderElement.addSubRenderElement(subRenderElement);
        context.camera._renderPipeline.pushRenderElement(context, renderElement);
    };
    _proto._onDestroy = function _onDestroy() {
        var mesh = this._mesh;
        if (mesh) {
            mesh.destroyed || this._addResourceReferCount(mesh, -1);
        }
        Renderer.prototype._onDestroy.call(this);
        this.generator._destroy();
    };
    /**
   * @internal
   */ _proto._isContainDirtyFlag = function _isContainDirtyFlag(type) {
        return (this._dirtyUpdateFlag & type) != 0;
    };
    /**
   * @internal
   */ _proto._setDirtyFlagFalse = function _setDirtyFlagFalse(type) {
        this._dirtyUpdateFlag &= ~type;
    };
    /**
   * @internal
   */ _proto._onWorldVolumeChanged = function _onWorldVolumeChanged() {
        this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
    };
    /**
   * @internal
   */ _proto._onGeneratorParamsChanged = function _onGeneratorParamsChanged() {
        this._dirtyUpdateFlag |= 4 | 2 | RendererUpdateFlags.WorldVolume;
    };
    /**
   * @internal
   */ _proto._onTransformChanged = function _onTransformChanged(type) {
        this._dirtyUpdateFlag |= 2 | RendererUpdateFlags.WorldVolume;
    };
    _create_class$2(ParticleRenderer, [
        {
            key: "renderMode",
            get: /**
   * Specifies how particles are rendered.
   */ function get() {
                return this._renderMode;
            },
            set: function set(value) {
                if (this._renderMode !== value) {
                    var lastRenderMode = this._renderMode;
                    this._renderMode = value;
                    var renderModeMacro = null;
                    var shaderData = this.shaderData;
                    switch(value){
                        case ParticleRenderMode.Billboard:
                            renderModeMacro = ParticleRenderer._billboardModeMacro;
                            break;
                        case ParticleRenderMode.StretchBillboard:
                            renderModeMacro = ParticleRenderer._stretchedBillboardModeMacro;
                            break;
                        case ParticleRenderMode.HorizontalBillboard:
                            throw "Not implemented";
                        case ParticleRenderMode.VerticalBillboard:
                            throw "Not implemented";
                        case ParticleRenderMode.Mesh:
                            throw "Not implemented";
                    }
                    if (this._currentRenderModeMacro !== renderModeMacro) {
                        this._currentRenderModeMacro && shaderData.disableMacro(this._currentRenderModeMacro);
                        renderModeMacro && shaderData.enableMacro(renderModeMacro);
                        this._currentRenderModeMacro = renderModeMacro;
                    }
                    // @ts-ignore
                    if (lastRenderMode !== ParticleRenderMode.Mesh !== (value === ParticleRenderMode.Mesh)) {
                        this.generator._reorganizeGeometryBuffers();
                    }
                }
            }
        },
        {
            key: "mesh",
            get: /**
   * The mesh of particle.
   * @remarks Valid when `renderMode` is `Mesh`.
   */ function get() {
                return this._mesh;
            },
            set: function set(value) {
                var lastMesh = this._mesh;
                if (lastMesh !== value) {
                    this._mesh = value;
                    lastMesh && this._addResourceReferCount(lastMesh, -1);
                    value && this._addResourceReferCount(value, 1);
                    if (this.renderMode === ParticleRenderMode.Mesh) {
                        this.generator._reorganizeGeometryBuffers();
                    }
                }
            }
        }
    ]);
    return ParticleRenderer;
}(Renderer);
ParticleRenderer._billboardModeMacro = ShaderMacro.getByName("RENDERER_MODE_SPHERE_BILLBOARD");
ParticleRenderer._stretchedBillboardModeMacro = ShaderMacro.getByName("RENDERER_MODE_STRETCHED_BILLBOARD");
ParticleRenderer._horizontalBillboardModeMacro = ShaderMacro.getByName("RENDERER_MODE_HORIZONTAL_BILLBOARD");
ParticleRenderer._verticalBillboardModeMacro = ShaderMacro.getByName("RENDERER_MODE_VERTICAL_BILLBOARD");
ParticleRenderer._renderModeMeshMacro = ShaderMacro.getByName("RENDERER_MODE_MESH");
ParticleRenderer._pivotOffsetProperty = ShaderProperty.getByName("renderer_PivotOffset");
ParticleRenderer._lengthScale = ShaderProperty.getByName("renderer_StretchedBillboardLengthScale");
ParticleRenderer._speedScale = ShaderProperty.getByName("renderer_StretchedBillboardSpeedScale");
ParticleRenderer._currentTime = ShaderProperty.getByName("renderer_CurrentTime");
__decorate$1([
    deepClone
], ParticleRenderer.prototype, "generator", void 0);
__decorate$1([
    shallowClone
], ParticleRenderer.prototype, "pivot", void 0);
__decorate$1([
    ignoreClone
], ParticleRenderer.prototype, "_generatorBounds", void 0);
__decorate$1([
    ignoreClone
], ParticleRenderer.prototype, "_transformedBounds", void 0);
__decorate$1([
    ignoreClone
], ParticleRenderer.prototype, "_onGeneratorParamsChanged", null);
__decorate$1([
    ignoreClone
], ParticleRenderer.prototype, "_onTransformChanged", null);
/**
 * @internal
 */ var ParticleUpdateFlags = /*#__PURE__*/ function(ParticleUpdateFlags) {
    /** On World Transform Changed */ ParticleUpdateFlags[ParticleUpdateFlags["TransformVolume"] = 2] = "TransformVolume";
    /** On Generator Bounds Related Params Changed */ ParticleUpdateFlags[ParticleUpdateFlags["GeneratorVolume"] = 4] = "GeneratorVolume";
    return ParticleUpdateFlags;
}({});

/**
 * Particle curve mode.
 */ var ParticleCurveMode = /*#__PURE__*/ function(ParticleCurveMode) {
    /* Single constant mode. */ ParticleCurveMode[ParticleCurveMode["Constant"] = 0] = "Constant";
    /* Random value between two constants mode. */ ParticleCurveMode[ParticleCurveMode["TwoConstants"] = 1] = "TwoConstants";
    /* Single curve mode. */ ParticleCurveMode[ParticleCurveMode["Curve"] = 2] = "Curve";
    /* Random value between two curves mode. */ ParticleCurveMode[ParticleCurveMode["TwoCurves"] = 3] = "TwoCurves";
    return ParticleCurveMode;
}({});

/**
 * Particle gradient mode.
 */ var ParticleGradientMode = /*#__PURE__*/ function(ParticleGradientMode) {
    /* Single constant color. */ ParticleGradientMode[ParticleGradientMode["Constant"] = 0] = "Constant";
    /* Random value between two constant colors. */ ParticleGradientMode[ParticleGradientMode["TwoConstants"] = 1] = "TwoConstants";
    /* Single color gradient curve mode. */ ParticleGradientMode[ParticleGradientMode["Gradient"] = 2] = "Gradient";
    /* Random value between two color gradients. */ ParticleGradientMode[ParticleGradientMode["TwoGradients"] = 3] = "TwoGradients";
    return ParticleGradientMode;
}({});

/**
 * @internal
 */ var ParticleRandomSubSeeds = /*#__PURE__*/ function(ParticleRandomSubSeeds) {
    ParticleRandomSubSeeds[ParticleRandomSubSeeds["Burst"] = 592910910] = "Burst";
    ParticleRandomSubSeeds[ParticleRandomSubSeeds["StartDelay"] = 322376503] = "StartDelay";
    ParticleRandomSubSeeds[ParticleRandomSubSeeds["StartColor"] = 306581307] = "StartColor";
    ParticleRandomSubSeeds[ParticleRandomSubSeeds["StartSize"] = 1793934638] = "StartSize";
    ParticleRandomSubSeeds[ParticleRandomSubSeeds["StartRotation"] = 3737431713] = "StartRotation";
    ParticleRandomSubSeeds[ParticleRandomSubSeeds["randomizeRotationDirection"] = 2527743459] = "randomizeRotationDirection";
    ParticleRandomSubSeeds[ParticleRandomSubSeeds["StartLifetime"] = 2368504881] = "StartLifetime";
    ParticleRandomSubSeeds[ParticleRandomSubSeeds["StartSpeed"] = 4085612399] = "StartSpeed";
    ParticleRandomSubSeeds[ParticleRandomSubSeeds["VelocityOverLifetime"] = 3774601268] = "VelocityOverLifetime";
    ParticleRandomSubSeeds[ParticleRandomSubSeeds["ColorOverLifetime"] = 326370691] = "ColorOverLifetime";
    ParticleRandomSubSeeds[ParticleRandomSubSeeds["SizeOverLifetime"] = 1494990940] = "SizeOverLifetime";
    ParticleRandomSubSeeds[ParticleRandomSubSeeds["RotationOverLifetime"] = 1089181156] = "RotationOverLifetime";
    ParticleRandomSubSeeds[ParticleRandomSubSeeds["TextureSheetAnimation"] = 197469413] = "TextureSheetAnimation";
    ParticleRandomSubSeeds[ParticleRandomSubSeeds["Shape"] = 2941263940] = "Shape";
    ParticleRandomSubSeeds[ParticleRandomSubSeeds["GravityModifier"] = 2759560269] = "GravityModifier";
    ParticleRandomSubSeeds[ParticleRandomSubSeeds["ForceOverLifetime"] = 3875246972] = "ForceOverLifetime";
    return ParticleRandomSubSeeds;
}({});

/**
 * Particle gradient.
 */ var ParticleGradient = /*#__PURE__*/ function() {
    function ParticleGradient(colorKeys, alphaKeys) {
        if (colorKeys === void 0) colorKeys = null;
        if (alphaKeys === void 0) alphaKeys = null;
        this._colorKeys = [];
        this._alphaKeys = [];
        this._colorTypeArrayDirty = false;
        this._alphaTypeArrayDirty = false;
        if (colorKeys) {
            for(var i = 0, n = colorKeys.length; i < n; i++){
                var key = colorKeys[i];
                this.addColorKey(key);
            }
        }
        if (alphaKeys) {
            for(var i1 = 0, n1 = alphaKeys.length; i1 < n1; i1++){
                var key1 = alphaKeys[i1];
                this.addAlphaKey(key1);
            }
        }
    }
    var _proto = ParticleGradient.prototype;
    _proto.addColorKey = function addColorKey(timeOrKey, color) {
        var colorKeys = this._colorKeys;
        if (colorKeys.length === 4) {
            throw new Error("Gradient can only have 4 color keys");
        }
        var key = typeof timeOrKey === "number" ? new GradientColorKey(timeOrKey, color) : timeOrKey;
        key._onValueChanged = this._setColorTypeArrayDirty.bind(this);
        this._addKey(colorKeys, key);
        this._colorTypeArrayDirty = true;
    };
    _proto.addAlphaKey = function addAlphaKey(timeOrKey, alpha) {
        var alphaKeys = this._alphaKeys;
        if (alphaKeys.length === 4) {
            throw new Error("Gradient can only have 4 alpha keys");
        }
        var key = typeof timeOrKey === "number" ? new GradientAlphaKey(timeOrKey, alpha) : timeOrKey;
        key._onValueChanged = this._setAlphaTypeArrayDirty.bind(this);
        this._addKey(alphaKeys, key);
        this._alphaTypeArrayDirty = true;
    };
    /**
   * Remove a color key from the gradient.
   * @param index - The remove color key index
   */ _proto.removeColorKey = function removeColorKey(index) {
        this._colorKeys[index]._onValueChanged = null;
        this._removeKey(this._colorKeys, index);
        this._colorTypeArrayDirty = true;
    };
    /**
   * Remove an alpha key from the gradient.
   * @param index - The remove alpha key index
   */ _proto.removeAlphaKey = function removeAlphaKey(index) {
        this._alphaKeys[index]._onValueChanged = null;
        this._removeKey(this._alphaKeys, index);
        this._alphaTypeArrayDirty = true;
    };
    /**
   * Set the keys of the gradient.
   * @param colorKeys - The color keys
   * @param alphaKeys - The alpha keys
   */ _proto.setKeys = function setKeys(colorKeys, alphaKeys) {
        var currentColorKeys = this._colorKeys;
        var currentAlphaKeys = this._alphaKeys;
        for(var i = 0, n = currentColorKeys.length; i < n; i++){
            currentColorKeys[i]._onValueChanged = null;
        }
        for(var i1 = 0, n1 = currentAlphaKeys.length; i1 < n1; i1++){
            currentAlphaKeys[i1]._onValueChanged = null;
        }
        currentColorKeys.length = 0;
        currentAlphaKeys.length = 0;
        for(var i2 = 0, n2 = colorKeys.length; i2 < n2; i2++){
            this._addKey(currentColorKeys, colorKeys[i2]);
        }
        for(var i3 = 0, n3 = alphaKeys.length; i3 < n3; i3++){
            this._addKey(currentAlphaKeys, alphaKeys[i3]);
        }
        this._alphaTypeArrayDirty = true;
        this._colorTypeArrayDirty = true;
    };
    /**
   * @internal
   */ _proto._getColorTypeArray = function _getColorTypeArray() {
        var typeArray = this._colorTypeArray || (this._colorTypeArray = new Float32Array(4 * 4));
        if (this._colorTypeArrayDirty) {
            var keys = this._colorKeys;
            for(var i = 0, n = Math.min(keys.length, 4); i < n; i++){
                var offset = i * 4;
                var key = keys[i];
                typeArray[offset] = key.time;
                var color = key.color;
                typeArray[offset + 1] = color.r;
                typeArray[offset + 2] = color.g;
                typeArray[offset + 3] = color.b;
            }
            this._colorTypeArrayDirty = false;
        }
        return typeArray;
    };
    /**
   * @internal
   */ _proto._getAlphaTypeArray = function _getAlphaTypeArray() {
        var typeArray = this._alphaTypeArray || (this._alphaTypeArray = new Float32Array(4 * 2));
        if (this._alphaTypeArrayDirty) {
            var keys = this._alphaKeys;
            for(var i = 0, n = Math.min(keys.length, 4); i < n; i++){
                var offset = i * 2;
                var key = keys[i];
                typeArray[offset] = key.time;
                typeArray[offset + 1] = key.alpha;
            }
            this._alphaTypeArrayDirty = false;
        }
        return typeArray;
    };
    _proto._addKey = function _addKey(keys, key) {
        var time = key.time;
        var count = keys.length;
        var duration = count ? keys[count - 1].time : 0;
        if (time >= duration) {
            keys.push(key);
        } else {
            var index = count;
            while(--index >= 0 && time < keys[index].time);
            keys.splice(index + 1, 0, key);
        }
    };
    _proto._removeKey = function _removeKey(keys, index) {
        keys.splice(index, 1);
    };
    _proto._setColorTypeArrayDirty = function _setColorTypeArrayDirty() {
        this._colorTypeArrayDirty = true;
    };
    _proto._setAlphaTypeArrayDirty = function _setAlphaTypeArrayDirty() {
        this._alphaTypeArrayDirty = true;
    };
    _create_class$2(ParticleGradient, [
        {
            key: "colorKeys",
            get: /**
   * The color keys of the gradient.
   */ function get() {
                return this._colorKeys;
            }
        },
        {
            key: "alphaKeys",
            get: /**
   * The alpha keys of the gradient.
   */ function get() {
                return this._alphaKeys;
            }
        }
    ]);
    return ParticleGradient;
}();
__decorate$1([
    deepClone
], ParticleGradient.prototype, "_colorKeys", void 0);
__decorate$1([
    deepClone
], ParticleGradient.prototype, "_alphaKeys", void 0);
__decorate$1([
    ignoreClone
], ParticleGradient.prototype, "_colorTypeArray", void 0);
__decorate$1([
    ignoreClone
], ParticleGradient.prototype, "_alphaTypeArray", void 0);
__decorate$1([
    ignoreClone
], ParticleGradient.prototype, "_setColorTypeArrayDirty", null);
__decorate$1([
    ignoreClone
], ParticleGradient.prototype, "_setAlphaTypeArrayDirty", null);
/**
 * The color key of the particle gradient.
 */ var GradientColorKey = /*#__PURE__*/ function() {
    function GradientColorKey(time, color) {
        /** @internal */ this._onValueChanged = null;
        this._color = new Color();
        this._time = time;
        color && this._color.copyFrom(color);
        // @ts-ignore
        this._color._onValueChanged = this._onValueChanged;
    }
    _create_class$2(GradientColorKey, [
        {
            key: "time",
            get: /**
   * The key time.
   */ function get() {
                return this._time;
            },
            set: function set(value) {
                this._time = value;
                this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
            }
        },
        {
            key: "color",
            get: /**
   * The key color.
   */ function get() {
                return this._color;
            },
            set: function set(value) {
                if (this._color !== value) {
                    this._color.copyFrom(value);
                }
            }
        }
    ]);
    return GradientColorKey;
}();
/**
 * The alpha key of the particle gradient.
 */ var GradientAlphaKey = /*#__PURE__*/ function() {
    function GradientAlphaKey(time, alpha) {
        /** @internal */ this._onValueChanged = null;
        this._time = time;
        this._alpha = alpha;
    }
    _create_class$2(GradientAlphaKey, [
        {
            key: "time",
            get: /**
   * The key time.
   */ function get() {
                return this._time;
            },
            set: function set(value) {
                this._time = value;
                this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
            }
        },
        {
            key: "alpha",
            get: /**
   * The key alpha.
   */ function get() {
                return this._alpha;
            },
            set: function set(value) {
                this._alpha = value;
                this._onValueChanged == null ? void 0 : this._onValueChanged.call(this);
            }
        }
    ]);
    return GradientAlphaKey;
}();

/**
 * Particle composite gradient.
 */ var ParticleCompositeGradient = /*#__PURE__*/ function() {
    function ParticleCompositeGradient(constantOrGradient, constantMaxOrGradientMax) {
        /** The gradient mode. */ this.mode = ParticleGradientMode.Constant;
        /* The min constant color used by the gradient if mode is set to `TwoConstants`. */ this.constantMin = new Color();
        /* The max constant color used by the gradient if mode is set to `TwoConstants`. */ this.constantMax = new Color();
        /** The min gradient used by the gradient if mode is set to `Gradient`. */ this.gradientMin = new ParticleGradient();
        /** The max gradient used by the gradient if mode is set to `Gradient`. */ this.gradientMax = new ParticleGradient();
        if (constantOrGradient.constructor === Color) {
            if (constantMaxOrGradientMax) {
                this.constantMin.copyFrom(constantOrGradient);
                this.constantMax.copyFrom(constantMaxOrGradientMax);
                this.mode = ParticleGradientMode.TwoConstants;
            } else {
                this.constant.copyFrom(constantOrGradient);
                this.mode = ParticleGradientMode.Constant;
            }
        } else {
            if (constantMaxOrGradientMax) {
                this.gradientMin = constantOrGradient;
                this.gradientMax = constantMaxOrGradientMax;
                this.mode = ParticleGradientMode.TwoGradients;
            } else {
                this.gradient = constantOrGradient;
                this.mode = ParticleGradientMode.Gradient;
            }
        }
    }
    var _proto = ParticleCompositeGradient.prototype;
    /**
   * Query the color at the specified time.
   * @param time - Normalized time at which to evaluate the gradient, Valid when `mode` is set to `Gradient` or `TwoGradients`
   * @param lerpFactor - Lerp factor between two constants or gradients, Valid when `mode` is set to `TwoConstants` or `TwoGradients`
   * @param out - The result color
   */ _proto.evaluate = function evaluate(time, lerpFactor, out) {
        switch(this.mode){
            case ParticleGradientMode.Constant:
                out.copyFrom(this.constant);
                break;
            case ParticleGradientMode.TwoConstants:
                Color.lerp(this.constantMin, this.constantMax, lerpFactor, out);
                break;
        }
    };
    _create_class$2(ParticleCompositeGradient, [
        {
            key: "constant",
            get: /**
   *  The constant color used by the gradient if mode is set to `Constant`.
   */ function get() {
                return this.constantMax;
            },
            set: function set(value) {
                this.constantMax = value;
            }
        },
        {
            key: "gradient",
            get: /**
   * The gradient used by the gradient if mode is set to `Gradient`.
   */ function get() {
                return this.gradientMax;
            },
            set: function set(value) {
                this.gradientMax = value;
            }
        }
    ]);
    return ParticleCompositeGradient;
}();
__decorate$1([
    deepClone
], ParticleCompositeGradient.prototype, "constantMin", void 0);
__decorate$1([
    deepClone
], ParticleCompositeGradient.prototype, "constantMax", void 0);
__decorate$1([
    deepClone
], ParticleCompositeGradient.prototype, "gradientMin", void 0);
__decorate$1([
    deepClone
], ParticleCompositeGradient.prototype, "gradientMax", void 0);

/**
 * Particle generator module.
 */ var ParticleGeneratorModule = /*#__PURE__*/ function() {
    function ParticleGeneratorModule(generator) {
        this._enabled = false;
        this._generator = generator;
    }
    var _proto = ParticleGeneratorModule.prototype;
    _proto._enableMacro = function _enableMacro(shaderData, lastEnableMacro, enableMacro) {
        if (lastEnableMacro !== enableMacro) {
            lastEnableMacro && shaderData.disableMacro(lastEnableMacro);
            enableMacro && shaderData.enableMacro(enableMacro);
        }
        return enableMacro;
    };
    _proto._onCompositeCurveChange = function _onCompositeCurveChange(lastValue, value) {
        var renderer = this._generator._renderer;
        lastValue == null ? void 0 : lastValue._unRegisterOnValueChanged(renderer._onGeneratorParamsChanged);
        value == null ? void 0 : value._registerOnValueChanged(renderer._onGeneratorParamsChanged);
        renderer._onGeneratorParamsChanged();
    };
    _create_class$2(ParticleGeneratorModule, [
        {
            key: "enabled",
            get: /**
   * Specifies whether the module is enabled or not.
   */ function get() {
                return this._enabled;
            },
            set: function set(value) {
                this._enabled = value;
            }
        }
    ]);
    return ParticleGeneratorModule;
}();
__decorate$1([
    ignoreClone
], ParticleGeneratorModule.prototype, "_generator", void 0);

/**
 * Color over lifetime module.
 */ var ColorOverLifetimeModule = /*#__PURE__*/ function(ParticleGeneratorModule) {
    _inherits$2(ColorOverLifetimeModule, ParticleGeneratorModule);
    function ColorOverLifetimeModule() {
        var _this;
        _this = ParticleGeneratorModule.apply(this, arguments) || this, /** Color gradient over lifetime. */ _this.color = new ParticleCompositeGradient(new ParticleGradient([
            new GradientColorKey(0.0, new Color(1, 1, 1)),
            new GradientColorKey(1.0, new Color(1, 1, 1))
        ], [
            new GradientAlphaKey(0, 1),
            new GradientAlphaKey(1, 1)
        ])), /** @internal */ _this._colorGradientRand = new Rand(0, ParticleRandomSubSeeds.ColorOverLifetime), _this._gradientKeysCount = new Vector4(0, 0, 0, 0) // x: minColorKeysMaxTime, y: minAlphaKeysMaxTime, z: maxColorKeysMaxTime, w: maxAlphaKeysMaxTime
        ;
        return _this;
    }
    var _proto = ColorOverLifetimeModule.prototype;
    /**
   * @internal
   */ _proto._updateShaderData = function _updateShaderData(shaderData) {
        var colorMacro = null;
        if (this.enabled) {
            var mode = this.color.mode;
            if (mode !== ParticleGradientMode.Gradient && mode !== ParticleGradientMode.TwoGradients) {
                throw new Error("Invalid color mode, only gradient and two gradients are supported in color over lifetime.");
            }
            var color = this.color;
            shaderData.setFloatArray(ColorOverLifetimeModule._maxGradientColor, color.gradientMax._getColorTypeArray());
            shaderData.setFloatArray(ColorOverLifetimeModule._maxGradientAlpha, color.gradientMax._getAlphaTypeArray());
            if (mode === ParticleGradientMode.Gradient) {
                colorMacro = ColorOverLifetimeModule._gradientMacro;
            } else {
                shaderData.setFloatArray(ColorOverLifetimeModule._minGradientColor, color.gradientMin._getColorTypeArray());
                shaderData.setFloatArray(ColorOverLifetimeModule._minGradientAlpha, color.gradientMin._getAlphaTypeArray());
                colorMacro = ColorOverLifetimeModule._randomGradientsMacro;
            }
            var colorMinKeys = color.gradientMin.colorKeys;
            var alphaMinKeys = color.gradientMin.alphaKeys;
            var colorMaxKeys = color.gradientMax.colorKeys;
            var alphaMaxKeys = color.gradientMax.alphaKeys;
            this._gradientKeysCount.set(colorMinKeys.length ? colorMinKeys[colorMinKeys.length - 1].time : 0, alphaMinKeys.length ? alphaMinKeys[alphaMinKeys.length - 1].time : 0, colorMaxKeys.length ? colorMaxKeys[colorMaxKeys.length - 1].time : 0, alphaMaxKeys.length ? alphaMaxKeys[alphaMaxKeys.length - 1].time : 0);
            shaderData.setVector4(ColorOverLifetimeModule._gradientKeysCount, this._gradientKeysCount);
        }
        this._colorMacro = this._enableMacro(shaderData, this._colorMacro, colorMacro);
    };
    /**
   * @internal
   */ _proto._resetRandomSeed = function _resetRandomSeed(seed) {
        this._colorGradientRand.reset(seed, ParticleRandomSubSeeds.ColorOverLifetime);
    };
    return ColorOverLifetimeModule;
}(ParticleGeneratorModule);
ColorOverLifetimeModule._gradientMacro = ShaderMacro.getByName("RENDERER_COL_GRADIENT");
ColorOverLifetimeModule._randomGradientsMacro = ShaderMacro.getByName("RENDERER_COL_RANDOM_GRADIENTS");
ColorOverLifetimeModule._minGradientColor = ShaderProperty.getByName("renderer_COLMinGradientColor");
ColorOverLifetimeModule._minGradientAlpha = ShaderProperty.getByName("renderer_COLMinGradientAlpha");
ColorOverLifetimeModule._maxGradientColor = ShaderProperty.getByName("renderer_COLMaxGradientColor");
ColorOverLifetimeModule._maxGradientAlpha = ShaderProperty.getByName("renderer_COLMaxGradientAlpha");
ColorOverLifetimeModule._gradientKeysCount = ShaderProperty.getByName("renderer_COLGradientKeysMaxTime");
__decorate$1([
    deepClone
], ColorOverLifetimeModule.prototype, "color", void 0);
__decorate$1([
    ignoreClone
], ColorOverLifetimeModule.prototype, "_colorGradientRand", void 0);
__decorate$1([
    ignoreClone
], ColorOverLifetimeModule.prototype, "_gradientKeysCount", void 0);
__decorate$1([
    ignoreClone
], ColorOverLifetimeModule.prototype, "_colorMacro", void 0);

/**
 * Particle composite curve.
 */ var ParticleCompositeCurve = /*#__PURE__*/ function() {
    function ParticleCompositeCurve(constantOrCurve, constantMaxOrCurveMax) {
        this._updateManager = new UpdateFlagManager();
        this._mode = ParticleCurveMode.Constant;
        this._constantMin = 0;
        this._constantMax = 0;
        this._updateDispatch = this._updateManager.dispatch.bind(this._updateManager);
        if (typeof constantOrCurve === "number") {
            if (constantMaxOrCurveMax) {
                this.constantMin = constantOrCurve;
                this.constantMax = constantMaxOrCurveMax;
                this.mode = ParticleCurveMode.TwoConstants;
            } else {
                this.constant = constantOrCurve;
                this.mode = ParticleCurveMode.Constant;
            }
        } else {
            if (constantMaxOrCurveMax) {
                this.curveMin = constantOrCurve;
                this.curveMax = constantMaxOrCurveMax;
                this.mode = ParticleCurveMode.TwoCurves;
            } else {
                this.curve = constantOrCurve;
                this.mode = ParticleCurveMode.Curve;
            }
        }
    }
    var _proto = ParticleCompositeCurve.prototype;
    /**
   * Query the value at the specified time.
   * @param time - Normalized time at which to evaluate the curve, Valid when `mode` is set to `Curve` or `TwoCurves`
   * @param lerpFactor - Lerp factor between two constants or curves, Valid when `mode` is set to `TwoConstants` or `TwoCurves`
   * @returns - The result curve value
   */ _proto.evaluate = function evaluate(time, lerpFactor) {
        switch(this.mode){
            case ParticleCurveMode.Constant:
                return this.constant;
            case ParticleCurveMode.TwoConstants:
                return this.constantMin + (this.constantMax - this.constantMin) * lerpFactor;
            case ParticleCurveMode.Curve:
                var _this_curve;
                return (_this_curve = this.curve) == null ? void 0 : _this_curve._evaluate(time);
            case ParticleCurveMode.TwoCurves:
                var _this_curveMin, _this_curveMax;
                var min = (_this_curveMin = this.curveMin) == null ? void 0 : _this_curveMin._evaluate(time);
                return min + (((_this_curveMax = this.curveMax) == null ? void 0 : _this_curveMax._evaluate(time)) - min) * lerpFactor;
        }
    };
    /**
   * @internal
   */ _proto._getMax = function _getMax() {
        switch(this.mode){
            case ParticleCurveMode.Constant:
                return this.constantMax;
            case ParticleCurveMode.TwoConstants:
                return Math.max(this.constantMin, this.constantMax);
            case ParticleCurveMode.Curve:
                var _this_curveMax;
                return this._getMaxKeyValue((_this_curveMax = this.curveMax) == null ? void 0 : _this_curveMax.keys);
            case ParticleCurveMode.TwoCurves:
                var _this_curveMin, _this_curveMax1;
                var min = this._getMaxKeyValue((_this_curveMin = this.curveMin) == null ? void 0 : _this_curveMin.keys);
                var max = this._getMaxKeyValue((_this_curveMax1 = this.curveMax) == null ? void 0 : _this_curveMax1.keys);
                return min > max ? min : max;
        }
    };
    /**
   * @internal

   */ _proto._getMinMax = function _getMinMax(out) {
        switch(this.mode){
            case ParticleCurveMode.Constant:
                out.x = out.y = this.constantMax;
                break;
            case ParticleCurveMode.TwoConstants:
                out.set(Math.min(this.constantMin, this.constantMax), Math.max(this.constantMin, this.constantMax));
                break;
            case ParticleCurveMode.Curve:
                var _this_curveMax, _this_curveMax1;
                out.set(this._getMinKeyValue((_this_curveMax = this.curveMax) == null ? void 0 : _this_curveMax.keys), this._getMaxKeyValue((_this_curveMax1 = this.curveMax) == null ? void 0 : _this_curveMax1.keys));
                break;
            case ParticleCurveMode.TwoCurves:
                var _this_curveMax2, _this_curveMin, _this_curveMax3, _this_curveMin1;
                var minCurveMax = this._getMinKeyValue((_this_curveMax2 = this.curveMax) == null ? void 0 : _this_curveMax2.keys);
                var minCurveMin = this._getMinKeyValue((_this_curveMin = this.curveMin) == null ? void 0 : _this_curveMin.keys);
                var maxCurveMax = this._getMaxKeyValue((_this_curveMax3 = this.curveMax) == null ? void 0 : _this_curveMax3.keys);
                var maxCurveMin = this._getMaxKeyValue((_this_curveMin1 = this.curveMin) == null ? void 0 : _this_curveMin1.keys);
                var min = minCurveMax < minCurveMin ? minCurveMax : minCurveMin;
                var max = maxCurveMax > maxCurveMin ? maxCurveMax : maxCurveMin;
                out.set(min, max);
                break;
        }
    };
    /**
   * @internal
   */ _proto._registerOnValueChanged = function _registerOnValueChanged(listener) {
        this._updateManager.addListener(listener);
    };
    /**
   * @internal
   */ _proto._unRegisterOnValueChanged = function _unRegisterOnValueChanged(listener) {
        this._updateManager.removeListener(listener);
    };
    _proto._getMaxKeyValue = function _getMaxKeyValue(keys) {
        var max = undefined;
        var _keys_length;
        var count = (_keys_length = keys == null ? void 0 : keys.length) != null ? _keys_length : 0;
        if (count > 0) {
            max = keys[0].value;
            for(var i = 1; i < count; i++){
                var value = keys[i].value;
                max = Math.max(max, value);
            }
        }
        return max;
    };
    _proto._getMinKeyValue = function _getMinKeyValue(keys) {
        var min = undefined;
        var _keys_length;
        var count = (_keys_length = keys == null ? void 0 : keys.length) != null ? _keys_length : 0;
        if (count > 0) {
            min = keys[0].value;
            for(var i = 1; i < count; i++){
                var value = keys[i].value;
                min = Math.min(min, value);
            }
        }
        return min;
    };
    _proto._onCurveChange = function _onCurveChange(lastValue, value) {
        var dispatch = this._updateDispatch;
        lastValue == null ? void 0 : lastValue._unRegisterOnValueChanged(dispatch);
        value == null ? void 0 : value._registerOnValueChanged(dispatch);
        dispatch();
    };
    _create_class$2(ParticleCompositeCurve, [
        {
            key: "mode",
            get: /**
   * The curve mode.
   */ function get() {
                return this._mode;
            },
            set: function set(value) {
                if (value !== this._mode) {
                    this._mode = value;
                    this._updateDispatch();
                }
            }
        },
        {
            key: "constantMin",
            get: /**
   * The min constant value used by the curve if mode is set to `TwoConstants`.
   */ function get() {
                return this._constantMin;
            },
            set: function set(value) {
                if (value !== this._constantMin) {
                    this._constantMin = value;
                    this._updateDispatch();
                }
            }
        },
        {
            key: "constantMax",
            get: /**
   * The max constant value used by the curve if mode is set to `TwoConstants`.
   */ function get() {
                return this._constantMax;
            },
            set: function set(value) {
                if (value !== this._constantMax) {
                    this._constantMax = value;
                    this._updateDispatch();
                }
            }
        },
        {
            key: "curveMin",
            get: /**
   * The min curve used by the curve if mode is set to `TwoCurves`.
   */ function get() {
                return this._curveMin;
            },
            set: function set(value) {
                var lastCurve = this._curveMin;
                if (value !== lastCurve) {
                    this._curveMin = value;
                    this._onCurveChange(lastCurve, value);
                }
            }
        },
        {
            key: "curveMax",
            get: /**
   * The max curve used by the curve if mode is set to `TwoCurves`.
   */ function get() {
                return this._curveMax;
            },
            set: function set(value) {
                var lastCurve = this._curveMax;
                if (value !== lastCurve) {
                    this._curveMax = value;
                    this._onCurveChange(lastCurve, value);
                }
            }
        },
        {
            key: "constant",
            get: /**
   * The constant value used by the curve if mode is set to `Constant`.
   */ function get() {
                return this.constantMax;
            },
            set: function set(value) {
                this.constantMax = value;
            }
        },
        {
            key: "curve",
            get: /**
   * The curve used by the curve if mode is set to `Curve`.
   */ function get() {
                return this.curveMax;
            },
            set: function set(value) {
                this.curveMax = value;
            }
        }
    ]);
    return ParticleCompositeCurve;
}();
__decorate$1([
    ignoreClone
], ParticleCompositeCurve.prototype, "_updateManager", void 0);
__decorate$1([
    deepClone
], ParticleCompositeCurve.prototype, "_curveMin", void 0);
__decorate$1([
    deepClone
], ParticleCompositeCurve.prototype, "_curveMax", void 0);
__decorate$1([
    ignoreClone
], ParticleCompositeCurve.prototype, "_updateDispatch", void 0);

/**
 * The EmissionModule of a Particle Generator.
 */ var EmissionModule = /*#__PURE__*/ function(ParticleGeneratorModule) {
    _inherits$2(EmissionModule, ParticleGeneratorModule);
    function EmissionModule() {
        var _this;
        _this = ParticleGeneratorModule.apply(this, arguments) || this, /**  The rate of particle emission. */ _this.rateOverTime = new ParticleCompositeCurve(10), /**  The rate at which the emitter spawns new particles over distance. */ _this.rateOverDistance = new ParticleCompositeCurve(0), /** @internal */ _this._shapeRand = new Rand(0, ParticleRandomSubSeeds.Shape), /** @internal */ _this._frameRateTime = 0, _this._bursts = [], _this._currentBurstIndex = 0, _this._burstRand = new Rand(0, ParticleRandomSubSeeds.Burst);
        return _this;
    }
    var _proto = EmissionModule.prototype;
    /**
   * Add a single burst.
   * @param burst - The burst
   */ _proto.addBurst = function addBurst(burst) {
        var bursts = this._bursts;
        var burstIndex = bursts.length;
        while(--burstIndex >= 0 && burst.time < bursts[burstIndex].time);
        bursts.splice(burstIndex + 1, 0, burst);
    };
    /**
   * Remove a single burst from the array of bursts.
   * @param burst - The burst data
   */ _proto.removeBurst = function removeBurst(burst) {
        var index = this._bursts.indexOf(burst);
        if (index !== -1) {
            this._bursts.splice(index, 1);
        }
    };
    /**
   * Remove a single burst from the array of bursts.
   * @param index - The burst data index
   */ _proto.removeBurstByIndex = function removeBurstByIndex(index) {
        this._bursts.splice(index, 1);
    };
    /**
   * Clear burst data.
   */ _proto.clearBurst = function clearBurst() {
        this._bursts.length = 0;
    };
    /**
   * @internal
   */ _proto._emit = function _emit(lastPlayTime, playTime) {
        this._emitByRateOverTime(playTime);
        this._emitByBurst(lastPlayTime, playTime);
    };
    /**
   * @internal
   */ _proto._resetRandomSeed = function _resetRandomSeed(seed) {
        this._burstRand.reset(seed, ParticleRandomSubSeeds.Burst);
        this._shapeRand.reset(seed, ParticleRandomSubSeeds.Shape);
    };
    /**
   * @internal
   */ _proto._reset = function _reset() {
        this._frameRateTime = 0;
        this._currentBurstIndex = 0;
    };
    /**
   * @internal
   */ _proto._destroy = function _destroy() {
        var _this__shape;
        (_this__shape = this._shape) == null ? void 0 : _this__shape._unRegisterOnValueChanged(this._generator._renderer._onGeneratorParamsChanged);
    };
    _proto._emitByRateOverTime = function _emitByRateOverTime(playTime) {
        var ratePerSeconds = this.rateOverTime.evaluate(undefined, undefined);
        if (ratePerSeconds > 0) {
            var generator = this._generator;
            var emitInterval = 1.0 / ratePerSeconds;
            var cumulativeTime = playTime - this._frameRateTime;
            while(cumulativeTime >= emitInterval){
                cumulativeTime -= emitInterval;
                this._frameRateTime += emitInterval;
                generator._emit(this._frameRateTime, 1);
            }
        }
    };
    _proto._emitByBurst = function _emitByBurst(lastPlayTime, playTime) {
        var main = this._generator.main;
        var duration = main.duration;
        var cycleCount = Math.floor((playTime - lastPlayTime) / duration);
        // Across one cycle
        if (main.isLoop && (cycleCount > 0 || playTime % duration < lastPlayTime % duration)) {
            var middleTime = Math.ceil(lastPlayTime / duration) * duration;
            this._emitBySubBurst(lastPlayTime, middleTime, duration);
            this._currentBurstIndex = 0;
            for(var i = 0; i < cycleCount; i++){
                var lastMiddleTime = middleTime;
                middleTime += duration;
                this._emitBySubBurst(lastMiddleTime, middleTime, duration);
                this._currentBurstIndex = 0;
            }
            this._emitBySubBurst(middleTime, playTime, duration);
        } else {
            this._emitBySubBurst(lastPlayTime, playTime, duration);
        }
    };
    _proto._emitBySubBurst = function _emitBySubBurst(lastPlayTime, playTime, duration) {
        var generator = this._generator;
        var rand = this._burstRand;
        var bursts = this.bursts;
        // Calculate the relative time of the burst
        var baseTime = Math.floor(lastPlayTime / duration) * duration;
        var startTime = lastPlayTime % duration;
        var endTime = startTime + (playTime - lastPlayTime);
        var index = this._currentBurstIndex;
        for(var n = bursts.length; index < n; index++){
            var burst = bursts[index];
            var burstTime = burst.time;
            if (burstTime > endTime) {
                break;
            }
            if (burstTime >= startTime) {
                var count = burst.count.evaluate(undefined, rand.random());
                generator._emit(baseTime + burstTime, count);
            }
        }
        this._currentBurstIndex = index;
    };
    _create_class$2(EmissionModule, [
        {
            key: "shape",
            get: /**
   * The shape of the emitter.
   */ function get() {
                return this._shape;
            },
            set: function set(value) {
                var lastShape = this._shape;
                if (value !== lastShape) {
                    this._shape = value;
                    var renderer = this._generator._renderer;
                    lastShape == null ? void 0 : lastShape._unRegisterOnValueChanged(renderer._onGeneratorParamsChanged);
                    value == null ? void 0 : value._registerOnValueChanged(renderer._onGeneratorParamsChanged);
                    renderer._onGeneratorParamsChanged();
                }
            }
        },
        {
            key: "bursts",
            get: /**
   * Gets the burst array.
   */ function get() {
                return this._bursts;
            }
        }
    ]);
    return EmissionModule;
}(ParticleGeneratorModule);
__decorate$1([
    deepClone
], EmissionModule.prototype, "rateOverTime", void 0);
__decorate$1([
    deepClone
], EmissionModule.prototype, "rateOverDistance", void 0);
__decorate$1([
    deepClone
], EmissionModule.prototype, "_shape", void 0);
__decorate$1([
    ignoreClone
], EmissionModule.prototype, "_shapeRand", void 0);
__decorate$1([
    deepClone
], EmissionModule.prototype, "_bursts", void 0);
__decorate$1([
    ignoreClone
], EmissionModule.prototype, "_burstRand", void 0);

/**
 * Force over lifetime module.
 */ var ForceOverLifetimeModule = /*#__PURE__*/ function(ParticleGeneratorModule) {
    _inherits$2(ForceOverLifetimeModule, ParticleGeneratorModule);
    function ForceOverLifetimeModule(generator) {
        var _this;
        _this = ParticleGeneratorModule.call(this, generator) || this, /** @internal */ _this._forceRand = new Rand(0, ParticleRandomSubSeeds.ForceOverLifetime), _this._forceMinConstant = new Vector3(), _this._forceMaxConstant = new Vector3(), _this._space = ParticleSimulationSpace.Local;
        _this.forceX = new ParticleCompositeCurve(0);
        _this.forceY = new ParticleCompositeCurve(0);
        _this.forceZ = new ParticleCompositeCurve(0);
        return _this;
    }
    var _proto = ForceOverLifetimeModule.prototype;
    /**
   * @internal
   */ _proto._updateShaderData = function _updateShaderData(shaderData) {
        var forceModeMacro = null;
        var isRandomModeMacro = null;
        if (this.enabled) {
            var forceX = this._forceX;
            var forceY = this._forceY;
            var forceZ = this._forceZ;
            var isRandomCurveMode = forceX.mode === ParticleCurveMode.TwoCurves && forceY.mode === ParticleCurveMode.TwoCurves && forceZ.mode === ParticleCurveMode.TwoCurves;
            if (isRandomCurveMode || forceX.mode === ParticleCurveMode.Curve && forceY.mode === ParticleCurveMode.Curve && forceZ.mode === ParticleCurveMode.Curve) {
                shaderData.setFloatArray(ForceOverLifetimeModule._maxGradientXProperty, forceX.curveMax._getTypeArray());
                shaderData.setFloatArray(ForceOverLifetimeModule._maxGradientYProperty, forceY.curveMax._getTypeArray());
                shaderData.setFloatArray(ForceOverLifetimeModule._maxGradientZProperty, forceZ.curveMax._getTypeArray());
                forceModeMacro = ForceOverLifetimeModule._curveModeMacro;
                if (isRandomCurveMode) {
                    shaderData.setFloatArray(ForceOverLifetimeModule._minGradientXProperty, forceX.curveMin._getTypeArray());
                    shaderData.setFloatArray(ForceOverLifetimeModule._minGradientYProperty, forceY.curveMin._getTypeArray());
                    shaderData.setFloatArray(ForceOverLifetimeModule._minGradientZProperty, forceZ.curveMin._getTypeArray());
                    isRandomModeMacro = ForceOverLifetimeModule._isRandomMacro;
                }
            } else {
                var constantMax = this._forceMaxConstant;
                constantMax.set(forceX.constantMax, forceY.constantMax, forceZ.constantMax);
                shaderData.setVector3(ForceOverLifetimeModule._maxConstantProperty, constantMax);
                forceModeMacro = ForceOverLifetimeModule._constantModeMacro;
                if (forceX.mode === ParticleCurveMode.TwoConstants && forceY.mode === ParticleCurveMode.TwoConstants && forceZ.mode === ParticleCurveMode.TwoConstants) {
                    var constantMin = this._forceMinConstant;
                    constantMin.set(forceX.constantMin, forceY.constantMin, forceZ.constantMin);
                    shaderData.setVector3(ForceOverLifetimeModule._minConstantProperty, constantMin);
                    isRandomModeMacro = ForceOverLifetimeModule._isRandomMacro;
                }
            }
            shaderData.setInt(ForceOverLifetimeModule._spaceProperty, this._space);
        }
        this._forceMacro = this._enableMacro(shaderData, this._forceMacro, forceModeMacro);
        this._randomModeMacro = this._enableMacro(shaderData, this._randomModeMacro, isRandomModeMacro);
    };
    /**
   * @internal
   */ _proto._resetRandomSeed = function _resetRandomSeed(seed) {
        this._forceRand.reset(seed, ParticleRandomSubSeeds.ForceOverLifetime);
    };
    /**
   * @internal
   */ _proto._isRandomMode = function _isRandomMode() {
        var modeX = this.forceX.mode;
        var modeY = this.forceY.mode;
        var modeZ = this.forceZ.mode;
        return modeX === ParticleCurveMode.TwoCurves && modeY === ParticleCurveMode.TwoCurves && modeZ === ParticleCurveMode.TwoCurves || modeX === ParticleCurveMode.TwoConstants && modeY === ParticleCurveMode.TwoConstants && modeZ === ParticleCurveMode.TwoConstants;
    };
    _create_class$2(ForceOverLifetimeModule, [
        {
            key: "forceX",
            get: /**
   * Force over lifetime for x axis.
   */ function get() {
                return this._forceX;
            },
            set: function set(value) {
                var lastValue = this._forceX;
                if (value !== lastValue) {
                    this._forceX = value;
                    this._onCompositeCurveChange(lastValue, value);
                }
            }
        },
        {
            key: "forceY",
            get: /**
   * Force over lifetime for y axis.
   */ function get() {
                return this._forceY;
            },
            set: function set(value) {
                var lastValue = this._forceY;
                if (value !== lastValue) {
                    this._forceY = value;
                    this._onCompositeCurveChange(lastValue, value);
                }
            }
        },
        {
            key: "forceZ",
            get: /**
   * Force over lifetime for z axis.
   */ function get() {
                return this._forceZ;
            },
            set: function set(value) {
                var lastValue = this._forceZ;
                if (value !== lastValue) {
                    this._forceZ = value;
                    this._onCompositeCurveChange(lastValue, value);
                }
            }
        },
        {
            key: "space",
            get: /**
   * Force space.
   */ function get() {
                return this._space;
            },
            set: function set(value) {
                if (value !== this._space) {
                    this._space = value;
                    this._generator._renderer._onGeneratorParamsChanged();
                }
            }
        }
    ]);
    return ForceOverLifetimeModule;
}(ParticleGeneratorModule);
ForceOverLifetimeModule._constantModeMacro = ShaderMacro.getByName("RENDERER_FOL_CONSTANT_MODE");
ForceOverLifetimeModule._curveModeMacro = ShaderMacro.getByName("RENDERER_FOL_CURVE_MODE");
ForceOverLifetimeModule._isRandomMacro = ShaderMacro.getByName("RENDERER_FOL_IS_RANDOM_TWO");
ForceOverLifetimeModule._minConstantProperty = ShaderProperty.getByName("renderer_FOLMinConst");
ForceOverLifetimeModule._maxConstantProperty = ShaderProperty.getByName("renderer_FOLMaxConst");
ForceOverLifetimeModule._minGradientXProperty = ShaderProperty.getByName("renderer_FOLMinGradientX");
ForceOverLifetimeModule._minGradientYProperty = ShaderProperty.getByName("renderer_FOLMinGradientY");
ForceOverLifetimeModule._minGradientZProperty = ShaderProperty.getByName("renderer_FOLMinGradientZ");
ForceOverLifetimeModule._maxGradientXProperty = ShaderProperty.getByName("renderer_FOLMaxGradientX");
ForceOverLifetimeModule._maxGradientYProperty = ShaderProperty.getByName("renderer_FOLMaxGradientY");
ForceOverLifetimeModule._maxGradientZProperty = ShaderProperty.getByName("renderer_FOLMaxGradientZ");
ForceOverLifetimeModule._spaceProperty = ShaderProperty.getByName("renderer_FOLSpace");
__decorate$1([
    ignoreClone
], ForceOverLifetimeModule.prototype, "_forceRand", void 0);
__decorate$1([
    ignoreClone
], ForceOverLifetimeModule.prototype, "_forceMinConstant", void 0);
__decorate$1([
    ignoreClone
], ForceOverLifetimeModule.prototype, "_forceMaxConstant", void 0);
__decorate$1([
    ignoreClone
], ForceOverLifetimeModule.prototype, "_forceMacro", void 0);
__decorate$1([
    ignoreClone
], ForceOverLifetimeModule.prototype, "_randomModeMacro", void 0);
__decorate$1([
    deepClone
], ForceOverLifetimeModule.prototype, "_forceX", void 0);
__decorate$1([
    deepClone
], ForceOverLifetimeModule.prototype, "_forceY", void 0);
__decorate$1([
    deepClone
], ForceOverLifetimeModule.prototype, "_forceZ", void 0);

/**
 * Control how Particle Generator apply transform scale.
 */ var ParticleScaleMode = /*#__PURE__*/ function(ParticleScaleMode) {
    /** Scale the Particle Generator using the entire transform hierarchy. */ ParticleScaleMode[ParticleScaleMode["Hierarchy"] = 0] = "Hierarchy";
    /** Scale the Particle Generator using only its own transform scale. (Ignores parent scale). */ ParticleScaleMode[ParticleScaleMode["Local"] = 1] = "Local";
    /** Only apply transform scale to the shape component, which controls where particles are spawned, but does not affect their size or movement. */ ParticleScaleMode[ParticleScaleMode["World"] = 2] = "World";
    return ParticleScaleMode;
}({});

var MainModule = /*#__PURE__*/ function() {
    function MainModule(generator) {
        this._tempVector40 = new Vector4();
        /** The duration of the Particle Generator in seconds. */ this.duration = 5.0;
        /** Specifies whether the Particle Generator loops. */ this.isLoop = true;
        /** Start delay in seconds. */ this.startDelay = new ParticleCompositeCurve(0);
        /** A flag to enable 3D particle rotation, when disabled, only `startRotationZ` is used. */ this.startRotation3D = false;
        /** The initial rotation of particles around the x-axis when emitted.*/ this.startRotationX = new ParticleCompositeCurve(0);
        /** The initial rotation of particles around the y-axis when emitted. */ this.startRotationY = new ParticleCompositeCurve(0);
        /** The initial rotation of particles around the z-axis when emitted. */ this.startRotationZ = new ParticleCompositeCurve(0);
        /** Makes some particles spin in the opposite direction. */ this.flipRotation = 0;
        /** The mode of start color */ this.startColor = new ParticleCompositeGradient(new Color(1, 1, 1, 1));
        /** A scale that this Particle Generator applies to gravity, defined by Physics.gravity. */ /** Override the default playback speed of the Particle Generator. */ this.simulationSpeed = 1.0;
        /** Control how the Particle Generator applies its Transform component to the particles it emits. */ this.scalingMode = ParticleScaleMode.Local;
        /** If set to true, the Particle Generator automatically begins to play on startup. */ this.playOnEnabled = true;
        /** @internal */ this._maxParticleBuffer = 1000;
        /** @internal */ this._startDelayRand = new Rand(0, ParticleRandomSubSeeds.StartDelay);
        /** @internal */ this._startSpeedRand = new Rand(0, ParticleRandomSubSeeds.StartSpeed);
        /** @internal */ this._startLifeTimeRand = new Rand(0, ParticleRandomSubSeeds.StartLifetime);
        /** @internal */ this._startColorRand = new Rand(0, ParticleRandomSubSeeds.StartColor);
        /** @internal */ this._startSizeRand = new Rand(0, ParticleRandomSubSeeds.StartSize);
        /** @internal */ this._startRotationRand = new Rand(0, ParticleRandomSubSeeds.StartRotation);
        this._gravityModifierRand = new Rand(0, ParticleRandomSubSeeds.GravityModifier);
        this._startSize3D = false;
        this._simulationSpace = ParticleSimulationSpace.Local;
        this._generator = generator;
        this.startLifetime = new ParticleCompositeCurve(5);
        this.startSpeed = new ParticleCompositeCurve(5);
        this.startSizeX = new ParticleCompositeCurve(1);
        this.startSizeY = new ParticleCompositeCurve(1);
        this.startSizeZ = new ParticleCompositeCurve(1);
        this.gravityModifier = new ParticleCompositeCurve(0);
    }
    var _proto = MainModule.prototype;
    /**
   * @internal
   */ _proto._resetRandomSeed = function _resetRandomSeed(randomSeed) {
        this._startSpeedRand.reset(randomSeed, ParticleRandomSubSeeds.StartSpeed);
        this._startLifeTimeRand.reset(randomSeed, ParticleRandomSubSeeds.StartLifetime);
        this._startColorRand.reset(randomSeed, ParticleRandomSubSeeds.StartColor);
        this._startSizeRand.reset(randomSeed, ParticleRandomSubSeeds.StartSize);
        this._startRotationRand.reset(randomSeed, ParticleRandomSubSeeds.StartRotation);
    };
    /**
   * @internal
   */ _proto._getPositionScale = function _getPositionScale() {
        var transform = this._generator._renderer.entity.transform;
        switch(this.scalingMode){
            case ParticleScaleMode.Hierarchy:
            case ParticleScaleMode.World:
                return transform.lossyWorldScale;
            case ParticleScaleMode.Local:
                return transform.scale;
        }
    };
    /**
   * @internal
   */ _proto._updateShaderData = function _updateShaderData(shaderData) {
        var renderer = this._generator._renderer;
        var transform = renderer.entity.transform;
        switch(this.simulationSpace){
            case ParticleSimulationSpace.Local:
                shaderData.setVector3(MainModule._worldPosition, transform.worldPosition);
                var worldRotation = transform.worldRotationQuaternion;
                var worldRotationV4 = this._tempVector40.copyFrom(worldRotation); // Maybe shaderData should support Quaternion
                shaderData.setVector4(MainModule._worldRotation, worldRotationV4);
                break;
            case ParticleSimulationSpace.World:
                break;
            default:
                throw new Error("ParticleRenderer: SimulationSpace value is invalid.");
        }
        switch(this.scalingMode){
            case ParticleScaleMode.Hierarchy:
                var scale = transform.lossyWorldScale;
                shaderData.setVector3(MainModule._positionScale, scale);
                shaderData.setVector3(MainModule._sizeScale, scale);
                break;
            case ParticleScaleMode.Local:
                var scale = transform.scale;
                shaderData.setVector3(MainModule._positionScale, scale);
                shaderData.setVector3(MainModule._sizeScale, scale);
                break;
            case ParticleScaleMode.World:
                shaderData.setVector3(MainModule._positionScale, transform.lossyWorldScale);
                shaderData.setVector3(MainModule._sizeScale, MainModule._vector3One);
                break;
        }
        shaderData.setVector3(MainModule._gravity, renderer.scene.physics.gravity);
        shaderData.setInt(MainModule._simulationSpace, this.simulationSpace);
        shaderData.setFloat(MainModule._startRotation3D, +this.startRotation3D);
        shaderData.setInt(MainModule._scaleMode, this.scalingMode);
    };
    /**
   * @internal
   */ _proto._cloneTo = function _cloneTo(target) {
        target.maxParticles = this.maxParticles;
        if (target._simulationSpace === ParticleSimulationSpace.World) {
            target._generator._generateTransformedBounds();
        }
    };
    _proto._onCompositeCurveChange = function _onCompositeCurveChange(lastValue, value) {
        var renderer = this._generator._renderer;
        lastValue == null ? void 0 : lastValue._unRegisterOnValueChanged(renderer._onGeneratorParamsChanged);
        value == null ? void 0 : value._registerOnValueChanged(renderer._onGeneratorParamsChanged);
        renderer._onGeneratorParamsChanged();
    };
    _create_class$2(MainModule, [
        {
            key: "startLifetime",
            get: /**
   * The initial lifetime of particles when emitted.
   */ function get() {
                return this._startLifetime;
            },
            set: function set(value) {
                var lastValue = this._startLifetime;
                if (value !== lastValue) {
                    this._startLifetime = value;
                    this._onCompositeCurveChange(lastValue, value);
                }
            }
        },
        {
            key: "startSpeed",
            get: /**
   * The initial speed of particles when the Particle Generator first spawns them.
   */ function get() {
                return this._startSpeed;
            },
            set: function set(value) {
                var lastValue = this._startSpeed;
                if (value !== lastValue) {
                    this._startSpeed = value;
                    this._onCompositeCurveChange(lastValue, value);
                }
            }
        },
        {
            key: "startSize3D",
            get: /**
   * A flag to enable specifying particle size individually for each axis.
   */ function get() {
                return this._startSize3D;
            },
            set: function set(value) {
                if (value !== this._startSize3D) {
                    this._startSize3D = value;
                    this._generator._renderer._onGeneratorParamsChanged();
                }
            }
        },
        {
            key: "startSizeX",
            get: /**
   * The initial size of particles along the x-axis when the Particle Generator first spawns them.
   */ function get() {
                return this._startSizeX;
            },
            set: function set(value) {
                var lastValue = this._startSizeX;
                if (value !== lastValue) {
                    this._startSizeX = value;
                    this._onCompositeCurveChange(lastValue, value);
                }
            }
        },
        {
            key: "startSizeY",
            get: /**
   * The initial size of particles along the y-axis when the Particle Generator first spawns them.
   */ function get() {
                return this._startSizeY;
            },
            set: function set(value) {
                var lastValue = this._startSizeY;
                if (value !== lastValue) {
                    this._startSizeY = value;
                    this._onCompositeCurveChange(lastValue, value);
                }
            }
        },
        {
            key: "startSizeZ",
            get: /**
   * The initial size of particles along the z-axis when the Particle Generator first spawns them.
   */ function get() {
                return this._startSizeZ;
            },
            set: function set(value) {
                var lastValue = this._startSizeZ;
                if (value !== lastValue) {
                    this._startSizeZ = value;
                    this._onCompositeCurveChange(lastValue, value);
                }
            }
        },
        {
            key: "gravityModifier",
            get: /**
   * A scale that this Particle Generator applies to gravity, defined by Physics.gravity.
   */ function get() {
                return this._gravityModifier;
            },
            set: function set(value) {
                var lastValue = this._gravityModifier;
                if (value !== lastValue) {
                    this._gravityModifier = value;
                    this._onCompositeCurveChange(lastValue, value);
                }
            }
        },
        {
            key: "simulationSpace",
            get: /**
   * This selects the space in which to simulate particles. It can be either world or local space.
   */ function get() {
                return this._simulationSpace;
            },
            set: function set(value) {
                if (value !== this._simulationSpace) {
                    this._simulationSpace = value;
                    var generator = this._generator;
                    generator._renderer._onTransformChanged(TransformModifyFlags.WorldMatrix);
                    if (value === ParticleSimulationSpace.Local) {
                        generator._freeBoundsArray();
                    }
                }
            }
        },
        {
            key: "maxParticles",
            get: /**
   * Max particles count.
   */ function get() {
                return this._maxParticleBuffer - 1;
            },
            set: function set(value) {
                this._maxParticleBuffer = value + 1;
            }
        },
        {
            key: "startSize",
            get: /**
   * The initial size of particles when the Particle Generator first spawns them.
   */ function get() {
                return this.startSizeX;
            },
            set: function set(value) {
                this.startSizeX = value;
            }
        }
    ]);
    return MainModule;
}();
MainModule._vector3One = new Vector3(1, 1, 1);
MainModule._positionScale = ShaderProperty.getByName("renderer_PositionScale");
MainModule._sizeScale = ShaderProperty.getByName("renderer_SizeScale");
MainModule._worldPosition = ShaderProperty.getByName("renderer_WorldPosition");
MainModule._worldRotation = ShaderProperty.getByName("renderer_WorldRotation");
MainModule._gravity = ShaderProperty.getByName("renderer_Gravity");
MainModule._simulationSpace = ShaderProperty.getByName("renderer_SimulationSpace");
MainModule._startRotation3D = ShaderProperty.getByName("renderer_ThreeDStartRotation");
MainModule._scaleMode = ShaderProperty.getByName("renderer_ScalingMode");
__decorate$1([
    deepClone
], MainModule.prototype, "startDelay", void 0);
__decorate$1([
    deepClone
], MainModule.prototype, "startRotationX", void 0);
__decorate$1([
    deepClone
], MainModule.prototype, "startRotationY", void 0);
__decorate$1([
    deepClone
], MainModule.prototype, "startRotationZ", void 0);
__decorate$1([
    deepClone
], MainModule.prototype, "startColor", void 0);
__decorate$1([
    ignoreClone
], MainModule.prototype, "_maxParticleBuffer", void 0);
__decorate$1([
    ignoreClone
], MainModule.prototype, "_startDelayRand", void 0);
__decorate$1([
    ignoreClone
], MainModule.prototype, "_startSpeedRand", void 0);
__decorate$1([
    ignoreClone
], MainModule.prototype, "_startLifeTimeRand", void 0);
__decorate$1([
    ignoreClone
], MainModule.prototype, "_startColorRand", void 0);
__decorate$1([
    ignoreClone
], MainModule.prototype, "_startSizeRand", void 0);
__decorate$1([
    ignoreClone
], MainModule.prototype, "_startRotationRand", void 0);
__decorate$1([
    ignoreClone
], MainModule.prototype, "_gravityModifierRand", void 0);
__decorate$1([
    deepClone
], MainModule.prototype, "_startLifetime", void 0);
__decorate$1([
    deepClone
], MainModule.prototype, "_startSpeed", void 0);
__decorate$1([
    deepClone
], MainModule.prototype, "_startSizeX", void 0);
__decorate$1([
    deepClone
], MainModule.prototype, "_startSizeY", void 0);
__decorate$1([
    deepClone
], MainModule.prototype, "_startSizeZ", void 0);
__decorate$1([
    deepClone
], MainModule.prototype, "_gravityModifier", void 0);
__decorate$1([
    ignoreClone
], MainModule.prototype, "_generator", void 0);

/**
 * Rotate particles throughout their lifetime.
 */ var RotationOverLifetimeModule = /*#__PURE__*/ function(ParticleGeneratorModule) {
    _inherits$2(RotationOverLifetimeModule, ParticleGeneratorModule);
    function RotationOverLifetimeModule() {
        var _this;
        _this = ParticleGeneratorModule.apply(this, arguments) || this, /** Specifies whether the rotation is separate on each axis, when disabled, only `rotationZ` is used. */ _this.separateAxes = false, /** Rotation over lifetime for z axis. */ _this.rotationX = new ParticleCompositeCurve(0), /** Rotation over lifetime for z axis. */ _this.rotationY = new ParticleCompositeCurve(0), /** Rotation over lifetime for z axis. */ _this.rotationZ = new ParticleCompositeCurve(45), /** @internal */ _this._rotationRand = new Rand(0, ParticleRandomSubSeeds.RotationOverLifetime), _this._rotationMinConstant = new Vector3(), _this._rotationMaxConstant = new Vector3();
        return _this;
    }
    var _proto = RotationOverLifetimeModule.prototype;
    /**
   * @internal
   */ _proto._updateShaderData = function _updateShaderData(shaderData) {
        var enableSeparateMacro = null;
        var isCurveMacro = null;
        var isRandomTwoMacro = null;
        if (this.enabled) {
            var rotationX = this.rotationX;
            var rotationY = this.rotationY;
            var rotationZ = this.rotationZ;
            var separateAxes = this.separateAxes;
            var isRandomCurveMode = separateAxes ? rotationX.mode === ParticleCurveMode.TwoCurves && rotationY.mode === ParticleCurveMode.TwoCurves && rotationZ.mode === ParticleCurveMode.TwoCurves : rotationZ.mode === ParticleCurveMode.TwoCurves;
            var isCurveMode = isRandomCurveMode || separateAxes ? rotationX.mode === ParticleCurveMode.Curve && rotationY.mode === ParticleCurveMode.Curve && rotationZ.mode === ParticleCurveMode.Curve : rotationZ.mode === ParticleCurveMode.Curve;
            if (isCurveMode) {
                shaderData.setFloatArray(RotationOverLifetimeModule._maxCurveZProperty, rotationZ.curveMax._getTypeArray());
                if (separateAxes) {
                    shaderData.setFloatArray(RotationOverLifetimeModule._maxCurveXProperty, rotationX.curveMax._getTypeArray());
                    shaderData.setFloatArray(RotationOverLifetimeModule._maxCurveYProperty, rotationY.curveMax._getTypeArray());
                }
                if (isRandomCurveMode) {
                    shaderData.setFloatArray(RotationOverLifetimeModule._minCurveZProperty, rotationZ.curveMin._getTypeArray());
                    if (separateAxes) {
                        shaderData.setFloatArray(RotationOverLifetimeModule._minCurveXProperty, rotationX.curveMin._getTypeArray());
                        shaderData.setFloatArray(RotationOverLifetimeModule._minCurveYProperty, rotationY.curveMin._getTypeArray());
                    }
                    isRandomTwoMacro = RotationOverLifetimeModule._isRandomTwoMacro;
                }
                isCurveMacro = RotationOverLifetimeModule._curveModeMacro;
            } else {
                var constantMax = this._rotationMaxConstant;
                constantMax.set(MathUtil.degreeToRadian(rotationX.constantMax), MathUtil.degreeToRadian(rotationY.constantMax), MathUtil.degreeToRadian(rotationZ.constantMax));
                shaderData.setVector3(RotationOverLifetimeModule._maxConstantProperty, constantMax);
                if (separateAxes ? rotationX.mode === ParticleCurveMode.TwoConstants && rotationY.mode === ParticleCurveMode.TwoConstants && rotationZ.mode === ParticleCurveMode.TwoConstants : rotationZ.mode === ParticleCurveMode.TwoConstants) {
                    var constantMin = this._rotationMinConstant;
                    constantMin.set(MathUtil.degreeToRadian(rotationX.constantMin), MathUtil.degreeToRadian(rotationY.constantMin), MathUtil.degreeToRadian(rotationZ.constantMin));
                    shaderData.setVector3(RotationOverLifetimeModule._minConstantProperty, constantMin);
                    isRandomTwoMacro = RotationOverLifetimeModule._isRandomTwoMacro;
                }
                isCurveMacro = RotationOverLifetimeModule._constantModeMacro;
            }
            if (separateAxes) {
                enableSeparateMacro = RotationOverLifetimeModule._isSeparateMacro;
            }
        }
        this._enableSeparateMacro = this._enableMacro(shaderData, this._enableSeparateMacro, enableSeparateMacro);
        this._isCurveMacro = this._enableMacro(shaderData, this._isCurveMacro, isCurveMacro);
        this._isRandomTwoMacro = this._enableMacro(shaderData, this._isRandomTwoMacro, isRandomTwoMacro);
    };
    /**
   * @internal
   */ _proto._resetRandomSeed = function _resetRandomSeed(seed) {
        this._rotationRand.reset(seed, ParticleRandomSubSeeds.RotationOverLifetime);
    };
    return RotationOverLifetimeModule;
}(ParticleGeneratorModule);
RotationOverLifetimeModule._constantModeMacro = ShaderMacro.getByName("RENDERER_ROL_CONSTANT_MODE");
RotationOverLifetimeModule._curveModeMacro = ShaderMacro.getByName("RENDERER_ROL_CURVE_MODE");
RotationOverLifetimeModule._isSeparateMacro = ShaderMacro.getByName("RENDERER_ROL_IS_SEPARATE");
RotationOverLifetimeModule._isRandomTwoMacro = ShaderMacro.getByName("RENDERER_ROL_IS_RANDOM_TWO");
RotationOverLifetimeModule._minConstantProperty = ShaderProperty.getByName("renderer_ROLMinConst");
RotationOverLifetimeModule._minCurveXProperty = ShaderProperty.getByName("renderer_ROLMinCurveX");
RotationOverLifetimeModule._minCurveYProperty = ShaderProperty.getByName("renderer_ROLMinCurveY");
RotationOverLifetimeModule._minCurveZProperty = ShaderProperty.getByName("renderer_ROLMinCurveZ");
RotationOverLifetimeModule._maxConstantProperty = ShaderProperty.getByName("renderer_ROLMaxConst");
RotationOverLifetimeModule._maxCurveXProperty = ShaderProperty.getByName("renderer_ROLMaxCurveX");
RotationOverLifetimeModule._maxCurveYProperty = ShaderProperty.getByName("renderer_ROLMaxCurveY");
RotationOverLifetimeModule._maxCurveZProperty = ShaderProperty.getByName("renderer_ROLMaxCurveZ");
__decorate$1([
    deepClone
], RotationOverLifetimeModule.prototype, "rotationX", void 0);
__decorate$1([
    deepClone
], RotationOverLifetimeModule.prototype, "rotationY", void 0);
__decorate$1([
    deepClone
], RotationOverLifetimeModule.prototype, "rotationZ", void 0);
__decorate$1([
    ignoreClone
], RotationOverLifetimeModule.prototype, "_rotationRand", void 0);
__decorate$1([
    ignoreClone
], RotationOverLifetimeModule.prototype, "_rotationMinConstant", void 0);
__decorate$1([
    ignoreClone
], RotationOverLifetimeModule.prototype, "_rotationMaxConstant", void 0);
__decorate$1([
    ignoreClone
], RotationOverLifetimeModule.prototype, "_enableSeparateMacro", void 0);
__decorate$1([
    ignoreClone
], RotationOverLifetimeModule.prototype, "_isCurveMacro", void 0);
__decorate$1([
    ignoreClone
], RotationOverLifetimeModule.prototype, "_isRandomTwoMacro", void 0);

/**
 * Particle curve.
 */ var ParticleCurve = /*#__PURE__*/ function() {
    function ParticleCurve() {
        for(var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++){
            keys[_key] = arguments[_key];
        }
        this._updateManager = new UpdateFlagManager();
        this._keys = new Array();
        this._typeArrayDirty = false;
        this._updateDispatch = this._updateManager.dispatch.bind(this._updateManager);
        for(var i = 0, n = keys.length; i < n; i++){
            var key = keys[i];
            this.addKey(key);
        }
    }
    var _proto = ParticleCurve.prototype;
    _proto.addKey = function addKey(timeOrKey, value) {
        var keys = this._keys;
        if (keys.length === 4) {
            throw new Error("Curve can only have 4 keys");
        }
        var key = typeof timeOrKey === "number" ? new CurveKey(timeOrKey, value) : timeOrKey;
        this._addKey(keys, key);
        key._registerOnValueChanged(this._updateDispatch);
        this._updateDispatch();
        this._typeArrayDirty = true;
    };
    /**
   * Remove a key from the curve.
   * @param index - The remove key index
   */ _proto.removeKey = function removeKey(index) {
        var keys = this._keys;
        var removeKey = keys[index];
        keys.splice(index, 1);
        this._typeArrayDirty = true;
        removeKey._unRegisterOnValueChanged(this._updateDispatch);
        this._updateDispatch();
    };
    /**
   * Set the keys of the curve.
   * @param keys - The keys
   */ _proto.setKeys = function setKeys(keys) {
        this._keys.length = 0;
        for(var i = 0, n = keys.length; i < n; i++){
            this.addKey(keys[i]);
        }
        this._typeArrayDirty = true;
    };
    /**
   * @internal
   */ _proto._evaluate = function _evaluate(normalizedAge) {
        var keys = this.keys;
        var length = keys.length;
        for(var i = 0; i < length; i++){
            var key = keys[i];
            var time = key.time;
            if (normalizedAge <= time) {
                if (i === 0) {
                    // Small than first key
                    return key.value;
                } else {
                    // Between two keys
                    var _keys_ = keys[i - 1], lastTime = _keys_.time, lastValue = _keys_.value;
                    var age = (normalizedAge - lastTime) / (time - lastTime);
                    return lastValue + (key.value - lastValue) * age;
                }
            }
        }
        // Large than last key
        return keys[length - 1].value;
    };
    /**
   * @internal
   */ _proto._getTypeArray = function _getTypeArray() {
        var typeArray = this._typeArray || (this._typeArray = new Float32Array(4 * 2));
        if (this._typeArrayDirty) {
            var keys = this._keys;
            for(var i = 0, n = Math.min(keys.length, 4); i < n; i++){
                var offset = i * 2;
                var key = keys[i];
                typeArray[offset] = key.time;
                typeArray[offset + 1] = key.value;
            }
            this._typeArrayDirty = false;
        }
        return typeArray;
    };
    /**
   * @internal
   */ _proto._registerOnValueChanged = function _registerOnValueChanged(listener) {
        this._updateManager.addListener(listener);
    };
    /**
   * @internal
   */ _proto._unRegisterOnValueChanged = function _unRegisterOnValueChanged(listener) {
        this._updateManager.removeListener(listener);
    };
    _proto._addKey = function _addKey(keys, key) {
        var count = keys.length;
        var time = key.time;
        var duration = count ? keys[count - 1].time : 0;
        if (time >= duration) {
            keys.push(key);
        } else {
            var index = count;
            while(--index >= 0 && time < keys[index].time);
            keys.splice(index + 1, 0, key);
        }
    };
    _create_class$2(ParticleCurve, [
        {
            key: "keys",
            get: /**
   * The keys of the curve.
   */ function get() {
                return this._keys;
            }
        }
    ]);
    return ParticleCurve;
}();
__decorate$1([
    ignoreClone
], ParticleCurve.prototype, "_updateManager", void 0);
__decorate$1([
    deepClone
], ParticleCurve.prototype, "_keys", void 0);
__decorate$1([
    ignoreClone
], ParticleCurve.prototype, "_typeArray", void 0);
__decorate$1([
    ignoreClone
], ParticleCurve.prototype, "_updateDispatch", void 0);
/**
 * The key of the curve.
 */ var CurveKey = /*#__PURE__*/ function() {
    function CurveKey(time, value) {
        this._updateManager = new UpdateFlagManager();
        this._time = time;
        this._value = value;
    }
    var _proto = CurveKey.prototype;
    /**
   * @internal
   */ _proto._registerOnValueChanged = function _registerOnValueChanged(listener) {
        this._updateManager.addListener(listener);
    };
    /**
   * @internal
   */ _proto._unRegisterOnValueChanged = function _unRegisterOnValueChanged(listener) {
        this._updateManager.removeListener(listener);
    };
    _create_class$2(CurveKey, [
        {
            key: "time",
            get: /**
   * The key time.
   */ function get() {
                return this._time;
            },
            set: function set(value) {
                if (value !== this._time) {
                    this._time = value;
                    this._updateManager.dispatch();
                }
            }
        },
        {
            key: "value",
            get: /**
   * The key value.
   */ function get() {
                return this._value;
            },
            set: function set(value) {
                if (value !== this._value) {
                    this._value = value;
                    this._updateManager.dispatch();
                }
            }
        }
    ]);
    return CurveKey;
}();
__decorate$1([
    ignoreClone
], CurveKey.prototype, "_updateManager", void 0);

/**
 * Size over lifetime module.
 */ var SizeOverLifetimeModule = /*#__PURE__*/ function(ParticleGeneratorModule) {
    _inherits$2(SizeOverLifetimeModule, ParticleGeneratorModule);
    function SizeOverLifetimeModule(generator) {
        var _this;
        _this = ParticleGeneratorModule.call(this, generator) || this, _this._separateAxes = false;
        _this.sizeX = new ParticleCompositeCurve(new ParticleCurve(new CurveKey(0, 0), new CurveKey(1, 1)));
        _this.sizeY = new ParticleCompositeCurve(new ParticleCurve(new CurveKey(0, 0), new CurveKey(1, 1)));
        _this.sizeZ = new ParticleCompositeCurve(new ParticleCurve(new CurveKey(0, 0), new CurveKey(1, 1)));
        return _this;
    }
    var _proto = SizeOverLifetimeModule.prototype;
    /**
   * @internal
   */ _proto._updateShaderData = function _updateShaderData(shaderData) {
        var enableSeparateMacro = null;
        var isCurveMacro = null;
        var isRandomTwoMacro = null;
        if (this.enabled) {
            var sizeX = this.sizeX;
            var sizeY = this.sizeY;
            var sizeZ = this.sizeZ;
            var separateAxes = this.separateAxes;
            var isRandomCurveMode = separateAxes ? sizeX.mode === ParticleCurveMode.TwoCurves && sizeY.mode === ParticleCurveMode.TwoCurves && sizeZ.mode === ParticleCurveMode.TwoCurves : sizeX.mode === ParticleCurveMode.TwoCurves;
            var isCurveMode = isRandomCurveMode || separateAxes ? sizeX.mode === ParticleCurveMode.Curve && sizeY.mode === ParticleCurveMode.Curve && sizeZ.mode === ParticleCurveMode.Curve : sizeX.mode === ParticleCurveMode.Curve;
            if (isCurveMode) {
                shaderData.setFloatArray(SizeOverLifetimeModule._maxCurveXProperty, sizeX.curveMax._getTypeArray());
                if (separateAxes) {
                    shaderData.setFloatArray(SizeOverLifetimeModule._maxCurveYProperty, sizeY.curveMax._getTypeArray());
                    shaderData.setFloatArray(SizeOverLifetimeModule._maxCurveZProperty, sizeZ.curveMax._getTypeArray());
                }
                if (isRandomCurveMode) {
                    shaderData.setFloatArray(SizeOverLifetimeModule._minCurveXProperty, sizeX.curveMin._getTypeArray());
                    if (separateAxes) {
                        shaderData.setFloatArray(SizeOverLifetimeModule._minCurveYProperty, sizeY.curveMin._getTypeArray());
                        shaderData.setFloatArray(SizeOverLifetimeModule._minCurveZProperty, sizeZ.curveMin._getTypeArray());
                    }
                    isRandomTwoMacro = SizeOverLifetimeModule._isRandomTwoMacro;
                }
                isCurveMacro = SizeOverLifetimeModule._curveModeMacro;
            }
            if (separateAxes) {
                enableSeparateMacro = SizeOverLifetimeModule._isSeparateMacro;
            }
        }
        this._enableSeparateMacro = this._enableMacro(shaderData, this._enableSeparateMacro, enableSeparateMacro);
        this._isCurveMacro = this._enableMacro(shaderData, this._isCurveMacro, isCurveMacro);
        this._isRandomTwoMacro = this._enableMacro(shaderData, this._isRandomTwoMacro, isRandomTwoMacro);
    };
    _create_class$2(SizeOverLifetimeModule, [
        {
            key: "separateAxes",
            get: function get() {
                return this._separateAxes;
            },
            set: /**
   * Specifies whether the Size is separate on each axis.
   */ function set(value) {
                if (value !== this._separateAxes) {
                    this._separateAxes = value;
                    this._generator._renderer._onGeneratorParamsChanged();
                }
            }
        },
        {
            key: "sizeX",
            get: /**
   * Size curve over lifetime for x axis.
   */ function get() {
                return this._sizeX;
            },
            set: function set(value) {
                var lastValue = this._sizeX;
                if (value !== lastValue) {
                    this._sizeX = value;
                    this._onCompositeCurveChange(lastValue, value);
                }
            }
        },
        {
            key: "sizeY",
            get: /**
   * Size curve over lifetime for y axis.
   */ function get() {
                return this._sizeY;
            },
            set: function set(value) {
                var lastValue = this._sizeY;
                if (value !== lastValue) {
                    this._sizeY = value;
                    this._onCompositeCurveChange(lastValue, value);
                }
            }
        },
        {
            key: "sizeZ",
            get: /**
   * Size curve over lifetime for z axis.
   */ function get() {
                return this._sizeZ;
            },
            set: function set(value) {
                var lastValue = this._sizeZ;
                if (value !== lastValue) {
                    this._sizeZ = value;
                    this._onCompositeCurveChange(lastValue, value);
                }
            }
        },
        {
            key: "size",
            get: /**
   * Size curve over lifetime.
   */ function get() {
                return this.sizeX;
            },
            set: function set(value) {
                this.sizeX = value;
            }
        }
    ]);
    return SizeOverLifetimeModule;
}(ParticleGeneratorModule);
SizeOverLifetimeModule._curveModeMacro = ShaderMacro.getByName("RENDERER_SOL_CURVE_MODE");
SizeOverLifetimeModule._isSeparateMacro = ShaderMacro.getByName("RENDERER_SOL_IS_SEPARATE");
SizeOverLifetimeModule._isRandomTwoMacro = ShaderMacro.getByName("RENDERER_SOL_IS_RANDOM_TWO");
SizeOverLifetimeModule._minCurveXProperty = ShaderProperty.getByName("renderer_SOLMinCurveX");
SizeOverLifetimeModule._minCurveYProperty = ShaderProperty.getByName("renderer_SOLMinCurveY");
SizeOverLifetimeModule._minCurveZProperty = ShaderProperty.getByName("renderer_SOLMinCurveZ");
SizeOverLifetimeModule._maxCurveXProperty = ShaderProperty.getByName("renderer_SOLMaxCurveX");
SizeOverLifetimeModule._maxCurveYProperty = ShaderProperty.getByName("renderer_SOLMaxCurveY");
SizeOverLifetimeModule._maxCurveZProperty = ShaderProperty.getByName("renderer_SOLMaxCurveZ");
__decorate$1([
    deepClone
], SizeOverLifetimeModule.prototype, "_sizeX", void 0);
__decorate$1([
    deepClone
], SizeOverLifetimeModule.prototype, "_sizeY", void 0);
__decorate$1([
    deepClone
], SizeOverLifetimeModule.prototype, "_sizeZ", void 0);
__decorate$1([
    ignoreClone
], SizeOverLifetimeModule.prototype, "_enableSeparateMacro", void 0);
__decorate$1([
    ignoreClone
], SizeOverLifetimeModule.prototype, "_isCurveMacro", void 0);
__decorate$1([
    ignoreClone
], SizeOverLifetimeModule.prototype, "_isRandomTwoMacro", void 0);

/**
 * Texture sheet animation module.
 */ var TextureSheetAnimationModule = /*#__PURE__*/ function(ParticleGeneratorModule) {
    _inherits$2(TextureSheetAnimationModule, ParticleGeneratorModule);
    function TextureSheetAnimationModule() {
        var _this;
        _this = ParticleGeneratorModule.apply(this, arguments) || this, /** Frame over time curve of the texture sheet. */ _this.frameOverTime = new ParticleCompositeCurve(new ParticleCurve(new CurveKey(0, 0), new CurveKey(1, 1))), /** Texture sheet animation type. */ _this.type = 0, /** Cycle count. */ _this.cycleCount = 1, /** @internal */ _this._tillingInfo = new Vector3(1, 1, 1) // x:subU, y:subV, z:tileCount
        , /** @internal */ _this._frameOverTimeRand = new Rand(0, ParticleRandomSubSeeds.TextureSheetAnimation), _this._tiling = new Vector2(1, 1);
        return _this;
    }
    var _proto = TextureSheetAnimationModule.prototype;
    /**
   * @internal
   */ _proto._updateShaderData = function _updateShaderData(shaderData) {
        var frameMacro = null;
        if (this.enabled) {
            var mode = this.frameOverTime.mode;
            if (mode === ParticleCurveMode.Curve || mode === ParticleCurveMode.TwoCurves) {
                var frame = this.frameOverTime;
                shaderData.setFloatArray(TextureSheetAnimationModule._frameMaxCurveProperty, frame.curveMax._getTypeArray());
                if (mode === ParticleCurveMode.Curve) {
                    frameMacro = TextureSheetAnimationModule._frameCurveMacro;
                } else {
                    shaderData.setFloatArray(TextureSheetAnimationModule._frameMinCurveProperty, frame.curveMin._getTypeArray());
                    frameMacro = TextureSheetAnimationModule._frameRandomCurvesMacro;
                }
                shaderData.setFloat(TextureSheetAnimationModule._cycleCountProperty, this.cycleCount);
                shaderData.setVector3(TextureSheetAnimationModule._tillingParamsProperty, this._tillingInfo);
            }
        }
        this._frameCurveMacro = this._enableMacro(shaderData, this._frameCurveMacro, frameMacro);
    };
    /**
   * @internal
   */ _proto._resetRandomSeed = function _resetRandomSeed(randomSeed) {
        this._frameOverTimeRand.reset(randomSeed, ParticleRandomSubSeeds.TextureSheetAnimation);
    };
    _create_class$2(TextureSheetAnimationModule, [
        {
            key: "tiling",
            get: /**
   * Tiling of the texture sheet.
   * */ function get() {
                return this._tiling;
            },
            set: function set(value) {
                this._tiling = value;
                this._tillingInfo.set(1.0 / value.x, 1.0 / value.y, value.x * value.y);
            }
        }
    ]);
    return TextureSheetAnimationModule;
}(ParticleGeneratorModule);
TextureSheetAnimationModule._frameCurveMacro = ShaderMacro.getByName("RENDERER_TSA_FRAME_CURVE");
TextureSheetAnimationModule._frameRandomCurvesMacro = ShaderMacro.getByName("RENDERER_TSA_FRAME_RANDOM_CURVES");
TextureSheetAnimationModule._frameMinCurveProperty = ShaderProperty.getByName("renderer_TSAFrameMinCurve");
TextureSheetAnimationModule._frameMaxCurveProperty = ShaderProperty.getByName("renderer_TSAFrameMaxCurve");
TextureSheetAnimationModule._cycleCountProperty = ShaderProperty.getByName("renderer_TSACycles");
TextureSheetAnimationModule._tillingParamsProperty = ShaderProperty.getByName("renderer_TSATillingParams");
__decorate$1([
    deepClone
], TextureSheetAnimationModule.prototype, "frameOverTime", void 0);
__decorate$1([
    shallowClone
], TextureSheetAnimationModule.prototype, "_tillingInfo", void 0);
__decorate$1([
    ignoreClone
], TextureSheetAnimationModule.prototype, "_frameOverTimeRand", void 0);
__decorate$1([
    deepClone
], TextureSheetAnimationModule.prototype, "_tiling", void 0);
__decorate$1([
    ignoreClone
], TextureSheetAnimationModule.prototype, "_frameCurveMacro", void 0);

/**
 * Velocity over lifetime module.
 */ var VelocityOverLifetimeModule = /*#__PURE__*/ function(ParticleGeneratorModule) {
    _inherits$2(VelocityOverLifetimeModule, ParticleGeneratorModule);
    function VelocityOverLifetimeModule(generator) {
        var _this;
        _this = ParticleGeneratorModule.call(this, generator) || this, /** @internal */ _this._velocityRand = new Rand(0, ParticleRandomSubSeeds.VelocityOverLifetime), _this._velocityMinConstant = new Vector3(), _this._velocityMaxConstant = new Vector3(), _this._space = ParticleSimulationSpace.Local;
        _this.velocityX = new ParticleCompositeCurve(0);
        _this.velocityY = new ParticleCompositeCurve(0);
        _this.velocityZ = new ParticleCompositeCurve(0);
        return _this;
    }
    var _proto = VelocityOverLifetimeModule.prototype;
    /**
   * @internal
   */ _proto._updateShaderData = function _updateShaderData(shaderData) {
        var velocityMacro = null;
        var isRandomModeMacro = null;
        if (this.enabled) {
            var velocityX = this.velocityX;
            var velocityY = this.velocityY;
            var velocityZ = this.velocityZ;
            var isRandomCurveMode = velocityX.mode === ParticleCurveMode.TwoCurves && velocityY.mode === ParticleCurveMode.TwoCurves && velocityZ.mode === ParticleCurveMode.TwoCurves;
            if (isRandomCurveMode || velocityX.mode === ParticleCurveMode.Curve && velocityY.mode === ParticleCurveMode.Curve && velocityZ.mode === ParticleCurveMode.Curve) {
                shaderData.setFloatArray(VelocityOverLifetimeModule._maxGradientXProperty, velocityX.curveMax._getTypeArray());
                shaderData.setFloatArray(VelocityOverLifetimeModule._maxGradientYProperty, velocityY.curveMax._getTypeArray());
                shaderData.setFloatArray(VelocityOverLifetimeModule._maxGradientZProperty, velocityZ.curveMax._getTypeArray());
                velocityMacro = VelocityOverLifetimeModule._curveModeMacro;
                if (isRandomCurveMode) {
                    shaderData.setFloatArray(VelocityOverLifetimeModule._minGradientXProperty, velocityX.curveMin._getTypeArray());
                    shaderData.setFloatArray(VelocityOverLifetimeModule._minGradientYProperty, velocityY.curveMin._getTypeArray());
                    shaderData.setFloatArray(VelocityOverLifetimeModule._minGradientZProperty, velocityZ.curveMin._getTypeArray());
                    isRandomModeMacro = VelocityOverLifetimeModule._isRandomMacro;
                }
            } else {
                var constantMax = this._velocityMaxConstant;
                constantMax.set(velocityX.constantMax, velocityY.constantMax, velocityZ.constantMax);
                shaderData.setVector3(VelocityOverLifetimeModule._maxConstantProperty, constantMax);
                velocityMacro = VelocityOverLifetimeModule._constantModeMacro;
                if (velocityX.mode === ParticleCurveMode.TwoConstants && velocityY.mode === ParticleCurveMode.TwoConstants && velocityZ.mode === ParticleCurveMode.TwoConstants) {
                    var constantMin = this._velocityMinConstant;
                    constantMin.set(velocityX.constantMin, velocityY.constantMin, velocityZ.constantMin);
                    shaderData.setVector3(VelocityOverLifetimeModule._minConstantProperty, constantMin);
                    isRandomModeMacro = VelocityOverLifetimeModule._isRandomMacro;
                }
            }
            shaderData.setInt(VelocityOverLifetimeModule._spaceProperty, this.space);
        }
        this._velocityMacro = this._enableMacro(shaderData, this._velocityMacro, velocityMacro);
        this._randomModeMacro = this._enableMacro(shaderData, this._randomModeMacro, isRandomModeMacro);
    };
    /**
   * @internal
   */ _proto._resetRandomSeed = function _resetRandomSeed(seed) {
        this._velocityRand.reset(seed, ParticleRandomSubSeeds.VelocityOverLifetime);
    };
    _create_class$2(VelocityOverLifetimeModule, [
        {
            key: "velocityX",
            get: /**
   * Velocity over lifetime for x axis.
   */ function get() {
                return this._velocityX;
            },
            set: function set(value) {
                var lastValue = this._velocityX;
                if (value !== lastValue) {
                    this._velocityX = value;
                    this._onCompositeCurveChange(lastValue, value);
                }
            }
        },
        {
            key: "velocityY",
            get: /**
   * Velocity over lifetime for y axis.
   */ function get() {
                return this._velocityY;
            },
            set: function set(value) {
                var lastValue = this._velocityY;
                if (value !== lastValue) {
                    this._velocityY = value;
                    this._onCompositeCurveChange(lastValue, value);
                }
            }
        },
        {
            key: "velocityZ",
            get: /**
   * Velocity over lifetime for z axis.
   */ function get() {
                return this._velocityZ;
            },
            set: function set(value) {
                var lastValue = this._velocityZ;
                if (value !== lastValue) {
                    this._velocityZ = value;
                    this._onCompositeCurveChange(lastValue, value);
                }
            }
        },
        {
            key: "space",
            get: /**
   * Velocity space.
   */ function get() {
                return this._space;
            },
            set: function set(value) {
                if (value !== this._space) {
                    this._space = value;
                    this._generator._renderer._onGeneratorParamsChanged();
                }
            }
        },
        {
            key: "enabled",
            get: function get() {
                return this._enabled;
            },
            set: function set(value) {
                if (value !== this._enabled) {
                    this._enabled = value;
                    this._generator._renderer._onGeneratorParamsChanged();
                }
            }
        }
    ]);
    return VelocityOverLifetimeModule;
}(ParticleGeneratorModule);
VelocityOverLifetimeModule._constantModeMacro = ShaderMacro.getByName("RENDERER_VOL_CONSTANT_MODE");
VelocityOverLifetimeModule._curveModeMacro = ShaderMacro.getByName("RENDERER_VOL_CURVE_MODE");
VelocityOverLifetimeModule._isRandomMacro = ShaderMacro.getByName("RENDERER_VOL_IS_RANDOM_TWO");
VelocityOverLifetimeModule._minConstantProperty = ShaderProperty.getByName("renderer_VOLMinConst");
VelocityOverLifetimeModule._maxConstantProperty = ShaderProperty.getByName("renderer_VOLMaxConst");
VelocityOverLifetimeModule._minGradientXProperty = ShaderProperty.getByName("renderer_VOLMinGradientX");
VelocityOverLifetimeModule._minGradientYProperty = ShaderProperty.getByName("renderer_VOLMinGradientY");
VelocityOverLifetimeModule._minGradientZProperty = ShaderProperty.getByName("renderer_VOLMinGradientZ");
VelocityOverLifetimeModule._maxGradientXProperty = ShaderProperty.getByName("renderer_VOLMaxGradientX");
VelocityOverLifetimeModule._maxGradientYProperty = ShaderProperty.getByName("renderer_VOLMaxGradientY");
VelocityOverLifetimeModule._maxGradientZProperty = ShaderProperty.getByName("renderer_VOLMaxGradientZ");
VelocityOverLifetimeModule._spaceProperty = ShaderProperty.getByName("renderer_VOLSpace");
__decorate$1([
    ignoreClone
], VelocityOverLifetimeModule.prototype, "_velocityRand", void 0);
__decorate$1([
    ignoreClone
], VelocityOverLifetimeModule.prototype, "_velocityMinConstant", void 0);
__decorate$1([
    ignoreClone
], VelocityOverLifetimeModule.prototype, "_velocityMaxConstant", void 0);
__decorate$1([
    ignoreClone
], VelocityOverLifetimeModule.prototype, "_velocityMacro", void 0);
__decorate$1([
    ignoreClone
], VelocityOverLifetimeModule.prototype, "_randomModeMacro", void 0);
__decorate$1([
    deepClone
], VelocityOverLifetimeModule.prototype, "_velocityX", void 0);
__decorate$1([
    deepClone
], VelocityOverLifetimeModule.prototype, "_velocityY", void 0);
__decorate$1([
    deepClone
], VelocityOverLifetimeModule.prototype, "_velocityZ", void 0);

/**
 * Particle Generator.
 */ var ParticleGenerator = /*#__PURE__*/ function() {
    function ParticleGenerator(renderer) {
        /** Use auto random seed. */ this.useAutoRandomSeed = true;
        /** Emission module. */ this.emission = new EmissionModule(this);
        /** Rotation over lifetime module. */ this.rotationOverLifetime = new RotationOverLifetimeModule(this);
        /** Color over lifetime module. */ this.colorOverLifetime = new ColorOverLifetimeModule(this);
        /** Texture sheet animation module. */ this.textureSheetAnimation = new TextureSheetAnimationModule(this);
        /** @internal */ this._currentParticleCount = 0;
        /** @internal */ this._playTime = 0;
        /** @internal */ this._firstNewElement = 0;
        /** @internal */ this._firstActiveElement = 0;
        /** @internal */ this._firstFreeElement = 0;
        /** @internal */ this._firstRetiredElement = 0;
        /** @internal */ this._vertexBufferBindings = new Array();
        /** @internal */ this._subPrimitive = new SubMesh(0, 0, MeshTopology.Triangles);
        this._isPlaying = false;
        this._instanceBufferResized = false;
        this._waitProcessRetiredElementCount = 0;
        this._randomSeed = 0;
        this._transformedBoundsCount = 0;
        this._firstActiveTransformedBoundingBox = 0;
        this._firstFreeTransformedBoundingBox = 0;
        this._playStartDelay = 0;
        this._renderer = renderer;
        var subPrimitive = new SubPrimitive();
        subPrimitive.start = 0;
        this._primitive = new Primitive(renderer.engine);
        this._reorganizeGeometryBuffers();
        this._resizeInstanceBuffer(true, ParticleGenerator._particleIncreaseCount);
        this.main = new MainModule(this);
        this.velocityOverLifetime = new VelocityOverLifetimeModule(this);
        this.forceOverLifetime = new ForceOverLifetimeModule(this);
        this.sizeOverLifetime = new SizeOverLifetimeModule(this);
        this.emission.enabled = true;
    }
    var _proto = ParticleGenerator.prototype;
    /**
   * Start emitting particles.
   * @param withChildren - Whether to start the particle generator of the child entity
   */ _proto.play = function play(withChildren) {
        if (withChildren === void 0) withChildren = true;
        if (withChildren) {
            var particleRenderers = this._renderer.entity.getComponentsIncludeChildren(ParticleRenderer, ParticleGenerator._tempParticleRenderers);
            for(var i = 0, n = particleRenderers.length; i < n; i++){
                var particleRenderer = particleRenderers[i];
                particleRenderer.generator.play(false);
            }
        } else {
            this._isPlaying = true;
            if (this.useAutoRandomSeed) {
                this._resetGlobalRandSeed(Math.floor(Math.random() * 0xffffffff)); // 2^32 - 1
            }
            this._playStartDelay = this.main.startDelay.evaluate(undefined, this.main._startDelayRand.random());
        }
    };
    /**
   * Stop emitting particles.
   * @param withChildren - Whether to stop the particle generator of the child entity
   * @param stopMode - Stop mode
   */ _proto.stop = function stop(withChildren, stopMode) {
        if (withChildren === void 0) withChildren = true;
        if (stopMode === void 0) stopMode = ParticleStopMode.StopEmitting;
        if (withChildren) {
            var particleRenderers = this._renderer.entity.getComponentsIncludeChildren(ParticleRenderer, ParticleGenerator._tempParticleRenderers);
            for(var i = 0, n = particleRenderers.length; i < n; i++){
                var particleRenderer = particleRenderers[i];
                particleRenderer.generator.stop(false, stopMode);
            }
        } else {
            this._isPlaying = false;
            if (stopMode === ParticleStopMode.StopEmittingAndClear) {
                // Move the pointer to free immediately
                var firstFreeElement = this._firstFreeElement;
                this._firstRetiredElement = firstFreeElement;
                this._firstActiveElement = firstFreeElement;
                this._firstNewElement = firstFreeElement;
                this._playTime = 0;
                this._firstActiveTransformedBoundingBox = this._firstFreeTransformedBoundingBox;
                this.emission._reset();
            }
        }
    };
    /**
   * Manually emit certain number of particles immediately.
   * @param count - Number of particles to emit
   */ _proto.emit = function emit(count) {
        this._emit(this._playTime, count);
    };
    /**
   * @internal
   */ _proto._emit = function _emit(playTime, count) {
        if (this.emission.enabled) {
            // Wait the existing particles to be retired
            var notRetireParticleCount = this._getNotRetiredParticleCount();
            if (notRetireParticleCount >= this.main.maxParticles) {
                return;
            }
            var position = ParticleGenerator._tempVector30;
            var direction = ParticleGenerator._tempVector31;
            var transform = this._renderer.entity.transform;
            var shape = this.emission.shape;
            for(var i = 0; i < count; i++){
                if (shape == null ? void 0 : shape.enabled) {
                    shape._generatePositionAndDirection(this.emission._shapeRand, playTime, position, direction);
                    var positionScale = this.main._getPositionScale();
                    position.multiply(positionScale);
                    direction.normalize().multiply(positionScale);
                } else {
                    position.set(0, 0, 0);
                    direction.set(0, 0, -1);
                }
                this._addNewParticle(position, direction, transform, playTime);
            }
        }
    };
    /**
   * @internal
   */ _proto._update = function _update(elapsedTime) {
        var lastAlive = this.isAlive;
        var _this = this, main = _this.main, emission = _this.emission;
        var duration = main.duration;
        var lastPlayTime = this._playTime;
        var deltaTime = elapsedTime * main.simulationSpeed;
        // Process start delay time
        if (this._playStartDelay > 0) {
            var remainingDelay = this._playStartDelay -= deltaTime;
            if (remainingDelay < 0) {
                this._playTime -= remainingDelay;
                this._playStartDelay = 0;
            } else {
                return;
            }
        }
        this._playTime += deltaTime;
        this._retireActiveParticles();
        this._freeRetiredParticles();
        if (main.simulationSpace === ParticleSimulationSpace.World) {
            this._retireTransformedBounds();
        }
        if (emission.enabled && this._isPlaying) {
            // If maxParticles is changed dynamically, currentParticleCount may be greater than maxParticles
            if (this._currentParticleCount > main._maxParticleBuffer) {
                var notRetireParticleCount = this._getNotRetiredParticleCount();
                if (notRetireParticleCount < main._maxParticleBuffer) {
                    this._resizeInstanceBuffer(false);
                }
            }
            emission._emit(lastPlayTime, this._playTime);
            if (!main.isLoop && this._playTime > duration) {
                this._isPlaying = false;
            }
        }
        if (this.isAlive) {
            if (main.simulationSpace === ParticleSimulationSpace.World) {
                this._generateTransformedBounds();
            }
        } else {
            // Reset play time when is not playing and no active particles to avoid potential precision problems in GPU
            var discardTime = Math.min(emission._frameRateTime, Math.floor(this._playTime / duration) * duration);
            this._playTime -= discardTime;
            emission._frameRateTime -= discardTime;
        }
        if (this.isAlive !== lastAlive) {
            this._renderer._onWorldVolumeChanged();
        }
        // Add new particles to vertex buffer when has wait process retired element or new particle
        //
        // Another choice is just add new particles to vertex buffer and render all particles ignore the retired particle in shader, especially billboards
        // But webgl don't support map buffer range, so this choice don't have performance advantage even less set data to GPU
        if (this._firstNewElement != this._firstFreeElement || this._waitProcessRetiredElementCount > 0 || this._instanceBufferResized || this._instanceVertexBufferBinding._buffer.isContentLost) {
            this._addActiveParticlesToVertexBuffer();
        }
    };
    /**
   * @internal
   */ _proto._reorganizeGeometryBuffers = function _reorganizeGeometryBuffers() {
        var renderer = this._renderer;
        var particleUtils = renderer.engine._particleBufferUtils;
        var primitive = this._primitive;
        var vertexBufferBindings = this._vertexBufferBindings;
        primitive.clearVertexElements();
        vertexBufferBindings.length = 0;
        if (renderer.renderMode === ParticleRenderMode.Mesh) {
            var mesh = renderer.mesh;
            if (!mesh) {
                return;
            }
            var positionElement = mesh.getVertexElement(VertexAttribute.Position);
            var colorElement = mesh.getVertexElement(VertexAttribute.Color);
            var uvElement = mesh.getVertexElement(VertexAttribute.UV);
            var positionBufferBinding = positionElement ? mesh.vertexBufferBindings[positionElement.bindingIndex] : null;
            var colorBufferBinding = colorElement ? mesh.vertexBufferBindings[colorElement.bindingIndex] : null;
            var uvBufferBinding = uvElement ? mesh.vertexBufferBindings[uvElement.bindingIndex] : null;
            if (positionBufferBinding) {
                var index = this._addVertexBufferBindingsFilterDuplicate(positionBufferBinding, vertexBufferBindings);
                primitive.addVertexElement(new VertexElement(VertexAttribute.Position, positionElement.offset, positionElement.format, index));
            }
            if (colorBufferBinding) {
                var index1 = this._addVertexBufferBindingsFilterDuplicate(colorBufferBinding, vertexBufferBindings);
                primitive.addVertexElement(new VertexElement(VertexAttribute.Color, colorElement.offset, colorElement.format, index1));
            }
            if (uvBufferBinding) {
                var index2 = this._addVertexBufferBindingsFilterDuplicate(uvBufferBinding, vertexBufferBindings);
                primitive.addVertexElement(new VertexElement(VertexAttribute.UV, uvElement.offset, uvElement.format, index2));
            }
            // @todo: multi subMesh or not support
            var indexBufferBinding = mesh._primitive.indexBufferBinding;
            primitive.setIndexBufferBinding(indexBufferBinding);
            this._subPrimitive.count = indexBufferBinding.buffer.byteLength / primitive._glIndexByteCount;
        } else {
            primitive.addVertexElement(particleUtils.billboardVertexElement);
            vertexBufferBindings.push(particleUtils.billboardVertexBufferBinding);
            primitive.setIndexBufferBinding(particleUtils.billboardIndexBufferBinding);
            this._subPrimitive.count = ParticleBufferUtils.billboardIndexCount;
        }
        primitive.setVertexBufferBindings(vertexBufferBindings);
        var instanceVertexElements = particleUtils.instanceVertexElements;
        var bindingIndex = vertexBufferBindings.length;
        for(var i = 0, n = instanceVertexElements.length; i < n; i++){
            var element = instanceVertexElements[i];
            primitive.addVertexElement(new VertexElement(element.attribute, element.offset, element.format, bindingIndex, element.instanceStepRate));
        }
    };
    /**
   * @internal
   */ _proto._resizeInstanceBuffer = function _resizeInstanceBuffer(isIncrease, increaseCount) {
        var _this__instanceVertexBufferBinding;
        (_this__instanceVertexBufferBinding = this._instanceVertexBufferBinding) == null ? void 0 : _this__instanceVertexBufferBinding.buffer.destroy();
        var stride = ParticleBufferUtils.instanceVertexStride;
        var newParticleCount = isIncrease ? this._currentParticleCount + increaseCount : this.main._maxParticleBuffer;
        var newByteLength = stride * newParticleCount;
        var engine = this._renderer.engine;
        var vertexInstanceBuffer = new Buffer(engine, BufferBindFlag.VertexBuffer, newByteLength, BufferUsage.Dynamic, false);
        vertexInstanceBuffer.isGCIgnored = true;
        var vertexBufferBindings = this._primitive.vertexBufferBindings;
        var vertexBufferBinding = new VertexBufferBinding(vertexInstanceBuffer, stride);
        var instanceVertices = new Float32Array(newByteLength / 4);
        var lastInstanceVertices = this._instanceVertices;
        if (lastInstanceVertices) {
            var floatStride = ParticleBufferUtils.instanceVertexFloatStride;
            var firstFreeElement = this._firstFreeElement;
            var firstRetiredElement = this._firstRetiredElement;
            if (isIncrease) {
                instanceVertices.set(new Float32Array(lastInstanceVertices.buffer, 0, firstFreeElement * floatStride));
                var nextFreeElement = firstFreeElement + 1;
                var freeEndOffset = (nextFreeElement + increaseCount) * floatStride;
                instanceVertices.set(new Float32Array(lastInstanceVertices.buffer, nextFreeElement * floatStride * 4), freeEndOffset);
                // Maintain expanded pointers
                this._firstNewElement > firstFreeElement && (this._firstNewElement += increaseCount);
                this._firstActiveElement > firstFreeElement && (this._firstActiveElement += increaseCount);
                firstRetiredElement > firstFreeElement && (this._firstRetiredElement += increaseCount);
            } else {
                var migrateCount, bufferOffset;
                if (firstRetiredElement <= firstFreeElement) {
                    migrateCount = firstFreeElement - firstRetiredElement;
                    bufferOffset = 0;
                    // Maintain expanded pointers
                    this._firstFreeElement -= firstRetiredElement;
                    this._firstNewElement -= firstRetiredElement;
                    this._firstActiveElement -= firstRetiredElement;
                    this._firstRetiredElement = 0;
                } else {
                    migrateCount = this._currentParticleCount - firstRetiredElement;
                    bufferOffset = firstFreeElement;
                    // Maintain expanded pointers
                    this._firstNewElement > firstFreeElement && (this._firstNewElement -= firstFreeElement);
                    this._firstActiveElement > firstFreeElement && (this._firstActiveElement -= firstFreeElement);
                    firstRetiredElement > firstFreeElement && (this._firstRetiredElement -= firstFreeElement);
                }
                instanceVertices.set(new Float32Array(lastInstanceVertices.buffer, firstRetiredElement * floatStride * 4, migrateCount * floatStride), bufferOffset * floatStride);
            }
            this._instanceBufferResized = true;
        }
        // Instance buffer always at last
        this._primitive.setVertexBufferBinding(lastInstanceVertices ? vertexBufferBindings.length - 1 : vertexBufferBindings.length, vertexBufferBinding);
        this._instanceVertices = instanceVertices;
        this._instanceVertexBufferBinding = vertexBufferBinding;
        this._currentParticleCount = newParticleCount;
    };
    /**
   * @internal
   */ _proto._updateShaderData = function _updateShaderData(shaderData) {
        this.main._updateShaderData(shaderData);
        this.velocityOverLifetime._updateShaderData(shaderData);
        this.forceOverLifetime._updateShaderData(shaderData);
        this.textureSheetAnimation._updateShaderData(shaderData);
        this.sizeOverLifetime._updateShaderData(shaderData);
        this.rotationOverLifetime._updateShaderData(shaderData);
        this.colorOverLifetime._updateShaderData(shaderData);
    };
    /**
   * @internal
   */ _proto._resetGlobalRandSeed = function _resetGlobalRandSeed(seed) {
        this._randomSeed = seed;
        this.main._resetRandomSeed(seed);
        this.emission._resetRandomSeed(seed);
        this.textureSheetAnimation._resetRandomSeed(seed);
        this.velocityOverLifetime._resetRandomSeed(seed);
        this.forceOverLifetime._resetRandomSeed(seed);
        this.rotationOverLifetime._resetRandomSeed(seed);
        this.colorOverLifetime._resetRandomSeed(seed);
    };
    /**
   * @internal
   */ _proto._getAliveParticleCount = function _getAliveParticleCount() {
        if (this._firstActiveElement <= this._firstFreeElement) {
            return this._firstFreeElement - this._firstActiveElement;
        } else {
            var instanceCount = this._currentParticleCount - this._firstActiveElement;
            if (this._firstFreeElement > 0) {
                instanceCount += this._firstFreeElement;
            }
            return instanceCount;
        }
    };
    /**
   * @internal
   */ _proto._getNotRetiredParticleCount = function _getNotRetiredParticleCount() {
        if (this._firstRetiredElement <= this._firstFreeElement) {
            return this._firstFreeElement - this._firstRetiredElement;
        } else {
            var instanceCount = this._currentParticleCount - this._firstRetiredElement;
            if (this._firstFreeElement > 0) {
                instanceCount += this._firstFreeElement;
            }
            return instanceCount;
        }
    };
    /**
   * @internal
   */ _proto._destroy = function _destroy() {
        this._instanceVertexBufferBinding.buffer.destroy();
        this._primitive.destroy();
        this.emission._destroy();
    };
    /**
   * @internal
   */ _proto._updateBoundsSimulationLocal = function _updateBoundsSimulationLocal(bounds) {
        var renderer = this._renderer;
        // Get longest Lifetime
        var maxLifetime = this.main.startLifetime._getMax();
        var generatorBounds = renderer._generatorBounds, transformedBounds = renderer._transformedBounds;
        if (renderer._isContainDirtyFlag(ParticleUpdateFlags.GeneratorVolume)) {
            this._calculateGeneratorBounds(maxLifetime, generatorBounds);
            renderer._setDirtyFlagFalse(ParticleUpdateFlags.GeneratorVolume);
        }
        if (renderer._isContainDirtyFlag(ParticleUpdateFlags.TransformVolume)) {
            this._calculateTransformedBounds(maxLifetime, generatorBounds, transformedBounds);
            renderer._setDirtyFlagFalse(ParticleUpdateFlags.TransformVolume);
        }
        this._addGravityToBounds(maxLifetime, transformedBounds, bounds);
    };
    /**
   * @internal
   */ _proto._updateBoundsSimulationWorld = function _updateBoundsSimulationWorld(bounds) {
        var boundsArray = this._transformedBoundsArray;
        var firstActiveElement = this._firstActiveTransformedBoundingBox;
        var firstFreeElement = this._firstFreeTransformedBoundingBox;
        var index = firstActiveElement * ParticleBufferUtils.boundsFloatStride;
        bounds.min.copyFromArray(boundsArray, index);
        bounds.max.copyFromArray(boundsArray, index + 3);
        if (firstActiveElement < firstFreeElement) {
            for(var i = firstActiveElement + 1; i < firstFreeElement; i++){
                this._mergeTransformedBounds(i, bounds);
            }
        } else {
            for(var i1 = firstActiveElement + 1, n = this._transformedBoundsCount; i1 < n; i1++){
                this._mergeTransformedBounds(i1, bounds);
            }
            if (firstFreeElement > 0) {
                for(var i2 = 0; i2 < firstFreeElement; i2++){
                    this._mergeTransformedBounds(i2, bounds);
                }
            }
        }
        var maxLifetime = this.main.startLifetime._getMax();
        this._addGravityToBounds(maxLifetime, bounds, bounds);
    };
    /**
   * @internal
   */ _proto._freeBoundsArray = function _freeBoundsArray() {
        this._transformedBoundsArray = null;
        this._transformedBoundsCount = 0;
        this._firstActiveTransformedBoundingBox = 0;
        this._firstFreeTransformedBoundingBox = 0;
    };
    /**
   * @internal
   */ _proto._generateTransformedBounds = function _generateTransformedBounds() {
        var renderer = this._renderer;
        // Get longest Lifetime
        var maxLifetime = this.main.startLifetime._getMax();
        var generatorBounds = renderer._generatorBounds;
        if (renderer._isContainDirtyFlag(ParticleUpdateFlags.GeneratorVolume)) {
            this._calculateGeneratorBounds(maxLifetime, generatorBounds);
            renderer._setDirtyFlagFalse(ParticleUpdateFlags.GeneratorVolume);
        }
        var boundsFloatStride = ParticleBufferUtils.boundsFloatStride, boundsTimeOffset = ParticleBufferUtils.boundsTimeOffset, boundsMaxLifetimeOffset = ParticleBufferUtils.boundsMaxLifetimeOffset;
        var firstFreeElement = this._firstFreeTransformedBoundingBox;
        if (renderer._isContainDirtyFlag(ParticleUpdateFlags.TransformVolume)) {
            // Resize transformed bounds if needed
            var nextFreeElement = firstFreeElement + 1;
            if (nextFreeElement >= this._transformedBoundsCount) {
                nextFreeElement = 0;
            }
            if (nextFreeElement === this._firstActiveTransformedBoundingBox) {
                this._resizeTransformedBoundsArray();
                nextFreeElement = firstFreeElement + 1;
            }
            // Generate transformed bounds
            var transformedBounds = renderer._transformedBounds;
            this._calculateTransformedBounds(maxLifetime, generatorBounds, transformedBounds);
            var boundsOffset = firstFreeElement * boundsFloatStride;
            var boundsArray = this._transformedBoundsArray;
            transformedBounds.min.copyToArray(boundsArray, boundsOffset);
            transformedBounds.max.copyToArray(boundsArray, boundsOffset + 3);
            boundsArray[boundsOffset + boundsTimeOffset] = this._playTime;
            boundsArray[boundsOffset + boundsMaxLifetimeOffset] = maxLifetime;
            this._firstFreeTransformedBoundingBox = nextFreeElement;
            renderer._setDirtyFlagFalse(ParticleUpdateFlags.TransformVolume);
        } else {
            var previousFreeElement = this._firstFreeTransformedBoundingBox - 1;
            if (previousFreeElement < 0) {
                previousFreeElement = this._transformedBoundsCount;
            }
            this._transformedBoundsArray[previousFreeElement * ParticleBufferUtils.boundsFloatStride + boundsTimeOffset] = this._playTime;
        }
    };
    _proto._addNewParticle = function _addNewParticle(position, direction, transform, playTime) {
        var firstFreeElement = this._firstFreeElement;
        var nextFreeElement = firstFreeElement + 1;
        if (nextFreeElement >= this._currentParticleCount) {
            nextFreeElement = 0;
        }
        var main = this.main;
        // Check if can be expanded
        // Using 'nextFreeElement' instead of 'freeElement' when comparing with '_firstRetiredElement'
        // aids in definitively identifying the head and tail of the circular queue.
        // Failure to adopt this approach may impede growth initiation
        // due to the initial alignment of 'freeElement' and 'firstRetiredElement'.
        if (nextFreeElement === this._firstRetiredElement) {
            var increaseCount = Math.min(ParticleGenerator._particleIncreaseCount, main._maxParticleBuffer - this._currentParticleCount);
            if (increaseCount === 0) {
                return;
            }
            this._resizeInstanceBuffer(true, increaseCount);
            // Recalculate nextFreeElement after resize
            nextFreeElement = firstFreeElement + 1;
        }
        var pos, rot;
        if (main.simulationSpace === ParticleSimulationSpace.World) {
            pos = transform.worldPosition;
            rot = transform.worldRotationQuaternion;
        }
        var startSpeed = main.startSpeed.evaluate(undefined, main._startSpeedRand.random());
        var instanceVertices = this._instanceVertices;
        var offset = firstFreeElement * ParticleBufferUtils.instanceVertexFloatStride;
        // Position
        position.copyToArray(instanceVertices, offset);
        // Start life time
        instanceVertices[offset + ParticleBufferUtils.startLifeTimeOffset] = main.startLifetime.evaluate(undefined, main._startLifeTimeRand.random());
        // Direction
        direction.copyToArray(instanceVertices, offset + 4);
        // Time
        instanceVertices[offset + ParticleBufferUtils.timeOffset] = playTime;
        // Color
        var startColor = ParticleGenerator._tempColor0;
        main.startColor.evaluate(undefined, main._startColorRand.random(), startColor);
        startColor.copyToArray(instanceVertices, offset + 8);
        var duration = this.main.duration;
        var normalizedEmitAge = playTime % duration / duration;
        // Start size
        var startSizeRand = main._startSizeRand;
        if (main.startSize3D) {
            instanceVertices[offset + 12] = main.startSizeX.evaluate(normalizedEmitAge, startSizeRand.random());
            instanceVertices[offset + 13] = main.startSizeY.evaluate(normalizedEmitAge, startSizeRand.random());
            instanceVertices[offset + 14] = main.startSizeZ.evaluate(normalizedEmitAge, startSizeRand.random());
        } else {
            var size = main.startSize.evaluate(normalizedEmitAge, startSizeRand.random());
            instanceVertices[offset + 12] = size;
            instanceVertices[offset + 13] = size;
            instanceVertices[offset + 14] = size;
        }
        // Start rotation
        var startRotationRand = main._startRotationRand, flipRotation = main.flipRotation;
        var isOpposite = flipRotation < startRotationRand.random();
        var rotationZ = MathUtil.degreeToRadian(main.startRotationZ.evaluate(undefined, startRotationRand.random()));
        if (main.startRotation3D) {
            var rotationX = MathUtil.degreeToRadian(main.startRotationX.evaluate(undefined, startRotationRand.random()));
            var rotationY = MathUtil.degreeToRadian(main.startRotationY.evaluate(undefined, startRotationRand.random()));
            instanceVertices[offset + 15] = isOpposite ? -rotationX : rotationX;
            instanceVertices[offset + 16] = isOpposite ? -rotationY : rotationY;
            instanceVertices[offset + 17] = isOpposite ? -rotationZ : rotationZ;
        } else {
            instanceVertices[offset + 15] = isOpposite ? -rotationZ : rotationZ;
        }
        // Start speed
        instanceVertices[offset + 18] = startSpeed;
        // Gravity, color, size, rotation
        switch(main.gravityModifier.mode){
            case ParticleCurveMode.Constant:
                instanceVertices[offset + 19] = main.gravityModifier.constant;
                break;
            case ParticleCurveMode.TwoConstants:
                instanceVertices[offset + 19] = main.gravityModifier.evaluate(undefined, main._gravityModifierRand.random());
                break;
        }
        var colorOverLifetime = this.colorOverLifetime;
        if (colorOverLifetime.enabled && colorOverLifetime.color.mode === ParticleGradientMode.TwoGradients) {
            instanceVertices[offset + 20] = colorOverLifetime._colorGradientRand.random();
        }
        // instanceVertices[offset + 21] = rand.random();
        var rotationOverLifetime = this.rotationOverLifetime;
        if (rotationOverLifetime.enabled && rotationOverLifetime.rotationZ.mode === ParticleCurveMode.TwoConstants) {
            instanceVertices[offset + 22] = rotationOverLifetime._rotationRand.random();
        }
        // Texture sheet animation
        var textureSheetAnimation = this.textureSheetAnimation;
        if (textureSheetAnimation.enabled && textureSheetAnimation.frameOverTime.mode === ParticleCurveMode.TwoCurves) {
            instanceVertices[offset + 23] = textureSheetAnimation._frameOverTimeRand.random();
        }
        // Velocity random
        var velocityOverLifetime = this.velocityOverLifetime;
        if (velocityOverLifetime.enabled && velocityOverLifetime.velocityX.mode === ParticleCurveMode.TwoConstants && velocityOverLifetime.velocityY.mode === ParticleCurveMode.TwoConstants && velocityOverLifetime.velocityZ.mode === ParticleCurveMode.TwoConstants) {
            var rand = velocityOverLifetime._velocityRand;
            instanceVertices[offset + 24] = rand.random();
            instanceVertices[offset + 25] = rand.random();
            instanceVertices[offset + 26] = rand.random();
        }
        if (this.main.simulationSpace === ParticleSimulationSpace.World) {
            // Simulation world position
            pos.copyToArray(instanceVertices, offset + 27);
            // Simulation world position
            rot.copyToArray(instanceVertices, offset + 30);
        }
        // Simulation UV
        if (textureSheetAnimation.enabled) {
            var frameOverTime = textureSheetAnimation.frameOverTime;
            var _textureSheetAnimation__tillingInfo = textureSheetAnimation._tillingInfo, x = _textureSheetAnimation__tillingInfo.x, y = _textureSheetAnimation__tillingInfo.y, z = _textureSheetAnimation__tillingInfo.z;
            var tileRow = 0;
            if (frameOverTime.mode === ParticleCurveMode.Constant || frameOverTime.mode === ParticleCurveMode.TwoConstants) {
                tileRow = Math.floor(frameOverTime.evaluate(undefined, textureSheetAnimation._frameOverTimeRand.random()) * z) * x;
            }
            var tileRowIndex = Math.floor(tileRow);
            instanceVertices[offset + ParticleBufferUtils.simulationUVOffset] = x;
            instanceVertices[offset + 35] = y;
            instanceVertices[offset + 36] = tileRow - tileRowIndex;
            instanceVertices[offset + 37] = tileRowIndex * y;
        } else {
            instanceVertices[offset + ParticleBufferUtils.simulationUVOffset] = 1;
            instanceVertices[offset + 35] = 1;
            instanceVertices[offset + 36] = 0;
            instanceVertices[offset + 37] = 0;
        }
        var forceOverLifetime = this.forceOverLifetime;
        if (forceOverLifetime.enabled && forceOverLifetime._isRandomMode()) {
            var rand1 = forceOverLifetime._forceRand;
            instanceVertices[offset + 38] = rand1.random();
            instanceVertices[offset + 39] = rand1.random();
            instanceVertices[offset + 40] = rand1.random();
        }
        this._firstFreeElement = nextFreeElement;
    };
    _proto._retireActiveParticles = function _retireActiveParticles() {
        var engine = this._renderer.engine;
        var frameCount = engine.time.frameCount;
        var instanceVertices = this._instanceVertices;
        while(this._firstActiveElement !== this._firstNewElement){
            var activeParticleOffset = this._firstActiveElement * ParticleBufferUtils.instanceVertexFloatStride;
            var activeParticleTimeOffset = activeParticleOffset + ParticleBufferUtils.timeOffset;
            var particleAge = this._playTime - instanceVertices[activeParticleTimeOffset];
            // Use `Math.fround` to ensure the precision of comparison is same
            if (Math.fround(particleAge) < instanceVertices[activeParticleOffset + ParticleBufferUtils.startLifeTimeOffset]) {
                break;
            }
            // Store frame count in time offset to free retired particle
            instanceVertices[activeParticleTimeOffset] = frameCount;
            if (++this._firstActiveElement >= this._currentParticleCount) {
                this._firstActiveElement = 0;
            }
            // Record wait process retired element count
            this._waitProcessRetiredElementCount++;
        }
    };
    _proto._freeRetiredParticles = function _freeRetiredParticles() {
        var frameCount = this._renderer.engine.time.frameCount;
        while(this._firstRetiredElement !== this._firstActiveElement){
            var offset = this._firstRetiredElement * ParticleBufferUtils.instanceVertexFloatStride + ParticleBufferUtils.startLifeTimeOffset;
            var age = frameCount - this._instanceVertices[offset];
            // WebGL don't support map buffer range, so off this optimization
            if (age < 0) {
                break;
            }
            if (++this._firstRetiredElement >= this._currentParticleCount) {
                this._firstRetiredElement = 0;
            }
        }
    };
    _proto._addActiveParticlesToVertexBuffer = function _addActiveParticlesToVertexBuffer() {
        var firstActiveElement = this._firstActiveElement;
        var firstFreeElement = this._firstFreeElement;
        // firstActiveElement == firstFreeElement should not update
        if (firstActiveElement === firstFreeElement) {
            return;
        }
        var byteStride = ParticleBufferUtils.instanceVertexStride;
        var start = firstActiveElement * byteStride;
        var instanceBuffer = this._instanceVertexBufferBinding.buffer;
        var dataBuffer = this._instanceVertices.buffer;
        if (firstActiveElement < firstFreeElement) {
            instanceBuffer.setData(dataBuffer, 0, start, (firstFreeElement - firstActiveElement) * byteStride, SetDataOptions.Discard);
        } else {
            var firstSegmentCount = (this._currentParticleCount - firstActiveElement) * byteStride;
            instanceBuffer.setData(dataBuffer, 0, start, firstSegmentCount, SetDataOptions.Discard);
            if (firstFreeElement > 0) {
                instanceBuffer.setData(dataBuffer, firstSegmentCount, 0, firstFreeElement * byteStride);
            }
        }
        this._firstNewElement = firstFreeElement;
        this._waitProcessRetiredElementCount = 0;
        this._instanceBufferResized = false;
    };
    _proto._addVertexBufferBindingsFilterDuplicate = function _addVertexBufferBindingsFilterDuplicate(vertexBufferBinding, out) {
        var index = 0;
        for(var n = out.length; index < n; index++){
            if (out[index] === vertexBufferBinding) {
                return index;
            }
        }
        out.push(vertexBufferBinding);
        return index;
    };
    _proto._resizeTransformedBoundsArray = function _resizeTransformedBoundsArray() {
        var floatStride = ParticleBufferUtils.boundsFloatStride;
        var increaseCount = ParticleGenerator._transformedBoundsIncreaseCount;
        this._transformedBoundsCount += increaseCount;
        var lastBoundsArray = this._transformedBoundsArray;
        var boundsArray = new Float32Array(this._transformedBoundsCount * floatStride);
        if (lastBoundsArray) {
            var firstFreeElement = this._firstFreeTransformedBoundingBox;
            boundsArray.set(new Float32Array(lastBoundsArray.buffer, 0, firstFreeElement * floatStride));
            var nextFreeElement = firstFreeElement + 1;
            var freeEndOffset = (nextFreeElement + increaseCount) * floatStride;
            boundsArray.set(new Float32Array(lastBoundsArray.buffer, nextFreeElement * floatStride * 4), freeEndOffset);
            var firstActiveElement = this._firstActiveTransformedBoundingBox;
            if (firstActiveElement > firstFreeElement) {
                this._firstActiveTransformedBoundingBox += increaseCount;
            }
        }
        this._transformedBoundsArray = boundsArray;
    };
    _proto._retireTransformedBounds = function _retireTransformedBounds() {
        var boundsFloatStride = ParticleBufferUtils.boundsFloatStride, boundsTimeOffset = ParticleBufferUtils.boundsTimeOffset, boundsMaxLifetimeOffset = ParticleBufferUtils.boundsMaxLifetimeOffset;
        var boundsArray = this._transformedBoundsArray;
        var firstFreeElement = this._firstFreeTransformedBoundingBox;
        var count = this._transformedBoundsCount;
        while(this._firstActiveTransformedBoundingBox !== firstFreeElement){
            var index = this._firstActiveTransformedBoundingBox * boundsFloatStride;
            var age = this._playTime - boundsArray[index + boundsTimeOffset];
            if (age <= boundsArray[index + boundsMaxLifetimeOffset]) {
                break;
            }
            if (++this._firstActiveTransformedBoundingBox >= count) {
                this._firstActiveTransformedBoundingBox = 0;
            }
            this._renderer._onWorldVolumeChanged();
        }
    };
    _proto._calculateGeneratorBounds = function _calculateGeneratorBounds(maxLifetime, bounds) {
        var directionMax = ParticleGenerator._tempVector30, directionMin = ParticleGenerator._tempVector31, speedMinMax = ParticleGenerator._tempVector20;
        var min = bounds.min, max = bounds.max;
        var main = this.main;
        // StartSpeed's impact
        var shape = this.emission.shape;
        if (shape == null ? void 0 : shape.enabled) {
            shape._getPositionRange(min, max);
            shape._getDirectionRange(directionMin, directionMax);
        } else {
            min.set(0, 0, 0);
            max.set(0, 0, 0);
            directionMin.set(0, 0, -1);
            directionMax.set(0, 0, 0);
        }
        this._getExtremeValueFromZero(main.startSpeed, speedMinMax);
        var speedMin = speedMinMax.x, speedMax = speedMinMax.y;
        var dirMinX = directionMin.x, dirMinY = directionMin.y, dirMinZ = directionMin.z;
        var dirMaxX = directionMax.x, dirMaxY = directionMax.y, dirMaxZ = directionMax.z;
        min.set(min.x + Math.min(dirMinX * speedMax, dirMaxX * speedMin) * maxLifetime, min.y + Math.min(dirMinY * speedMax, dirMaxY * speedMin) * maxLifetime, min.z + Math.min(dirMinZ * speedMax, dirMaxZ * speedMin) * maxLifetime);
        max.set(max.x + Math.max(dirMinX * speedMin, dirMaxX * speedMax) * maxLifetime, max.y + Math.max(dirMinY * speedMin, dirMaxY * speedMax) * maxLifetime, max.z + Math.max(dirMinZ * speedMin, dirMaxZ * speedMax) * maxLifetime);
        // StartSize's impact
        var maxSize = main.startSize._getMax();
        if (main.startSize3D) {
            var startSizeYMax = main.startSizeY._getMax();
            if (this._renderer.renderMode === ParticleRenderMode.Billboard || ParticleRenderMode.StretchBillboard || ParticleRenderMode.HorizontalBillboard) {
                maxSize = Math.max(maxSize, startSizeYMax);
            } else {
                var startSizeZMax = main.startSizeZ._getMax();
                maxSize = Math.max(maxSize, startSizeYMax, startSizeZMax);
            }
        }
        // Use diagonal for potential rotation
        maxSize *= 1.414;
        // SizeOverLifetime impact
        var sizeOverLifetime = this.sizeOverLifetime;
        if (sizeOverLifetime.enabled) {
            var maxSizeOverLifetime = sizeOverLifetime.size._getMax();
            if (sizeOverLifetime.separateAxes) {
                var maxSizeOverLifetimeY = sizeOverLifetime.sizeY._getMax();
                var maxSizeOverLifetimeZ = sizeOverLifetime.sizeZ._getMax();
                maxSizeOverLifetime = Math.max(maxSizeOverLifetime, maxSizeOverLifetimeY, maxSizeOverLifetimeZ);
            }
            maxSize *= maxSizeOverLifetime;
        }
        min.set(min.x - maxSize, min.y - maxSize, min.z - maxSize);
        max.set(max.x + maxSize, max.y + maxSize, max.z + maxSize);
    };
    _proto._mergeTransformedBounds = function _mergeTransformedBounds(index, bounds) {
        var min = bounds.min, max = bounds.max;
        var boundsArray = this._transformedBoundsArray;
        var offset = index * ParticleBufferUtils.boundsFloatStride;
        min.set(Math.min(min.x, boundsArray[offset]), Math.min(min.y, boundsArray[offset + 1]), Math.min(min.z, boundsArray[offset + 2]));
        max.set(Math.max(max.x, boundsArray[offset + 3]), Math.max(max.y, boundsArray[offset + 4]), Math.max(max.z, boundsArray[offset + 5]));
    };
    _proto._calculateTransformedBounds = function _calculateTransformedBounds(maxLifetime, origin, out) {
        var velMinMaxX = ParticleGenerator._tempVector20, velMinMaxY = ParticleGenerator._tempVector21, velMinMaxZ = ParticleGenerator._tempVector22, worldOffsetMin = ParticleGenerator._tempVector30, worldOffsetMax = ParticleGenerator._tempVector31, rotateMat = ParticleGenerator._tempMat;
        worldOffsetMin.set(0, 0, 0);
        worldOffsetMax.set(0, 0, 0);
        var transform = this._renderer.entity.transform;
        var worldPosition = transform.worldPosition;
        Matrix.rotationQuaternion(transform.worldRotationQuaternion, rotateMat);
        var min = out.min, max = out.max;
        min.copyFrom(origin.min);
        max.copyFrom(origin.max);
        var velocityOverLifetime = this.velocityOverLifetime;
        if (velocityOverLifetime.enabled) {
            this._getExtremeValueFromZero(velocityOverLifetime.velocityX, velMinMaxX);
            this._getExtremeValueFromZero(velocityOverLifetime.velocityY, velMinMaxY);
            this._getExtremeValueFromZero(velocityOverLifetime.velocityZ, velMinMaxZ);
            velMinMaxX.scale(maxLifetime);
            velMinMaxY.scale(maxLifetime);
            velMinMaxZ.scale(maxLifetime);
            if (velocityOverLifetime.space === ParticleSimulationSpace.Local) {
                min.set(min.x + velMinMaxX.x, min.y + velMinMaxY.x, min.z + velMinMaxZ.x);
                max.set(max.x + velMinMaxX.y, max.y + velMinMaxY.y, max.z + velMinMaxZ.y);
            } else {
                worldOffsetMin.set(worldOffsetMin.x + velMinMaxX.x, worldOffsetMin.y + velMinMaxY.x, worldOffsetMin.z + velMinMaxZ.x);
                worldOffsetMax.set(worldOffsetMax.x + velMinMaxX.y, worldOffsetMax.y + velMinMaxY.y, worldOffsetMax.z + velMinMaxZ.y);
            }
        }
        var forceOverLifetime = this.forceOverLifetime;
        if (forceOverLifetime.enabled) {
            var forceMinMaxX = ParticleGenerator._tempVector20, forceMinMaxY = ParticleGenerator._tempVector21, forceMinMaxZ = ParticleGenerator._tempVector22;
            this._getExtremeValueFromZero(forceOverLifetime.forceX, forceMinMaxX);
            this._getExtremeValueFromZero(forceOverLifetime.forceY, forceMinMaxY);
            this._getExtremeValueFromZero(forceOverLifetime.forceZ, forceMinMaxZ);
            var coefficient = 0.5 * maxLifetime * maxLifetime;
            forceMinMaxX.scale(coefficient);
            forceMinMaxY.scale(coefficient);
            forceMinMaxZ.scale(coefficient);
            if (forceOverLifetime.space === ParticleSimulationSpace.Local) {
                min.set(min.x + forceMinMaxX.x, min.y + forceMinMaxY.x, min.z + forceMinMaxZ.x);
                max.set(max.x + forceMinMaxX.y, max.y + forceMinMaxY.y, max.z + forceMinMaxZ.y);
            } else {
                worldOffsetMin.set(worldOffsetMin.x + forceMinMaxX.x, worldOffsetMin.y + forceMinMaxY.x, worldOffsetMin.z + forceMinMaxZ.x);
                worldOffsetMax.set(worldOffsetMax.x + forceMinMaxX.y, worldOffsetMax.y + forceMinMaxY.y, worldOffsetMax.z + forceMinMaxZ.y);
            }
        }
        out.transform(rotateMat);
        min.add(worldOffsetMin);
        max.add(worldOffsetMax);
        min.add(worldPosition);
        max.add(worldPosition);
    };
    _proto._addGravityToBounds = function _addGravityToBounds(maxLifetime, origin, out) {
        var originMin = origin.min, originMax = origin.max;
        var modifierMinMax = ParticleGenerator._tempVector20;
        // Gravity modifier impact
        this._getExtremeValueFromZero(this.main.gravityModifier, modifierMinMax);
        var _this__renderer_scene_physics_gravity = this._renderer.scene.physics.gravity, x = _this__renderer_scene_physics_gravity.x, y = _this__renderer_scene_physics_gravity.y, z = _this__renderer_scene_physics_gravity.z;
        var coefficient = 0.5 * maxLifetime * maxLifetime;
        var minGravityEffect = modifierMinMax.x * coefficient;
        var maxGravityEffect = modifierMinMax.y * coefficient;
        var gravityEffectMinX = x * minGravityEffect;
        var gravityEffectMaxX = x * maxGravityEffect;
        var gravityEffectMinY = y * minGravityEffect;
        var gravityEffectMaxY = y * maxGravityEffect;
        var gravityEffectMinZ = z * minGravityEffect;
        var gravityEffectMaxZ = z * maxGravityEffect;
        // `origin` and `out` maybe is same reference
        out.min.set(Math.min(gravityEffectMinX, gravityEffectMaxX) + originMin.x, Math.min(gravityEffectMinY, gravityEffectMaxY) + originMin.y, Math.min(gravityEffectMinZ, gravityEffectMaxZ) + originMin.z);
        out.max.set(Math.max(gravityEffectMinX, gravityEffectMaxX) + originMax.x, Math.max(gravityEffectMinY, gravityEffectMaxY) + originMax.y, Math.max(gravityEffectMinZ, gravityEffectMaxZ) + originMax.z);
    };
    _proto._getExtremeValueFromZero = function _getExtremeValueFromZero(curve, out) {
        curve._getMinMax(out);
        out.x = Math.min(0, out.x);
        out.y = Math.max(0, out.y);
    };
    _create_class$2(ParticleGenerator, [
        {
            key: "isAlive",
            get: /**
   * Whether the particle generator is contain alive or is still creating particles.
   */ function get() {
                if (this._isPlaying) {
                    return true;
                }
                return this._firstActiveElement !== this._firstFreeElement;
            }
        },
        {
            key: "randomSeed",
            get: /**
   * Random seed.
   *
   * @remarks
   * If `useAutoRandomSeed` is true, this value will be random changed when play.
   * If you set this value custom, `useAutoRandomSeed` will be false.
   */ function get() {
                return this._randomSeed;
            },
            set: function set(value) {
                this._resetGlobalRandSeed(value);
                this.useAutoRandomSeed = false;
            }
        }
    ]);
    return ParticleGenerator;
}();
ParticleGenerator._tempVector20 = new Vector2();
ParticleGenerator._tempVector21 = new Vector2();
ParticleGenerator._tempVector22 = new Vector2();
ParticleGenerator._tempVector30 = new Vector3();
ParticleGenerator._tempVector31 = new Vector3();
ParticleGenerator._tempMat = new Matrix();
ParticleGenerator._tempColor0 = new Color();
ParticleGenerator._tempParticleRenderers = new Array();
ParticleGenerator._particleIncreaseCount = 128;
ParticleGenerator._transformedBoundsIncreaseCount = 16;
__decorate$1([
    deepClone
], ParticleGenerator.prototype, "main", void 0);
__decorate$1([
    deepClone
], ParticleGenerator.prototype, "emission", void 0);
__decorate$1([
    deepClone
], ParticleGenerator.prototype, "velocityOverLifetime", void 0);
__decorate$1([
    deepClone
], ParticleGenerator.prototype, "forceOverLifetime", void 0);
__decorate$1([
    deepClone
], ParticleGenerator.prototype, "sizeOverLifetime", void 0);
__decorate$1([
    deepClone
], ParticleGenerator.prototype, "rotationOverLifetime", void 0);
__decorate$1([
    deepClone
], ParticleGenerator.prototype, "colorOverLifetime", void 0);
__decorate$1([
    deepClone
], ParticleGenerator.prototype, "textureSheetAnimation", void 0);
__decorate$1([
    ignoreClone
], ParticleGenerator.prototype, "_playTime", void 0);
__decorate$1([
    ignoreClone
], ParticleGenerator.prototype, "_firstNewElement", void 0);
__decorate$1([
    ignoreClone
], ParticleGenerator.prototype, "_firstActiveElement", void 0);
__decorate$1([
    ignoreClone
], ParticleGenerator.prototype, "_firstFreeElement", void 0);
__decorate$1([
    ignoreClone
], ParticleGenerator.prototype, "_firstRetiredElement", void 0);
__decorate$1([
    ignoreClone
], ParticleGenerator.prototype, "_primitive", void 0);
__decorate$1([
    ignoreClone
], ParticleGenerator.prototype, "_vertexBufferBindings", void 0);
__decorate$1([
    ignoreClone
], ParticleGenerator.prototype, "_subPrimitive", void 0);
__decorate$1([
    ignoreClone
], ParticleGenerator.prototype, "_renderer", void 0);
__decorate$1([
    ignoreClone
], ParticleGenerator.prototype, "_isPlaying", void 0);
__decorate$1([
    ignoreClone
], ParticleGenerator.prototype, "_instanceBufferResized", void 0);
__decorate$1([
    ignoreClone
], ParticleGenerator.prototype, "_waitProcessRetiredElementCount", void 0);
__decorate$1([
    ignoreClone
], ParticleGenerator.prototype, "_instanceVertexBufferBinding", void 0);
__decorate$1([
    ignoreClone
], ParticleGenerator.prototype, "_instanceVertices", void 0);
__decorate$1([
    ignoreClone
], ParticleGenerator.prototype, "_transformedBoundsArray", void 0);
__decorate$1([
    ignoreClone
], ParticleGenerator.prototype, "_transformedBoundsCount", void 0);
__decorate$1([
    ignoreClone
], ParticleGenerator.prototype, "_firstActiveTransformedBoundingBox", void 0);
__decorate$1([
    ignoreClone
], ParticleGenerator.prototype, "_firstFreeTransformedBoundingBox", void 0);
__decorate$1([
    ignoreClone
], ParticleGenerator.prototype, "_playStartDelay", void 0);

/**
 * Particle Material.
 */ var ParticleMaterial = /*#__PURE__*/ function(BaseMaterial1) {
    _inherits$2(ParticleMaterial, BaseMaterial1);
    function ParticleMaterial(engine) {
        var _this;
        _this = BaseMaterial1.call(this, engine, Shader.find("particle-shader")) || this;
        var shaderData = _this.shaderData;
        shaderData.setColor(BaseMaterial._baseColorProp, new Color(1, 1, 1, 1));
        shaderData.setColor(BaseMaterial._emissiveColorProp, new Color(0, 0, 0, 1));
        _this.isTransparent = true;
        return _this;
    }
    var _proto = ParticleMaterial.prototype;
    /**
   * @inheritdoc
   */ _proto.clone = function clone() {
        var dest = new ParticleMaterial(this._engine);
        this._cloneToAndModifyName(dest);
        return dest;
    };
    _create_class$2(ParticleMaterial, [
        {
            key: "baseColor",
            get: /**
   * Base color.
   */ function get() {
                return this.shaderData.getColor(BaseMaterial._baseColorProp);
            },
            set: function set(value) {
                var baseColor = this.shaderData.getColor(BaseMaterial._baseColorProp);
                if (value !== baseColor) {
                    baseColor.copyFrom(value);
                }
            }
        },
        {
            key: "baseTexture",
            get: /**
   * Base texture.
   */ function get() {
                return this.shaderData.getTexture(BaseMaterial._baseTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(BaseMaterial._baseTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro(BaseMaterial._baseTextureMacro);
                } else {
                    this.shaderData.disableMacro(BaseMaterial._baseTextureMacro);
                }
            }
        },
        {
            key: "emissiveColor",
            get: /**
   * Emissive color.
   */ function get() {
                return this.shaderData.getColor(BaseMaterial._emissiveColorProp);
            },
            set: function set(value) {
                var emissiveColor = this.shaderData.getColor(BaseMaterial._emissiveColorProp);
                if (value !== emissiveColor) {
                    emissiveColor.copyFrom(value);
                }
            }
        },
        {
            key: "emissiveTexture",
            get: /**
   * Emissive texture.
   */ function get() {
                return this.shaderData.getTexture(BaseMaterial._emissiveTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(BaseMaterial._emissiveTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro(BaseMaterial._emissiveTextureMacro);
                } else {
                    this.shaderData.disableMacro(BaseMaterial._emissiveTextureMacro);
                }
            }
        }
    ]);
    return ParticleMaterial;
}(BaseMaterial);

/**
 * A burst is a particle emission event, where a number of particles are all emitted at the same time
 */ var Burst = function Burst(time, count) {
    this.time = time;
    this.count = count;
};
__decorate$1([
    deepClone
], Burst.prototype, "count", void 0);

/**
 * Base class for all particle shapes.
 */ var BaseShape = /*#__PURE__*/ function() {
    function BaseShape() {
        this._updateManager = new UpdateFlagManager();
        this._enabled = true;
        this._randomDirectionAmount = 0;
    }
    var _proto = BaseShape.prototype;
    /**
   * @internal
   */ _proto._registerOnValueChanged = function _registerOnValueChanged(listener) {
        this._updateManager.addListener(listener);
    };
    /**
   * @internal
   */ _proto._unRegisterOnValueChanged = function _unRegisterOnValueChanged(listener) {
        this._updateManager.removeListener(listener);
    };
    _create_class$2(BaseShape, [
        {
            key: "enabled",
            get: /**
   * Specifies whether the ShapeModule is enabled or disabled.
   */ function get() {
                return this._enabled;
            },
            set: function set(value) {
                if (value !== this._enabled) {
                    this._enabled = value;
                    this._updateManager.dispatch();
                }
            }
        },
        {
            key: "randomDirectionAmount",
            get: /**
   * Randomizes the starting direction of particles.
   */ function get() {
                return this._randomDirectionAmount;
            },
            set: function set(value) {
                if (value !== this._randomDirectionAmount) {
                    this._randomDirectionAmount = value;
                    this._updateManager.dispatch();
                }
            }
        }
    ]);
    return BaseShape;
}();
__decorate$1([
    ignoreClone
], BaseShape.prototype, "_updateManager", void 0);

/**
 * @internal
 */ var ShapeUtils = /*#__PURE__*/ function() {
    function ShapeUtils() {}
    ShapeUtils.randomPointUnitArcCircle = function randomPointUnitArcCircle(arc, out, rand) {
        var angle = rand.random() * arc;
        out.x = Math.cos(angle);
        out.y = Math.sin(angle);
    };
    ShapeUtils.randomPointInsideUnitArcCircle = function randomPointInsideUnitArcCircle(arc, out, rand) {
        ShapeUtils.randomPointUnitArcCircle(arc, out, rand);
        var range = Math.sqrt(rand.random());
        out.x = out.x * range;
        out.y = out.y * range;
    };
    ShapeUtils.randomPointUnitCircle = function randomPointUnitCircle(out, rand) {
        var angle = rand.random() * Math.PI * 2;
        out.x = Math.cos(angle);
        out.y = Math.sin(angle);
    };
    ShapeUtils.randomPointInsideUnitCircle = function randomPointInsideUnitCircle(out, rand) {
        ShapeUtils.randomPointUnitCircle(out, rand);
        var range = Math.sqrt(rand.random());
        out.x = out.x * range;
        out.y = out.y * range;
    };
    ShapeUtils._randomPointUnitSphere = function _randomPointUnitSphere(out, rand) {
        var z = rand.random() * 2 - 1.0;
        var a = rand.random() * Math.PI * 2;
        var r = Math.sqrt(1.0 - z * z);
        out.x = r * Math.cos(a);
        out.y = r * Math.sin(a);
        out.z = z;
    };
    ShapeUtils._randomPointInsideUnitSphere = function _randomPointInsideUnitSphere(out, rand) {
        ShapeUtils._randomPointUnitSphere(out, rand);
        var range = Math.pow(rand.random(), 1.0 / 3.0);
        out.x = out.x * range;
        out.y = out.y * range;
        out.z = out.z * range;
    };
    ShapeUtils._randomPointInsideHalfUnitBox = function _randomPointInsideHalfUnitBox(out, rand) {
        if (rand === void 0) rand = null;
        out.x = rand.random() - 0.5;
        out.y = rand.random() - 0.5;
        out.z = rand.random() - 0.5;
    };
    return ShapeUtils;
}();

/**
 * The emission shape.
 */ var ParticleShapeType = /*#__PURE__*/ function(ParticleShapeType) {
    /** Emit from the volume of a box. */ ParticleShapeType[ParticleShapeType["Box"] = 0] = "Box";
    /** Emit from a circle. */ ParticleShapeType[ParticleShapeType["Circle"] = 1] = "Circle";
    /** Emit from the base of a cone. */ ParticleShapeType[ParticleShapeType["Cone"] = 2] = "Cone";
    /** Emit from a half-sphere. */ ParticleShapeType[ParticleShapeType["Hemisphere"] = 3] = "Hemisphere";
    /** Emit from a sphere. */ ParticleShapeType[ParticleShapeType["Sphere"] = 4] = "Sphere";
    /** Emit from a mesh. */ ParticleShapeType[ParticleShapeType["Mesh"] = 5] = "Mesh";
    return ParticleShapeType;
}({});

/**
 * Particle shape that emits particles from a box.
 */ var BoxShape = /*#__PURE__*/ function(BaseShape) {
    _inherits$2(BoxShape, BaseShape);
    function BoxShape() {
        var _this;
        _this = BaseShape.call(this) || this, _this.shapeType = ParticleShapeType.Box, _this._size = new Vector3(1, 1, 1);
        // @ts-ignore
        _this._size._onValueChanged = _this._updateManager.dispatch.bind(_this._updateManager);
        return _this;
    }
    var _proto = BoxShape.prototype;
    /**
   * @internal
   */ _proto._generatePositionAndDirection = function _generatePositionAndDirection(rand, emitTime, position, direction) {
        ShapeUtils._randomPointInsideHalfUnitBox(position, rand);
        position.multiply(this.size);
        var defaultDirection = BoxShape._tempVector30;
        defaultDirection.set(0.0, 0.0, -1);
        ShapeUtils._randomPointUnitSphere(direction, rand);
        Vector3.lerp(defaultDirection, direction, this.randomDirectionAmount, direction);
    };
    /**
   * @internal
   */ _proto._getDirectionRange = function _getDirectionRange(outMin, outMax) {
        var radian = Math.PI * this.randomDirectionAmount;
        if (this.randomDirectionAmount < 0.5) {
            var dirSin = Math.sin(radian);
            outMin.set(-dirSin, -dirSin, -1);
            outMax.set(dirSin, dirSin, 0);
        } else {
            var dirCos = Math.cos(radian);
            outMin.set(-1, -1, -1);
            outMax.set(1, 1, -dirCos);
        }
    };
    /**
   * @internal
   */ _proto._getPositionRange = function _getPositionRange(outMin, outMax) {
        var _this__size = this._size, x = _this__size.x, y = _this__size.y, z = _this__size.z;
        outMin.set(-x * 0.5, -y * 0.5, -z * 0.5);
        outMax.set(x * 0.5, y * 0.5, z * 0.5);
    };
    _create_class$2(BoxShape, [
        {
            key: "size",
            get: /**
   * The size of the box.
   */ function get() {
                return this._size;
            },
            set: function set(value) {
                if (value !== this._size) {
                    this._size.copyFrom(value);
                }
            }
        }
    ]);
    return BoxShape;
}(BaseShape);
BoxShape._tempVector30 = new Vector3();
__decorate$1([
    deepClone
], BoxShape.prototype, "_size", void 0);

/**
 * Particle shape multi mode value.
 */ var ParticleShapeArcMode = /*#__PURE__*/ function(ParticleShapeArcMode) {
    /** Generate points randomly. */ ParticleShapeArcMode[ParticleShapeArcMode["Random"] = 0] = "Random";
    /** Animate the emission point around the shape. */ ParticleShapeArcMode[ParticleShapeArcMode["Loop"] = 1] = "Loop";
    return ParticleShapeArcMode;
}({});

/**
 * Particle shape that emits particles from a circle.
 */ var CircleShape = /*#__PURE__*/ function(BaseShape) {
    _inherits$2(CircleShape, BaseShape);
    function CircleShape() {
        var _this;
        _this = BaseShape.apply(this, arguments) || this, _this.shapeType = ParticleShapeType.Circle, _this._radius = 1.0, _this._arc = 360.0, _this._arcMode = ParticleShapeArcMode.Random, _this._arcSpeed = 1.0;
        return _this;
    }
    var _proto = CircleShape.prototype;
    /**
   * @internal
   */ _proto._generatePositionAndDirection = function _generatePositionAndDirection(rand, emitTime, position, direction) {
        var positionPoint = CircleShape._tempPositionPoint;
        switch(this.arcMode){
            case ParticleShapeArcMode.Loop:
                var normalizedEmitTime = emitTime * this.arcSpeed * (360 / this.arc) % 1;
                var radian = MathUtil.degreeToRadian(this.arc * normalizedEmitTime);
                positionPoint.set(Math.cos(radian), Math.sin(radian));
                positionPoint.scale(rand.random());
                break;
            case ParticleShapeArcMode.Random:
                ShapeUtils.randomPointInsideUnitArcCircle(MathUtil.degreeToRadian(this.arc), positionPoint, rand);
                break;
        }
        position.set(positionPoint.x, positionPoint.y, 0);
        position.scale(this.radius);
        ShapeUtils._randomPointUnitSphere(direction, rand);
        Vector3.lerp(position, direction, this.randomDirectionAmount, direction);
    };
    /**
   * @internal
   */ _proto._getDirectionRange = function _getDirectionRange(outMin, outMax) {
        var randomDirZ = this.randomDirectionAmount > 0.5 ? 1 : Math.sin(this.randomDirectionAmount * Math.PI);
        var randomDegreeOnXY = 0.5 * (360 - this._arc) * this.randomDirectionAmount;
        var randomDirY = randomDegreeOnXY > 90 ? -1 : -Math.sin(randomDegreeOnXY);
        this._getUnitArcRange(this._arc + randomDegreeOnXY, outMin, outMax, randomDirY, randomDirZ);
    };
    /**
   * @internal
   */ _proto._getPositionRange = function _getPositionRange(outMin, outMax) {
        this._getUnitArcRange(this._arc, outMin, outMax, 0, 0);
        outMin.scale(this._radius);
        outMax.scale(this._radius);
    };
    _proto._getUnitArcRange = function _getUnitArcRange(arc, outMin, outMax, randomDirY, randomDirZ) {
        var radian = MathUtil.degreeToRadian(arc);
        var dirSin = Math.sin(radian);
        var dirCos = Math.cos(radian);
        if (arc < 90) {
            outMin.set(0, randomDirY, -randomDirZ);
            outMax.set(1, dirSin, randomDirZ);
        } else if (arc < 180) {
            outMin.set(dirCos, randomDirY, -randomDirZ);
            outMax.set(1, 1, randomDirZ);
        } else if (arc < 270) {
            outMin.set(-1, Math.min(dirSin, randomDirY), -randomDirZ);
            outMax.set(1, 1, randomDirZ);
        } else {
            outMin.set(-1, -1, -randomDirZ);
            outMax.set(1, 1, randomDirZ);
        }
    };
    _create_class$2(CircleShape, [
        {
            key: "radius",
            get: /**
   * Radius of the shape to emit particles from.
   */ function get() {
                return this._radius;
            },
            set: function set(value) {
                if (value !== this._radius) {
                    this._radius = value;
                    this._updateManager.dispatch();
                }
            }
        },
        {
            key: "arc",
            get: /**
   * Angle of the circle arc to emit particles from.
   */ function get() {
                return this._arc;
            },
            set: function set(value) {
                if (value !== this._arc) {
                    this._arc = value;
                    this._updateManager.dispatch();
                }
            }
        },
        {
            key: "arcMode",
            get: /**
   * The mode to generate particles around the arc.
   */ function get() {
                return this._arcMode;
            },
            set: function set(value) {
                if (value !== this._arcMode) {
                    this._arcMode = value;
                    this._updateManager.dispatch();
                }
            }
        },
        {
            key: "arcSpeed",
            get: /**
   * The speed of complete 360 degree rotation.
   */ function get() {
                return this._arcSpeed;
            },
            set: function set(value) {
                if (value !== this._arcSpeed) {
                    this._arcSpeed = value;
                    this._updateManager.dispatch();
                }
            }
        }
    ]);
    return CircleShape;
}(BaseShape);
CircleShape._tempPositionPoint = new Vector2();

/**
 * Cone shape.
 */ var ConeShape = /*#__PURE__*/ function(BaseShape) {
    _inherits$2(ConeShape, BaseShape);
    function ConeShape() {
        var _this;
        _this = BaseShape.apply(this, arguments) || this, _this.shapeType = ParticleShapeType.Cone, _this._angle = 25.0, _this._radius = 1.0, _this._length = 5.0, _this._emitType = 0;
        return _this;
    }
    var _proto = ConeShape.prototype;
    /**
   * @internal
   */ _proto._generatePositionAndDirection = function _generatePositionAndDirection(rand, emitTime, position, direction) {
        var unitPosition = ConeShape._tempVector20;
        var radian = MathUtil.degreeToRadian(this.angle);
        var dirSinA = Math.sin(radian);
        var dirCosA = Math.cos(radian);
        switch(this.emitType){
            case 0:
                ShapeUtils.randomPointInsideUnitCircle(unitPosition, rand);
                position.set(unitPosition.x * this.radius, unitPosition.y * this.radius, 0);
                var unitDirection = ConeShape._tempVector21;
                ShapeUtils.randomPointInsideUnitCircle(unitDirection, rand);
                Vector2.lerp(unitPosition, unitDirection, this.randomDirectionAmount, unitDirection);
                direction.set(unitDirection.x * dirSinA, unitDirection.y * dirSinA, -dirCosA);
                break;
            case 1:
                ShapeUtils.randomPointInsideUnitCircle(unitPosition, rand);
                position.set(unitPosition.x * this.radius, unitPosition.y * this.radius, 0);
                direction.set(unitPosition.x * dirSinA, unitPosition.y * dirSinA, -dirCosA);
                direction.normalize();
                var distance = ConeShape._tempVector30;
                Vector3.scale(direction, this.length * rand.random(), distance);
                position.add(distance);
                var randomDirection = ConeShape._tempVector31;
                ShapeUtils._randomPointUnitSphere(randomDirection, rand);
                Vector3.lerp(direction, randomDirection, this.randomDirectionAmount, direction);
                break;
        }
    };
    /**
   * @internal
   */ _proto._getDirectionRange = function _getDirectionRange(outMin, outMax) {
        var radian = 0;
        switch(this.emitType){
            case 0:
                radian = MathUtil.degreeToRadian(this._angle);
                break;
            case 1:
                var randomRadian = MathUtil.degreeToRadian((180 - this._angle) * this.randomDirectionAmount + this._angle);
                radian = Math.sin(randomRadian);
                break;
        }
        var dirSin = Math.sin(radian);
        outMin.set(-dirSin, -dirSin, -1);
        outMax.set(dirSin, dirSin, 0);
    };
    /**
   * @internal
   */ _proto._getPositionRange = function _getPositionRange(outMin, outMax) {
        var radius = this.radius;
        switch(this.emitType){
            case 0:
                outMin.set(-radius, -radius, 0);
                outMax.set(radius, radius, 0);
                break;
            case 1:
                var length = this.length;
                var dirSin = Math.sin(MathUtil.degreeToRadian(this._angle));
                outMin.set(-radius - dirSin * length, -radius - dirSin * length, -length);
                outMax.set(radius + dirSin * length, radius + dirSin * length, 0);
                break;
        }
    };
    _create_class$2(ConeShape, [
        {
            key: "angle",
            get: /**
   * Angle of the cone to emit particles from.
   */ function get() {
                return this._angle;
            },
            set: function set(value) {
                if (value !== this._angle) {
                    this._angle = value;
                    this._updateManager.dispatch();
                }
            }
        },
        {
            key: "radius",
            get: /**
   * Radius of the shape to emit particles from.
   */ function get() {
                return this._radius;
            },
            set: function set(value) {
                if (value !== this._radius) {
                    this._radius = value;
                    this._updateManager.dispatch();
                }
            }
        },
        {
            key: "length",
            get: /**
   * Length of the cone to emit particles from.
   */ function get() {
                return this._length;
            },
            set: function set(value) {
                if (value !== this._length) {
                    this._length = value;
                    this._updateManager.dispatch();
                }
            }
        },
        {
            key: "emitType",
            get: /**
   * Cone emitter type.
   */ function get() {
                return this._emitType;
            },
            set: function set(value) {
                if (value !== this._emitType) {
                    this._emitType = value;
                    this._updateManager.dispatch();
                }
            }
        }
    ]);
    return ConeShape;
}(BaseShape);
ConeShape._tempVector20 = new Vector2();
ConeShape._tempVector21 = new Vector2();
ConeShape._tempVector30 = new Vector3();
ConeShape._tempVector31 = new Vector3();
/**
 * Cone emitter type.
 */ var ConeEmitType = /*#__PURE__*/ function(ConeEmitType) {
    /** Emit particles from the base of the cone. */ ConeEmitType[ConeEmitType["Base"] = 0] = "Base";
    /** Emit particles from the volume of the cone. */ ConeEmitType[ConeEmitType["Volume"] = 1] = "Volume";
    return ConeEmitType;
}({});

/**
 * Particle shape that emits particles from a hemisphere.
 */ var HemisphereShape = /*#__PURE__*/ function(BaseShape) {
    _inherits$2(HemisphereShape, BaseShape);
    function HemisphereShape() {
        var _this;
        _this = BaseShape.apply(this, arguments) || this, _this.shapeType = ParticleShapeType.Hemisphere, _this._radius = 1.0;
        return _this;
    }
    var _proto = HemisphereShape.prototype;
    /**
   * @internal
   */ _proto._generatePositionAndDirection = function _generatePositionAndDirection(rand, emitTime, position, direction) {
        ShapeUtils._randomPointInsideUnitSphere(position, rand);
        position.scale(this.radius);
        var z = position.z;
        z > 0.0 && (position.z = -z);
        ShapeUtils._randomPointUnitSphere(direction, rand);
        Vector3.lerp(position, direction, this.randomDirectionAmount, direction);
    };
    /**
   * @internal
   */ _proto._getDirectionRange = function _getDirectionRange(outMin, outMax) {
        var randomDir = Math.sin(0.5 * this.randomDirectionAmount * Math.PI);
        outMin.set(-1, -1, -1);
        outMax.set(1, 1, randomDir);
    };
    /**
   * @internal
   */ _proto._getPositionRange = function _getPositionRange(outMin, outMax) {
        var radius = this._radius;
        outMin.set(-radius, -radius, -radius);
        outMax.set(radius, radius, 0);
    };
    _create_class$2(HemisphereShape, [
        {
            key: "radius",
            get: /**
   * Radius of the shape to emit particles from.
   */ function get() {
                return this._radius;
            },
            set: function set(value) {
                if (value !== this._radius) {
                    this._radius = value;
                    this._updateManager.dispatch();
                }
            }
        }
    ]);
    return HemisphereShape;
}(BaseShape);

/**
 * Particle shape that emits particles from a mesh.
 */ var MeshShape = /*#__PURE__*/ function(BaseShape) {
    _inherits$2(MeshShape, BaseShape);
    function MeshShape() {
        var _this;
        _this = BaseShape.apply(this, arguments) || this, _this.shapeType = ParticleShapeType.Mesh, _this._positionElementInfo = new Vector4() // x:offset, y:stride, z:isNormalized, w:normalizedScaleFactor
        , _this._normalElementInfo = new Vector4() // x:offset, y:stride, z:isNormalized, w:normalizedScaleFactor
        ;
        return _this;
    }
    var _proto = MeshShape.prototype;
    /**
   * @internal
   */ _proto._generatePositionAndDirection = function _generatePositionAndDirection(rand, emitTime, position, direction) {
        var _this = this, positions = _this._positionBuffer, positionInfo = _this._positionElementInfo, normals = _this._normalBuffer, normalInfo = _this._normalElementInfo;
        var randomIndex = Math.floor(rand.random() * this._mesh.vertexCount);
        // index = randomIndex * stride + offset
        var positionIndex = randomIndex * positionInfo.y + positionInfo.x;
        var normalIndex = randomIndex * normalInfo.y + normalInfo.x;
        position.set(positions[positionIndex], positions[positionIndex + 1], positions[positionIndex + 2]);
        positionInfo.z && position.scale(positionInfo.w);
        direction.set(normals[normalIndex], normals[normalIndex + 1], normals[normalIndex + 2]);
        normalInfo.z && direction.scale(normalInfo.w);
    };
    /**
   * @internal
   */ _proto._getPositionRange = function _getPositionRange(outMin, outMax) {
        var bounds = this._mesh.bounds;
        bounds.min.copyTo(outMin);
        bounds.max.copyTo(outMax);
    };
    /**
   * @internal
   */ _proto._getDirectionRange = function _getDirectionRange(outMin, outMax) {
        // @todo: Should use min and max of normal, use bounds is worst, but we can't get the min and max of normal by fast way.
        var bounds = this._mesh.bounds;
        bounds.min.copyTo(outMin);
        bounds.max.copyTo(outMax);
    };
    _proto._getAttributeBuffer = function _getAttributeBuffer(mesh, vertexElement, reusePositionBuffer, outVertexElementInfo) {
        var vertexBufferBinding = mesh.vertexBufferBindings[vertexElement.bindingIndex];
        var formatMetaInfo = vertexElement._formatMetaInfo;
        var typedBuffer;
        if (reusePositionBuffer) {
            typedBuffer = this._positionBuffer;
        } else {
            var buffer = vertexBufferBinding == null ? void 0 : vertexBufferBinding.buffer;
            if (!buffer) {
                throw "" + vertexElement.attribute + " buffer not found.";
            }
            if (buffer.readable) {
                // If buffer is readable, we can get the data directly
                typedBuffer = mesh._getVertexTypedArray(buffer.data.buffer, formatMetaInfo.type);
            } else {
                // Must read from GPU
                var unit8Buffer = new Uint8Array(buffer.byteLength);
                typedBuffer = mesh._getVertexTypedArray(unit8Buffer.buffer, formatMetaInfo.type);
                buffer.getData(typedBuffer);
            }
        }
        outVertexElementInfo.set(vertexElement.offset / typedBuffer.BYTES_PER_ELEMENT, vertexBufferBinding.stride / typedBuffer.BYTES_PER_ELEMENT, formatMetaInfo.normalized ? 1 : 0, formatMetaInfo.normalizedScaleFactor);
        return typedBuffer;
    };
    _proto._onMeshChanged = function _onMeshChanged(type) {
        if (type & MeshModifyFlags.VertexElements) {
            var mesh = this._mesh;
            if (mesh) {
                var positionElement = mesh.getVertexElement(VertexAttribute.Position);
                var normalElement = mesh.getVertexElement(VertexAttribute.Normal);
                if (!positionElement || !normalElement) {
                    throw "Mesh must have both " + VertexAttribute.Position + " and " + VertexAttribute.Normal + " attribute.";
                }
                this._positionBuffer = this._getAttributeBuffer(mesh, positionElement, false, this._positionElementInfo);
                // If the position and normal use the same buffer, we can reuse the position buffer
                var reusePositionBuffer = positionElement.bindingIndex === normalElement.bindingIndex;
                this._normalBuffer = this._getAttributeBuffer(mesh, normalElement, reusePositionBuffer, this._normalElementInfo);
            } else {
                this._positionElementInfo.set(-1, -1, -1, -1);
                this._positionBuffer = null;
                this._normalElementInfo.set(-1, -1, -1, -1);
                this._normalBuffer = null;
            }
        }
    };
    /**
   * @internal
   */ _proto._cloneTo = function _cloneTo(target, _, __) {
        target.mesh = this._mesh;
    };
    _create_class$2(MeshShape, [
        {
            key: "mesh",
            get: /**
   * Mesh to emit particles from.
   */ function get() {
                return this._mesh;
            },
            set: function set(value) {
                var lastMesh = this._mesh;
                if (lastMesh !== value) {
                    this._mesh = value;
                    if (lastMesh) {
                        lastMesh._addReferCount(-1);
                        lastMesh._updateFlagManager.removeListener(this._onMeshChanged);
                    }
                    if (value) {
                        value._addReferCount(1);
                        value._updateFlagManager.addListener(this._onMeshChanged);
                    }
                    this._onMeshChanged(MeshModifyFlags.VertexElements);
                    this._updateManager.dispatch();
                }
            }
        }
    ]);
    return MeshShape;
}(BaseShape);
__decorate$1([
    ignoreClone
], MeshShape.prototype, "_mesh", void 0);
__decorate$1([
    ignoreClone
], MeshShape.prototype, "_positionBuffer", void 0);
__decorate$1([
    ignoreClone
], MeshShape.prototype, "_normalBuffer", void 0);
__decorate$1([
    ignoreClone
], MeshShape.prototype, "_positionElementInfo", void 0);
__decorate$1([
    ignoreClone
], MeshShape.prototype, "_normalElementInfo", void 0);
__decorate$1([
    ignoreClone
], MeshShape.prototype, "_onMeshChanged", null);

/**
 * Particle shape that emits particles from a sphere.
 */ var SphereShape = /*#__PURE__*/ function(BaseShape) {
    _inherits$2(SphereShape, BaseShape);
    function SphereShape() {
        var _this;
        _this = BaseShape.apply(this, arguments) || this, _this.shapeType = ParticleShapeType.Sphere, _this._radius = 1.0;
        return _this;
    }
    var _proto = SphereShape.prototype;
    /**
   * @internal
   */ _proto._generatePositionAndDirection = function _generatePositionAndDirection(rand, emitTime, position, direction) {
        ShapeUtils._randomPointInsideUnitSphere(position, rand);
        position.scale(this.radius);
        ShapeUtils._randomPointUnitSphere(direction, rand);
        Vector3.lerp(position, direction, this.randomDirectionAmount, direction);
    };
    /**
   * @internal
   */ _proto._getDirectionRange = function _getDirectionRange(outMin, outMax) {
        outMin.set(-1, -1, -1);
        outMax.set(1, 1, 1);
    };
    /**
   * @internal
   */ _proto._getPositionRange = function _getPositionRange(outMin, outMax) {
        var radius = this._radius;
        outMin.set(-radius, -radius, -radius);
        outMax.set(radius, radius, radius);
    };
    _create_class$2(SphereShape, [
        {
            key: "radius",
            get: /**
   * Radius of the shape to emit particles from.
   */ function get() {
                return this._radius;
            },
            set: function set(value) {
                if (value !== this._radius) {
                    this._radius = value;
                    this._updateManager.dispatch();
                }
            }
        }
    ]);
    return SphereShape;
}(BaseShape);

var FRAG_SHADER = "#define GLSLIFY 1\nvarying vec2 v_uv;\n\nuniform sampler2D u_texture;\n\nvoid main(void) {\n\n  gl_FragColor = texture2D(u_texture, v_uv);\n\n}\n"; // eslint-disable-line

var VERT_SHADER = "#define GLSLIFY 1\nattribute vec3 POSITION;\nattribute vec2 TEXCOORD_0;\n\nvarying vec2 v_uv;\n\nuniform mat4 camera_ProjMat;\nuniform mat4 camera_ViewMat;\n\nvoid main() {\n\n  gl_Position = camera_ProjMat * camera_ViewMat * vec4( POSITION, 1.0 );\n  v_uv = TEXCOORD_0;\n\n}\n"; // eslint-disable-line

Shader.create("trail", VERT_SHADER, FRAG_SHADER);
var TrailMaterial = /*#__PURE__*/ function(Material) {
    _inherits$2(TrailMaterial, Material);
    function TrailMaterial(engine) {
        var _this;
        _this = Material.call(this, engine, Shader.find("trail")) || this;
        var target = _this.renderState.blendState.targetBlendState;
        target.enabled = true;
        target.sourceColorBlendFactor = target.sourceAlphaBlendFactor = BlendFactor.SourceAlpha;
        target.destinationColorBlendFactor = target.destinationAlphaBlendFactor = BlendFactor.One;
        _this.renderState.depthState.writeEnabled = false;
        return _this;
    }
    return TrailMaterial;
}(Material);

var _tempVector3 = new Vector3();
/**
 * @deprecated
 */ var TrailRenderer = /*#__PURE__*/ function(MeshRenderer) {
    _inherits$2(TrailRenderer, MeshRenderer);
    function TrailRenderer(entity, props) {
        var _this;
        _this = MeshRenderer.call(this, entity) || this;
        _this._stroke = props.stroke || 0.2;
        _this._minSeg = props.minSeg || 0.02;
        _this._lifetime = props.lifetime || 1000;
        _this._maxPointNum = _this._lifetime / 1000.0 * entity.engine.targetFrameRate;
        _this._points = [];
        _this._pointStates = [];
        _this._strapPoints = [];
        for(var i = 0; i < _this._maxPointNum; i++){
            _this._points.push(new Vector3());
            _this._pointStates.push(_this._lifetime);
            _this._strapPoints.push(new Vector3());
            _this._strapPoints.push(new Vector3());
        }
        _this._curPointNum = 0;
        var mtl = props.material || new TrailMaterial(_this.engine);
        _this.setMaterial(mtl);
        _this.setTexture(props.texture);
        _this._initGeometry();
        return _this;
    }
    var _proto = TrailRenderer.prototype;
    /**
   * @internal
   */ _proto.update = function update(deltaTime) {
        var mov = 0, newIdx = 0;
        for(var i = 0; i < this._curPointNum; i++){
            this._pointStates[i] -= deltaTime;
            if (this._pointStates[i] < 0) {
                mov++;
            } else if (mov > 0) {
                newIdx = i - mov;
                // Move data
                this._pointStates[newIdx] = this._pointStates[i];
                // Move point
                this._points[newIdx].copyFrom(this._points[i]);
            }
        }
        this._curPointNum -= mov;
        var appendNewPoint = true;
        if (this._curPointNum === this._maxPointNum) {
            appendNewPoint = false;
        } else if (this._curPointNum > 0) {
            var lastPoint = this._points[this._points.length - 1];
            if (Vector3.distance(this.entity.transform.worldPosition, lastPoint) < this._minSeg) {
                appendNewPoint = false;
            }
        }
        if (appendNewPoint) {
            this._pointStates[this._curPointNum] = this._lifetime;
            this._points[this._curPointNum].copyFrom(this.entity.transform.worldPosition);
            this._curPointNum++;
        }
    };
    /**
   * @deprecated
   * Set trail texture.
   * @param texture
   */ _proto.setTexture = function setTexture(texture) {
        if (texture) {
            this.getMaterial().shaderData.setTexture("u_texture", texture);
        }
    };
    /**
   * @internal
   */ _proto._render = function _render(context) {
        this._updateStrapVertices(context.camera, this._points);
        this._updateStrapCoords();
        this._vertexBuffer.setData(this._vertices);
        MeshRenderer.prototype._render.call(this, context);
    };
    _proto._initGeometry = function _initGeometry() {
        var mesh = new BufferMesh(this._entity.engine);
        var vertexStride = 20;
        var vertexCount = this._maxPointNum * 2;
        var vertexFloatCount = vertexCount * vertexStride;
        var vertices = new Float32Array(vertexFloatCount);
        var vertexElements = [
            new VertexElement("POSITION", 0, VertexElementFormat.Vector3, 0),
            new VertexElement("TEXCOORD_0", 12, VertexElementFormat.Vector2, 0)
        ];
        var vertexBuffer = new Buffer(this.engine, vertexFloatCount * 4, BufferUsage.Dynamic);
        mesh.setVertexBufferBinding(vertexBuffer, vertexStride);
        mesh.setVertexElements(vertexElements);
        mesh.addSubMesh(0, vertexCount, MeshTopology.TriangleStrip);
        this._vertexBuffer = vertexBuffer;
        this._vertexStride = vertexStride;
        this._vertices = vertices;
        this.mesh = mesh;
    };
    _proto._updateStrapVertices = function _updateStrapVertices(camera, points) {
        var m = camera.viewMatrix;
        var e = m.elements;
        var vx = new Vector3(e[0], e[4], e[8]);
        var vy = new Vector3(e[1], e[5], e[9]);
        var vz = new Vector3(e[2], e[6], e[10]);
        var s = this._stroke;
        vy.scale(s);
        var up = new Vector3();
        var down = new Vector3();
        var rotation = new Quaternion();
        Vector3.transformByQuat(vx, rotation, vx);
        Vector3.transformByQuat(vy, rotation, vy);
        var dy = new Vector3();
        var cross = new Vector3();
        var perpVector = new Vector3();
        vx.normalize();
        var vertices = this._vertices;
        //-- quad pos
        for(var i = 0; i < this._maxPointNum; i++){
            //-- center pos
            if (i < this._curPointNum) {
                var p = points[i];
                if (i === this._curPointNum - 1 && i !== 0) {
                    Vector3.subtract(p, points[i - 1], perpVector);
                } else {
                    Vector3.subtract(points[i + 1], p, perpVector);
                }
                this._projectOnPlane(perpVector, vz, perpVector);
                perpVector.normalize();
                // Calculate angle between vectors
                var angle = Math.acos(Vector3.dot(vx, perpVector));
                Vector3.cross(vx, perpVector, cross);
                if (Vector3.dot(cross, vz) <= 0) {
                    angle = Math.PI * 2 - angle;
                }
                Quaternion.rotationAxisAngle(vz, angle, rotation);
                Vector3.transformByQuat(vy, rotation, dy);
                Vector3.add(p, dy, up);
                Vector3.subtract(p, dy, down);
            }
            var p0 = i * 2 * this._vertexStride / 4;
            var p1 = (i * 2 + 1) * this._vertexStride / 4;
            vertices[p0] = up.x;
            vertices[p0 + 1] = up.y;
            vertices[p0 + 2] = up.z;
            vertices[p1] = down.x;
            vertices[p1 + 1] = down.y;
            vertices[p1 + 2] = down.z;
        }
    };
    _proto._updateStrapCoords = function _updateStrapCoords() {
        if (this._prePointsNum === this._curPointNum) {
            return;
        }
        this._prePointsNum = this._curPointNum;
        var count = this._curPointNum;
        var texDelta = 1.0 / count;
        var vertices = this._vertices;
        for(var i = 0; i < count; i++){
            var d = 1.0 - i * texDelta;
            var p0 = i * 2 * this._vertexStride / 4;
            var p1 = (i * 2 + 1) * this._vertexStride / 4;
            vertices[p0] = 0;
            vertices[p0 + 1] = d;
            vertices[p1] = 1.0;
            vertices[p1 + 1] = d;
        }
    };
    _proto._projectOnVector = function _projectOnVector(a, p, out) {
        var n_p = p.clone();
        Vector3.normalize(n_p, n_p);
        var cosine = Vector3.dot(a, n_p);
        out.x = n_p.x * cosine;
        out.y = n_p.y * cosine;
        out.z = n_p.z * cosine;
    };
    _proto._projectOnPlane = function _projectOnPlane(a, n, out) {
        this._projectOnVector(a, n, _tempVector3);
        Vector3.subtract(a, _tempVector3, out);
    };
    return TrailRenderer;
}(MeshRenderer);

/**
 * Environmental probes, providing necessary capabilities such as reflection and refraction.
 * @example
 * ```ts
 * const probe = cameraEntity.addComponent( CubeProbe )
 * probe.onTextureChange = cubeTexture => {
 *   envLight.specularTexture = cubeTexture;
 *   skybox.specularTexture = cubeTexture;
 * }
 * ```
 */ var Probe = /*#__PURE__*/ function(Script) {
    _inherits$2(Probe, Script);
    function Probe() {
        var _this;
        _this = Script.apply(this, arguments) || this, /**
   * Probe's layer, render everything by default.
   */ _this.probeLayer = Layer.Everything, /**
   * The width of the probe rendering target.
   */ _this.width = 1024, /**
   * The height of the probe rendering target.
   */ _this.height = 1024, /**
   * When using WebGL2, you can turn on MSAA at the hardware layer.
   */ _this.antiAliasing = 1, /**
   * Whether the probe is rendered to the cube color texture.
   */ _this._isCube = false;
        return _this;
    }
    var _proto = Probe.prototype;
    /**
   * Provide hooks for users to exchange Texture.
   * @remarks Prevent issue: Feedback Loops Between Textures and the Framebuffer.
   */ _proto.onTextureChange = function onTextureChange(renderColorTexture) {};
    _proto.onBeginRender = function onBeginRender(camera) {
        if (!this.enabled) return;
        this._camera = camera;
        this._oriCameraCullingMask = camera.cullingMask;
        camera.cullingMask = this.probeLayer;
        if (!this._activeRenderTarget || this._activeRenderTarget.width !== this.width || this._activeRenderTarget.height !== this.height || this._activeRenderTarget.antiAliasing !== this.antiAliasing) {
            this._renderTarget = new RenderTarget(this.engine, this.width, this.height, this._isCube ? new TextureCube(this.engine, this.width) : new Texture2D(this.engine, this.width, this.height), RenderBufferDepthFormat.Depth, this.antiAliasing);
            this._renderTargetSwap = new RenderTarget(this.engine, this.width, this.height, this._isCube ? new TextureCube(this.engine, this.width) : new Texture2D(this.engine, this.width, this.height), RenderBufferDepthFormat.Depth, this.antiAliasing);
            this._activeRenderTarget = this._renderTarget;
        }
        this._oriCameraRenderTarget = camera.renderTarget;
        camera.renderTarget = this._activeRenderTarget;
    };
    _proto.onEndRender = function onEndRender(camera) {
        if (!this.enabled) return;
        this.onTextureChange && this.onTextureChange(this._texture);
        this._activeRenderTarget = this._activeRenderTarget === this._renderTarget ? this._renderTargetSwap : this._renderTarget;
    };
    _proto._reset = function _reset() {
        if (!this.enabled) return;
        this._camera.renderTarget = this._oriCameraRenderTarget;
        this._camera.cullingMask = this._oriCameraCullingMask;
    };
    _create_class$2(Probe, [
        {
            key: "_texture",
            get: function get() {
                var _this__activeRenderTarget;
                return (_this__activeRenderTarget = this._activeRenderTarget) == null ? void 0 : _this__activeRenderTarget.getColorTexture();
            }
        }
    ]);
    return Probe;
}(Script);

var cacheTarget = new Vector3();
var cacheUp = new Vector3();
var cacheDir = new Vector3();
/**
 * Cube probe, generate cubeTexture, used for dynamic environment reflection and other effects.
 */ var CubeProbe = /*#__PURE__*/ function(Probe) {
    _inherits$2(CubeProbe, Probe);
    function CubeProbe() {
        var _this;
        _this = Probe.apply(this, arguments) || this, /**
   * The position of the probe can be set, the default is the origin [0,0,0].
   */ _this.position = new Vector3(0, 0, 0), /** @internal */ _this._isCube = true, _this.oriViewMatrix = new Matrix();
        return _this;
    }
    var _proto = CubeProbe.prototype;
    _proto.onBeginRender = function onBeginRender(camera) {
        if (!this.enabled) return;
        Probe.prototype.onBeginRender.call(this, camera);
        this._storeCamera(camera);
        // Render 6 faces
        for(var faceIndex = 0; faceIndex < 6; faceIndex++){
            // Change camera parameters
            this._setCamera(faceIndex, camera);
            camera.render(TextureCubeFace.PositiveX + faceIndex);
        }
        this._restoreCamera(camera);
        Probe.prototype._reset.call(this);
    };
    /**
   * Store original camera parameters.
   */ _proto._storeCamera = function _storeCamera(camera) {
        this.oriViewMatrix.copyFrom(camera.viewMatrix);
        this._oriFieldOfView = camera.fieldOfView;
    };
    /**
   * Restore camera parameters.
   */ _proto._restoreCamera = function _restoreCamera(camera) {
        camera.viewMatrix.copyFrom(this.oriViewMatrix);
        camera.fieldOfView = this._oriFieldOfView;
    };
    /**
   * Set camera parameters according to the rendering surface.
   */ _proto._setCamera = function _setCamera(faceIndex, camera) {
        switch(faceIndex){
            // positive_x
            case 0:
                cacheUp.set(0, -1, 0);
                cacheDir.set(1, 0, 0);
                break;
            // negative_x
            case 1:
                cacheUp.set(0, -1, 0);
                cacheDir.set(-1, 0, 0);
                break;
            // positive_y
            case 2:
                cacheUp.set(0, 0, 1);
                cacheDir.set(0, 1, 0);
                break;
            // negative_y
            case 3:
                cacheUp.set(0, 0, -1);
                cacheDir.set(0, -1, 0);
                break;
            // positive_z
            case 4:
                cacheUp.set(0, -1, 0);
                cacheDir.set(0, 0, 1);
                break;
            // negative_z
            case 5:
                cacheUp.set(0, -1, 0);
                cacheDir.set(0, 0, -1);
                break;
        }
        Vector3.add(this.position, cacheDir, cacheTarget);
        Matrix.lookAt(this.position, cacheTarget, cacheUp, camera.viewMatrix);
        camera.fieldOfView = 90;
    };
    return CubeProbe;
}(Probe);

/**
 * Audio Clip.
 */ var AudioClip = /*#__PURE__*/ function(ReferResource) {
    _inherits$2(AudioClip, ReferResource);
    function AudioClip(engine, name) {
        if (name === void 0) name = "";
        var _this;
        _this = ReferResource.call(this, engine) || this, _this._audioBuffer = null;
        _this.name = name;
        return _this;
    }
    var _proto = AudioClip.prototype;
    /**
   * @internal
   */ _proto._getAudioSource = function _getAudioSource() {
        return this._audioBuffer;
    };
    /**
   * @internal
   */ _proto._setAudioSource = function _setAudioSource(value) {
        this._audioBuffer = value;
    };
    _proto._onDestroy = function _onDestroy() {
        ReferResource.prototype._onDestroy.call(this);
        this._audioBuffer = null;
        this.name = null;
    };
    _create_class$2(AudioClip, [
        {
            key: "channels",
            get: /**
   * Number of discrete audio channels.
   */ function get() {
                return this._audioBuffer.numberOfChannels;
            }
        },
        {
            key: "sampleRate",
            get: /**
   * Sample rate, in samples per second.
   */ function get() {
                return this._audioBuffer.sampleRate;
            }
        },
        {
            key: "duration",
            get: /**
   * Duration, in seconds.
   */ function get() {
                return this._audioBuffer.duration;
            }
        }
    ]);
    return AudioClip;
}(ReferResource);

/**
 * @internal
 * Audio Manager.
 */ var AudioManager = /*#__PURE__*/ function() {
    function AudioManager() {}
    AudioManager.getContext = function getContext() {
        var context = AudioManager._context;
        if (!context) {
            AudioManager._context = context = new window.AudioContext();
            // Safari can't resume audio context without element interaction
            document.addEventListener("pointerdown", AudioManager._tryResume, true);
            document.addEventListener("touchend", AudioManager._tryResume, true);
            document.addEventListener("touchstart", AudioManager._tryResume, true);
        }
        return context;
    };
    AudioManager.getGainNode = function getGainNode() {
        var gainNode = AudioManager._gainNode;
        if (!AudioManager._gainNode) {
            AudioManager._gainNode = gainNode = AudioManager.getContext().createGain();
            gainNode.connect(AudioManager.getContext().destination);
        }
        return gainNode;
    };
    AudioManager.isAudioContextRunning = function isAudioContextRunning() {
        if (AudioManager.getContext().state !== "running") {
            console.warn("The AudioContext is not running and requires user interaction, such as a click or touch.");
            return false;
        }
        return true;
    };
    AudioManager._tryResume = function _tryResume() {
        if (AudioManager._context.state !== "running") {
            if (AudioManager._isResuming) {
                return;
            }
            AudioManager._isResuming = true;
            AudioManager._context.resume().then(function() {
                AudioManager._isResuming = false;
            });
        }
    };
    return AudioManager;
}();
AudioManager._isResuming = false;

/**
 * Audio Source Component.
 */ var AudioSource = /*#__PURE__*/ function(Component) {
    _inherits$2(AudioSource, Component);
    function AudioSource(entity) {
        var _this;
        _this = Component.call(this, entity) || this, /** If set to true, the audio component automatically begins to play on startup. */ _this.playOnEnabled = true, _this._isPlaying = false, _this._sourceNode = null, _this._pausedTime = -1, _this._playTime = -1, _this._volume = 1, _this._lastVolume = 1, _this._playbackRate = 1, _this._loop = false;
        _this._onPlayEnd = _this._onPlayEnd.bind(_this);
        _this._gainNode = AudioManager.getContext().createGain();
        _this._gainNode.connect(AudioManager.getGainNode());
        return _this;
    }
    var _proto = AudioSource.prototype;
    /**
   * Play the clip.
   */ _proto.play = function play() {
        if (!this._canPlay()) {
            return;
        }
        if (this._isPlaying) {
            return;
        }
        var startTime = this._pausedTime > 0 ? this._pausedTime - this._playTime : 0;
        this._initSourceNode(startTime);
        this._playTime = AudioManager.getContext().currentTime - startTime;
        this._pausedTime = -1;
        this._isPlaying = true;
    };
    /**
   * Stops playing the clip.
   */ _proto.stop = function stop() {
        if (this._isPlaying) {
            this._clearSourceNode();
            this._isPlaying = false;
            this._pausedTime = -1;
            this._playTime = -1;
        }
    };
    /**
   * Pauses playing the clip.
   */ _proto.pause = function pause() {
        if (this._isPlaying) {
            this._clearSourceNode();
            this._pausedTime = AudioManager.getContext().currentTime;
            this._isPlaying = false;
        }
    };
    /**
   * @internal
   */ _proto._onEnable = function _onEnable() {
        this.playOnEnabled && this.play();
    };
    /**
   * @internal
   */ _proto._onDisable = function _onDisable() {
        this.pause();
    };
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        Component.prototype._onDestroy.call(this);
        this.stop();
        this.clip = null;
    };
    _proto._onPlayEnd = function _onPlayEnd() {
        this.stop();
    };
    _proto._initSourceNode = function _initSourceNode(startTime) {
        var context = AudioManager.getContext();
        var sourceNode = context.createBufferSource();
        sourceNode.buffer = this._clip._getAudioSource();
        sourceNode.playbackRate.value = this._playbackRate;
        sourceNode.loop = this._loop;
        sourceNode.onended = this._onPlayEnd;
        this._sourceNode = sourceNode;
        sourceNode.connect(this._gainNode);
        this._sourceNode.start(0, startTime);
    };
    _proto._clearSourceNode = function _clearSourceNode() {
        this._sourceNode.stop();
        this._sourceNode.disconnect();
        this._sourceNode.onended = null;
        this._sourceNode = null;
    };
    _proto._canPlay = function _canPlay() {
        var _this__clip;
        var isValidClip = ((_this__clip = this._clip) == null ? void 0 : _this__clip._getAudioSource()) ? true : false;
        return isValidClip && AudioManager.isAudioContextRunning();
    };
    _create_class$2(AudioSource, [
        {
            key: "clip",
            get: /**
   * The audio clip to play.
   */ function get() {
                return this._clip;
            },
            set: function set(value) {
                var lastClip = this._clip;
                if (lastClip !== value) {
                    lastClip && lastClip._addReferCount(-1);
                    value && value._addReferCount(1);
                    this._clip = value;
                    this.stop();
                }
            }
        },
        {
            key: "isPlaying",
            get: /**
   * Whether the clip playing right now.
   */ function get() {
                return this._isPlaying;
            }
        },
        {
            key: "volume",
            get: /**
   * The volume of the audio source, ranging from 0 to 1.
   * @defaultValue `1`
   */ function get() {
                return this._volume;
            },
            set: function set(value) {
                value = Math.min(Math.max(0, value), 1.0);
                this._volume = value;
                this._gainNode.gain.setValueAtTime(value, AudioManager.getContext().currentTime);
            }
        },
        {
            key: "playbackRate",
            get: /**
   * The playback rate of the audio source.
   * @defaultValue `1`
   */ function get() {
                return this._playbackRate;
            },
            set: function set(value) {
                this._playbackRate = value;
                if (this._isPlaying) {
                    this._sourceNode.playbackRate.value = this._playbackRate;
                }
            }
        },
        {
            key: "mute",
            get: /**
   * Mutes or unmute the audio source.
   * Mute sets volume as 0, unmute restore volume.
   */ function get() {
                return this.volume === 0;
            },
            set: function set(value) {
                if (value) {
                    this._lastVolume = this.volume;
                    this.volume = 0;
                } else {
                    this.volume = this._lastVolume;
                }
            }
        },
        {
            key: "loop",
            get: /**
   * Whether the audio clip looping.
   * @defaultValue `false`
   */ function get() {
                return this._loop;
            },
            set: function set(value) {
                if (value !== this._loop) {
                    this._loop = value;
                    if (this._isPlaying) {
                        this._sourceNode.loop = this._loop;
                    }
                }
            }
        },
        {
            key: "time",
            get: /**
   * Playback position in seconds.
   */ function get() {
                if (this._isPlaying) {
                    var currentTime = AudioManager.getContext().currentTime;
                    return currentTime - this._playTime;
                } else {
                    return this._pausedTime > 0 ? this._pausedTime - this._playTime : 0;
                }
            }
        }
    ]);
    return AudioSource;
}(Component);
__decorate$1([
    ignoreClone
], AudioSource.prototype, "_isPlaying", void 0);
__decorate$1([
    ignoreClone
], AudioSource.prototype, "_clip", void 0);
__decorate$1([
    deepClone
], AudioSource.prototype, "_gainNode", void 0);
__decorate$1([
    ignoreClone
], AudioSource.prototype, "_sourceNode", void 0);
__decorate$1([
    deepClone
], AudioSource.prototype, "_pausedTime", void 0);
__decorate$1([
    ignoreClone
], AudioSource.prototype, "_playTime", void 0);
__decorate$1([
    deepClone
], AudioSource.prototype, "_volume", void 0);
__decorate$1([
    deepClone
], AudioSource.prototype, "_lastVolume", void 0);
__decorate$1([
    deepClone
], AudioSource.prototype, "_playbackRate", void 0);
__decorate$1([
    deepClone
], AudioSource.prototype, "_loop", void 0);

/**
 * @internal
 */ var Polyfill = /*#__PURE__*/ function() {
    function Polyfill() {}
    Polyfill.registerPolyfill = function registerPolyfill() {
        Polyfill._registerMatchAll();
        Polyfill._registerAudioContext();
        Polyfill._registerTextMetrics();
    };
    Polyfill._registerMatchAll = function _registerMatchAll() {
        if (!String.prototype.matchAll) {
            Logger.info("Polyfill String.prototype.matchAll");
            String.prototype.matchAll = function(pattern) {
                var flags = pattern.flags;
                var globalFlagIdx = flags.indexOf("g");
                if (globalFlagIdx === -1) {
                    throw TypeError("String.prototype.matchAll called with a non-global RegExp argument");
                }
                var bindThis = this;
                return function() {
                    var matchResult, matchFlag, matchPattern, _tmp, _tmp1, _i, index, item;
                    return __generator$1(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                matchResult = bindThis.match(pattern);
                                if (matchResult == null) return [
                                    2,
                                    null
                                ];
                                matchFlag = flags.split("g").join("");
                                matchPattern = new RegExp(pattern.source, matchFlag);
                                _tmp = [];
                                for(_tmp1 in matchResult)_tmp.push(_tmp1);
                                _i = 0;
                                _state.label = 1;
                            case 1:
                                if (!(_i < _tmp.length)) return [
                                    3,
                                    4
                                ];
                                index = _tmp[_i];
                                item = matchResult[index];
                                return [
                                    4,
                                    item.match(matchPattern)
                                ];
                            case 2:
                                _state.sent();
                                _state.label = 3;
                            case 3:
                                _i++;
                                return [
                                    3,
                                    1
                                ];
                            case 4:
                                return [
                                    2
                                ];
                        }
                    });
                }();
            };
        }
    };
    Polyfill._registerAudioContext = function _registerAudioContext() {
        // IOS 12 and the following system do not support AudioContext, need to switch to webkitAudioContext
        if (!window.AudioContext && window.webkitAudioContext) {
            Logger.info("Polyfill window.AudioContext");
            window.AudioContext = window.webkitAudioContext;
            var originalDecodeAudioData = AudioContext.prototype.decodeAudioData;
            AudioContext.prototype.decodeAudioData = function(arrayBuffer, successCallback, errorCallback) {
                var _this = this;
                return new Promise(function(resolve, reject) {
                    originalDecodeAudioData.call(_this, arrayBuffer, function(buffer) {
                        successCallback == null ? void 0 : successCallback(buffer);
                        resolve(buffer);
                    }, function(error) {
                        errorCallback == null ? void 0 : errorCallback(error);
                        reject(error);
                    });
                });
            };
        }
    };
    Polyfill._registerTextMetrics = function _registerTextMetrics() {
        // Based on the specific version of the engine implementation, when actualBoundingBoxLeft is not supported, width is used to represent the rendering width, and `textAlign` uses the default value `start` and direction is left to right.
        // Some devices do not support actualBoundingBoxLeft and actualBoundingBoxRight in TextMetrics.
        // Examples: Google Pixel 2 XL (Android 11), Honor 6X (Android 8).
        // In WeChat Mini Games, TextMetrics may be reported as not defined, so a check for window.TextMetrics is added.
        if (window.TextMetrics && !("actualBoundingBoxLeft" in TextMetrics.prototype)) {
            Object.defineProperties(TextMetrics.prototype, {
                actualBoundingBoxLeft: {
                    get: function get() {
                        return 0;
                    }
                },
                actualBoundingBoxRight: {
                    get: function get() {
                        return this.width;
                    }
                }
            });
        }
    };
    return Polyfill;
}();

Polyfill.registerPolyfill();

const CoreObjects = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    AmbientLight,
    get AnimationArrayCurve () { return AnimationArrayCurve; },
    get AnimationBoolCurve () { return AnimationBoolCurve; },
    AnimationClip,
    AnimationClipCurveBinding,
    get AnimationColorCurve () { return AnimationColorCurve; },
    AnimationCurve,
    AnimationEvent,
    get AnimationFloatArrayCurve () { return AnimationFloatArrayCurve; },
    get AnimationFloatCurve () { return AnimationFloatCurve; },
    get AnimationQuaternionCurve () { return AnimationQuaternionCurve; },
    get AnimationRectCurve () { return AnimationRectCurve; },
    get AnimationRefCurve () { return AnimationRefCurve; },
    get AnimationStringCurve () { return AnimationStringCurve; },
    get AnimationVector2Curve () { return AnimationVector2Curve; },
    get AnimationVector3Curve () { return AnimationVector3Curve; },
    get AnimationVector4Curve () { return AnimationVector4Curve; },
    Animator,
    AnimatorCondition,
    AnimatorConditionMode,
    AnimatorController,
    AnimatorControllerLayer,
    AnimatorControllerParameter,
    AnimatorCullingMode,
    AnimatorLayerBlendingMode,
    AnimatorLayerMask,
    AnimatorState,
    AnimatorStateMachine,
    AnimatorStateTransition,
    AntiAliasing,
    AssetPromise,
    AssetType,
    AudioClip,
    AudioManager,
    AudioSource,
    Background,
    BackgroundMode,
    BackgroundTextureFillMode,
    BaseMaterial,
    BasicRenderPipeline,
    BatchUtils,
    BlendFactor,
    BlendMode,
    BlendOperation,
    BlendShape,
    BlendShapeFrame,
    BlendState,
    BlinnPhongMaterial,
    Blitter,
    BloomDownScaleMode,
    BloomEffect,
    BoolUpdateFlag,
    BoxColliderShape,
    BoxShape,
    Buffer,
    BufferBindFlag,
    BufferMesh,
    BufferUsage,
    BufferUtil,
    Burst,
    get Camera () { return Camera; },
    CameraClearFlags,
    CameraModifyFlags,
    CameraType: CameraType$1,
    Canvas,
    CapsuleColliderShape,
    CharRenderInfo,
    CharacterController,
    CircleShape,
    ClearableObjectPool,
    CloneManager,
    get Collider () { return Collider; },
    ColliderShape,
    ColliderShapeUpAxis,
    Collision,
    CollisionDetectionMode,
    ColorOverLifetimeModule,
    ColorWriteMask,
    CompareFunction,
    Component,
    ConeEmitType,
    ConeShape,
    ContactPoint,
    ContentRestorer,
    ControllerCollisionFlag,
    ControllerNonWalkableMode,
    CubeProbe,
    CullMode,
    CurveKey,
    DataType,
    DependentMode,
    DepthState,
    DepthTextureMode,
    DiffuseMode,
    DirectLight,
    DisorderedArray,
    Downsampling,
    DynamicCollider,
    DynamicColliderConstraints,
    EmissionModule,
    Engine,
    EngineObject,
    Entity,
    EntityModifyFlags,
    EventDispatcher,
    FinalPass,
    FixedJoint,
    FogMode,
    Font,
    FontStyle,
    GLCapabilityType,
    GradientAlphaKey,
    GradientColorKey,
    HemisphereShape,
    HingeJoint,
    HitResult,
    IndexBufferBinding,
    IndexFormat,
    InputManager,
    InterpolationType,
    get Joint () { return Joint; },
    JointLimits,
    JointMotor,
    Keyframe,
    Keys,
    Layer,
    LayerPathMask,
    Light,
    Loader,
    Logger,
    MSAASamples,
    MainModule,
    Material,
    Mesh,
    MeshRenderer,
    MeshShape,
    MeshTopology,
    ModelMesh,
    OverflowMode,
    PBRBaseMaterial,
    PBRMaterial,
    PBRSpecularMaterial,
    ParticleCompositeCurve,
    ParticleCompositeGradient,
    ParticleCurve,
    ParticleCurveMode,
    ParticleGenerator,
    ParticleGradient,
    ParticleGradientMode,
    ParticleMaterial,
    ParticleRenderMode,
    ParticleRenderer,
    ParticleScaleMode,
    ParticleShapeArcMode,
    ParticleShapeType,
    ParticleSimulationSpace,
    ParticleStopMode,
    PhysicsMaterial,
    PhysicsMaterialCombineMode,
    PhysicsScene,
    PipelineStage,
    PlaneColliderShape,
    Platform,
    PointLight,
    Pointer,
    PointerButton,
    PointerEventData,
    PointerEventEmitter,
    PointerPhase,
    PostProcess,
    PostProcessEffect,
    PostProcessEffectBoolParameter,
    PostProcessEffectColorParameter,
    PostProcessEffectEnumParameter,
    PostProcessEffectFloatParameter,
    PostProcessEffectParameter,
    PostProcessEffectTextureParameter,
    PostProcessEffectVector2Parameter,
    PostProcessEffectVector3Parameter,
    PostProcessEffectVector4Parameter,
    PostProcessManager,
    PostProcessPass,
    PostProcessPassEvent,
    PostProcessUberPass,
    Primitive,
    PrimitiveMesh,
    Probe,
    RasterState,
    ReferResource,
    RefractionMode,
    RenderBufferDepthFormat,
    RenderFace,
    RenderQueue,
    RenderQueueFlags,
    RenderQueueType,
    RenderState,
    RenderStateDataKey: RenderStateElementKey,
    RenderTarget,
    RenderTargetBlendState,
    get Renderer () { return Renderer; },
    RendererUpdateFlags,
    ReplacementFailureStrategy,
    ResourceManager,
    ReturnableObjectPool,
    RotationOverLifetimeModule,
    SafeLoopArray,
    Scene,
    SceneManager,
    Script,
    SetDataOptions,
    Shader,
    ShaderData,
    ShaderDataGroup,
    ShaderFactory,
    ShaderLib,
    ShaderMacro,
    ShaderMacroCollection,
    ShaderPass,
    ShaderPlatformTarget,
    ShaderProperty,
    ShaderPropertyType,
    ShaderTagKey,
    ShadowCascadesMode,
    ShadowResolution,
    ShadowType,
    get SimpleSpriteAssembler () { return SimpleSpriteAssembler; },
    SizeOverLifetimeModule,
    Skin,
    SkinnedMeshRenderer,
    Sky,
    SkyBoxMaterial,
    SkyProceduralMaterial,
    get SlicedSpriteAssembler () { return SlicedSpriteAssembler; },
    SphereColliderShape,
    SphereShape,
    SpotLight,
    SpringJoint,
    Sprite,
    SpriteAtlas,
    SpriteDrawMode,
    SpriteMask,
    SpriteMaskInteraction,
    SpriteMaskLayer,
    SpriteModifyFlags,
    SpriteRenderer,
    SpriteTileMode,
    StateMachineScript,
    StaticCollider,
    StencilOperation,
    StencilState,
    SubFont,
    SubMesh,
    SubPrimitive,
    SubShader,
    SunMode,
    SystemInfo,
    TextHorizontalAlignment,
    TextRenderer,
    TextUtils,
    TextVerticalAlignment,
    Texture,
    Texture2D,
    Texture2DArray,
    TextureCoordinate,
    TextureCube,
    TextureCubeFace,
    TextureDepthCompareFunction,
    TextureFilterMode,
    TextureFormat,
    TextureSheetAnimationModule,
    TextureUsage,
    TextureUtils,
    TextureWrapMode: TextureWrapMode$1,
    get TiledSpriteAssembler () { return TiledSpriteAssembler; },
    Time,
    TonemappingEffect,
    TonemappingMode,
    TrailMaterial,
    TrailRenderer,
    Transform,
    UnlitMaterial,
    Utils,
    VelocityOverLifetimeModule,
    VertexAttribute,
    VertexBufferBinding,
    VertexElement,
    VertexElementFormat,
    WrapMode,
    XRManager,
    assignmentClone,
    deepClone,
    dependentComponents,
    ignoreClone,
    registerPointerEventEmitter,
    request,
    resourceLoader,
    shallowClone
}, Symbol.toStringTag, { value: 'Module' }));

/**
 * Smoothing plug-in.
 * */ var GLCompressedTextureInternalFormat = /*#__PURE__*/ function(GLCompressedTextureInternalFormat) {
    // astc
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_4X4_KHR"] = 37808] = "RGBA_ASTC_4X4_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_5X4_KHR"] = 37809] = "RGBA_ASTC_5X4_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_5X5_KHR"] = 37810] = "RGBA_ASTC_5X5_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_6X5_KHR"] = 37811] = "RGBA_ASTC_6X5_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_6X6_KHR"] = 37812] = "RGBA_ASTC_6X6_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_8X5_KHR"] = 37813] = "RGBA_ASTC_8X5_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_8X6_KHR"] = 37814] = "RGBA_ASTC_8X6_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_8X8_KHR"] = 37815] = "RGBA_ASTC_8X8_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_10X5_KHR"] = 37816] = "RGBA_ASTC_10X5_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_10X6_KHR"] = 37817] = "RGBA_ASTC_10X6_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_10X8_KHR"] = 37818] = "RGBA_ASTC_10X8_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_10X10_KHR"] = 37819] = "RGBA_ASTC_10X10_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_12X10_KHR"] = 37820] = "RGBA_ASTC_12X10_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_12X12_KHR"] = 37821] = "RGBA_ASTC_12X12_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_4X4_KHR"] = 37840] = "SRGB8_ALPHA8_ASTC_4X4_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_5X4_KHR"] = 37841] = "SRGB8_ALPHA8_ASTC_5X4_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_5X5_KHR"] = 37842] = "SRGB8_ALPHA8_ASTC_5X5_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_6X5_KHR"] = 37843] = "SRGB8_ALPHA8_ASTC_6X5_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_6X6_KHR"] = 37844] = "SRGB8_ALPHA8_ASTC_6X6_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_8X5_KHR"] = 37845] = "SRGB8_ALPHA8_ASTC_8X5_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_8X6_KHR"] = 37846] = "SRGB8_ALPHA8_ASTC_8X6_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_8X8_KHR"] = 37847] = "SRGB8_ALPHA8_ASTC_8X8_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_10X5_KHR"] = 37848] = "SRGB8_ALPHA8_ASTC_10X5_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_10X6_KHR"] = 37849] = "SRGB8_ALPHA8_ASTC_10X6_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_10X8_KHR"] = 37850] = "SRGB8_ALPHA8_ASTC_10X8_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_10X10_KHR"] = 37851] = "SRGB8_ALPHA8_ASTC_10X10_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_12X10_KHR"] = 37852] = "SRGB8_ALPHA8_ASTC_12X10_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_12X12_KHR"] = 37853] = "SRGB8_ALPHA8_ASTC_12X12_KHR";
    // etc1
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB_ETC1_WEBGL"] = 36196] = "RGB_ETC1_WEBGL";
    // etc2
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["R11_EAC"] = 37488] = "R11_EAC";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SIGNED_R11_EAC"] = 37489] = "SIGNED_R11_EAC";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RG11_EAC"] = 37490] = "RG11_EAC";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SIGNED_RG11_EAC"] = 37491] = "SIGNED_RG11_EAC";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB8_ETC2"] = 37492] = "RGB8_ETC2";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ETC2"] = 37493] = "SRGB8_ETC2";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA8_ETC2_EAC"] = 37496] = "RGBA8_ETC2_EAC";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "SRGB8_ALPHA8_ETC2_EAC";
    // pvrtc
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB_PVRTC_4BPPV1_IMG"] = 35840] = "RGB_PVRTC_4BPPV1_IMG";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB_PVRTC_2BPPV1_IMG"] = 35841] = "RGB_PVRTC_2BPPV1_IMG";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "RGBA_PVRTC_4BPPV1_IMG";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "RGBA_PVRTC_2BPPV1_IMG";
    // s3tc
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB_S3TC_DXT1_EXT"] = 33776] = "RGB_S3TC_DXT1_EXT";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_S3TC_DXT1_EXT"] = 33777] = "RGBA_S3TC_DXT1_EXT";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_S3TC_DXT3_EXT"] = 33778] = "RGBA_S3TC_DXT3_EXT";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_S3TC_DXT5_EXT"] = 33779] = "RGBA_S3TC_DXT5_EXT";
    // s3tc sRGB
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB_S3TC_DXT1_EXT"] = 35916] = "SRGB_S3TC_DXT1_EXT";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "SRGB_ALPHA_S3TC_DXT1_EXT";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "SRGB_ALPHA_S3TC_DXT3_EXT";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "SRGB_ALPHA_S3TC_DXT5_EXT";
    // bptc
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_BPTC_UNORM_EXT"] = 36492] = "RGBA_BPTC_UNORM_EXT";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB_ALPHA_BPTC_UNORM_EXT"] = 36493] = "SRGB_ALPHA_BPTC_UNORM_EXT";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB_BPTC_SIGNED_FLOAT_EXT"] = 36494] = "RGB_BPTC_SIGNED_FLOAT_EXT";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB_BPTC_UNSIGNED_FLOAT_EXT"] = 36495] = "RGB_BPTC_UNSIGNED_FLOAT_EXT";
    return GLCompressedTextureInternalFormat;
}({});

function _defineProperties$1(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;

        if ("value" in descriptor) descriptor.writable = true;

        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class$1(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);

    return Constructor;
}

function _set_prototype_of$1(o, p) {
    _set_prototype_of$1 = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;

        return o;
    };

    return _set_prototype_of$1(o, p);
}

function _inherits$1(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });

    if (superClass) _set_prototype_of$1(subClass, superClass);
}

function _instanceof$2(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else return left instanceof right;
}

/**
 * The canvas used on the web, which can support HTMLCanvasElement and OffscreenCanvas.
 */ var WebCanvas = /*#__PURE__*/ function(Canvas) {
    _inherits$1(WebCanvas, Canvas);
    function WebCanvas(webCanvas) {
        var _this;
        _this = Canvas.call(this) || this, _this._scale = new Vector2();
        var width = webCanvas.width;
        var height = webCanvas.height;
        _this._webCanvas = webCanvas;
        _this.width = width;
        _this.height = height;
        return _this;
    }
    var _proto = WebCanvas.prototype;
    /**
   * Resize the rendering size according to the clientWidth and clientHeight of the canvas.
   * @param pixelRatio - Pixel ratio
   */ _proto.resizeByClientSize = function resizeByClientSize(pixelRatio) {
        if (pixelRatio === void 0) pixelRatio = window.devicePixelRatio;
        var webCanvas = this._webCanvas;
        if (typeof OffscreenCanvas === "undefined" || !_instanceof$2(webCanvas, OffscreenCanvas)) {
            var exportWidth = webCanvas.clientWidth * pixelRatio;
            var exportHeight = webCanvas.clientHeight * pixelRatio;
            this.width = exportWidth;
            this.height = exportHeight;
        }
    };
    /**
   * Set scale.
   * @param x - Scale along the X axis
   * @param y - Scale along the Y axis
   */ _proto.setScale = function setScale(x, y) {
        this._scale.set(x, y);
        this.scale = this._scale;
    };
    _proto._onWidthChanged = function _onWidthChanged(value) {
        this._webCanvas.width = value;
    };
    _proto._onHeightChange = function _onHeightChange(value) {
        this._webCanvas.height = value;
    };
    _create_class$1(WebCanvas, [
        {
            key: "scale",
            get: /**
   * The scale of canvas, the value is visible width/height divide the render width/height.
   * @remarks Need to re-assign after modification to ensure that the modification takes effect.
   */ function get() {
                var webCanvas = this._webCanvas;
                if (typeof OffscreenCanvas === "undefined" || !_instanceof$2(webCanvas, OffscreenCanvas)) {
                    this._scale.set(webCanvas.clientWidth * devicePixelRatio / webCanvas.width, webCanvas.clientHeight * devicePixelRatio / webCanvas.height);
                }
                return this._scale;
            },
            set: function set(value) {
                var webCanvas = this._webCanvas;
                if (typeof OffscreenCanvas === "undefined" || !_instanceof$2(webCanvas, OffscreenCanvas)) {
                    webCanvas.style.transformOrigin = "left top";
                    webCanvas.style.transform = "scale(" + value.x + ", " + value.y + ")";
                }
            }
        }
    ]);
    return WebCanvas;
}(Canvas);

/**
 * WebGL platform engine,support includes WebGL1.0 and WebGL2.0.
 */ var WebGLEngine = /*#__PURE__*/ function(Engine) {
    _inherits$1(WebGLEngine, Engine);
    function WebGLEngine() {
        return Engine.apply(this, arguments) || this;
    }
    /**
   * Create a WebGL engine.
   * @param configuration - WebGL engine configuration
   * @returns A promise that will resolve when the engine is created
   */ WebGLEngine.create = function create(configuration) {
        var canvas = configuration.canvas;
        var webCanvas = new WebCanvas(typeof canvas === "string" ? document.getElementById(canvas) : canvas);
        var webGLGraphicDevice = new WebGLGraphicDevice(configuration.graphicDeviceOptions);
        var engine = new WebGLEngine(webCanvas, webGLGraphicDevice, configuration);
        // @ts-ignore
        var promise = engine._initialize(configuration);
        return promise.then(function() {
            engine.sceneManager.addScene(new Scene(engine, "DefaultScene"));
            return engine;
        });
    };
    _create_class$1(WebGLEngine, [
        {
            key: "canvas",
            get: /**
   * Web canvas.
   */ function get() {
                // @ts-ignore
                return this._canvas;
            }
        }
    ]);
    return WebGLEngine;
}(Engine);

function _extends$1() {
    _extends$1 = Object.assign || function assign(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }

        return target;
    };

    return _extends$1.apply(this, arguments);
}

var GLBuffer = /*#__PURE__*/ function() {
    function GLBuffer(rhi, type, byteLength, bufferUsage, data) {
        if (bufferUsage === void 0) bufferUsage = BufferUsage.Static;
        var gl = rhi.gl;
        var glBuffer = gl.createBuffer();
        var glBufferUsage = this._getGLBufferUsage(gl, bufferUsage);
        var glBindTarget = type === BufferBindFlag.VertexBuffer ? gl.ARRAY_BUFFER : gl.ELEMENT_ARRAY_BUFFER;
        this._gl = gl;
        this._glBuffer = glBuffer;
        this._glBufferUsage = glBufferUsage;
        this._glBindTarget = glBindTarget;
        this._isWebGL2 = rhi.isWebGL2;
        this.bind();
        if (data) {
            gl.bufferData(glBindTarget, data, glBufferUsage);
        } else {
            gl.bufferData(glBindTarget, byteLength, glBufferUsage);
        }
        gl.bindBuffer(glBindTarget, null);
    }
    var _proto = GLBuffer.prototype;
    _proto.bind = function bind() {
        this._gl.bindBuffer(this._glBindTarget, this._glBuffer);
    };
    _proto.setData = function setData(byteLength, data, bufferByteOffset, dataOffset, dataLength, options) {
        var gl = this._gl;
        var glBindTarget = this._glBindTarget;
        this.bind();
        if (options === SetDataOptions.Discard) {
            gl.bufferData(glBindTarget, byteLength, this._glBufferUsage);
        }
        // TypeArray is BYTES_PER_ELEMENT, unTypeArray is 1
        var byteSize = data.BYTES_PER_ELEMENT || 1;
        var dataByteLength = dataLength ? byteSize * dataLength : data.byteLength;
        if (dataOffset !== 0 || dataByteLength < data.byteLength) {
            var isArrayBufferView = data.byteOffset !== undefined;
            if (this._isWebGL2 && isArrayBufferView) {
                gl.bufferSubData(glBindTarget, bufferByteOffset, data, dataOffset, dataByteLength / byteSize);
            } else {
                var subData = new Uint8Array(isArrayBufferView ? data.buffer : data, dataOffset * byteSize, dataByteLength);
                gl.bufferSubData(glBindTarget, bufferByteOffset, subData);
            }
        } else {
            gl.bufferSubData(glBindTarget, bufferByteOffset, data);
        }
        gl.bindBuffer(glBindTarget, null);
    };
    _proto.getData = function getData(data, bufferByteOffset, dataOffset, dataLength) {
        if (this._isWebGL2) {
            var gl = this._gl;
            this.bind();
            gl.getBufferSubData(this._glBindTarget, bufferByteOffset, data, dataOffset, dataLength);
        } else {
            throw "Buffer is write-only on WebGL1.0 platforms.";
        }
    };
    _proto.destroy = function destroy() {
        this._gl.deleteBuffer(this._glBuffer);
        this._gl = null;
        this._glBuffer = null;
    };
    _proto._getGLBufferUsage = function _getGLBufferUsage(gl, bufferUsage) {
        switch(bufferUsage){
            case BufferUsage.Static:
                return gl.STATIC_DRAW;
            case BufferUsage.Dynamic:
                return gl.DYNAMIC_DRAW;
            case BufferUsage.Stream:
                return gl.STREAM_DRAW;
        }
    };
    return GLBuffer;
}();

/**
 * GL capability.
 */ var GLCapability = /*#__PURE__*/ function() {
    function GLCapability(rhi) {
        this._rhi = rhi;
        this.capabilityList = new Map();
        this._init();
        this._compatibleAllInterface();
    }
    var _proto = GLCapability.prototype;
    /**
   * Check device capabilities.
   */ _proto.canIUse = function canIUse(capabilityType) {
        return this.capabilityList.get(capabilityType);
    };
    /**
   * Check if can use some compressed texture format.
   */ _proto.canIUseCompressedTextureInternalFormat = function canIUseCompressedTextureInternalFormat(internalType) {
        var // astc
        RGBA_ASTC_4X4_KHR = GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR, RGBA_ASTC_12X12_KHR = GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR, SRGB8_ALPHA8_ASTC_4X4_KHR = GLCompressedTextureInternalFormat.SRGB8_ALPHA8_ASTC_4X4_KHR, SRGB8_ALPHA8_ASTC_12X12_KHR = GLCompressedTextureInternalFormat.SRGB8_ALPHA8_ASTC_12X12_KHR, // etc1
        RGB_ETC1_WEBGL = GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL, // etc
        R11_EAC = GLCompressedTextureInternalFormat.R11_EAC, SRGB8_ALPHA8_ETC2_EAC = GLCompressedTextureInternalFormat.SRGB8_ALPHA8_ETC2_EAC, // pvrtc
        RGB_PVRTC_4BPPV1_IMG = GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG, RGBA_PVRTC_2BPPV1_IMG = GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG, // s3tc
        RGB_S3TC_DXT1_EXT = GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT, RGBA_S3TC_DXT5_EXT = GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT, // bptc
        RGBA_BPTC_UNORM_EXT = GLCompressedTextureInternalFormat.RGBA_BPTC_UNORM_EXT, RGB_BPTC_UNSIGNED_FLOAT_EXT = GLCompressedTextureInternalFormat.RGB_BPTC_UNSIGNED_FLOAT_EXT;
        if (internalType >= RGBA_ASTC_4X4_KHR && RGBA_ASTC_12X12_KHR <= RGBA_ASTC_12X12_KHR || internalType >= SRGB8_ALPHA8_ASTC_4X4_KHR && internalType <= SRGB8_ALPHA8_ASTC_12X12_KHR) {
            return this.canIUse(GLCapabilityType.astc);
        } else if (internalType === RGB_ETC1_WEBGL) {
            return this.canIUse(GLCapabilityType.etc1);
        } else if (internalType >= R11_EAC && internalType <= SRGB8_ALPHA8_ETC2_EAC) {
            return this.canIUse(GLCapabilityType.etc);
        } else if (internalType >= RGB_PVRTC_4BPPV1_IMG && internalType <= RGBA_PVRTC_2BPPV1_IMG) {
            return this.canIUse(GLCapabilityType.pvrtc);
        } else if (internalType >= RGB_S3TC_DXT1_EXT && internalType <= RGBA_S3TC_DXT5_EXT) {
            return this.canIUse(GLCapabilityType.s3tc);
        } else if (internalType >= RGBA_BPTC_UNORM_EXT && internalType <= RGB_BPTC_UNSIGNED_FLOAT_EXT) {
            return this.canIUse(GLCapabilityType.bptc);
        }
        return false;
    };
    /**
   *  Init capabilities.
   */ _proto._init = function _init() {
        var cap = this.capabilityList;
        var isWebGL2 = this.rhi.isWebGL2;
        var requireExtension = this.rhi.requireExtension.bind(this.rhi);
        var shaderVertexID = GLCapabilityType.shaderVertexID, standardDerivatives = GLCapabilityType.standardDerivatives, shaderTextureLod = GLCapabilityType.shaderTextureLod, elementIndexUint = GLCapabilityType.elementIndexUint, depthTexture = GLCapabilityType.depthTexture, vertexArrayObject = GLCapabilityType.vertexArrayObject, instancedArrays = GLCapabilityType.instancedArrays, multipleSample = GLCapabilityType.multipleSample, drawBuffers = GLCapabilityType.drawBuffers, blendMinMax = GLCapabilityType.blendMinMax, astc = GLCapabilityType.astc, astc_webkit = GLCapabilityType.astc_webkit, etc = GLCapabilityType.etc, etc_webkit = GLCapabilityType.etc_webkit, etc1 = GLCapabilityType.etc1, etc1_webkit = GLCapabilityType.etc1_webkit, pvrtc = GLCapabilityType.pvrtc, pvrtc_webkit = GLCapabilityType.pvrtc_webkit, s3tc = GLCapabilityType.s3tc, s3tc_webkit = GLCapabilityType.s3tc_webkit, bptc = GLCapabilityType.bptc, s3tc_srgb = GLCapabilityType.s3tc_srgb, textureFloat = GLCapabilityType.textureFloat, textureHalfFloat = GLCapabilityType.textureHalfFloat, textureFloatLinear = GLCapabilityType.textureFloatLinear, textureHalfFloatLinear = GLCapabilityType.textureHalfFloatLinear, WEBGL_colorBufferFloat = GLCapabilityType.WEBGL_colorBufferFloat, colorBufferFloat = GLCapabilityType.colorBufferFloat, colorBufferHalfFloat = GLCapabilityType.colorBufferHalfFloat, textureFilterAnisotropic = GLCapabilityType.textureFilterAnisotropic, fragDepth = GLCapabilityType.fragDepth, sRGB = GLCapabilityType.sRGB;
        cap.set(shaderVertexID, isWebGL2);
        cap.set(standardDerivatives, isWebGL2 || !!requireExtension(standardDerivatives));
        cap.set(shaderTextureLod, isWebGL2 || !!requireExtension(shaderTextureLod));
        cap.set(elementIndexUint, isWebGL2 || !!requireExtension(elementIndexUint));
        cap.set(depthTexture, isWebGL2 || !!requireExtension(depthTexture));
        cap.set(vertexArrayObject, isWebGL2 || !!requireExtension(vertexArrayObject));
        cap.set(instancedArrays, isWebGL2 || !!requireExtension(instancedArrays));
        cap.set(multipleSample, isWebGL2);
        cap.set(drawBuffers, isWebGL2 || !!requireExtension(drawBuffers));
        cap.set(blendMinMax, isWebGL2 || !!requireExtension(blendMinMax));
        cap.set(textureFloat, isWebGL2 || !!requireExtension(textureFloat));
        cap.set(textureHalfFloat, isWebGL2 || !!requireExtension(textureHalfFloat));
        cap.set(textureFloatLinear, !!requireExtension(textureFloatLinear));
        cap.set(textureHalfFloatLinear, isWebGL2 || !!requireExtension(textureHalfFloatLinear));
        cap.set(colorBufferFloat, isWebGL2 && !!requireExtension(colorBufferFloat) || !!requireExtension(WEBGL_colorBufferFloat));
        cap.set(colorBufferHalfFloat, isWebGL2 && !!requireExtension(colorBufferFloat) || !!requireExtension(colorBufferHalfFloat));
        cap.set(textureFilterAnisotropic, !!requireExtension(textureFilterAnisotropic));
        cap.set(fragDepth, isWebGL2 || !!requireExtension(fragDepth));
        cap.set(astc, !!(requireExtension(astc) || requireExtension(astc_webkit)));
        cap.set(etc, !!(requireExtension(etc) || requireExtension(etc_webkit)));
        cap.set(etc1, !!(requireExtension(etc1) || requireExtension(etc1_webkit)));
        cap.set(pvrtc, !!(requireExtension(pvrtc) || requireExtension(pvrtc_webkit)));
        cap.set(s3tc, !!(requireExtension(s3tc) || requireExtension(s3tc_webkit)));
        cap.set(s3tc_srgb, !!requireExtension(s3tc_srgb));
        cap.set(bptc, !!requireExtension(bptc));
        cap.set(sRGB, isWebGL2 || !!requireExtension(sRGB));
    };
    /**
   * If there are extensions that can supplement this ability, smooth out the difference.
   * @example
   * compatible(GLCapabilityType.depthTexture,{
   *    UNSIGNED_INT_24_8: "UNSIGNED_INT_24_8_WEBGL"
   * })
   * gl.UNSIGNED_INT_24_8 = ext.UNSIGNED_INT_24_8_WEBGL
   */ _proto._compatibleInterface = function _compatibleInterface(capabilityType, flatItem) {
        var rhi = this.rhi;
        var gl = rhi.gl;
        var ext = null;
        if (ext = rhi.requireExtension(capabilityType)) {
            for(var glKey in flatItem){
                var extensionKey = flatItem[glKey];
                var extensionVal = ext[extensionKey];
                // Mini game hack the native function,use “.bind” to smooth out if is “Funcion”.
                if (extensionVal == null ? void 0 : extensionVal.bind) {
                    gl[glKey] = extensionVal.bind(ext);
                } else {
                    gl[glKey] = extensionVal;
                }
            }
        }
    };
    _proto._compatibleAllInterface = function _compatibleAllInterface() {
        var depthTexture = GLCapabilityType.depthTexture, vertexArrayObject = GLCapabilityType.vertexArrayObject, instancedArrays = GLCapabilityType.instancedArrays, drawBuffers = GLCapabilityType.drawBuffers, textureFilterAnisotropic = GLCapabilityType.textureFilterAnisotropic, textureHalfFloat = GLCapabilityType.textureHalfFloat, colorBufferHalfFloat = GLCapabilityType.colorBufferHalfFloat, WEBGL_colorBufferFloat = GLCapabilityType.WEBGL_colorBufferFloat, blendMinMax = GLCapabilityType.blendMinMax, sRGB = GLCapabilityType.sRGB;
        var isWebGL2 = this.rhi.isWebGL2;
        if (!isWebGL2) {
            this._compatibleInterface(blendMinMax, {
                MIN: "MIN_EXT",
                MAX: "MAX_EXT"
            });
            this._compatibleInterface(depthTexture, {
                UNSIGNED_INT_24_8: "UNSIGNED_INT_24_8_WEBGL"
            });
            this._compatibleInterface(vertexArrayObject, {
                createVertexArray: "createVertexArrayOES",
                deleteVertexArray: "deleteVertexArrayOES",
                isVertexArray: "isVertexArrayOES",
                bindVertexArray: "bindVertexArrayOES"
            });
            this._compatibleInterface(instancedArrays, {
                drawArraysInstanced: "drawArraysInstancedANGLE",
                drawElementsInstanced: "drawElementsInstancedANGLE",
                vertexAttribDivisor: "vertexAttribDivisorANGLE"
            });
            this._compatibleInterface(drawBuffers, {
                MAX_DRAW_BUFFERS: "MAX_DRAW_BUFFERS_WEBGL"
            });
            var items = {};
            if (this.canIUse(GLCapabilityType.drawBuffers)) {
                var maxDrawBuffers = this.maxDrawBuffers;
                for(var i = 0; i < maxDrawBuffers; i++){
                    i != 0 && (items["COLOR_ATTACHMENT" + i] = "COLOR_ATTACHMENT" + i + "_WEBGL");
                    items["DRAW_BUFFER" + i] = "DRAW_BUFFER" + i + "_WEBGL";
                }
                this._compatibleInterface(drawBuffers, _extends$1({
                    drawBuffers: "drawBuffersWEBGL"
                }, items));
            }
            this._compatibleInterface(textureHalfFloat, {
                HALF_FLOAT: "HALF_FLOAT_OES"
            });
            this._compatibleInterface(colorBufferHalfFloat, {
                RGBA16F: "RBGA16F_EXT"
            });
            this._compatibleInterface(WEBGL_colorBufferFloat, {
                RGBA32F: "RBGA32F_EXT"
            });
            this._compatibleInterface(sRGB, {
                SRGB8: "SRGB_EXT",
                SRGB8_ALPHA8: "SRGB_ALPHA_EXT"
            });
        }
        this._compatibleInterface(textureFilterAnisotropic, {
            TEXTURE_MAX_ANISOTROPY_EXT: "TEXTURE_MAX_ANISOTROPY_EXT"
        });
    };
    _create_class$1(GLCapability, [
        {
            key: "maxTextureSize",
            get: function get() {
                return this.rhi.renderStates.getParameter(this.rhi.gl.MAX_TEXTURE_SIZE);
            }
        },
        {
            key: "canUseFloatTextureBlendShape",
            get: function get() {
                return this.canIUse(GLCapabilityType.shaderVertexID) && this.canIUse(GLCapabilityType.textureFloat) && this.rhi.renderStates.getParameter(this.rhi.gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0;
            }
        },
        {
            key: "canIUseMoreJoints",
            get: /**
   * Whether can use more joints.
   */ function get() {
                return this.canIUse(GLCapabilityType.textureFloat) && this.rhi.renderStates.getParameter(this.rhi.gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0;
            }
        },
        {
            key: "maxDrawBuffers",
            get: function get() {
                if (!this._maxDrawBuffers) {
                    if (this.canIUse(GLCapabilityType.drawBuffers)) {
                        this._maxDrawBuffers = this._rhi.gl.getParameter(this._rhi.gl.MAX_DRAW_BUFFERS);
                    } else {
                        this._maxDrawBuffers = 1;
                    }
                }
                return this._maxDrawBuffers;
            }
        },
        {
            key: "maxAnisoLevel",
            get: /**
   * Max anisoLevel.
   */ function get() {
                if (!this._maxAnisoLevel) {
                    var ext = this._rhi.requireExtension(GLCapabilityType.textureFilterAnisotropic);
                    this._maxAnisoLevel = ext ? this._rhi.gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
                }
                return this._maxAnisoLevel;
            }
        },
        {
            key: "maxAntiAliasing",
            get: /**
   * Max MSAA count.
   */ function get() {
                if (!this._maxAntiAliasing) {
                    var gl = this._rhi.gl;
                    var canMSAA = this.canIUse(GLCapabilityType.multipleSample);
                    this._maxAntiAliasing = canMSAA ? gl.getParameter(gl.MAX_SAMPLES) : 1;
                }
                return this._maxAntiAliasing;
            }
        },
        {
            key: "rhi",
            get: function get() {
                return this._rhi;
            }
        }
    ]);
    return GLCapability;
}();

/**
 * GLContext extension.
 */ var GLExtensions = /*#__PURE__*/ function() {
    function GLExtensions(rhi) {
        this.rhi = rhi;
        this._requireResult = {};
    }
    var _proto = GLExtensions.prototype;
    /**
   * Require an extension.
   */ _proto.requireExtension = function requireExtension(ext) {
        if (this._requireResult[ext] !== undefined) {
            return this._requireResult[ext];
        }
        this._requireResult[ext] = this.rhi.gl.getExtension(ext);
        return this._requireResult[ext];
    };
    return GLExtensions;
}();

/**
 * Improvement of VAO:
 * 1) WebGL2.0 must support VAO, almost all devices support vao extensions in webgl1.0, we can use PollyFill,only keep VAO mode.
 */ /**
 * @internal
 * GL platform primitive.
 */ var GLPrimitive = /*#__PURE__*/ function() {
    function GLPrimitive(rhi, primitive) {
        this._attribLocArray = [];
        this._vaoMap = new Map();
        this._primitive = primitive;
        this._canUseInstancedArrays = rhi.canIUse(GLCapabilityType.instancedArrays);
        this._isSupportVAO = rhi.canIUse(GLCapabilityType.vertexArrayObject);
        this._gl = rhi.gl;
    }
    var _proto = GLPrimitive.prototype;
    /**
   * Draw the primitive.
   */ _proto.draw = function draw(shaderProgram, subMesh) {
        var gl = this._gl;
        var primitive = this._primitive;
        var useVao = this._isSupportVAO && primitive.enableVAO;
        if (useVao) {
            if (primitive._bufferStructChanged) {
                this._clearVAO();
            }
            if (!this._vaoMap.has(shaderProgram.id)) {
                this._registerVAO(shaderProgram);
            }
            var vao = this._vaoMap.get(shaderProgram.id);
            gl.bindVertexArray(vao);
        } else {
            this._bindBufferAndAttrib(shaderProgram);
        }
        var indexBufferBinding = primitive.indexBufferBinding, instanceCount = primitive.instanceCount, _glIndexType = primitive._glIndexType, _glIndexByteCount = primitive._glIndexByteCount;
        var topology = subMesh.topology, start = subMesh.start, count = subMesh.count;
        if (!instanceCount) {
            if (indexBufferBinding) {
                if (useVao) {
                    gl.drawElements(topology, count, _glIndexType, start * _glIndexByteCount);
                } else {
                    var _glBuffer = indexBufferBinding.buffer._platformBuffer._glBuffer;
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _glBuffer);
                    gl.drawElements(topology, count, _glIndexType, start * _glIndexByteCount);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                }
            } else {
                gl.drawArrays(topology, start, count);
            }
        } else {
            if (this._canUseInstancedArrays) {
                if (indexBufferBinding) {
                    if (useVao) {
                        gl.drawElementsInstanced(topology, count, _glIndexType, start * _glIndexByteCount, instanceCount);
                    } else {
                        var _glBuffer1 = indexBufferBinding.buffer._platformBuffer._glBuffer;
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _glBuffer1);
                        gl.drawElementsInstanced(topology, count, _glIndexType, start * _glIndexByteCount, instanceCount);
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                    }
                } else {
                    gl.drawArraysInstanced(topology, start, count, instanceCount);
                }
            } else {
                Logger.error("ANGLE_instanced_arrays extension is not supported");
            }
        }
        // Unbind
        if (useVao) {
            gl.bindVertexArray(null);
        } else {
            this._disableAttrib();
        }
    };
    _proto.destroy = function destroy() {
        this._isSupportVAO && this._clearVAO();
    };
    /**
   * Bind buffer and attribute.
   */ _proto._bindBufferAndAttrib = function _bindBufferAndAttrib(shaderProgram) {
        var gl = this._gl;
        var primitive = this._primitive;
        var vertexBufferBindings = primitive.vertexBufferBindings;
        this._attribLocArray.length = 0;
        var attributeLocation = shaderProgram.attributeLocation;
        var attributes = primitive._vertexElementMap;
        var vbo;
        var lastBoundVbo;
        for(var name in attributeLocation){
            var loc = attributeLocation[name];
            if (loc === -1) continue;
            var element = attributes[name];
            if (element) {
                var _vertexBufferBindings_element_bindingIndex = vertexBufferBindings[element.bindingIndex], buffer = _vertexBufferBindings_element_bindingIndex.buffer, stride = _vertexBufferBindings_element_bindingIndex.stride;
                vbo = buffer._platformBuffer._glBuffer;
                // prevent binding the vbo which already bound at the last loop, e.g. a buffer with multiple attributes.
                if (lastBoundVbo !== vbo) {
                    lastBoundVbo = vbo;
                    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
                }
                gl.enableVertexAttribArray(loc);
                var elementInfo = element._formatMetaInfo;
                gl.vertexAttribPointer(loc, elementInfo.size, elementInfo.type, elementInfo.normalized, stride, element.offset);
                if (this._canUseInstancedArrays) {
                    gl.vertexAttribDivisor(loc, element.instanceStepRate);
                }
                this._attribLocArray.push(loc);
            } else {
                Logger.warn("vertex attribute not found: " + name);
            }
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
    };
    _proto._disableAttrib = function _disableAttrib() {
        var gl = this._gl;
        for(var i = 0, l = this._attribLocArray.length; i < l; i++){
            gl.disableVertexAttribArray(this._attribLocArray[i]);
        }
    };
    _proto._registerVAO = function _registerVAO(shaderProgram) {
        var gl = this._gl;
        var vao = gl.createVertexArray();
        /** register VAO */ gl.bindVertexArray(vao);
        var indexBufferBinding = this._primitive.indexBufferBinding;
        if (indexBufferBinding) {
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBufferBinding.buffer._platformBuffer._glBuffer);
        }
        this._bindBufferAndAttrib(shaderProgram);
        /** unbind */ gl.bindVertexArray(null);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        this._disableAttrib();
        this._vaoMap.set(shaderProgram.id, vao);
    };
    _proto._clearVAO = function _clearVAO() {
        var gl = this._gl;
        this._vaoMap.forEach(function(vao) {
            gl.deleteVertexArray(vao);
        });
        this._vaoMap.clear();
    };
    return GLPrimitive;
}();

/**
 * @private
 */ var GLRenderStates = /*#__PURE__*/ function() {
    function GLRenderStates(gl) {
        this._parameters = {};
        this._gl = gl;
        this._parameters = {}; // current gl state parameters
        /** cache */ this._parameters[gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS] = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        this._parameters[gl.MAX_VERTEX_UNIFORM_VECTORS] = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
        this._parameters[gl.MAX_VERTEX_ATTRIBS] = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
        this._parameters[gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS] = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
        this._parameters[gl.MAX_TEXTURE_SIZE] = gl.getParameter(gl.MAX_TEXTURE_SIZE);
        // init blend state same as BlendState default value.
        gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        gl.colorMask(true, true, true, true);
        gl.blendColor(0, 0, 0, 0);
        gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
        // init depth state same as DepthState default value.
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LESS);
        gl.depthMask(true);
        // init stencil state same as StencilState default value.
        gl.disable(gl.STENCIL_TEST);
        gl.stencilFuncSeparate(gl.FRONT, gl.ALWAYS, 0, 0xff);
        gl.stencilFuncSeparate(gl.BACK, gl.ALWAYS, 0, 0xff);
        gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.KEEP);
        gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.KEEP);
        gl.stencilMask(0xff);
        // init raster state same as RasterState default value.
        gl.enable(gl.CULL_FACE);
        gl.cullFace(gl.BACK);
        gl.disable(gl.POLYGON_OFFSET_FILL);
        gl.polygonOffset(0, 0);
    }
    var _proto = GLRenderStates.prototype;
    /**
   * Get a parameter.
   */ _proto.getParameter = function getParameter(pname) {
        return this._parameters[pname];
    };
    return GLRenderStates;
}();

/**
 * Texture in WebGL platform.
 */ var GLTexture = /*#__PURE__*/ function() {
    function GLTexture(rhi, texture, target) {
        this._texture = texture;
        this._rhi = rhi;
        this._gl = rhi.gl;
        this._isWebGL2 = rhi.isWebGL2;
        this._target = target;
        this._glTexture = this._gl.createTexture();
    }
    var _proto = GLTexture.prototype;
    /**
   * Destroy texture.
   */ _proto.destroy = function destroy() {
        this._gl.deleteTexture(this._glTexture);
        this._texture = null;
        this._glTexture = null;
        this._formatDetail = null;
    };
    /**
   * @internal
   */ _proto.setUseDepthCompareMode = function setUseDepthCompareMode(value) {
        var gl = this._gl;
        gl.texParameteri(this._target, gl.TEXTURE_COMPARE_MODE, value ? gl.COMPARE_REF_TO_TEXTURE : gl.NONE);
    };
    /**
   * Generate multi-level textures based on the 0th level data.
   */ _proto.generateMipmaps = function generateMipmaps() {
        var texture = this._texture;
        //@ts-ignore
        var mipmap = texture._mipmap;
        if (!TextureUtils.supportGenerateMipmaps(texture.format, mipmap, texture.isSRGBColorSpace, this._isWebGL2)) {
            Logger.warn("Auto-generating mipmaps for sRGB textures is only supported in [WebGL2 + R8G8B8A8], you must generate mipmaps manually.");
            return;
        }
        // @todo (1x1).generateMipmap() will flash back in uc.
        if (texture.width !== 1 || texture.height !== 1) {
            this._bind();
            this._gl.generateMipmap(this._target);
        }
    };
    _proto._bind = function _bind() {
        this._rhi.bindTexture(this);
    };
    /**
   * Pre-development mipmapping GPU memory.
   */ _proto._init = function _init(isCube) {
        var gl = this._gl;
        var isWebGL2 = this._isWebGL2;
        var _this__formatDetail = this._formatDetail, internalFormat = _this__formatDetail.internalFormat, baseFormat = _this__formatDetail.baseFormat, dataType = _this__formatDetail.dataType;
        // @ts-ignore
        var _this__texture = this._texture, mipmapCount = _this__texture.mipmapCount, width = _this__texture.width, height = _this__texture.height, usage = _this__texture.usage, _isDepthTexture = _this__texture._isDepthTexture;
        this._bind();
        if (isWebGL2 && !(baseFormat === gl.LUMINANCE_ALPHA || baseFormat === gl.ALPHA) && usage !== TextureUsage.Dynamic) {
            gl.texStorage2D(this._target, mipmapCount, internalFormat, width, height);
        } else {
            if (!isCube) {
                if (_isDepthTexture) {
                    gl.texImage2D(this._target, 0, internalFormat, width, height, 0, baseFormat, dataType, null);
                } else {
                    for(var i = 0; i < mipmapCount; i++){
                        var mipWidth = Math.max(1, width >> i);
                        var mipHeight = Math.max(1, height >> i);
                        gl.texImage2D(this._target, i, internalFormat, mipWidth, mipHeight, 0, baseFormat, dataType, null);
                    }
                }
            } else {
                for(var i1 = 0; i1 < mipmapCount; i1++){
                    var size = Math.max(1, width >> i1);
                    for(var faceIndex = 0; faceIndex < 6; faceIndex++){
                        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, i1, internalFormat, size, size, 0, baseFormat, dataType, null);
                    }
                }
            }
        }
    };
    /**
   * Get the pixel color buffer according to the specified cube face and area.
   * @param face - You can choose which cube face to read
   * @param x - X coordinate of area start
   * @param y - Y coordinate of area start
   * @param width - Area width
   * @param height - Area height
   * @param out - Color buffer
   * @param mipLevel - Set mip level the data want to get from
   */ _proto._getPixelBuffer = function _getPixelBuffer(face, x, y, width, height, mipLevel, out) {
        var gl = this._gl;
        var _this__formatDetail = this._formatDetail, baseFormat = _this__formatDetail.baseFormat, dataType = _this__formatDetail.dataType, readFormat = _this__formatDetail.readFormat, alignment = _this__formatDetail.alignment;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._getReadFrameBuffer());
        if (mipLevel > 0 && !this._isWebGL2) {
            mipLevel = 0;
            Logger.error("mipLevel only take effect in WebGL2.0");
        }
        if (face != null) {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, this._glTexture, mipLevel);
        } else {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._glTexture, mipLevel);
        }
        gl.pixelStorei(gl.PACK_ALIGNMENT, alignment);
        // Base format is different from read format in webgl1.0 with sRGB
        gl.readPixels(x, y, width, height, readFormat != null ? readFormat : baseFormat, dataType, out);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    };
    _proto._getReadFrameBuffer = function _getReadFrameBuffer() {
        var frameBuffer = this._rhi._readFrameBuffer;
        if (!frameBuffer) {
            this._rhi._readFrameBuffer = frameBuffer = this._gl.createFramebuffer();
        }
        return frameBuffer;
    };
    _proto._validate = function _validate(texture, rhi) {
        var format = texture.format, width = texture.width, height = texture.height;
        // Validate sRGB format
        // @ts-ignore
        var isSRGBColorSpace = texture._isSRGBColorSpace;
        if (isSRGBColorSpace && !TextureUtils.supportSRGB(format)) {
            Logger.warn("Only support sRGB color space in RGB8 or RGBA8 or some compressed texture format");
            // @ts-ignore
            texture._isSRGBColorSpace = false;
        }
        var isWebGL2 = rhi.isWebGL2;
        // Validate mipmap
        // @ts-ignore
        var mipmap = texture._mipmap;
        if (mipmap && !TextureUtils.supportMipmaps(width, height, isWebGL2)) {
            Logger.warn("Non-power-2 texture is not supported for mipmap in WebGL1, and has automatically downgraded to non-mipmap");
            /** @ts-ignore */ texture._mipmap = false;
            /** @ts-ignore */ texture._mipmapCount = texture._getMipmapCount();
        }
    };
    _proto._setWrapMode = function _setWrapMode(value, pname) {
        var gl = this._gl;
        var isWebGL2 = this._isWebGL2;
        var target = this._target;
        var _this__texture = this._texture, width = _this__texture.width, height = _this__texture.height;
        if (!isWebGL2 && value !== TextureWrapMode$1.Clamp && (!MathUtil.isPowerOf2(width) || !MathUtil.isPowerOf2(height))) {
            Logger.warn("non-power-2 texture is not supported for REPEAT or MIRRORED_REPEAT in WebGL1,and has automatically downgraded to CLAMP_TO_EDGE");
            value = TextureWrapMode$1.Clamp;
        }
        switch(value){
            case TextureWrapMode$1.Clamp:
                gl.texParameteri(target, pname, gl.CLAMP_TO_EDGE);
                break;
            case TextureWrapMode$1.Repeat:
                gl.texParameteri(target, pname, gl.REPEAT);
                break;
            case TextureWrapMode$1.Mirror:
                gl.texParameteri(target, pname, gl.MIRRORED_REPEAT);
                break;
        }
    };
    /**
   * Get more texture info from TextureFormat.
   * @internal
   */ GLTexture._getFormatDetail = function _getFormatDetail(format, isSRGBColorSpace, gl, isWebGL2) {
        switch(format){
            case TextureFormat.R8G8B8:
                return {
                    internalFormat: isSRGBColorSpace ? gl.SRGB8 : isWebGL2 ? gl.RGB8 : gl.RGB,
                    baseFormat: isSRGBColorSpace ? isWebGL2 ? gl.RGB : gl.SRGB8 : gl.RGB,
                    readFormat: gl.RGB,
                    dataType: gl.UNSIGNED_BYTE,
                    isCompressed: false,
                    alignment: 1
                };
            case TextureFormat.R8G8B8A8:
                return {
                    internalFormat: isSRGBColorSpace ? gl.SRGB8_ALPHA8 : isWebGL2 ? gl.RGBA8 : gl.RGBA,
                    baseFormat: isSRGBColorSpace ? isWebGL2 ? gl.RGBA : gl.SRGB8_ALPHA8 : gl.RGBA,
                    readFormat: gl.RGBA,
                    dataType: gl.UNSIGNED_BYTE,
                    isCompressed: false,
                    alignment: 4
                };
            case TextureFormat.R4G4B4A4:
                return {
                    internalFormat: isWebGL2 ? gl.RGBA4 : gl.RGBA,
                    baseFormat: gl.RGBA,
                    dataType: gl.UNSIGNED_SHORT_4_4_4_4,
                    isCompressed: false,
                    alignment: 2
                };
            case TextureFormat.R5G5B5A1:
                return {
                    internalFormat: isWebGL2 ? gl.RGB5_A1 : gl.RGBA,
                    baseFormat: gl.RGBA,
                    dataType: gl.UNSIGNED_SHORT_5_5_5_1,
                    isCompressed: false,
                    alignment: 2
                };
            case TextureFormat.R5G6B5:
                return {
                    internalFormat: isWebGL2 ? gl.RGB565 : gl.RGB,
                    baseFormat: gl.RGB,
                    dataType: gl.UNSIGNED_SHORT_5_6_5,
                    isCompressed: false,
                    alignment: 2
                };
            case TextureFormat.Alpha8:
                return {
                    internalFormat: gl.ALPHA,
                    baseFormat: gl.ALPHA,
                    dataType: gl.UNSIGNED_BYTE,
                    isCompressed: false,
                    alignment: 1
                };
            case TextureFormat.LuminanceAlpha:
                return {
                    internalFormat: gl.LUMINANCE_ALPHA,
                    baseFormat: gl.LUMINANCE_ALPHA,
                    dataType: gl.UNSIGNED_BYTE,
                    isCompressed: false,
                    alignment: 2
                };
            case TextureFormat.R16G16B16A16:
                return {
                    internalFormat: isWebGL2 ? gl.RGBA16F : gl.RGBA,
                    baseFormat: gl.RGBA,
                    dataType: gl.HALF_FLOAT,
                    isCompressed: false,
                    alignment: 8
                };
            case TextureFormat.R32G32B32A32:
                return {
                    internalFormat: isWebGL2 ? gl.RGBA32F : gl.RGBA,
                    baseFormat: gl.RGBA,
                    dataType: gl.FLOAT,
                    isCompressed: false,
                    alignment: 8
                };
            // Only WebGL2 support
            case TextureFormat.R11G11B10_UFloat:
                return {
                    internalFormat: gl.R11F_G11F_B10F,
                    baseFormat: gl.RGB,
                    dataType: gl.FLOAT,
                    isCompressed: false,
                    alignment: 4
                };
            // Only WebGL2 support
            case TextureFormat.R32G32B32A32_UInt:
                return {
                    internalFormat: gl.RGBA32UI,
                    baseFormat: gl.RGBA_INTEGER,
                    dataType: gl.UNSIGNED_INT,
                    isCompressed: false,
                    alignment: 8
                };
            // Only WebGL2 support
            case TextureFormat.R8:
                return {
                    internalFormat: gl.R8,
                    baseFormat: gl.RED,
                    dataType: gl.UNSIGNED_BYTE,
                    isCompressed: false,
                    alignment: 1
                };
            // Only WebGL2 support
            case TextureFormat.R8G8:
                return {
                    internalFormat: gl.RG8,
                    baseFormat: gl.RG,
                    dataType: gl.UNSIGNED_BYTE,
                    isCompressed: false,
                    alignment: 2
                };
            case TextureFormat.BC1:
                return {
                    internalFormat: isSRGBColorSpace ? GLCompressedTextureInternalFormat.SRGB_S3TC_DXT1_EXT : GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT,
                    isCompressed: true
                };
            case TextureFormat.BC3:
                return {
                    internalFormat: isSRGBColorSpace ? GLCompressedTextureInternalFormat.SRGB_ALPHA_S3TC_DXT5_EXT : GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT,
                    isCompressed: true
                };
            case TextureFormat.BC7:
                return {
                    internalFormat: isSRGBColorSpace ? GLCompressedTextureInternalFormat.SRGB_ALPHA_BPTC_UNORM_EXT : GLCompressedTextureInternalFormat.RGBA_BPTC_UNORM_EXT,
                    isCompressed: true
                };
            case TextureFormat.ETC1_RGB:
                return {
                    internalFormat: GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL,
                    isCompressed: true
                };
            case TextureFormat.ETC2_RGB:
                return {
                    internalFormat: isSRGBColorSpace ? GLCompressedTextureInternalFormat.SRGB8_ETC2 : GLCompressedTextureInternalFormat.RGB8_ETC2,
                    isCompressed: true
                };
            case TextureFormat.ETC2_RGBA5:
                return {
                    internalFormat: GLCompressedTextureInternalFormat.RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
                    isCompressed: true
                };
            case TextureFormat.ETC2_RGBA8:
                return {
                    internalFormat: isSRGBColorSpace ? GLCompressedTextureInternalFormat.SRGB8_ALPHA8_ETC2_EAC : GLCompressedTextureInternalFormat.RGBA8_ETC2_EAC,
                    isCompressed: true
                };
            case TextureFormat.PVRTC_RGB2:
                return {
                    internalFormat: GLCompressedTextureInternalFormat.RGB_PVRTC_2BPPV1_IMG,
                    isCompressed: true
                };
            case TextureFormat.PVRTC_RGBA2:
                return {
                    internalFormat: GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG,
                    isCompressed: true
                };
            case TextureFormat.PVRTC_RGB4:
                return {
                    internalFormat: GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG,
                    isCompressed: true
                };
            case TextureFormat.PVRTC_RGBA4:
                return {
                    internalFormat: GLCompressedTextureInternalFormat.RGBA_PVRTC_4BPPV1_IMG,
                    isCompressed: true
                };
            case TextureFormat.ASTC_4x4:
                return {
                    internalFormat: isSRGBColorSpace ? GLCompressedTextureInternalFormat.SRGB8_ALPHA8_ASTC_4X4_KHR : GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR,
                    isCompressed: true
                };
            case TextureFormat.ASTC_5x5:
                return {
                    internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_5X5_KHR,
                    isCompressed: true
                };
            case TextureFormat.ASTC_6x6:
                return {
                    internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_6X6_KHR,
                    isCompressed: true
                };
            case TextureFormat.ASTC_8x8:
                return {
                    internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_8X8_KHR,
                    isCompressed: true
                };
            case TextureFormat.ASTC_10x10:
                return {
                    internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_10X10_KHR,
                    isCompressed: true
                };
            case TextureFormat.ASTC_12x12:
                return {
                    internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR,
                    isCompressed: true
                };
            case TextureFormat.Depth:
                return {
                    internalFormat: isWebGL2 ? gl.DEPTH_COMPONENT32F : gl.DEPTH_COMPONENT,
                    baseFormat: gl.DEPTH_COMPONENT,
                    dataType: isWebGL2 ? gl.FLOAT : gl.UNSIGNED_SHORT,
                    isCompressed: false,
                    attachment: gl.DEPTH_ATTACHMENT
                };
            case TextureFormat.DepthStencil:
                return {
                    internalFormat: isWebGL2 ? gl.DEPTH32F_STENCIL8 : gl.DEPTH_STENCIL,
                    baseFormat: gl.DEPTH_STENCIL,
                    dataType: isWebGL2 ? gl.FLOAT_32_UNSIGNED_INT_24_8_REV : gl.UNSIGNED_INT_24_8,
                    isCompressed: false,
                    attachment: gl.DEPTH_STENCIL_ATTACHMENT
                };
            case TextureFormat.Depth16:
                return {
                    internalFormat: isWebGL2 ? gl.DEPTH_COMPONENT16 : gl.DEPTH_COMPONENT,
                    baseFormat: gl.DEPTH_COMPONENT,
                    dataType: gl.UNSIGNED_SHORT,
                    isCompressed: false,
                    attachment: gl.DEPTH_ATTACHMENT
                };
            case TextureFormat.Depth24Stencil8:
                return {
                    internalFormat: isWebGL2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,
                    baseFormat: gl.DEPTH_STENCIL,
                    dataType: gl.UNSIGNED_INT_24_8,
                    isCompressed: false,
                    attachment: gl.DEPTH_STENCIL_ATTACHMENT
                };
            // Only WebGL2 support
            case TextureFormat.Depth24:
                return {
                    internalFormat: gl.DEPTH_COMPONENT24,
                    baseFormat: gl.DEPTH_COMPONENT,
                    dataType: gl.UNSIGNED_INT,
                    isCompressed: false,
                    attachment: gl.DEPTH_ATTACHMENT
                };
            // Only WebGL2 support
            case TextureFormat.Depth32:
                return {
                    internalFormat: gl.DEPTH_COMPONENT32F,
                    baseFormat: gl.DEPTH_COMPONENT,
                    dataType: gl.FLOAT,
                    isCompressed: false,
                    attachment: gl.DEPTH_ATTACHMENT
                };
            // Only WebGL2 support
            case TextureFormat.Depth32Stencil8:
                return {
                    internalFormat: gl.DEPTH32F_STENCIL8,
                    baseFormat: gl.DEPTH_STENCIL,
                    dataType: gl.FLOAT_32_UNSIGNED_INT_24_8_REV,
                    isCompressed: false,
                    attachment: gl.DEPTH_STENCIL_ATTACHMENT
                };
            default:
                throw new Error("this TextureFormat is not supported in Galacean Engine: " + format);
        }
    };
    /**
   * In WebGL 1, internalformat must be the same as baseFormat when call texImage2D.
   * @internal
   */ GLTexture._getRenderBufferDepthFormatDetail = function _getRenderBufferDepthFormatDetail(format, gl, isWebGL2) {
        switch(format){
            case TextureFormat.Depth:
                return {
                    internalFormat: isWebGL2 ? gl.DEPTH_COMPONENT32F : gl.DEPTH_COMPONENT16,
                    baseFormat: gl.DEPTH_COMPONENT,
                    dataType: isWebGL2 ? gl.FLOAT : gl.UNSIGNED_SHORT,
                    isCompressed: false,
                    attachment: gl.DEPTH_ATTACHMENT
                };
            case TextureFormat.DepthStencil:
                return {
                    internalFormat: isWebGL2 ? gl.DEPTH32F_STENCIL8 : gl.DEPTH_STENCIL,
                    baseFormat: gl.DEPTH_STENCIL,
                    dataType: isWebGL2 ? gl.FLOAT_32_UNSIGNED_INT_24_8_REV : gl.UNSIGNED_INT_24_8,
                    isCompressed: false,
                    attachment: gl.DEPTH_STENCIL_ATTACHMENT
                };
            case TextureFormat.Stencil:
                return {
                    internalFormat: gl.STENCIL_INDEX8,
                    baseFormat: gl.STENCIL_ATTACHMENT,
                    dataType: gl.UNSIGNED_BYTE,
                    isCompressed: false,
                    attachment: gl.STENCIL_ATTACHMENT
                };
            case TextureFormat.Depth16:
                return {
                    internalFormat: gl.DEPTH_COMPONENT16,
                    baseFormat: gl.DEPTH_COMPONENT,
                    dataType: gl.UNSIGNED_SHORT,
                    isCompressed: false,
                    attachment: gl.DEPTH_ATTACHMENT
                };
            case TextureFormat.Depth24Stencil8:
                return {
                    internalFormat: isWebGL2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,
                    baseFormat: gl.DEPTH_STENCIL,
                    dataType: gl.UNSIGNED_INT_24_8,
                    isCompressed: false,
                    attachment: gl.DEPTH_STENCIL_ATTACHMENT
                };
            case TextureFormat.Depth24:
                return {
                    internalFormat: gl.DEPTH_COMPONENT24,
                    baseFormat: gl.DEPTH_COMPONENT,
                    dataType: gl.UNSIGNED_INT,
                    isCompressed: false,
                    attachment: gl.DEPTH_ATTACHMENT
                };
            case TextureFormat.Depth32:
                return {
                    internalFormat: gl.DEPTH_COMPONENT32F,
                    baseFormat: gl.DEPTH_COMPONENT,
                    dataType: gl.FLOAT,
                    isCompressed: false,
                    attachment: gl.DEPTH_ATTACHMENT
                };
            case TextureFormat.Depth32Stencil8:
                return {
                    internalFormat: gl.DEPTH32F_STENCIL8,
                    baseFormat: gl.DEPTH_STENCIL,
                    dataType: gl.FLOAT_32_UNSIGNED_INT_24_8_REV,
                    isCompressed: false,
                    attachment: gl.DEPTH_STENCIL_ATTACHMENT
                };
            default:
                throw new Error("this TextureFormat is not supported in Galacean Engine: " + format);
        }
    };
    /**
   * @internal
   */ GLTexture._supportRenderBufferColorFormat = function _supportRenderBufferColorFormat(format, rhi) {
        var isSupported = true;
        switch(format){
            case TextureFormat.R16G16B16A16:
                {
                    if (!rhi.canIUse(GLCapabilityType.colorBufferHalfFloat) || !rhi.canIUse(GLCapabilityType.textureHalfFloat)) {
                        isSupported = false;
                    }
                }
                break;
            case TextureFormat.R32G32B32A32:
                {
                    if (!rhi.canIUse(GLCapabilityType.colorBufferFloat) || !rhi.canIUse(GLCapabilityType.textureFloat)) {
                        isSupported = false;
                    }
                }
                break;
            case TextureFormat.R11G11B10_UFloat:
                {
                    isSupported = rhi.isWebGL2;
                }
                break;
        }
        return isSupported;
    };
    /**
   * @internal
   */ GLTexture._supportRenderBufferDepthFormat = function _supportRenderBufferDepthFormat(format, rhi) {
        if (!rhi.isWebGL2) {
            switch(format){
                case TextureFormat.Depth24:
                case TextureFormat.Depth32:
                case TextureFormat.Depth32Stencil8:
                    return false;
            }
        }
        return true;
    };
    _create_class$1(GLTexture, [
        {
            key: "wrapModeU",
            set: /**
   * Wrapping mode for texture coordinate S.
   */ function set(value) {
                this._bind();
                this._setWrapMode(value, this._gl.TEXTURE_WRAP_S);
            }
        },
        {
            key: "wrapModeV",
            set: /**
   * Wrapping mode for texture coordinate T.
   */ function set(value) {
                this._bind();
                this._setWrapMode(value, this._gl.TEXTURE_WRAP_T);
            }
        },
        {
            key: "filterMode",
            set: /**
   * Filter mode for texture.
   */ function set(value) {
                var gl = this._gl;
                var target = this._target;
                /** @ts-ignore */ var _mipmap = this._texture._mipmap;
                this._bind();
                switch(value){
                    case TextureFilterMode.Point:
                        gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                        gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, _mipmap ? gl.NEAREST_MIPMAP_NEAREST : gl.NEAREST);
                        break;
                    case TextureFilterMode.Bilinear:
                        gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                        gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, _mipmap ? gl.LINEAR_MIPMAP_NEAREST : gl.LINEAR);
                        break;
                    case TextureFilterMode.Trilinear:
                        gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                        gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, _mipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);
                        break;
                }
            }
        },
        {
            key: "anisoLevel",
            set: /**
   * Anisotropic level for texture.
   */ function set(value) {
                var gl = this._gl;
                this._bind();
                gl.texParameterf(this._target, gl.TEXTURE_MAX_ANISOTROPY_EXT, value);
            }
        },
        {
            key: "depthCompareFunction",
            set: function set(value) {
                this._bind();
                var gl = this._gl;
                switch(value){
                    case TextureDepthCompareFunction.Never:
                        gl.texParameteri(this._target, gl.TEXTURE_COMPARE_FUNC, gl.NEVER);
                        break;
                    case TextureDepthCompareFunction.Less:
                        gl.texParameteri(this._target, gl.TEXTURE_COMPARE_FUNC, gl.LESS);
                        break;
                    case TextureDepthCompareFunction.Equal:
                        gl.texParameteri(this._target, gl.TEXTURE_COMPARE_FUNC, gl.EQUAL);
                        break;
                    case TextureDepthCompareFunction.LessEqual:
                        gl.texParameteri(this._target, gl.TEXTURE_COMPARE_FUNC, gl.LEQUAL);
                        break;
                    case TextureDepthCompareFunction.Greater:
                        gl.texParameteri(this._target, gl.TEXTURE_COMPARE_FUNC, gl.GREATER);
                        break;
                    case TextureDepthCompareFunction.NotEqual:
                        gl.texParameteri(this._target, gl.TEXTURE_COMPARE_FUNC, gl.NOTEQUAL);
                        break;
                    case TextureDepthCompareFunction.GreaterEqual:
                        gl.texParameteri(this._target, gl.TEXTURE_COMPARE_FUNC, gl.GEQUAL);
                        break;
                    case TextureDepthCompareFunction.Always:
                        gl.texParameteri(this._target, gl.TEXTURE_COMPARE_FUNC, gl.ALWAYS);
                        break;
                }
            }
        }
    ]);
    return GLTexture;
}();

/**
 * The render target in WebGL platform is used for off-screen rendering.
 */ var GLRenderTarget = /*#__PURE__*/ function() {
    function GLRenderTarget(rhi, target) {
        this._MSAAColorRenderBuffers = [];
        this._curMipLevel = 0;
        this._curFaceIndex = undefined;
        this._gl = rhi.gl;
        this._isWebGL2 = rhi.isWebGL2;
        this._target = target;
        /** @ts-ignore */ var _colorTextures = target._colorTextures, _depth = target._depth, width = target.width, height = target.height;
        var isDepthTexture = _instanceof$2(_depth, Texture);
        /** todo
     * MRT + Cube + [,MSAA]
     * MRT + MSAA
     */ for(var i = 0, n = _colorTextures.length; i < n; i++){
            var _colorTextures_i = _colorTextures[i], format = _colorTextures_i.format, isSRGBColorSpace = _colorTextures_i.isSRGBColorSpace;
            if (!GLTexture._supportRenderBufferColorFormat(format, rhi)) {
                throw new Error("TextureFormat is not supported:" + TextureFormat[format] + " in RenderTarget");
            }
            if (isSRGBColorSpace && format === TextureFormat.R8G8B8) {
                throw new Error("If you want to use sRGB color space, only R8G8B8A8 format is supported in RenderTarget");
            }
        }
        if (!isDepthTexture && !GLTexture._supportRenderBufferDepthFormat(_depth, rhi)) {
            throw new Error("TextureFormat is not supported:" + TextureFormat[_depth] + " in RenderTarget");
        }
        if (_colorTextures.length > 1 && !rhi.canIUse(GLCapabilityType.drawBuffers)) {
            throw new Error("MRT is not supported");
        }
        if (_colorTextures.some(function(v) {
            return v.width !== width || v.height !== height;
        })) {
            throw new Error("ColorTexture's size must as same as RenderTarget");
        }
        if (isDepthTexture && (_depth.width !== width || _depth.height !== height)) {
            throw new Error("DepthTexture's size must as same as RenderTarget");
        }
        // todo: necessary to support MRT + Cube + [,MSAA] ?
        if (_colorTextures.length > 1 && _colorTextures.some(function(v) {
            return _instanceof$2(v, TextureCube);
        })) {
            throw new Error("MRT+Cube+[,MSAA] is not supported");
        }
        var maxAntiAliasing = rhi.capability.maxAntiAliasing;
        if (target.antiAliasing > maxAntiAliasing) {
            Logger.warn("MSAA antiAliasing exceeds the limit and is automatically downgraded to:" + maxAntiAliasing);
            /** @ts-ignore */ target._antiAliasing = maxAntiAliasing;
        }
        this._frameBuffer = this._gl.createFramebuffer();
        // bind main FBO
        this._bindMainFBO();
        // bind MSAA FBO
        if (target.antiAliasing > 1) {
            this._MSAAFrameBuffer = this._gl.createFramebuffer();
            this._bindMSAAFBO();
        }
    }
    var _proto = GLRenderTarget.prototype;
    /**
   * Set which face and mipLevel of the cube texture to render to.
   * @param mipLevel - Set mip level the data want to write
   * @param faceIndex - Cube texture face
   */ _proto.activeRenderTarget = function activeRenderTarget(mipLevel, faceIndex) {
        // @todo: support MRT
        var _this = this, gl = _this._gl, target = _this._target;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
        var mipChanged = mipLevel !== this._curMipLevel;
        var faceChanged = faceIndex !== this._curFaceIndex;
        var colorTexture = target.getColorTexture(0);
        if (colorTexture) {
            var isCube = _instanceof$2(colorTexture, TextureCube);
            if (mipChanged || isCube && faceChanged) {
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, isCube ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex : gl.TEXTURE_2D, // @ts-ignore
                colorTexture._platformTexture._glTexture, mipLevel);
            }
        }
        var depthTexture = target.depthTexture;
        if (depthTexture) {
            var isCube1 = _instanceof$2(depthTexture, TextureCube);
            if (mipChanged || isCube1) {
                // @ts-ignore
                var platformTexture = depthTexture._platformTexture;
                gl.framebufferTexture2D(gl.FRAMEBUFFER, platformTexture._formatDetail.attachment, isCube1 ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex : gl.TEXTURE_2D, platformTexture._glTexture, mipLevel);
            }
        } else {
            if (mipChanged) {
                // @ts-ignore
                var internalFormat = GLTexture._getRenderBufferDepthFormatDetail(target._depth, gl, this._isWebGL2).internalFormat;
                gl.bindRenderbuffer(gl.RENDERBUFFER, this._depthRenderBuffer);
                gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, target.width >> mipLevel, target.height >> mipLevel);
            }
        }
        this._curMipLevel = mipLevel;
        this._curFaceIndex = faceIndex;
        if (this._MSAAFrameBuffer) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, this._MSAAFrameBuffer);
        }
    };
    /**
   * Blit FBO.
   */ _proto.blitRenderTarget = function blitRenderTarget() {
        if (!this._MSAAFrameBuffer) return;
        var gl = this._gl;
        var mask = gl.COLOR_BUFFER_BIT | (this._target.depthTexture ? gl.DEPTH_BUFFER_BIT : 0);
        var _this__target = this._target, colorTextureCount = _this__target.colorTextureCount, width = _this__target.width, height = _this__target.height;
        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._MSAAFrameBuffer);
        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._frameBuffer);
        for(var textureIndex = 0; textureIndex < colorTextureCount; textureIndex++){
            var attachment = gl.COLOR_ATTACHMENT0 + textureIndex;
            this._blitDrawBuffers[textureIndex] = attachment;
            gl.readBuffer(attachment);
            gl.drawBuffers(this._blitDrawBuffers);
            gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, gl.NEAREST);
            this._blitDrawBuffers[textureIndex] = gl.NONE;
        }
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    };
    /**
   * Destroy render target.
   */ _proto.destroy = function destroy() {
        var gl = this._gl;
        this._frameBuffer && gl.deleteFramebuffer(this._frameBuffer);
        this._depthRenderBuffer && gl.deleteRenderbuffer(this._depthRenderBuffer);
        this._MSAAFrameBuffer && gl.deleteFramebuffer(this._MSAAFrameBuffer);
        this._MSAADepthRenderBuffer && gl.deleteRenderbuffer(this._MSAADepthRenderBuffer);
        for(var i = 0; i < this._MSAAColorRenderBuffers.length; i++){
            gl.deleteRenderbuffer(this._MSAAColorRenderBuffers[i]);
        }
        this._frameBuffer = null;
        this._depthRenderBuffer = null;
        this._MSAAFrameBuffer = null;
        this._MSAAColorRenderBuffers.length = 0;
        this._MSAADepthRenderBuffer = null;
    };
    _proto._bindMainFBO = function _bindMainFBO() {
        var gl = this._gl;
        var isWebGL2 = this._isWebGL2;
        /** @ts-ignore */ var _this__target = this._target, _depth = _this__target._depth, colorTextureCount = _this__target.colorTextureCount, width = _this__target.width, height = _this__target.height;
        var drawBuffers = new Array(colorTextureCount);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
        /** color render buffer */ for(var i = 0; i < colorTextureCount; i++){
            var colorTexture = this._target.getColorTexture(i);
            var attachment = gl.COLOR_ATTACHMENT0 + i;
            drawBuffers[i] = attachment;
            if (!_instanceof$2(colorTexture, TextureCube)) {
                gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, /** @ts-ignore */ colorTexture._platformTexture._glTexture, 0);
            }
        }
        if (colorTextureCount > 1) {
            gl.drawBuffers(drawBuffers);
        }
        this._oriDrawBuffers = drawBuffers;
        /** depth render buffer */ if (_depth !== null) {
            if (_instanceof$2(_depth, Texture) && !_instanceof$2(_depth, TextureCube)) {
                // @ts-ignore
                var platformTexture = _depth._platformTexture;
                gl.framebufferTexture2D(gl.FRAMEBUFFER, platformTexture._formatDetail.attachment, gl.TEXTURE_2D, platformTexture._glTexture, 0);
            } else if (this._target.antiAliasing <= 1) {
                var _GLTexture__getRenderBufferDepthFormatDetail = GLTexture._getRenderBufferDepthFormatDetail(_depth, gl, isWebGL2), internalFormat = _GLTexture__getRenderBufferDepthFormatDetail.internalFormat, attachment1 = _GLTexture__getRenderBufferDepthFormatDetail.attachment;
                var depthRenderBuffer = gl.createRenderbuffer();
                this._depthRenderBuffer = depthRenderBuffer;
                gl.bindRenderbuffer(gl.RENDERBUFFER, depthRenderBuffer);
                gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, width, height);
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment1, gl.RENDERBUFFER, depthRenderBuffer);
            }
        }
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    };
    _proto._bindMSAAFBO = function _bindMSAAFBO() {
        var gl = this._gl;
        var isWebGL2 = this._isWebGL2;
        var MSAADepthRenderBuffer = gl.createRenderbuffer();
        /** @ts-ignore */ var _this__target = this._target, _depth = _this__target._depth, colorTextureCount = _this__target.colorTextureCount, antiAliasing = _this__target.antiAliasing, width = _this__target.width, height = _this__target.height;
        this._blitDrawBuffers = new Array(colorTextureCount);
        this._MSAADepthRenderBuffer = MSAADepthRenderBuffer;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._MSAAFrameBuffer);
        // prepare MRT+MSAA color RBOs
        for(var i = 0; i < colorTextureCount; i++){
            var MSAAColorRenderBuffer = gl.createRenderbuffer();
            this._MSAAColorRenderBuffers[i] = MSAAColorRenderBuffer;
            this._blitDrawBuffers[i] = gl.NONE;
            gl.bindRenderbuffer(gl.RENDERBUFFER, MSAAColorRenderBuffer);
            gl.renderbufferStorageMultisample(gl.RENDERBUFFER, antiAliasing, /** @ts-ignore */ this._target.getColorTexture(i)._platformTexture._formatDetail.internalFormat, width, height);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, MSAAColorRenderBuffer);
        }
        gl.drawBuffers(this._oriDrawBuffers);
        // prepare MSAA depth RBO
        if (_depth !== null) {
            var _ref = _instanceof$2(_depth, Texture) ? /** @ts-ignore */ _depth._platformTexture._formatDetail : GLTexture._getRenderBufferDepthFormatDetail(_depth, gl, isWebGL2), internalFormat = _ref.internalFormat, attachment = _ref.attachment;
            gl.bindRenderbuffer(gl.RENDERBUFFER, MSAADepthRenderBuffer);
            gl.renderbufferStorageMultisample(gl.RENDERBUFFER, antiAliasing, internalFormat, width, height);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, MSAADepthRenderBuffer);
        }
        this._checkFrameBuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    };
    _proto._checkFrameBuffer = function _checkFrameBuffer() {
        var gl = this._gl;
        var e = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
        switch(e){
            case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                throw new Error("The attachment types are mismatched or not all framebuffer attachment points are framebuffer attachment complete");
            case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                throw new Error("There is no attachment");
            case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                throw new Error(" Height and width of the attachment are not the same.");
            case gl.FRAMEBUFFER_UNSUPPORTED:
                // #5.14.3 Event Types in https://registry.khronos.org/webgl/specs/1.0.0/
                if (!gl.isContextLost()) {
                    throw new Error("The format of the attachment is not supported or if depth and stencil attachments are not the same renderbuffer");
                }
                break;
            case gl.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE:
                throw new Error("The values of gl.RENDERBUFFER_SAMPLES are different among attached renderbuffers, or are non-zero if the attached images are a mix of renderbuffers and textures.");
        }
    };
    return GLRenderTarget;
}();

/**
 * Texture 2d in WebGL platform.
 */ var GLTexture2D = /*#__PURE__*/ function(GLTexture1) {
    _inherits$1(GLTexture2D, GLTexture1);
    function GLTexture2D(rhi, texture2D) {
        var _this;
        _this = GLTexture1.call(this, rhi, texture2D, rhi.gl.TEXTURE_2D) || this, /** Backward compatible with WebGL1.0. */ _this._compressedMipFilled = 0;
        _this._validate(texture2D, rhi);
        var format = texture2D.format, isSRGBColorSpace = texture2D.isSRGBColorSpace;
        var isWebGL2 = _this._isWebGL2;
        _this._formatDetail = GLTexture._getFormatDetail(format, isSRGBColorSpace, _this._gl, isWebGL2);
        _this._formatDetail.isCompressed && !isWebGL2 || _this._init(false);
        return _this;
    }
    var _proto = GLTexture2D.prototype;
    /**
   * {@inheritDoc IPlatformTexture2D.setPixelBuffer}
   */ _proto.setPixelBuffer = function setPixelBuffer(colorBuffer, mipLevel, x, y, width, height) {
        if (mipLevel === void 0) mipLevel = 0;
        var gl = this._gl;
        var formatDetail = this._formatDetail;
        var mipWidth = Math.max(1, this._texture.width >> mipLevel);
        var mipHeight = Math.max(1, this._texture.height >> mipLevel);
        width = width || mipWidth - x;
        height = height || mipHeight - y;
        this._bind();
        if (formatDetail.isCompressed) {
            var isWebGL2 = this._isWebGL2;
            var internalFormat = formatDetail.internalFormat;
            var mipBit = 1 << mipLevel;
            if (isWebGL2 || this._compressedMipFilled & mipBit) {
                gl.compressedTexSubImage2D(this._target, mipLevel, x, y, width, height, internalFormat, colorBuffer);
            } else {
                gl.compressedTexImage2D(this._target, mipLevel, internalFormat, width, height, 0, colorBuffer);
                this._compressedMipFilled |= mipBit;
            }
        } else {
            var baseFormat = formatDetail.baseFormat, dataType = formatDetail.dataType;
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
            gl.pixelStorei(gl.UNPACK_ALIGNMENT, formatDetail.alignment);
            gl.texSubImage2D(this._target, mipLevel, x, y, width, height, baseFormat, dataType, colorBuffer);
        }
    };
    /**
   * {@inheritDoc IPlatformTexture2D.setImageSource}
   */ _proto.setImageSource = function setImageSource(imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
        var gl = this._gl;
        var _this__formatDetail = this._formatDetail, internalFormat = _this__formatDetail.internalFormat, baseFormat = _this__formatDetail.baseFormat, dataType = _this__formatDetail.dataType;
        this._bind();
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, +flipY);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, +premultiplyAlpha);
        if (this._texture.usage === TextureUsage.Dynamic) {
            gl.texImage2D(this._target, mipLevel, internalFormat, baseFormat, dataType, imageSource);
        } else {
            gl.texSubImage2D(this._target, mipLevel, x || 0, y || 0, baseFormat, dataType, imageSource);
        }
    };
    /**
   * {@inheritDoc IPlatformTexture2D.getPixelBuffer }
   */ _proto.getPixelBuffer = function getPixelBuffer(x, y, width, height, mipLevel, out) {
        if (this._formatDetail.isCompressed) {
            throw new Error("Unable to read compressed texture");
        }
        GLTexture1.prototype._getPixelBuffer.call(this, null, x, y, width, height, mipLevel, out);
    };
    return GLTexture2D;
}(GLTexture);

/**
 * Texture 2D array in WebGL platform.
 */ var GLTexture2DArray = /*#__PURE__*/ function(GLTexture1) {
    _inherits$1(GLTexture2DArray, GLTexture1);
    function GLTexture2DArray(rhi, texture2DArray) {
        var _this;
        _this = GLTexture1.call(this, rhi, texture2DArray, rhi.gl.TEXTURE_2D_ARRAY) || this;
        _this._validate(texture2DArray, rhi);
        var format = texture2DArray.format, width = texture2DArray.width, height = texture2DArray.height, length = texture2DArray.length, mipmapCount = texture2DArray.mipmapCount, isSRGBColorSpace = texture2DArray.isSRGBColorSpace;
        _this._bind();
        _this._formatDetail = GLTexture._getFormatDetail(format, isSRGBColorSpace, _this._gl, true);
        _this._gl.texStorage3D(_this._target, mipmapCount, _this._formatDetail.internalFormat, width, height, length);
        return _this;
    }
    var _proto = GLTexture2DArray.prototype;
    /**
   * {@inheritDoc IPlatformTexture2DArray.setPixelBuffer}
   */ _proto.setPixelBuffer = function setPixelBuffer(offsetIndex, colorBuffer, mipLevel, x, y, width, height, length) {
        var _this = this, target = _this._target, gl = _this._gl;
        var formatDetail = this._formatDetail;
        var internalFormat = formatDetail.internalFormat, baseFormat = formatDetail.baseFormat, dataType = formatDetail.dataType, isCompressed = formatDetail.isCompressed;
        width = width || Math.max(1, this._texture.width >> mipLevel) - x;
        height = height || Math.max(1, this._texture.height >> mipLevel) - y;
        length = length || this._texture.length;
        this._bind();
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
        gl.pixelStorei(gl.UNPACK_ALIGNMENT, formatDetail.alignment);
        if (isCompressed) {
            gl.compressedTexSubImage3D(target, mipLevel, x, y, offsetIndex, width, height, length, internalFormat, colorBuffer);
        } else {
            gl.texSubImage3D(target, mipLevel, x, y, offsetIndex, width, height, length, baseFormat, dataType, colorBuffer);
        }
    };
    /**
   * {@inheritDoc IPlatformTexture2DArray.setImageSource}
   */ _proto.setImageSource = function setImageSource(elementIndex, imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
        var gl = this._gl;
        var _this__formatDetail = this._formatDetail, baseFormat = _this__formatDetail.baseFormat, dataType = _this__formatDetail.dataType;
        this._bind();
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, +flipY);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, +premultiplyAlpha);
        var _imageSource_width, _imageSource_height;
        gl.texSubImage3D(this._target, mipLevel, x, y, elementIndex, (_imageSource_width = imageSource.width) != null ? _imageSource_width : imageSource.codedWidth, (_imageSource_height = imageSource.height) != null ? _imageSource_height : imageSource.codedHeight, 1, baseFormat, dataType, imageSource);
    };
    /**
   * {@inheritDoc IPlatformTexture2DArray.getPixelBuffer}
   */ _proto.getPixelBuffer = function getPixelBuffer(elementIndex, x, y, width, height, mipLevel, out) {
        var _this = this, gl = _this._gl, formatDetail = _this._formatDetail;
        if (formatDetail.isCompressed) {
            throw new Error("Unable to read compressed texture");
        }
        gl.pixelStorei(gl.PACK_ALIGNMENT, formatDetail.alignment);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._getReadFrameBuffer());
        gl.framebufferTextureLayer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, this._glTexture, mipLevel, elementIndex);
        gl.readPixels(x, y, width, height, formatDetail.baseFormat, formatDetail.dataType, out);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    };
    _proto._validate = function _validate(texture, rhi) {
        var format = texture.format;
        // Validate sRGB format
        // @ts-ignore
        var isSRGBColorSpace = texture._isSRGBColorSpace;
        if (isSRGBColorSpace && !TextureUtils.supportSRGB(format)) {
            Logger.warn("Only support sRGB color space in RGB8 or RGBA8 or some compressed texture format");
            // @ts-ignore
            texture._isSRGBColorSpace = false;
        }
    };
    return GLTexture2DArray;
}(GLTexture);

/**
 * Cube texture in WebGL platform.
 */ var GLTextureCube = /*#__PURE__*/ function(GLTexture1) {
    _inherits$1(GLTextureCube, GLTexture1);
    function GLTextureCube(rhi, textureCube) {
        var _this;
        _this = GLTexture1.call(this, rhi, textureCube, rhi.gl.TEXTURE_CUBE_MAP) || this, /** Backward compatible with WebGL1.0. */ _this._compressedFaceFilled = [
            0,
            0,
            0,
            0,
            0,
            0
        ];
        _this._validate(textureCube, rhi);
        var format = textureCube.format, isSRGBColorSpace = textureCube.isSRGBColorSpace;
        var isWebGL2 = _this._isWebGL2;
        _this._formatDetail = GLTexture._getFormatDetail(format, isSRGBColorSpace, _this._gl, isWebGL2);
        _this._formatDetail.isCompressed && !isWebGL2 || _this._init(true);
        return _this;
    }
    var _proto = GLTextureCube.prototype;
    /**
   * {@inheritDoc IPlatformTextureCube.setPixelBuffer}
   */ _proto.setPixelBuffer = function setPixelBuffer(face, colorBuffer, mipLevel, x, y, width, height) {
        var gl = this._gl;
        var isWebGL2 = this._isWebGL2;
        var formatDetail = this._formatDetail;
        var internalFormat = formatDetail.internalFormat, baseFormat = formatDetail.baseFormat, dataType = formatDetail.dataType, isCompressed = formatDetail.isCompressed;
        var mipSize = Math.max(1, this._texture.width >> mipLevel);
        width = width || mipSize - x;
        height = height || mipSize - y;
        this._bind();
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
        gl.pixelStorei(gl.UNPACK_ALIGNMENT, formatDetail.alignment);
        if (isCompressed) {
            var mipBit = 1 << mipLevel;
            if (isWebGL2 || this._compressedFaceFilled[face] & mipBit) {
                gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x, y, width, height, internalFormat, colorBuffer);
            } else {
                gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, internalFormat, width, height, 0, colorBuffer);
                this._compressedFaceFilled[face] |= mipBit;
            }
        } else {
            gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x, y, width, height, baseFormat, dataType, colorBuffer);
        }
    };
    /**
   * {@inheritDoc IPlatformTextureCube.setImageSource}
   */ _proto.setImageSource = function setImageSource(face, imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
        var gl = this._gl;
        var _this__formatDetail = this._formatDetail, baseFormat = _this__formatDetail.baseFormat, dataType = _this__formatDetail.dataType;
        this._bind();
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, +flipY);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, +premultiplyAlpha);
        gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x || 0, y || 0, baseFormat, dataType, imageSource);
    };
    /**
   * {@inheritDoc IPlatformTextureCube.getPixelBuffer}
   */ _proto.getPixelBuffer = function getPixelBuffer(face, x, y, width, height, mipLevel, out) {
        if (this._formatDetail.isCompressed) {
            throw new Error("Unable to read compressed texture");
        }
        GLTexture1.prototype._getPixelBuffer.call(this, face, x, y, width, height, mipLevel, out);
    };
    return GLTextureCube;
}(GLTexture);
/**
 * WebGL graphic device, including WebGL1.0 and WebGL2.0.
 */ var WebGLGraphicDevice = /*#__PURE__*/ function() {
    function WebGLGraphicDevice(initializeOptions) {
        if (initializeOptions === void 0) initializeOptions = {};
        /** @internal */ this._readFrameBuffer = null;
        /** @internal */ this._mainFrameBuffer = null;
        /** @internal */ this._mainFrameWidth = 0;
        /** @internal */ this._mainFrameHeight = 0;
        /** @internal */ this._enableGlobalDepthBias = false;
        this._activeTextures = new Array(32);
        this._lastViewport = new Vector4(null, null, null, null);
        this._lastScissor = new Vector4(null, null, null, null);
        this._lastClearColor = new Color(null, null, null, null);
        this._scissorEnable = false;
        var options = _extends$1({
            webGLMode: 0,
            _forceFlush: false,
            _maxAllowSkinUniformVectorCount: 256,
            alpha: true,
            depth: true,
            stencil: true,
            failIfMajorPerformanceCaveat: false,
            powerPreference: "default",
            premultipliedAlpha: true,
            preserveDrawingBuffer: false,
            desynchronized: false,
            xrCompatible: false
        }, initializeOptions);
        if (SystemInfo.platform === Platform.IPhone || SystemInfo.platform === Platform.IPad) {
            var version = SystemInfo.operatingSystem.match(/(\d+).?(\d+)?.?(\d+)?/);
            if (version) {
                var majorVersion = parseInt(version[1]);
                var minorVersion = parseInt(version[2]);
                if (majorVersion === 15 && minorVersion >= 0 && minorVersion <= 4) {
                    options._forceFlush = true;
                }
            }
        }
        this._options = options;
        // Force disable stencil, antialias and depth, we configure them in internal render target
        this._webGLOptions = {
            antialias: false,
            depth: false,
            stencil: false,
            alpha: options.alpha,
            failIfMajorPerformanceCaveat: options.failIfMajorPerformanceCaveat,
            powerPreference: options.powerPreference,
            premultipliedAlpha: options.premultipliedAlpha,
            preserveDrawingBuffer: options.preserveDrawingBuffer,
            desynchronized: options.desynchronized,
            xrCompatible: options.xrCompatible
        };
        this._onWebGLContextLost = this._onWebGLContextLost.bind(this);
        this._onWebGLContextRestored = this._onWebGLContextRestored.bind(this);
    }
    var _proto = WebGLGraphicDevice.prototype;
    _proto.init = function init(canvas, onDeviceLost, onDeviceRestored) {
        var webCanvas = canvas._webCanvas;
        var webGLMode = this._options.webGLMode;
        this._onDeviceLost = onDeviceLost;
        this._onDeviceRestored = onDeviceRestored;
        webCanvas.addEventListener("webglcontextlost", this._onWebGLContextLost, false);
        webCanvas.addEventListener("webglcontextrestored", this._onWebGLContextRestored, false);
        webCanvas.addEventListener("webglcontextcreationerror", this._onContextCreationError, false);
        this._webCanvas = webCanvas;
        var webGLOptions = this._webGLOptions;
        var gl;
        if (webGLMode == 0 || webGLMode == 1) {
            gl = webCanvas.getContext("webgl2", webGLOptions);
            if (!gl && (typeof OffscreenCanvas === "undefined" || !_instanceof$2(webCanvas, OffscreenCanvas))) {
                gl = webCanvas.getContext("experimental-webgl2", webGLOptions);
            }
            this._isWebGL2 = true;
            // Prevent weird browsers to lie (such as safari!)ƒ
            if (gl && !gl.deleteQuery) {
                this._isWebGL2 = false;
            }
        }
        if (!gl) {
            if (webGLMode == 0 || webGLMode == 2) {
                gl = webCanvas.getContext("webgl", webGLOptions);
                if (!gl && (typeof OffscreenCanvas === "undefined" || !_instanceof$2(webCanvas, OffscreenCanvas))) {
                    gl = webCanvas.getContext("experimental-webgl", webGLOptions);
                }
                this._isWebGL2 = false;
            }
        }
        if (!gl) {
            throw new Error("Get GL Context FAILED.");
        }
        this._gl = gl;
        this._initGLState(gl);
    };
    _proto.createPlatformPrimitive = function createPlatformPrimitive(primitive) {
        return new GLPrimitive(this, primitive);
    };
    _proto.createPlatformTexture2D = function createPlatformTexture2D(texture2D) {
        return new GLTexture2D(this, texture2D);
    };
    _proto.createPlatformTexture2DArray = function createPlatformTexture2DArray(texture2D) {
        return new GLTexture2DArray(this, texture2D);
    };
    _proto.createPlatformTextureCube = function createPlatformTextureCube(textureCube) {
        return new GLTextureCube(this, textureCube);
    };
    _proto.createPlatformRenderTarget = function createPlatformRenderTarget(target) {
        return new GLRenderTarget(this, target);
    };
    _proto.createPlatformBuffer = function createPlatformBuffer(type, byteLength, bufferUsage, data) {
        if (bufferUsage === void 0) bufferUsage = BufferUsage.Static;
        return new GLBuffer(this, type, byteLength, bufferUsage, data);
    };
    _proto.requireExtension = function requireExtension(ext) {
        return this._extensions.requireExtension(ext);
    };
    _proto.canIUse = function canIUse(capabilityType) {
        return this.capability.canIUse(capabilityType);
    };
    _proto.canIUseCompressedTextureInternalFormat = function canIUseCompressedTextureInternalFormat(type) {
        return this.capability.canIUseCompressedTextureInternalFormat(type);
    };
    _proto.viewport = function viewport(x, y, width, height) {
        var _this = this, gl = _this._gl, lastViewport = _this._lastViewport;
        if (x !== lastViewport.x || y !== lastViewport.y || width !== lastViewport.z || height !== lastViewport.w) {
            gl.viewport(x, y, width, height);
            lastViewport.set(x, y, width, height);
        }
    };
    _proto.scissor = function scissor(x, y, width, height) {
        var _this = this, gl = _this._gl, lastScissor = _this._lastScissor;
        if (x !== lastScissor.x || y !== lastScissor.y || width !== lastScissor.z || height !== lastScissor.w) {
            var _this1 = this, webCanvas = _this1._webCanvas;
            if (x === 0 && y === 0 && width === webCanvas.width && height === webCanvas.height) {
                if (this._scissorEnable) {
                    gl.disable(gl.SCISSOR_TEST);
                    this._scissorEnable = false;
                }
            } else {
                if (!this._scissorEnable) {
                    gl.enable(gl.SCISSOR_TEST);
                    this._scissorEnable = true;
                }
                gl.scissor(x, y, width, height);
            }
            lastScissor.set(x, y, width, height);
        }
    };
    _proto.colorMask = function colorMask(r, g, b, a) {
        this._gl.colorMask(r, g, b, a);
    };
    _proto.clearRenderTarget = function clearRenderTarget(engine, clearFlags, clearColor) {
        var gl = this._gl;
        var _engine__lastRenderState = engine._lastRenderState, targetBlendState = _engine__lastRenderState.blendState.targetBlendState, depthState = _engine__lastRenderState.depthState, stencilState = _engine__lastRenderState.stencilState;
        var clearFlag = 0;
        if (clearFlags & CameraClearFlags.Color && clearColor) {
            clearFlag |= gl.COLOR_BUFFER_BIT;
            var lc = this._lastClearColor;
            var r = clearColor.r, g = clearColor.g, b = clearColor.b, a = clearColor.a;
            if (clearColor && (r !== lc.r || g !== lc.g || b !== lc.b || a !== lc.a)) {
                gl.clearColor(r, g, b, a);
                lc.set(r, g, b, a);
            }
            if (targetBlendState.colorWriteMask !== ColorWriteMask.All) {
                gl.colorMask(true, true, true, true);
                targetBlendState.colorWriteMask = ColorWriteMask.All;
            }
        }
        if (clearFlags & CameraClearFlags.Depth) {
            clearFlag |= gl.DEPTH_BUFFER_BIT;
            if (depthState.writeEnabled !== true) {
                gl.depthMask(true);
                depthState.writeEnabled = true;
            }
        }
        if (clearFlags & CameraClearFlags.Stencil) {
            clearFlag |= gl.STENCIL_BUFFER_BIT;
            if (stencilState.writeMask !== 0xff) {
                gl.stencilMask(0xff);
                stencilState.writeMask = 0xff;
            }
        }
        gl.clear(clearFlag);
    };
    _proto.drawPrimitive = function drawPrimitive(primitive, subPrimitive, shaderProgram) {
        // todo: VAO not support morph animation
        if (primitive) {
            primitive.draw(shaderProgram, subPrimitive);
        } else {
            Logger.error("draw primitive failed.");
        }
    };
    _proto.getMainFrameBufferWidth = function getMainFrameBufferWidth() {
        return this._mainFrameWidth || this._gl.drawingBufferWidth;
    };
    _proto.getMainFrameBufferHeight = function getMainFrameBufferHeight() {
        return this._mainFrameHeight || this._gl.drawingBufferHeight;
    };
    _proto.activeRenderTarget = function activeRenderTarget(renderTarget, viewport, isFlipProjection, mipLevel, faceIndex) {
        var bufferWidth, bufferHeight;
        if (renderTarget) {
            /** @ts-ignore */ renderTarget._isContentLost = false;
            /** @ts-ignore */ var platformRenderTarget = renderTarget._platformRenderTarget;
            platformRenderTarget.activeRenderTarget(mipLevel, faceIndex);
            bufferWidth = renderTarget.width >> mipLevel;
            bufferHeight = renderTarget.height >> mipLevel;
        } else {
            var gl = this._gl;
            gl.bindFramebuffer(gl.FRAMEBUFFER, this._mainFrameBuffer);
            bufferWidth = this.getMainFrameBufferWidth();
            bufferHeight = this.getMainFrameBufferHeight();
        }
        var width = bufferWidth * viewport.z;
        var height = bufferHeight * viewport.w;
        var x = viewport.x * bufferWidth;
        var y = isFlipProjection ? viewport.y * bufferHeight : bufferHeight - viewport.y * bufferHeight - height;
        this.viewport(x, y, width, height);
        this.scissor(x, y, width, height);
    };
    _proto.blitInternalRTByBlitFrameBuffer = function blitInternalRTByBlitFrameBuffer(srcRT, destRT, clearFlags, viewport) {
        if (!this._isWebGL2) {
            Logger.warn("WebGL1.0 not support blit frame buffer.");
            return;
        }
        var gl = this._gl;
        // @ts-ignore
        var srcFrameBuffer = srcRT ? srcRT._platformRenderTarget._frameBuffer : null;
        // @ts-ignore
        var destFrameBuffer = destRT ? destRT._platformRenderTarget._frameBuffer : null;
        var bufferWidth = this.getMainFrameBufferWidth();
        var bufferHeight = this.getMainFrameBufferHeight();
        var srcWidth = srcRT ? srcRT.width : bufferWidth;
        var srcHeight = srcRT ? srcRT.height : bufferHeight;
        var blitWidth = destRT.width;
        var blitHeight = destRT.height;
        var needFlipY = !srcRT;
        var needBlitColor = (clearFlags & CameraClearFlags.Color) === 0;
        var needBlitDepth = (clearFlags & CameraClearFlags.Depth) === 0;
        var needBlitStencil = (clearFlags & CameraClearFlags.Stencil) === 0;
        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, srcFrameBuffer);
        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, destFrameBuffer);
        var blitMask = needBlitColor ? gl.COLOR_BUFFER_BIT : 0;
        if (needBlitDepth || needBlitStencil) {
            // @ts-ignore
            var depthFormat = destRT._depthFormat;
            if (needBlitDepth) {
                if (depthFormat === TextureFormat.Depth || depthFormat >= TextureFormat.DepthStencil && depthFormat <= TextureFormat.Depth32Stencil8) {
                    blitMask |= gl.DEPTH_BUFFER_BIT;
                } else {
                    Logger.warn("Do not clear depth, or set depth format of target which is " + TextureFormat[depthFormat] + " now.");
                }
            }
            if (needBlitStencil) {
                if (depthFormat === TextureFormat.Stencil || depthFormat === TextureFormat.DepthStencil || depthFormat >= TextureFormat.Depth24Stencil8 || depthFormat >= TextureFormat.Depth32Stencil8) {
                    blitMask |= gl.STENCIL_BUFFER_BIT;
                } else {
                    Logger.warn("Do not clear stencil, or set stencil format of target which is " + TextureFormat[depthFormat] + " now.");
                }
            }
        }
        var xStart = viewport.x * srcWidth;
        var xEnd = xStart + blitWidth;
        var yStart = needFlipY ? srcHeight - viewport.y * srcHeight : srcHeight - viewport.y * srcHeight - blitHeight;
        var yEnd = needFlipY ? yStart - blitHeight : yStart + blitHeight;
        gl.blitFramebuffer(xStart, yStart, xEnd, yEnd, 0, 0, blitWidth, blitHeight, blitMask, gl.NEAREST);
    };
    _proto.copyRenderTargetToSubTexture = function copyRenderTargetToSubTexture(srcRT, grabTexture, viewport) {
        var gl = this._gl;
        var bufferWidth = this.getMainFrameBufferWidth();
        var bufferHeight = this.getMainFrameBufferHeight();
        var srcWidth = srcRT ? srcRT.width : bufferWidth;
        var srcHeight = srcRT ? srcRT.height : bufferHeight;
        var copyWidth = grabTexture.width;
        var copyHeight = grabTexture.height;
        var flipY = !srcRT;
        var xStart = viewport.x * srcWidth;
        var yStart = flipY ? srcHeight - viewport.y * srcHeight - copyHeight : viewport.y * srcHeight;
        var _srcRT__platformRenderTarget__frameBuffer;
        // @ts-ignore
        var frameBuffer = (_srcRT__platformRenderTarget__frameBuffer = srcRT == null ? void 0 : srcRT._platformRenderTarget._frameBuffer) != null ? _srcRT__platformRenderTarget__frameBuffer : null;
        // @ts-ignore
        gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
        // @ts-ignore
        var glTexture = grabTexture._platformTexture;
        glTexture._bind();
        gl.copyTexSubImage2D(glTexture._target, 0, 0, 0, xStart, yStart, copyWidth, copyHeight);
    };
    _proto.activeTexture = function activeTexture(textureID) {
        if (this._activeTextureID !== textureID) {
            this._gl.activeTexture(textureID);
            this._activeTextureID = textureID;
        }
    };
    _proto.bindTexture = function bindTexture(texture) {
        var index = this._activeTextureID - this._gl.TEXTURE0;
        if (this._activeTextures[index] !== texture) {
            this._gl.bindTexture(texture._target, texture._glTexture);
            this._activeTextures[index] = texture;
        }
    };
    _proto.setGlobalDepthBias = function setGlobalDepthBias(bias, slopeBias) {
        var gl = this._gl;
        var enable = bias !== 0 || slopeBias !== 0;
        if (enable) {
            gl.enable(gl.POLYGON_OFFSET_FILL);
            gl.polygonOffset(slopeBias, bias);
        } else {
            gl.disable(gl.POLYGON_OFFSET_FILL);
        }
        this._enableGlobalDepthBias = enable;
    };
    _proto.flush = function flush() {
        this._gl.flush();
    };
    _proto.forceLoseDevice = function forceLoseDevice() {
        var extension = this.requireExtension(GLCapabilityType.WEBGL_lose_context);
        extension.loseContext();
    };
    _proto.forceRestoreDevice = function forceRestoreDevice() {
        var extension = this.requireExtension(GLCapabilityType.WEBGL_lose_context);
        extension.restoreContext();
    };
    _proto.resetState = function resetState() {
        this._readFrameBuffer = null;
        this._enableGlobalDepthBias = false;
        this._currentBindShaderProgram = null;
        var activeTextures = this._activeTextures;
        for(var i = 0, n = activeTextures.length; i < n; i++){
            activeTextures[i] = null;
        }
        this._lastViewport.set(null, null, null, null);
        this._lastScissor.set(null, null, null, null);
        this._lastClearColor.set(null, null, null, null);
        this._scissorEnable = false;
        this._initGLState(this._gl);
    };
    _proto._initGLState = function _initGLState(gl) {
        this._activeTextureID = gl.TEXTURE0;
        this._renderStates = new GLRenderStates(gl);
        this._extensions = new GLExtensions(this);
        this._capability = new GLCapability(this);
        // Make sure the active texture in gl context is on default, because gl context may be used in other webgl renderer.
        gl.activeTexture(gl.TEXTURE0);
        var debugRenderInfo = gl.getExtension("WEBGL_debug_renderer_info");
        if (debugRenderInfo != null) {
            this._renderer = gl.getParameter(debugRenderInfo.UNMASKED_RENDERER_WEBGL);
        }
    };
    _proto.destroy = function destroy() {
        var webCanvas = this._webCanvas;
        webCanvas.removeEventListener("webglcontextcreationerror", this._onContextCreationError, false);
        webCanvas.removeEventListener("webglcontextlost", this._onWebGLContextLost, false);
        webCanvas.removeEventListener("webglcontextrestored", this._onWebGLContextRestored, false);
    };
    _proto._onContextCreationError = function _onContextCreationError(event) {
        console.error("WebGLRenderer: WebGL context could not be created. Reason: ", event.statusMessage);
    };
    _proto._onWebGLContextLost = function _onWebGLContextLost(event) {
        event.preventDefault();
        this._onDeviceLost();
    };
    _proto._onWebGLContextRestored = function _onWebGLContextRestored(event) {
        this._onDeviceRestored();
    };
    _create_class$1(WebGLGraphicDevice, [
        {
            key: "isWebGL2",
            get: function get() {
                return this._isWebGL2;
            }
        },
        {
            key: "renderer",
            get: function get() {
                return this._renderer;
            }
        },
        {
            key: "gl",
            get: /**
   * GL Context
   * @member {WebGLRenderingContext}
   */ function get() {
                return this._gl;
            }
        },
        {
            key: "renderStates",
            get: function get() {
                return this._renderStates;
            }
        },
        {
            key: "capability",
            get: function get() {
                return this._capability;
            }
        },
        {
            key: "canIUseMoreJoints",
            get: function get() {
                return this.capability.canIUseMoreJoints;
            }
        }
    ]);
    return WebGLGraphicDevice;
}();

function _extends() {
    _extends = Object.assign || function assign(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }

        return target;
    };

    return _extends.apply(this, arguments);
}

function _set_prototype_of(o, p) {
    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;

        return o;
    };

    return _set_prototype_of(o, p);
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });

    if (superClass) _set_prototype_of(subClass, superClass);
}

function _type_of(obj) {
    "@swc/helpers - typeof";

    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
  function verb(n) { return function (v) { return step([n, v]); }; }
  function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
              case 0: case 1: t = op; break;
              case 4: _.label++; return { value: op[1], done: false };
              case 5: _.label++; y = op[1]; op = [0]; continue;
              case 7: op = _.ops.pop(); _.trys.pop(); continue;
              default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                  if (t[2]) _.ops.pop();
                  _.trys.pop(); continue;
          }
          op = body.call(thisArg, _);
      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
  }
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;

        if ("value" in descriptor) descriptor.writable = true;

        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);

    return Constructor;
}

var BufferReader = /*#__PURE__*/ function() {
    function BufferReader(data, byteOffset, byteLength, littleEndian) {
        if (byteOffset === void 0) byteOffset = 0;
        if (littleEndian === void 0) littleEndian = true;
        this.data = data;
        this._dataView = new DataView(data.buffer, data.byteOffset + byteOffset, byteLength != null ? byteLength : data.byteLength - byteOffset);
        this._littleEndian = littleEndian;
        this._position = 0;
        this._baseOffset = byteOffset;
    }
    var _proto = BufferReader.prototype;
    _proto.nextUint8 = function nextUint8() {
        var value = this._dataView.getUint8(this._position);
        this._position += 1;
        return value;
    };
    _proto.nextUint16 = function nextUint16() {
        var value = this._dataView.getUint16(this._position, this._littleEndian);
        this._position += 2;
        return value;
    };
    _proto.nextUint32 = function nextUint32() {
        var value = this._dataView.getUint32(this._position, this._littleEndian);
        this._position += 4;
        return value;
    };
    _proto.nextInt32 = function nextInt32() {
        var value = this._dataView.getInt32(this._position, this._littleEndian);
        this._position += 4;
        return value;
    };
    _proto.nextInt32Array = function nextInt32Array(len) {
        var value = new Int32Array(this.data.buffer, this._position + this._dataView.byteOffset, len);
        this._position += 4 * len;
        return value;
    };
    _proto.nextFloat32 = function nextFloat32() {
        var value = this._dataView.getFloat32(this._position, this._littleEndian);
        this._position += 4;
        return value;
    };
    _proto.nextFloat32Array = function nextFloat32Array(len) {
        var value = new Float32Array(this.data.buffer, this._position + this._dataView.byteOffset, len);
        this._position += 4 * len;
        return value;
    };
    _proto.nextUint32Array = function nextUint32Array(len) {
        var value = new Uint32Array(this.data.buffer, this._position + this._dataView.byteOffset, len);
        this._position += 4 * len;
        return value;
    };
    _proto.nextUint8Array = function nextUint8Array(len) {
        var value = new Uint8Array(this.data.buffer, this._position + this._dataView.byteOffset, len);
        this._position += len;
        return value;
    };
    _proto.nextUint64 = function nextUint64() {
        var left = this._dataView.getUint32(this._position, this._littleEndian);
        var right = this._dataView.getUint32(this._position + 4, this._littleEndian);
        var value = left + Math.pow(2, 32) * right;
        this._position += 8;
        return value;
    };
    _proto.nextStr = function nextStr() {
        var strByteLength = this.nextUint16();
        var uint8Array = new Uint8Array(this.data.buffer, this._position + this._dataView.byteOffset, strByteLength);
        this._position += strByteLength;
        return Utils.decodeText(uint8Array);
    };
    /**
   * image data 放在最后
   */ _proto.nextImageData = function nextImageData(count) {
        return new Uint8Array(this.data.buffer, this.data.byteOffset + this._position);
    };
    _proto.nextImagesData = function nextImagesData(count) {
        var imagesLen = new Array(count);
        // Start offset of Uint32Array should be a multiple of 4. ref: https://stackoverflow.com/questions/15417310/why-typed-array-constructors-require-offset-to-be-multiple-of-underlying-type-si
        for(var i = 0; i < count; i++){
            var len = this._dataView.getUint32(this._position, this._littleEndian);
            imagesLen[i] = len;
            this._position += 4;
        }
        var imagesData = [];
        for(var i1 = 0; i1 < count; i1++){
            var len1 = imagesLen[i1];
            var buffer = new Uint8Array(this.data.buffer, this._dataView.byteOffset + this._position, len1);
            this._position += len1;
            imagesData.push(buffer);
        }
        return imagesData;
    };
    _proto.skip = function skip(bytes) {
        this._position += bytes;
        return this;
    };
    _proto.scan = function scan(maxByteLength, term) {
        if (term === void 0) term = 0x00;
        var byteOffset = this._position;
        var byteLength = 0;
        while(this._dataView.getUint8(this._position) !== term && byteLength < maxByteLength){
            byteLength++;
            this._position++;
        }
        if (byteLength < maxByteLength) this._position++;
        return new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + byteOffset, byteLength);
    };
    _create_class(BufferReader, [
        {
            key: "position",
            get: function get() {
                return this._position;
            }
        },
        {
            key: "offset",
            get: function get() {
                return this._position + this._baseOffset;
            }
        }
    ]);
    return BufferReader;
}();

var decoderMap = {};
/**
 * Decoder decorator generator.
 * @param type - resource file type.
 * @returns Decoder decorator
 */ function decoder(type) {
    return function(target) {
        decoderMap[type] = target;
    };
}

var FileHeader = /*#__PURE__*/ function() {
    function FileHeader() {
        this.totalLength = 0;
        this.version = 0;
        this.type = "";
        this.name = "";
        this.headerLength = 0;
    }
    FileHeader.decode = function decode(arrayBuffer) {
        var dataView = new DataView(arrayBuffer);
        var totalLen = dataView.getUint32(0, true);
        var fileVersion = dataView.getUint8(4);
        var typeLen = dataView.getUint16(5, true);
        var typeUint8Array = new Uint8Array(arrayBuffer, 7, typeLen);
        var nameLen = dataView.getUint16(7 + typeLen, true);
        var nameUint8Array = new Uint8Array(arrayBuffer, 9 + typeLen, nameLen);
        var name = Utils.decodeText(nameUint8Array);
        var type = Utils.decodeText(typeUint8Array);
        var header = new FileHeader();
        header.totalLength = totalLen;
        header.name = name;
        header.type = type;
        header.version = fileVersion;
        header.headerLength = nameUint8Array.byteLength + typeUint8Array.byteLength + 9;
        return header;
    };
    _create_class(FileHeader, [
        {
            key: "dataLength",
            get: function get() {
                return this.totalLength - this.headerLength;
            }
        }
    ]);
    return FileHeader;
}();
var AnimationClipDecoder = /*#__PURE__*/ function() {
    function AnimationClipDecoder() {}
    AnimationClipDecoder.decode = function decode(engine, bufferReader) {
        return new AssetPromise(function(resolve) {
            var name = bufferReader.nextStr();
            var clip = new AnimationClip(name);
            var eventsLen = bufferReader.nextUint16();
            for(var i = 0; i < eventsLen; ++i){
                var event = new AnimationEvent();
                event.time = bufferReader.nextFloat32();
                event.functionName = bufferReader.nextStr();
                event.parameter = JSON.parse(bufferReader.nextStr()).val;
                clip.addEvent(event);
            }
            var curveBindingsLen = bufferReader.nextUint16();
            for(var i1 = 0; i1 < curveBindingsLen; ++i1){
                var relativePath = bufferReader.nextStr();
                var componentStr = bufferReader.nextStr();
                var componentType = Loader.getClass(componentStr);
                var property = bufferReader.nextStr();
                var getProperty = bufferReader.nextStr();
                var curve = void 0;
                var interpolation = bufferReader.nextUint8();
                var keysLen = bufferReader.nextUint16();
                var curveType = bufferReader.nextStr();
                switch(curveType){
                    case "AnimationFloatCurve":
                        {
                            curve = new AnimationFloatCurve();
                            curve.interpolation = interpolation;
                            for(var j = 0; j < keysLen; ++j){
                                var keyframe = new Keyframe();
                                keyframe.time = bufferReader.nextFloat32();
                                keyframe.value = bufferReader.nextFloat32();
                                keyframe.inTangent = bufferReader.nextFloat32();
                                keyframe.outTangent = bufferReader.nextFloat32();
                                curve.addKey(keyframe);
                            }
                            break;
                        }
                    case "AnimationArrayCurve":
                        {
                            curve = new AnimationArrayCurve();
                            curve.interpolation = interpolation;
                            for(var j1 = 0; j1 < keysLen; ++j1){
                                var keyframe1 = new Keyframe();
                                keyframe1.time = bufferReader.nextFloat32();
                                var len = bufferReader.nextUint16();
                                keyframe1.value = Array.from(bufferReader.nextFloat32Array(len));
                                keyframe1.inTangent = Array.from(bufferReader.nextFloat32Array(len));
                                keyframe1.outTangent = Array.from(bufferReader.nextFloat32Array(len));
                                curve.addKey(keyframe1);
                            }
                            break;
                        }
                    case "AnimationFloatArrayCurve":
                        {
                            curve = new AnimationFloatArrayCurve();
                            curve.interpolation = interpolation;
                            for(var j2 = 0; j2 < keysLen; ++j2){
                                var keyframe2 = new Keyframe();
                                keyframe2.time = bufferReader.nextFloat32();
                                var len1 = bufferReader.nextUint16();
                                keyframe2.value = bufferReader.nextFloat32Array(len1);
                                keyframe2.inTangent = Array.from(bufferReader.nextFloat32Array(len1));
                                keyframe2.outTangent = Array.from(bufferReader.nextFloat32Array(len1));
                                curve.addKey(keyframe2);
                            }
                            break;
                        }
                    case "AnimationVector2Curve":
                        {
                            curve = new AnimationVector2Curve();
                            curve.interpolation = interpolation;
                            for(var j3 = 0; j3 < keysLen; ++j3){
                                var keyframe3 = new Keyframe();
                                keyframe3.time = bufferReader.nextFloat32();
                                keyframe3.value = new Vector2(bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                keyframe3.inTangent = new Vector2(bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                keyframe3.outTangent = new Vector2(bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                curve.addKey(keyframe3);
                            }
                            break;
                        }
                    case "AnimationVector3Curve":
                        {
                            curve = new AnimationVector3Curve();
                            curve.interpolation = interpolation;
                            for(var j4 = 0; j4 < keysLen; ++j4){
                                var keyframe4 = new Keyframe();
                                keyframe4.time = bufferReader.nextFloat32();
                                keyframe4.value = new Vector3(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                keyframe4.inTangent = new Vector3(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                keyframe4.outTangent = new Vector3(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                curve.addKey(keyframe4);
                            }
                            break;
                        }
                    case "AnimationVector4Curve":
                        {
                            curve = new AnimationVector4Curve();
                            curve.interpolation = interpolation;
                            var keyframe5 = new Keyframe();
                            keyframe5.time = bufferReader.nextFloat32();
                            keyframe5.value = new Vector4(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                            keyframe5.inTangent = new Vector4(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                            keyframe5.outTangent = new Vector4(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                            curve.addKey(keyframe5);
                            break;
                        }
                    case "AnimationColorCurve":
                        {
                            curve = new AnimationColorCurve();
                            curve.interpolation = interpolation;
                            for(var j5 = 0; j5 < keysLen; ++j5){
                                var keyframe6 = new Keyframe();
                                keyframe6.time = bufferReader.nextFloat32();
                                keyframe6.value = new Color(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                keyframe6.inTangent = new Vector4(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                keyframe6.outTangent = new Vector4(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                curve.addKey(keyframe6);
                            }
                            break;
                        }
                    case "AnimationQuaternionCurve":
                        {
                            curve = new AnimationQuaternionCurve();
                            curve.interpolation = interpolation;
                            for(var j6 = 0; j6 < keysLen; ++j6){
                                var keyframe7 = new Keyframe();
                                keyframe7.time = bufferReader.nextFloat32();
                                keyframe7.value = new Quaternion(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                keyframe7.inTangent = new Vector4(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                keyframe7.outTangent = new Vector4(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                curve.addKey(keyframe7);
                            }
                            break;
                        }
                    case "AnimationRefCurve":
                        {
                            curve = new AnimationRefCurve();
                            curve.interpolation = interpolation;
                            for(var j7 = 0; j7 < keysLen; ++j7){
                                var keyframe8 = new Keyframe();
                                keyframe8.time = bufferReader.nextFloat32();
                                var str = bufferReader.nextStr();
                                if (str) {
                                    keyframe8.value = JSON.parse(str);
                                } else {
                                    keyframe8.value = null;
                                }
                                curve.addKey(keyframe8);
                            }
                            break;
                        }
                    case "AnimationBoolCurve":
                        {
                            curve = new AnimationBoolCurve();
                            curve.interpolation = interpolation;
                            for(var j8 = 0; j8 < keysLen; ++j8){
                                var keyframe9 = new Keyframe();
                                keyframe9.time = bufferReader.nextFloat32();
                                keyframe9.value = bufferReader.nextUint8() === 1;
                                curve.addKey(keyframe9);
                            }
                            break;
                        }
                    case "AnimationStringCurve":
                        {
                            curve = new AnimationStringCurve();
                            curve.interpolation = interpolation;
                            for(var j9 = 0; j9 < keysLen; ++j9){
                                var keyframe10 = new Keyframe();
                                keyframe10.time = bufferReader.nextFloat32();
                                keyframe10.value = bufferReader.nextStr();
                                curve.addKey(keyframe10);
                            }
                            break;
                        }
                }
                clip.addCurveBinding(relativePath, componentType, property, getProperty, curve);
            }
            resolve(clip);
        });
    };
    return AnimationClipDecoder;
}();
AnimationClipDecoder = __decorate([
    decoder("AnimationClip")
], AnimationClipDecoder);

var MeshDecoder = /*#__PURE__*/ function() {
    function MeshDecoder() {}
    MeshDecoder.decode = function decode(engine, bufferReader, restoredMesh) {
        return new AssetPromise(function(resolve) {
            var modelMesh = restoredMesh || new ModelMesh(engine);
            var jsonDataString = bufferReader.nextStr();
            var encodedMeshData = JSON.parse(jsonDataString);
            // @ts-ignore Vector3 is not compatible with {x: number, y: number, z: number}.
            encodedMeshData.bounds && modelMesh.bounds.copyFrom(encodedMeshData.bounds);
            var offset = Math.ceil(bufferReader.offset / 4) * 4 + bufferReader.data.byteOffset;
            var buffer = bufferReader.data.buffer;
            var float32Array = new Float32Array(buffer, encodedMeshData.positions.start + offset, (encodedMeshData.positions.end - encodedMeshData.positions.start) / 4);
            var vertexCount = float32Array.length / 3;
            var positions = float32ArrayToVector3(float32Array, vertexCount);
            modelMesh.setPositions(positions);
            if (encodedMeshData.normals) {
                var float32Array1 = new Float32Array(buffer, encodedMeshData.normals.start + offset, (encodedMeshData.normals.end - encodedMeshData.normals.start) / 4);
                var normals = float32ArrayToVector3(float32Array1, vertexCount);
                modelMesh.setNormals(normals);
            }
            if (encodedMeshData.uvs) {
                var float32Array2 = new Float32Array(buffer, encodedMeshData.uvs.start + offset, (encodedMeshData.uvs.end - encodedMeshData.uvs.start) / 4);
                modelMesh.setUVs(float32ArrayToVector2(float32Array2, vertexCount));
            }
            if (encodedMeshData.uv1) {
                var float32Array3 = new Float32Array(buffer, encodedMeshData.uv1.start + offset, (encodedMeshData.uv1.end - encodedMeshData.uv1.start) / 4);
                modelMesh.setUVs(float32ArrayToVector2(float32Array3, vertexCount), 1);
            }
            if (encodedMeshData.uv2) {
                var float32Array4 = new Float32Array(buffer, encodedMeshData.uv2.start + offset, (encodedMeshData.uv2.end - encodedMeshData.uv2.start) / 4);
                modelMesh.setUVs(float32ArrayToVector2(float32Array4, vertexCount), 2);
            }
            if (encodedMeshData.uv3) {
                var float32Array5 = new Float32Array(buffer, encodedMeshData.uv3.start + offset, (encodedMeshData.uv3.end - encodedMeshData.uv3.start) / 4);
                modelMesh.setUVs(float32ArrayToVector2(float32Array5, vertexCount), 3);
            }
            if (encodedMeshData.uv4) {
                var float32Array6 = new Float32Array(buffer, encodedMeshData.uv4.start + offset, (encodedMeshData.uv4.end - encodedMeshData.uv4.start) / 4);
                modelMesh.setUVs(float32ArrayToVector2(float32Array6, vertexCount), 4);
            }
            if (encodedMeshData.uv5) {
                var float32Array7 = new Float32Array(buffer, encodedMeshData.uv5.start + offset, (encodedMeshData.uv5.end - encodedMeshData.uv5.start) / 4);
                modelMesh.setUVs(float32ArrayToVector2(float32Array7, vertexCount), 5);
            }
            if (encodedMeshData.uv6) {
                var float32Array8 = new Float32Array(buffer, encodedMeshData.uv6.start + offset, (encodedMeshData.uv6.end - encodedMeshData.uv6.start) / 4);
                modelMesh.setUVs(float32ArrayToVector2(float32Array8, vertexCount), 6);
            }
            if (encodedMeshData.uv7) {
                var float32Array9 = new Float32Array(buffer, encodedMeshData.uv7.start + offset, (encodedMeshData.uv7.end - encodedMeshData.uv7.start) / 4);
                modelMesh.setUVs(float32ArrayToVector2(float32Array9, vertexCount), 7);
            }
            if (encodedMeshData.colors) {
                var float32Array10 = new Float32Array(buffer, encodedMeshData.colors.start + offset, (encodedMeshData.colors.end - encodedMeshData.colors.start) / 4);
                modelMesh.setColors(float32ArrayToVColor(float32Array10, vertexCount));
            }
            if (encodedMeshData.boneWeights) {
                var float32Array11 = new Float32Array(buffer, encodedMeshData.boneWeights.start + offset, (encodedMeshData.boneWeights.end - encodedMeshData.boneWeights.start) / 4);
                modelMesh.setBoneWeights(float32ArrayToVector4(float32Array11, vertexCount));
            }
            if (encodedMeshData.boneIndices) {
                var float32Array12 = new Float32Array(buffer, encodedMeshData.boneIndices.start + offset, (encodedMeshData.boneIndices.end - encodedMeshData.boneIndices.start) / 4);
                modelMesh.setBoneIndices(float32ArrayToVector4(float32Array12, vertexCount));
            }
            if (encodedMeshData.blendShapes) {
                encodedMeshData.blendShapes.forEach(function(blendShapeData) {
                    var blendShape = new BlendShape(blendShapeData.name);
                    blendShapeData.frames.forEach(function(frameData) {
                        var positionArray = new Float32Array(buffer, frameData.deltaPosition.start + offset, (frameData.deltaPosition.end - frameData.deltaPosition.start) / 4);
                        var count = positionArray.length / 3;
                        var deltaPosition = float32ArrayToVector3(positionArray, count);
                        if (frameData.deltaNormals) {
                            var normalsArray = new Float32Array(buffer, frameData.deltaNormals.start + offset, (frameData.deltaNormals.end - frameData.deltaNormals.start) / 4);
                            float32ArrayToVector3(normalsArray, count);
                        }
                        if (frameData.deltaTangents) {
                            var tangentsArray = new Float32Array(buffer, frameData.deltaTangents.start + offset, (frameData.deltaTangents.end - frameData.deltaTangents.start) / 4);
                            float32ArrayToVector4(tangentsArray, count);
                        }
                        blendShape.addFrame(frameData.weight, deltaPosition);
                    });
                    modelMesh.addBlendShape(blendShape);
                });
            }
            if (encodedMeshData.indices) {
                var indices = null;
                if (encodedMeshData.indices.type === 0) {
                    indices = new Uint16Array(buffer, encodedMeshData.indices.start + offset, (encodedMeshData.indices.end - encodedMeshData.indices.start) / 2);
                } else {
                    indices = new Uint32Array(buffer, encodedMeshData.indices.start + offset, (encodedMeshData.indices.end - encodedMeshData.indices.start) / 4);
                }
                modelMesh.setIndices(indices);
            }
            encodedMeshData.subMeshes.forEach(function(subMesh) {
                return modelMesh.addSubMesh(subMesh);
            });
            modelMesh.uploadData(false);
            resolve(modelMesh);
        });
    };
    return MeshDecoder;
}();
MeshDecoder = __decorate([
    decoder("Mesh")
], MeshDecoder);
function float32ArrayToVColor(float32Array, vertexCount) {
    var array = new Array(vertexCount);
    for(var i = 0; i < vertexCount; i++){
        array[i] = new Color(float32Array[i * 4], float32Array[i * 4 + 1], float32Array[i * 4 + 2], float32Array[i * 4 + 3]);
    }
    return array;
}
function float32ArrayToVector4(float32Array, vertexCount) {
    var array = new Array(vertexCount);
    for(var i = 0; i < vertexCount; i++){
        array[i] = new Vector4(float32Array[i * 4], float32Array[i * 4 + 1], float32Array[i * 4 + 2], float32Array[i * 4 + 3]);
    }
    return array;
}
function float32ArrayToVector3(float32Array, vertexCount) {
    var array = new Array(vertexCount);
    for(var i = 0; i < vertexCount; i++){
        array[i] = new Vector3(float32Array[i * 3], float32Array[i * 3 + 1], float32Array[i * 3 + 2]);
    }
    return array;
}
function float32ArrayToVector2(float32Array, vertexCount) {
    var array = new Array(vertexCount);
    for(var i = 0; i < vertexCount; i++){
        array[i] = new Vector2(float32Array[i * 2], float32Array[i * 2 + 1]);
    }
    return array;
}

function _is_native_reflect_construct() {
    // Since Reflect.construct can't be properly polyfilled, some
    // implementations (e.g. core-js@2) don't set the correct internal slots.
    // Those polyfills don't allow us to subclass built-ins, so we need to
    // use our fallback implementation.
    try {
        // If the internal slots aren't set, this throws an error similar to
        //   TypeError: this is not a Boolean object.
        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (_) {}
    return (_is_native_reflect_construct = function() {
        return !!result;
    })();
}

function _construct(Parent, args, Class) {
    if (_is_native_reflect_construct()) _construct = Reflect.construct;
    else {
        _construct = function construct(Parent, args, Class) {
            var a = [null];
            a.push.apply(a, args);
            var Constructor = Function.bind.apply(Parent, a);
            var instance = new Constructor();

            if (Class) _set_prototype_of(instance, Class.prototype);

            return instance;
        };
    }

    return _construct.apply(null, arguments);
}

var ParserType = /*#__PURE__*/ function(ParserType) {
    ParserType[ParserType["Prefab"] = 0] = "Prefab";
    ParserType[ParserType["Scene"] = 1] = "Scene";
    return ParserType;
}({});
/**
 * @internal
 */ var ParserContext = /*#__PURE__*/ function() {
    function ParserContext(engine, type, resource) {
        if (type === void 0) type = 1;
        this.engine = engine;
        this.type = type;
        this.resource = resource;
        this.entityMap = new Map();
        this.entityConfigMap = new Map();
        this.components = new Map();
        this.rootIds = [];
        this.strippedIds = [];
        this.componentWaitingMap = new Map();
        this.resourceManager = engine.resourceManager;
    }
    var _proto = ParserContext.prototype;
    _proto.addComponent = function addComponent(id, component) {
        this.components.set(id, component);
        var waitingList = this.componentWaitingMap.get(id);
        if (waitingList == null ? void 0 : waitingList.length) {
            waitingList.forEach(function(resolve) {
                return resolve(component);
            });
            this.componentWaitingMap.delete(id);
        }
    };
    _proto.getComponentByRef = function getComponentByRef(ref) {
        var _this = this;
        return new Promise(function(resolve, reject) {
            var component = _this.components.get(ref.componentId);
            if (component) {
                resolve(component);
            } else {
                var resolves = _this.componentWaitingMap.get(ref.componentId);
                if (resolves) {
                    resolves.push(resolve);
                } else {
                    _this.componentWaitingMap.set(ref.componentId, [
                        resolve
                    ]);
                }
            }
        });
    };
    _proto.clear = function clear() {
        this.entityMap.clear();
        this.components.clear();
        this.entityConfigMap.clear();
        this.rootIds.length = 0;
        this.strippedIds.length = 0;
    };
    return ParserContext;
}();

var ReflectionParser = /*#__PURE__*/ function() {
    function ReflectionParser(_context) {
        this._context = _context;
    }
    var _proto = ReflectionParser.prototype;
    _proto.parseEntity = function parseEntity(entityConfig) {
        var _this = this;
        return this._getEntityByConfig(entityConfig).then(function(entity) {
            var _entityConfig_isActive;
            entity.isActive = (_entityConfig_isActive = entityConfig.isActive) != null ? _entityConfig_isActive : true;
            var transform = entity.transform;
            var transformConfig = entityConfig.transform;
            if (transformConfig) {
                _this.parsePropsAndMethods(transform, transformConfig);
            } else {
                var position = entityConfig.position, rotation = entityConfig.rotation, scale = entityConfig.scale;
                if (position) transform.position.copyFrom(position);
                if (rotation) transform.rotation.copyFrom(rotation);
                if (scale) transform.scale.copyFrom(scale);
            }
            var _entityConfig_layer;
            entity.layer = (_entityConfig_layer = entityConfig.layer) != null ? _entityConfig_layer : entity.layer;
            // @ts-ignore
            _this._context.type === ParserType.Prefab && entity._markAsTemplate(_this._context.resource);
            return entity;
        });
    };
    _proto.parseClassObject = function parseClassObject(item) {
        var _this = this;
        var Class = Loader.getClass(item.class);
        var _item_constructParams;
        var params = (_item_constructParams = item.constructParams) != null ? _item_constructParams : [];
        return Promise.all(params.map(function(param) {
            return _this.parseBasicType(param);
        })).then(function(resultParams) {
            return _construct(Class, [].concat(resultParams));
        }).then(function(instance) {
            return _this.parsePropsAndMethods(instance, item);
        });
    };
    _proto.parsePropsAndMethods = function parsePropsAndMethods(instance, item) {
        var promises = [];
        if (item.methods) {
            for(var methodName in item.methods){
                var methodParams = item.methods[methodName];
                for(var i = 0, count = methodParams.length; i < count; i++){
                    promises.push(this.parseMethod(instance, methodName, methodParams[i]));
                }
            }
        }
        if (item.props) {
            var _this, _loop = function(key) {
                var value = item.props[key];
                var promise = _this.parseBasicType(value, instance[key]).then(function(v) {
                    return instance[key] = v;
                });
                promises.push(promise);
            };
            for(var key in item.props)_this = this, _loop(key);
        }
        return Promise.all(promises).then(function() {
            var handle = ReflectionParser.customParseComponentHandles[instance.constructor.name];
            if (handle) return handle(instance, item);
            else return instance;
        });
    };
    _proto.parseMethod = function parseMethod(instance, methodName, methodParams) {
        var _this = this;
        var isMethodObject = ReflectionParser._isMethodObject(methodParams);
        var params = isMethodObject ? methodParams.params : methodParams;
        return Promise.all(params.map(function(param) {
            return _this.parseBasicType(param);
        })).then(function(result) {
            var _instance;
            var methodResult = (_instance = instance)[methodName].apply(_instance, [].concat(result));
            if (isMethodObject && methodParams.result) {
                return _this.parsePropsAndMethods(methodResult, methodParams.result);
            } else {
                return methodResult;
            }
        });
    };
    _proto.parseBasicType = function parseBasicType(value, originValue) {
        var _this = this;
        if (Array.isArray(value)) {
            return Promise.all(value.map(function(item) {
                return _this.parseBasicType(item);
            }));
        } else if ((typeof value === "undefined" ? "undefined" : _type_of(value)) === "object" && value != null) {
            if (ReflectionParser._isClassType(value)) {
                return Promise.resolve(Loader.getClass(value["classType"]));
            } else if (ReflectionParser._isClass(value)) {
                // class object
                return this.parseClassObject(value);
            } else if (ReflectionParser._isAssetRef(value)) {
                var _this1 = this, context = _this1._context;
                // reference object
                // @ts-ignore
                return context.resourceManager.getResourceByRef(value).then(function(resource) {
                    if (context.type === ParserType.Prefab) {
                        // @ts-ignore
                        context.resource._addDependenceAsset(resource);
                    }
                    return resource;
                });
            } else if (ReflectionParser._isComponentRef(value)) {
                return this._context.getComponentByRef(value);
            } else if (ReflectionParser._isEntityRef(value)) {
                // entity reference
                return Promise.resolve(this._context.entityMap.get(value.entityId));
            } else if (originValue) {
                var _this2, _loop = function(key) {
                    if (key === "methods") {
                        var methods = value[key];
                        for(var methodName in methods){
                            var methodParams = methods[methodName];
                            for(var i = 0, count = methodParams.length; i < count; i++){
                                var params = methodParams[i];
                                var promise = _this2.parseMethod(originValue, methodName, params);
                                promises.push(promise);
                            }
                        }
                    } else {
                        promises.push(_this2.parseBasicType(value[key], originValue[key]).then(function(v) {
                            return originValue[key] = v;
                        }));
                    }
                };
                var promises = [];
                for(var key in value)_this2 = this, _loop(key);
                return Promise.all(promises).then(function() {
                    return originValue;
                });
            }
        }
        // primitive type
        return Promise.resolve(value);
    };
    _proto._getEntityByConfig = function _getEntityByConfig(entityConfig) {
        var _this = this;
        // @ts-ignore
        var assetRefId = entityConfig.assetRefId;
        var engine = this._context.engine;
        if (assetRefId) {
            return engine.resourceManager// @ts-ignore
            .getResourceByRef({
                refId: assetRefId,
                key: entityConfig.key,
                isClone: entityConfig.isClone
            }).then(function(entity) {
                // @ts-ignore
                var resource = engine.resourceManager._objectPool[assetRefId];
                if (_this._context.type === ParserType.Prefab) {
                    // @ts-ignore
                    _this._context.resource._addDependenceAsset(resource);
                }
                entity.name = entityConfig.name;
                return entity;
            });
        } else {
            var transform = entityConfig.transform;
            var entity = new Entity(engine, entityConfig.name, transform ? Loader.getClass(transform.class) : Transform);
            return Promise.resolve(entity);
        }
    };
    ReflectionParser.registerCustomParseComponent = function registerCustomParseComponent(componentType, handle) {
        this.customParseComponentHandles[componentType] = handle;
    };
    ReflectionParser._isClass = function _isClass(value) {
        return value["class"] !== undefined;
    };
    ReflectionParser._isClassType = function _isClassType(value) {
        return value["classType"] !== undefined;
    };
    ReflectionParser._isAssetRef = function _isAssetRef(value) {
        return value["refId"] !== undefined;
    };
    ReflectionParser._isEntityRef = function _isEntityRef(value) {
        return value["entityId"] !== undefined;
    };
    ReflectionParser._isComponentRef = function _isComponentRef(value) {
        return value["ownerId"] !== undefined && value["componentId"] !== undefined;
    };
    ReflectionParser._isMethodObject = function _isMethodObject(value) {
        return Array.isArray(value == null ? void 0 : value.params);
    };
    return ReflectionParser;
}();
ReflectionParser.customParseComponentHandles = new Map();

var Texture2DDecoder = /*#__PURE__*/ function() {
    function Texture2DDecoder() {}
    Texture2DDecoder.decode = function decode(engine, bufferReader, restoredTexture) {
        return new AssetPromise(function(resolve, reject) {
            var objectId = bufferReader.nextStr();
            var mipmap = !!bufferReader.nextUint8();
            var filterMode = bufferReader.nextUint8();
            var anisoLevel = bufferReader.nextUint8();
            var wrapModeU = bufferReader.nextUint8();
            var wrapModeV = bufferReader.nextUint8();
            var format = bufferReader.nextUint8();
            var width = bufferReader.nextUint16();
            var height = bufferReader.nextUint16();
            var isPixelBuffer = bufferReader.nextUint8();
            var isSRGBColorSpace = !!bufferReader.nextUint8();
            var mipCount = bufferReader.nextUint8();
            var imagesData = bufferReader.nextImagesData(mipCount);
            var texture2D = restoredTexture || new Texture2D(engine, width, height, format, mipmap, isSRGBColorSpace);
            texture2D.filterMode = filterMode;
            texture2D.anisoLevel = anisoLevel;
            texture2D.wrapModeU = wrapModeU;
            texture2D.wrapModeV = wrapModeV;
            if (isPixelBuffer) {
                var pixelBuffer = imagesData[0];
                texture2D.setPixelBuffer(pixelBuffer);
                if (mipmap) {
                    texture2D.generateMipmaps();
                    for(var i = 1; i < mipCount; i++){
                        var pixelBuffer1 = imagesData[i];
                        texture2D.setPixelBuffer(pixelBuffer1, i);
                    }
                }
                // @ts-ignore
                engine.resourceManager._objectPool[objectId] = texture2D;
                resolve(texture2D);
            } else {
                var blob = new window.Blob([
                    imagesData[0]
                ]);
                var img = new Image();
                img.onload = function() {
                    texture2D.setImageSource(img);
                    var completedCount = 0;
                    var onComplete = function() {
                        completedCount++;
                        if (completedCount >= mipCount) {
                            resolve(texture2D);
                        }
                    };
                    onComplete();
                    if (mipmap) {
                        var _loop = function(i) {
                            var blob = new window.Blob([
                                imagesData[i]
                            ]);
                            var img = new Image();
                            img.onload = function() {
                                texture2D.setImageSource(img, i);
                                onComplete();
                            };
                            img.src = URL.createObjectURL(blob);
                        };
                        texture2D.generateMipmaps();
                        for(var i = 1; i < mipCount; i++)_loop(i);
                    }
                };
                img.src = URL.createObjectURL(blob);
            }
        });
    };
    return Texture2DDecoder;
}();
Texture2DDecoder = __decorate([
    decoder("Texture2D")
], Texture2DDecoder);

var EditorTextureLoader = /*#__PURE__*/ function(Loader) {
    _inherits(EditorTextureLoader, Loader);
    function EditorTextureLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = EditorTextureLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var requestConfig = _extends({}, item, {
            type: "arraybuffer"
        });
        var url = item.url;
        return new AssetPromise(function(resolve, reject) {
            resourceManager// @ts-ignore
            ._request(url, requestConfig).then(function(data) {
                decode(data, resourceManager.engine).then(function(texture) {
                    resourceManager.addContentRestorer(new EditorTexture2DContentRestorer(texture, url, requestConfig));
                    resolve(texture);
                });
            }).catch(reject);
        });
    };
    return EditorTextureLoader;
}(Loader);
EditorTextureLoader = __decorate([
    resourceLoader("EditorTexture2D", [
        "prefab"
    ], true)
], EditorTextureLoader);
var EditorTexture2DContentRestorer = /*#__PURE__*/ function(ContentRestorer) {
    _inherits(EditorTexture2DContentRestorer, ContentRestorer);
    function EditorTexture2DContentRestorer(resource, url, requestConfig) {
        var _this;
        _this = ContentRestorer.call(this, resource) || this, _this.url = url, _this.requestConfig = requestConfig;
        return _this;
    }
    var _proto = EditorTexture2DContentRestorer.prototype;
    _proto.restoreContent = function restoreContent() {
        var texture = this.resource;
        var engine = texture.engine;
        return engine.resourceManager// @ts-ignore
        ._request(this.url, this.requestConfig).then(function(data) {
            return decode(data, engine, texture);
        });
    };
    return EditorTexture2DContentRestorer;
}(ContentRestorer);

function _instanceof$1(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else return left instanceof right;
}

function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
}

function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);

    var n = Object.prototype.toString.call(o).slice(8, -1);

    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}

function _create_for_of_iterator_helper_loose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (it) return (it = it.call(o)).next.bind(it);
    // Fallback for engines without symbol support
    if (Array.isArray(o) || (it = _unsupported_iterable_to_array(o)) || allowArrayLike) {
        if (it) o = it;

        var i = 0;

        return function() {
            if (i >= o.length) return { done: true };

            return { done: false, value: o[i++] };
        };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/**
 * The Prefab resource.
 */ var PrefabResource = /*#__PURE__*/ function(ReferResource1) {
    _inherits(PrefabResource, ReferResource1);
    function PrefabResource(engine, url) {
        var _this;
        _this = ReferResource1.call(this, engine) || this, _this.url = url, _this._dependenceAssets = new Set();
        return _this;
    }
    var _proto = PrefabResource.prototype;
    /**
   * Instantiate prefab.
   * @returns prefab's root entity
   */ _proto.instantiate = function instantiate() {
        var _this__root;
        return (_this__root = this._root) == null ? void 0 : _this__root.clone();
    };
    /**
   * @internal
   */ _proto._addDependenceAsset = function _addDependenceAsset(resource) {
        this._dependenceAssets.add(resource);
        // @todo: The PhysicsMaterial does not inherit from ReferResource. Currently,
        // ReferResource requires the engine to be passed as a parameter, which prevents cross-engine reuse.
        // A refactor of ReferResource will be needed in the future.
        if (_instanceof$1(resource, ReferResource)) {
            // @ts-ignore
            resource._associationSuperResource(this);
        }
    };
    _proto._onDestroy = function _onDestroy() {
        var _this = this;
        ReferResource1.prototype._onDestroy.call(this);
        this._root.destroy();
        this._dependenceAssets.forEach(function(asset) {
            if (_instanceof$1(asset, ReferResource)) {
                // @ts-ignore
                asset._disassociationSuperResource(_this);
            }
        });
    };
    return PrefabResource;
}(ReferResource);

/** @Internal */ var HierarchyParser = /*#__PURE__*/ function() {
    function HierarchyParser(data, context) {
        var _this = this;
        this.data = data;
        this.context = context;
        this._prefabContextMap = new WeakMap();
        this._prefabPromiseMap = new Map();
        this._engine = this.context.engine;
        this._organizeEntities = this._organizeEntities.bind(this);
        this._parseComponents = this._parseComponents.bind(this);
        this._parsePrefabModification = this._parsePrefabModification.bind(this);
        this._parseAddedComponents = this._parseAddedComponents.bind(this);
        this._parsePrefabRemovedEntities = this._parsePrefabRemovedEntities.bind(this);
        this._parsePrefabRemovedComponents = this._parsePrefabRemovedComponents.bind(this);
        this._clearAndResolve = this._clearAndResolve.bind(this);
        this.promise = new Promise(function(resolve, reject) {
            _this._reject = reject;
            _this._resolve = resolve;
        });
        this._reflectionParser = new ReflectionParser(context);
    }
    var _proto = HierarchyParser.prototype;
    /** start parse the scene or prefab or others */ _proto.start = function start() {
        this._parseEntities().then(this._organizeEntities).then(this._parseComponents).then(this._parsePrefabModification).then(this._parseAddedComponents).then(this._parsePrefabRemovedEntities).then(this._parsePrefabRemovedComponents).then(this._clearAndResolve).then(this._resolve).catch(this._reject);
    };
    _proto._parseEntities = function _parseEntities() {
        var _this = this;
        var entitiesConfig = this.data.entities;
        var entityConfigMap = this.context.entityConfigMap;
        var entityMap = this.context.entityMap;
        var engine = this._engine;
        var promises = entitiesConfig.map(function(entityConfig) {
            var _entityConfig_strippedId;
            var id = (_entityConfig_strippedId = entityConfig.strippedId) != null ? _entityConfig_strippedId : entityConfig.id;
            entityConfig.id = id;
            entityConfigMap.set(id, entityConfig);
            return _this._getEntityByConfig(entityConfig, engine);
        });
        return Promise.all(promises).then(function(entities) {
            for(var i = 0, l = entities.length; i < l; i++){
                entityMap.set(entitiesConfig[i].id, entities[i]);
            }
            return entities;
        });
    };
    _proto._parseComponents = function _parseComponents() {
        var entitiesConfig = this.data.entities;
        var entityMap = this.context.entityMap;
        var promises = [];
        for(var i = 0, l = entitiesConfig.length; i < l; i++){
            var entityConfig = entitiesConfig[i];
            if (entityConfig.strippedId) {
                continue;
            }
            var entity = entityMap.get(entityConfig.id);
            this._addComponents(entity, entityConfig.components, promises);
        }
        return Promise.all(promises);
    };
    _proto._parsePrefabModification = function _parsePrefabModification() {
        var _loop = function(i, l) {
            var entityConfig = entitiesConfig[i];
            var id = entityConfig.id, modifications = entityConfig.modifications;
            if (modifications == null ? void 0 : modifications.length) {
                var _promises;
                var rootEntity = entityMap.get(id);
                (_promises = promises).push.apply(_promises, [].concat(modifications.map(function(modification) {
                    var target = modification.target, props = modification.props, methods = modification.methods;
                    var entityId = target.entityId, componentId = target.componentId;
                    var context = _this._prefabContextMap.get(rootEntity);
                    var targetEntity = context.entityMap.get(entityId);
                    var targetComponent = context.components.get(componentId);
                    if (targetComponent) {
                        return _this._reflectionParser.parsePropsAndMethods(targetComponent, {
                            props: props,
                            methods: methods
                        });
                    } else if (targetEntity) {
                        return Promise.resolve(_this._applyEntityData(targetEntity, props));
                    }
                })));
            }
        };
        var _this = this;
        var entitiesConfig = this.data.entities;
        var entityMap = this.context.entityMap;
        var promises = [];
        for(var i = 0, l = entitiesConfig.length; i < l; i++)_loop(i);
        return Promise.all(promises);
    };
    _proto._parseAddedComponents = function _parseAddedComponents() {
        var entityMap = this.context.entityMap;
        var entityConfigMap = this.context.entityConfigMap;
        var strippedIds = this.context.strippedIds;
        var promises = [];
        for(var i = 0, n = strippedIds.length; i < n; i++){
            var entityConfig = entityConfigMap.get(strippedIds[i]);
            var prefabContext = this._prefabContextMap.get(entityMap.get(entityConfig.prefabInstanceId));
            var entity = prefabContext.entityMap.get(entityConfig.prefabSource.entityId);
            this._addComponents(entity, entityConfig.components, promises);
        }
        for(var _iterator = _create_for_of_iterator_helper_loose(this.context.componentWaitingMap.values()), _step; !(_step = _iterator()).done;){
            var waitingList = _step.value;
            waitingList.forEach(function(resolve) {
                return resolve(null);
            });
        }
        return Promise.all(promises);
    };
    _proto._parsePrefabRemovedEntities = function _parsePrefabRemovedEntities() {
        var _loop = function(i, l) {
            var entityConfig = entitiesConfig[i];
            var id = entityConfig.id, removedEntities = entityConfig.removedEntities;
            if (removedEntities == null ? void 0 : removedEntities.length) {
                var _promises;
                var rootEntity = entityMap.get(id);
                (_promises = promises).push.apply(_promises, [].concat(removedEntities.map(function(target) {
                    var entityId = target.entityId;
                    var context = _this._prefabContextMap.get(rootEntity);
                    var targetEntity = context.entityMap.get(entityId);
                    if (targetEntity) {
                        targetEntity.destroy();
                    }
                })));
            }
        };
        var _this = this;
        var entitiesConfig = this.data.entities;
        var entityMap = this.context.entityMap;
        var promises = [];
        for(var i = 0, l = entitiesConfig.length; i < l; i++)_loop(i);
        return Promise.all(promises);
    };
    _proto._parsePrefabRemovedComponents = function _parsePrefabRemovedComponents() {
        var _loop = function(i, l) {
            var entityConfig = entitiesConfig[i];
            var id = entityConfig.id, removedComponents = entityConfig.removedComponents;
            if (removedComponents == null ? void 0 : removedComponents.length) {
                var _promises;
                var rootEntity = entityMap.get(id);
                (_promises = promises).concat.apply(_promises, [].concat(removedComponents.map(function(target) {
                    var componentId = target.componentId;
                    var context = _this._prefabContextMap.get(rootEntity);
                    var targetComponent = context.components.get(componentId);
                    if (targetComponent) {
                        targetComponent.destroy();
                    }
                })));
            }
        };
        var _this = this;
        var entitiesConfig = this.data.entities;
        var entityMap = this.context.entityMap;
        var promises = [];
        for(var i = 0, l = entitiesConfig.length; i < l; i++)_loop(i);
        return Promise.all(promises);
    };
    _proto._organizeEntities = function _organizeEntities() {
        var _this_context = this.context, rootIds = _this_context.rootIds, strippedIds = _this_context.strippedIds;
        var parentIds = rootIds.concat(strippedIds);
        for(var _iterator = _create_for_of_iterator_helper_loose(parentIds), _step; !(_step = _iterator()).done;){
            var parentId = _step.value;
            this._parseChildren(parentId);
        }
        for(var i = 0; i < rootIds.length; i++){
            this._handleRootEntity(rootIds[i]);
        }
    };
    _proto._getEntityByConfig = function _getEntityByConfig(entityConfig, engine) {
        var _this = this;
        var entityPromise;
        if (entityConfig.assetRefId) {
            entityPromise = this._parsePrefab(entityConfig, engine);
        } else if (entityConfig.strippedId) {
            entityPromise = this._parseStrippedEntity(entityConfig);
        } else {
            entityPromise = this._parseEntity(entityConfig, engine);
        }
        return entityPromise.then(function(entity) {
            return _this._applyEntityData(entity, entityConfig);
        });
    };
    _proto._parseEntity = function _parseEntity(entityConfig, engine) {
        var transform = entityConfig.transform;
        var entity = new Entity(engine, entityConfig.name, transform ? Loader.getClass(transform.class) : Transform);
        if (!entityConfig.parent) this.context.rootIds.push(entityConfig.id);
        return Promise.resolve(entity);
    };
    _proto._parsePrefab = function _parsePrefab(entityConfig, engine) {
        var _this = this;
        var assetRefId = entityConfig.assetRefId;
        return engine.resourceManager// @ts-ignore
        .getResourceByRef({
            refId: assetRefId
        }).then(function(prefabResource) {
            var entity = _instanceof$1(prefabResource, PrefabResource) ? prefabResource.instantiate() : prefabResource.instantiateSceneRoot();
            var instanceContext = new ParserContext(engine, ParserType.Prefab, null);
            if (!entityConfig.parent) _this.context.rootIds.push(entityConfig.id);
            _this._generateInstanceContext(entity, instanceContext, "");
            _this._prefabContextMap.set(entity, instanceContext);
            var cbArray = _this._prefabPromiseMap.get(entityConfig.id);
            if (cbArray) {
                for(var i = 0, n = cbArray.length; i < n; i++){
                    cbArray[i].resolve(instanceContext);
                }
            }
            return entity;
        });
    };
    _proto._parseStrippedEntity = function _parseStrippedEntity(entityConfig) {
        var _this = this;
        this.context.strippedIds.push(entityConfig.id);
        return new Promise(function(resolve, reject) {
            var _this__prefabPromiseMap_get;
            var cbArray = (_this__prefabPromiseMap_get = _this._prefabPromiseMap.get(entityConfig.prefabInstanceId)) != null ? _this__prefabPromiseMap_get : [];
            cbArray.push({
                resolve: resolve,
                reject: reject
            });
            _this._prefabPromiseMap.set(entityConfig.prefabInstanceId, cbArray);
        }).then(function(context) {
            var entityId = entityConfig.prefabSource.entityId;
            return context.entityMap.get(entityId);
        });
    };
    _proto._parseChildren = function _parseChildren(parentId) {
        var _this_context = this.context, entityConfigMap = _this_context.entityConfigMap, entityMap = _this_context.entityMap;
        var children = entityConfigMap.get(parentId).children;
        if (children && children.length > 0) {
            var parent = entityMap.get(parentId);
            for(var i = 0; i < children.length; i++){
                var childId = children[i];
                var entity = entityMap.get(childId);
                parent.addChild(entity);
                this._parseChildren(childId);
            }
        }
    };
    _proto._addComponents = function _addComponents(entity, components, promises) {
        for(var i = 0, n = components.length; i < n; i++){
            var componentConfig = components[i];
            var key = !componentConfig.refId ? componentConfig.class : componentConfig.refId;
            var component = entity.addComponent(Loader.getClass(key));
            this.context.addComponent(componentConfig.id, component);
            var promise = this._reflectionParser.parsePropsAndMethods(component, componentConfig);
            promises.push(promise);
        }
        return promises;
    };
    _proto._applyEntityData = function _applyEntityData(entity, entityConfig) {
        if (entityConfig === void 0) entityConfig = {};
        var _entityConfig_isActive;
        entity.isActive = (_entityConfig_isActive = entityConfig.isActive) != null ? _entityConfig_isActive : entity.isActive;
        var _entityConfig_name;
        entity.name = (_entityConfig_name = entityConfig.name) != null ? _entityConfig_name : entity.name;
        var transform = entity.transform;
        var transformConfig = entityConfig.transform;
        if (transformConfig) {
            this._reflectionParser.parsePropsAndMethods(transform, transformConfig);
        } else {
            var position = entityConfig.position, rotation = entityConfig.rotation, scale = entityConfig.scale;
            if (position) transform.position.copyFrom(position);
            if (rotation) transform.rotation.copyFrom(rotation);
            if (scale) transform.scale.copyFrom(scale);
        }
        if (entityConfig.layer) entity.layer = entityConfig.layer;
        return entity;
    };
    _proto._generateInstanceContext = function _generateInstanceContext(entity, context, path) {
        var entityMap = context.entityMap, components = context.components;
        var componentsMap = {};
        var componentIndexMap = {};
        entityMap.set(path, entity);
        // @ts-ignore
        entity._components.forEach(function(component) {
            // @ts-ignore
            var name = Loader.getClassName(component.constructor);
            if (!componentsMap[name]) {
                componentsMap[name] = entity.getComponents(component.constructor, []);
                componentIndexMap[name] = 0;
            }
            components.set(path + ":" + name + "/" + componentIndexMap[name]++, component);
        });
        for(var i = 0, n = entity.children.length; i < n; i++){
            var child = entity.children[i];
            var childPath = path ? path + "/" + i : "" + i;
            this._generateInstanceContext(child, context, childPath);
        }
    };
    return HierarchyParser;
}();

/** @Internal */ var SceneParser = /*#__PURE__*/ function(HierarchyParser) {
    _inherits(SceneParser, HierarchyParser);
    function SceneParser(data, context, scene) {
        var _this;
        _this = HierarchyParser.call(this, data, context) || this, _this.scene = scene;
        return _this;
    }
    var _proto = SceneParser.prototype;
    _proto._handleRootEntity = function _handleRootEntity(id) {
        var entityMap = this.context.entityMap;
        this.scene.addRootEntity(entityMap.get(id));
    };
    _proto._clearAndResolve = function _clearAndResolve() {
        this.context.clear();
        return this.scene;
    };
    /**
   * Parse scene data.
   * @param engine - the engine of the parser context
   * @param sceneData - scene data which is exported by editor
   * @returns a promise of scene
   */ SceneParser.parse = function parse(engine, sceneData) {
        var scene = new Scene(engine);
        var context = new ParserContext(engine, ParserType.Scene, scene);
        var parser = new SceneParser(sceneData, context, scene);
        parser.start();
        return parser.promise.then(function() {
            return scene;
        });
    };
    return SceneParser;
}(HierarchyParser);

var MaterialLoaderType = /*#__PURE__*/ function(MaterialLoaderType) {
    MaterialLoaderType["Vector2"] = "Vector2";
    MaterialLoaderType["Vector3"] = "Vector3";
    MaterialLoaderType["Vector4"] = "Vector4";
    MaterialLoaderType["Color"] = "Color";
    MaterialLoaderType["Float"] = "Float";
    MaterialLoaderType["Texture"] = "Texture";
    MaterialLoaderType["Boolean"] = "Boolean";
    MaterialLoaderType["Integer"] = "Integer";
    return MaterialLoaderType;
}({});

var SpecularMode = /*#__PURE__*/ function(SpecularMode) {
    SpecularMode["Sky"] = "Sky";
    SpecularMode["Custom"] = "Custom";
    return SpecularMode;
}({});

/**
 * Decode engine binary resource.
 * @param arrayBuffer - array buffer of decode binary file
 * @param engine - engine
 * @returns
 */ function decode(arrayBuffer, engine) {
    for(var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){
        args[_key - 2] = arguments[_key];
    }
    var _decoderMap_header_type;
    var header = FileHeader.decode(arrayBuffer);
    var bufferReader = new BufferReader(new Uint8Array(arrayBuffer), header.headerLength, header.dataLength);
    return (_decoderMap_header_type = decoderMap[header.type]).decode.apply(_decoderMap_header_type, [].concat([
        engine,
        bufferReader
    ], args)).then(function(object) {
        object.name = header.name;
        return object;
    });
}

var AnimationClipLoader = /*#__PURE__*/ function(Loader) {
    _inherits(AnimationClipLoader, Loader);
    function AnimationClipLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = AnimationClipLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            resourceManager// @ts-ignore
            ._request(item.url, _extends({}, item, {
                type: "arraybuffer"
            })).then(function(data) {
                return decode(data, resourceManager.engine).then(function(clip) {
                    var curveBindingPromises = clip.curveBindings.map(function(curveBinding) {
                        var curve = curveBinding.curve;
                        var promises = curve.keys.map(function(key) {
                            return _this._parseKeyframeValue(key, resourceManager).then(function(actualValue) {
                                key.value = actualValue;
                            });
                        });
                        return Promise.all(promises);
                    });
                    return Promise.all(curveBindingPromises).then(function() {
                        resolve(clip);
                    });
                }).catch(reject);
            }).catch(reject);
        });
    };
    _proto._parseKeyframeValue = function _parseKeyframeValue(keyframe, resourceManager) {
        var value = keyframe.value;
        if ((typeof value === "undefined" ? "undefined" : _type_of(value)) === "object" && (value == null ? void 0 : value.refId)) {
            return new Promise(function(resolve) {
                resourceManager// @ts-ignore
                .getResourceByRef(value).then(function(asset) {
                    keyframe.value = asset;
                    resolve(keyframe.value);
                });
            });
        } else {
            return Promise.resolve(keyframe.value);
        }
    };
    return AnimationClipLoader;
}(Loader);
AnimationClipLoader = __decorate([
    resourceLoader(AssetType.AnimationClip, [
        "ani"
    ])
], AnimationClipLoader);

var AnimatorControllerLoader = /*#__PURE__*/ function(Loader1) {
    _inherits(AnimatorControllerLoader, Loader1);
    function AnimatorControllerLoader() {
        return Loader1.apply(this, arguments) || this;
    }
    var _proto = AnimatorControllerLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            resourceManager// @ts-ignore
            ._request(item.url, _extends({}, item, {
                type: "json"
            })).then(function(data) {
                var animatorController = new AnimatorController(resourceManager.engine);
                var layers = data.layers, parameters = data.parameters;
                var promises = [];
                layers.forEach(function(layerData, layerIndex) {
                    var name = layerData.name, blendingMode = layerData.blendingMode, weight = layerData.weight, stateMachineData = layerData.stateMachine;
                    var layer = new AnimatorControllerLayer(name);
                    layer.blendingMode = blendingMode;
                    layer.weight = weight;
                    if (stateMachineData) {
                        var states = stateMachineData.states, transitions = stateMachineData.transitions, entryTransitions = stateMachineData.entryTransitions, anyTransitions = stateMachineData.anyTransitions;
                        var stateMachine = layer.stateMachine;
                        var statesMap = {};
                        var transitionsMap = {};
                        states.forEach(function(stateData, stateIndex) {
                            var id = stateData.id, name = stateData.name, speed = stateData.speed, wrapMode = stateData.wrapMode, clipStartNormalizedTime = stateData.clipStartNormalizedTime, clipEndNormalizedTime = stateData.clipEndNormalizedTime, clipData = stateData.clip, scripts = stateData.scripts;
                            var state = stateMachine.addState(name);
                            state.speed = speed;
                            state.wrapMode = wrapMode;
                            state.clipStartTime = clipStartNormalizedTime;
                            state.clipEndTime = clipEndNormalizedTime;
                            scripts.forEach(function(script) {
                                state.addStateMachineScript(Loader.getClass(script));
                            });
                            statesMap[id] = state;
                            if (clipData) {
                                promises.push(new Promise(function(resolve) {
                                    //@ts-ignore
                                    resourceManager.getResourceByRef(clipData).then(function(clip) {
                                        resolve({
                                            layerIndex: layerIndex,
                                            stateIndex: stateIndex,
                                            clip: clip
                                        });
                                    });
                                }));
                            }
                        });
                        transitions.forEach(function(transitionData) {
                            var transition = _this._createTransition(transitionData, statesMap[transitionData.destinationStateId]);
                            transitionsMap[transitionData.id] = transition;
                        });
                        states.forEach(function(stateData) {
                            var id = stateData.id, transitions = stateData.transitions;
                            transitions.forEach(function(transitionId) {
                                var transition = transitionsMap[transitionId];
                                transition && statesMap[id].addTransition(transition);
                            });
                        });
                        entryTransitions.forEach(function(entryTransitionData) {
                            stateMachine.addEntryStateTransition(_this._createTransition(entryTransitionData, statesMap[entryTransitionData.destinationStateId]));
                        });
                        anyTransitions.forEach(function(anyTransitionData) {
                            stateMachine.addAnyStateTransition(_this._createTransition(anyTransitionData, statesMap[anyTransitionData.destinationStateId]));
                        });
                    }
                    animatorController.addLayer(layer);
                });
                parameters.forEach(function(parameterData) {
                    if (parameterData.isTrigger) {
                        animatorController.addTriggerParameter(parameterData.name);
                    } else {
                        animatorController.addParameter(parameterData.name, parameterData.defaultValue);
                    }
                });
                Promise.all(promises).then(function(clipData) {
                    clipData.forEach(function(data) {
                        var layerIndex = data.layerIndex, stateIndex = data.stateIndex, clip = data.clip;
                        animatorController.layers[layerIndex].stateMachine.states[stateIndex].clip = clip;
                    });
                    resolve(animatorController);
                });
            }).catch(reject);
        });
    };
    _proto._createTransition = function _createTransition(transitionData, destinationState) {
        var transition = new AnimatorStateTransition();
        transition.hasExitTime = transitionData.hasExitTime;
        transition.isFixedDuration = transitionData.isFixedDuration;
        transition.duration = transitionData.duration;
        transition.offset = transitionData.offset;
        transition.exitTime = transitionData.exitTime;
        transition.solo = transitionData.solo;
        transition.mute = transitionData.mute;
        // @ts-ignore
        transition._isExit = transitionData.isExit;
        transition.destinationState = destinationState;
        transitionData.conditions.forEach(function(conditionData) {
            transition.addCondition(conditionData.parameterName, conditionData.mode, conditionData.threshold);
        });
        return transition;
    };
    return AnimatorControllerLoader;
}(Loader);
AnimatorControllerLoader = __decorate([
    resourceLoader(AssetType.AnimatorController, [
        "json"
    ], false)
], AnimatorControllerLoader);

function isBase64(url) {
    return /^data:(.+?);base64,/.test(url);
}
var BufferLoader = /*#__PURE__*/ function(Loader) {
    _inherits(BufferLoader, Loader);
    function BufferLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = BufferLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var url = item.url;
        if (isBase64(url)) {
            return new AssetPromise(function(resolve) {
                var base64Str = url.slice(13 + RegExp.$1.length);
                var result = Uint8Array.from(atob(base64Str), function(c) {
                    return c.charCodeAt(0);
                });
                resolve(result.buffer);
            });
        }
        // @ts-ignore
        return resourceManager._request(url, _extends({}, item, {
            type: "arraybuffer"
        }));
    };
    return BufferLoader;
}(Loader);
BufferLoader = __decorate([
    resourceLoader(AssetType.Buffer, [
        "bin",
        "r3bin"
    ], false)
], BufferLoader);

var EnvLoader = /*#__PURE__*/ function(Loader) {
    _inherits(EnvLoader, Loader);
    function EnvLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = EnvLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        return new AssetPromise(function(resolve, reject) {
            var requestConfig = _extends({}, item, {
                type: "arraybuffer"
            });
            var engine = resourceManager.engine;
            var url = item.url;
            resourceManager// @ts-ignore
            ._request(url, requestConfig).then(function(arraybuffer) {
                var texture = EnvLoader._setTextureByBuffer(engine, arraybuffer);
                engine.resourceManager.addContentRestorer(new EnvContentRestorer(texture, url, requestConfig));
                var ambientLight = new AmbientLight(engine);
                var sh = new SphericalHarmonics3();
                ambientLight.diffuseMode = DiffuseMode.SphericalHarmonics;
                sh.copyFromArray(new Float32Array(arraybuffer, 0, 27));
                ambientLight.diffuseSphericalHarmonics = sh;
                ambientLight.specularTexture = texture;
                ambientLight.specularTextureDecodeRGBM = true;
                resolve(ambientLight);
            }).catch(function(e) {
                reject(e);
            });
        });
    };
    /**
   * @internal
   */ EnvLoader._setTextureByBuffer = function _setTextureByBuffer(engine, buffer, texture) {
        var _this;
        var shByteLength = 27 * 4;
        var size = (_this = new Uint16Array(buffer, shByteLength, 1)) == null ? void 0 : _this[0];
        texture || (texture = new TextureCube(engine, size, undefined, undefined, false));
        texture.filterMode = TextureFilterMode.Trilinear;
        var mipmapCount = texture.mipmapCount;
        var offset = shByteLength + 2;
        for(var mipLevel = 0; mipLevel < mipmapCount; mipLevel++){
            var mipSize = size >> mipLevel;
            for(var face = 0; face < 6; face++){
                var dataSize = mipSize * mipSize * 4;
                var data = new Uint8Array(buffer, offset, dataSize);
                offset += dataSize;
                texture.setPixelBuffer(TextureCubeFace.PositiveX + face, data, mipLevel);
            }
        }
        return texture;
    };
    return EnvLoader;
}(Loader);
EnvLoader = __decorate([
    resourceLoader(AssetType.Env, [
        "env"
    ])
], EnvLoader);
/**
 * @internal
 */ var EnvContentRestorer = /*#__PURE__*/ function(ContentRestorer) {
    _inherits(EnvContentRestorer, ContentRestorer);
    function EnvContentRestorer(resource, url, requestConfig) {
        var _this;
        _this = ContentRestorer.call(this, resource) || this, _this.url = url, _this.requestConfig = requestConfig;
        return _this;
    }
    var _proto = EnvContentRestorer.prototype;
    _proto.restoreContent = function restoreContent() {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            var resource = _this.resource;
            var engine = resource.engine;
            engine.resourceManager// @ts-ignore
            ._request(_this.url, _this.requestConfig).then(function(buffer) {
                EnvLoader._setTextureByBuffer(engine, buffer, resource);
                resolve(resource);
            }).catch(reject);
        });
    };
    return EnvContentRestorer;
}(ContentRestorer);

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) resolve(value);
    else Promise.resolve(value).then(_next, _throw);
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;

        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);

            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }

            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }

            _next(undefined);
        });
    };
}

var FontLoader = /*#__PURE__*/ function(Loader) {
    _inherits(FontLoader, Loader);
    function FontLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = FontLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            resourceManager// @ts-ignore
            ._request(item.url, _extends({}, item, {
                type: "json"
            })).then(function(data) {
                var fontName = data.fontName, fontUrl = data.fontUrl;
                if (fontUrl) {
                    _this._registerFont(fontName, fontUrl).then(function() {
                        var font = new Font(resourceManager.engine, fontName);
                        resolve(font);
                    }).catch(function(e) {
                        reject("load font " + fontUrl + " fail");
                    });
                } else {
                    var font = new Font(resourceManager.engine, fontName);
                    resolve(font);
                }
            }).catch(function(e) {
                reject(e);
            });
        });
    };
    _proto._registerFont = function _registerFont(fontName, fontUrl) {
        return _async_to_generator(function() {
            var fontFace;
            return __generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        fontFace = new FontFace(fontName, "url(" + fontUrl + ")");
                        return [
                            4,
                            fontFace.load()
                        ];
                    case 1:
                        _state.sent();
                        document.fonts.add(fontFace);
                        return [
                            2
                        ];
                }
            });
        })();
    };
    return FontLoader;
}(Loader);
FontLoader = __decorate([
    resourceLoader(AssetType.Font, [
        "font"
    ], false)
], FontLoader);

// Source: https://github.com/zeux/meshoptimizer/blob/master/js/meshopt_decoder.js
var ready;
function getMeshoptDecoder() {
    if (ready) return ready;
    var wasm_base = "b9H79Tebbbe8Fv9Gbb9Gvuuuuueu9Giuuub9Geueu9Giuuueuikqbeeedddillviebeoweuec:q;iekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbeY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVbdE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbiL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtblK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbol79IV9Rbrq:P8Yqdbk;3sezu8Jjjjjbcj;eb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Radz1jjjbhwcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhDcbhqinaqae9pmeaDaeaq9RaqaDfae6Egkcsfgocl4cifcd4hxdndndndnaoc9WGgmTmbcbhPcehsawcjdfhzalhHinaraH9Rax6midnaraHaxfgl9RcK6mbczhoinawcj;cbfaogifgoc9WfhOdndndndndnaHaic9WfgAco4fRbbaAci4coG4ciGPlbedibkaO9cb83ibaOcwf9cb83ibxikaOalRblalRbbgAco4gCaCciSgCE86bbaocGfalclfaCfgORbbaAcl4ciGgCaCciSgCE86bbaocVfaOaCfgORbbaAcd4ciGgCaCciSgCE86bbaoc7faOaCfgORbbaAciGgAaAciSgAE86bbaoctfaOaAfgARbbalRbegOco4gCaCciSgCE86bbaoc91faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc4faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc93faAaCfgARbbaOciGgOaOciSgOE86bbaoc94faAaOfgARbbalRbdgOco4gCaCciSgCE86bbaoc95faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc96faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc97faAaCfgARbbaOciGgOaOciSgOE86bbaoc98faAaOfgORbbalRbiglco4gAaAciSgAE86bbaoc99faOaAfgORbbalcl4ciGgAaAciSgAE86bbaoc9:faOaAfgORbbalcd4ciGgAaAciSgAE86bbaocufaOaAfgoRbbalciGglalciSglE86bbaoalfhlxdkaOalRbwalRbbgAcl4gCaCcsSgCE86bbaocGfalcwfaCfgORbbaAcsGgAaAcsSgAE86bbaocVfaOaAfgORbbalRbegAcl4gCaCcsSgCE86bbaoc7faOaCfgORbbaAcsGgAaAcsSgAE86bbaoctfaOaAfgORbbalRbdgAcl4gCaCcsSgCE86bbaoc91faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc4faOaAfgORbbalRbigAcl4gCaCcsSgCE86bbaoc93faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc94faOaAfgORbbalRblgAcl4gCaCcsSgCE86bbaoc95faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc96faOaAfgORbbalRbvgAcl4gCaCcsSgCE86bbaoc97faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc98faOaAfgORbbalRbogAcl4gCaCcsSgCE86bbaoc99faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc9:faOaAfgORbbalRbrglcl4gAaAcsSgAE86bbaocufaOaAfgoRbbalcsGglalcsSglE86bbaoalfhlxekaOal8Pbb83bbaOcwfalcwf8Pbb83bbalczfhlkdnaiam9pmbaiczfhoaral9RcL0mekkaiam6mialTmidnakTmbawaPfRbbhOcbhoazhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkkazcefhzaPcefgPad6hsalhHaPad9hmexvkkcbhlasceGmdxikalaxad2fhCdnakTmbcbhHcehsawcjdfhminaral9Rax6mialTmdalaxfhlawaHfRbbhOcbhoamhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkamcefhmaHcefgHad6hsaHad9hmbkaChlxikcbhocehsinaral9Rax6mdalTmealaxfhlaocefgoad6hsadao9hmbkaChlxdkcbhlasceGTmekc9:hoxikabaqad2fawcjdfakad2z1jjjb8Aawawcjdfakcufad2fadz1jjjb8Aakaqfhqalmbkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;ebf8Kjjjjbaok;yzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecjez:jjjjb8AavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:Lvoeue99dud99eud99dndnadcl9hmbaeTmeindndnabcdfgd8Sbb:Yab8Sbbgi:Ygl:l:tabcefgv8Sbbgo:Ygr:l:tgwJbb;:9cawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai86bbdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad86bbdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad86bbabclfhbaecufgembxdkkaeTmbindndnabclfgd8Ueb:Yab8Uebgi:Ygl:l:tabcdfgv8Uebgo:Ygr:l:tgwJb;:FSawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai87ebdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad87ebdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad87ebabcwfhbaecufgembkkk;siliui99iue99dnaeTmbcbhiabhlindndnJ;Zl81Zalcof8UebgvciV:Y:vgoal8Ueb:YNgrJb;:FSNJbbbZJbbb:;arJbbbb9GEMgw:lJbbb9p9DTmbaw:OhDxekcjjjj94hDkalclf8Uebhqalcdf8UebhkabavcefciGaiVcetfaD87ebdndnaoak:YNgwJb;:FSNJbbbZJbbb:;awJbbbb9GEMgx:lJbbb9p9DTmbax:Ohkxekcjjjj94hkkabavcdfciGaiVcetfak87ebdndnaoaq:YNgoJb;:FSNJbbbZJbbb:;aoJbbbb9GEMgx:lJbbb9p9DTmbax:Ohqxekcjjjj94hqkabavcufciGaiVcetfaq87ebdndnJbbjZararN:tawawN:taoaoN:tgrJbbbbarJbbbb9GE:rJb;:FSNJbbbZMgr:lJbbb9p9DTmbar:Ohqxekcjjjj94hqkabavciGaiVcetfaq87ebalcwfhlaiclfhiaecufgembkkk9mbdnadcd4ae2geTmbinababydbgdcwtcw91:Yadce91cjjj;8ifcjjj98G::NUdbabclfhbaecufgembkkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik;LeeeudndnaeabVciGTmbabhixekdndnadcz9pmbabhixekabhiinaiaeydbBdbaiclfaeclfydbBdbaicwfaecwfydbBdbaicxfaecxfydbBdbaiczfhiaeczfheadc9Wfgdcs0mbkkadcl6mbinaiaeydbBdbaeclfheaiclfhiadc98fgdci0mbkkdnadTmbinaiaeRbb86bbaicefhiaecefheadcufgdmbkkabk;aeedudndnabciGTmbabhixekaecFeGc:b:c:ew2hldndnadcz9pmbabhixekabhiinaialBdbaicxfalBdbaicwfalBdbaiclfalBdbaiczfhiadc9Wfgdcs0mbkkadcl6mbinaialBdbaiclfhiadc98fgdci0mbkkdnadTmbinaiae86bbaicefhiadcufgdmbkkabkkkebcjwklz9Kbb";
    var wasm_simd = "b9H79TebbbeKl9Gbb9Gvuuuuueu9Giuuub9Geueuikqbbebeedddilve9Weeeviebeoweuec:q;Aekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbdY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVblE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtboK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbrL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbwl79IV9RbDq;t9tqlbzik9:evu8Jjjjjbcz9Rhbcbheincbhdcbhiinabcwfadfaicjuaead4ceGglE86bbaialfhiadcefgdcw9hmbkaec:q:yjjbfai86bbaecitc:q1jjbfab8Piw83ibaecefgecjd9hmbkk;h8JlHud97euo978Jjjjjbcj;kb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Rad;8qbbcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhwcbhDinaDae9pmeawaeaD9RaDawfae6Egqcsfgoc9WGgkci2hxakcethmaocl4cifcd4hPabaDad2fhscbhzdnincehHalhOcbhAdninaraO9RaP6miavcj;cbfaAak2fhCaOaPfhlcbhidnakc;ab6mbaral9Rc;Gb6mbcbhoinaCaofhidndndndndnaOaoco4fRbbgXciGPlbedibkaipxbbbbbbbbbbbbbbbbpklbxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklbalczfhlkdndndndndnaXcd4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklzxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklzalczfhlkdndndndndnaXcl4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklaxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklaalczfhlkdndndndndnaXco4Plbedibkaipxbbbbbbbbbbbbbbbbpkl8WxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalclfaYpQbfaXc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalcwfaYpQbfaXc:q:yjjbfRbbfhlxekaialpbbbpkl8Walczfhlkaoc;abfhiaocjefak0meaihoaral9Rc;Fb0mbkkdndnaiak9pmbaici4hoinaral9RcK6mdaCaifhXdndndndndnaOaico4fRbbaocoG4ciGPlbedibkaXpxbbbbbbbbbbbbbbbbpklbxikaXalpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaXalpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaXalpbbbpklbalczfhlkaocdfhoaiczfgiak6mbkkalTmbaAci6hHalhOaAcefgohAaoclSmdxekkcbhlaHceGmdkdnakTmbavcjdfazfhiavazfpbdbhYcbhXinaiavcj;cbfaXfgopblbgLcep9TaLpxeeeeeeeeeeeeeeeegQp9op9Hp9rgLaoakfpblbg8Acep9Ta8AaQp9op9Hp9rg8ApmbzeHdOiAlCvXoQrLgEaoamfpblbg3cep9Ta3aQp9op9Hp9rg3aoaxfpblbg5cep9Ta5aQp9op9Hp9rg5pmbzeHdOiAlCvXoQrLg8EpmbezHdiOAlvCXorQLgQaQpmbedibedibedibediaYp9UgYp9AdbbaiadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaEa8EpmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwKDYq8AkEx3m5P8Es8FgLa3a5pmwKDYq8AkEx3m5P8Es8Fg8ApmbezHdiOAlvCXorQLgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfhiaXczfgXak6mbkkazclfgzad6mbkasavcjdfaqad2;8qbbavavcjdfaqcufad2fad;8qbbaqaDfhDc9:hoalmexikkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;kbf8Kjjjjbaokwbz:bjjjbk;uzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecje;8kbavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:EPliuo97eue978Jjjjjbca9Rhidndnadcl9hmbdnaec98GglTmbcbhvabhdinadadpbbbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpkbbadczfhdavclfgval6mbkkalae9pmeaiaeciGgvcdtgdVcbczad9R;8kbaiabalcdtfglad;8qbbdnavTmbaiaipblbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpklbkalaiad;8qbbskdnaec98GgxTmbcbhvabhdinadczfglalpbbbgopxbbbbbbFFbbbbbbFFgkp9oadpbbbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpkbbadaDakp9oawaopmbezHdiOAlvCXorQLp9qpkbbadcafhdavclfgvax6mbkkaxae9pmbaiaeciGgvcitgdfcbcaad9R;8kbaiabaxcitfglad;8qbbdnavTmbaiaipblzgopxbbbbbbFFbbbbbbFFgkp9oaipblbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpklzaiaDakp9oawaopmbezHdiOAlvCXorQLp9qpklbkalaiad;8qbbkk;4wllue97euv978Jjjjjbc8W9Rhidnaec98GglTmbcbhvabhoinaiaopbbbgraoczfgwpbbbgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklbaopxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblbpEb:T:j83ibaocwfarp5eaipblbpEe:T:j83ibawaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblbpEd:T:j83ibaocKfakp5eaipblbpEi:T:j83ibaocafhoavclfgval6mbkkdnalae9pmbaiaeciGgvcitgofcbcaao9R;8kbaiabalcitfgwao;8qbbdnavTmbaiaipblbgraipblzgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklaaipxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblapEb:T:j83ibaiarp5eaipblapEe:T:j83iwaiaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblapEd:T:j83izaiakp5eaipblapEi:T:j83iKkawaiao;8qbbkk:Pddiue978Jjjjjbc;ab9Rhidnadcd4ae2glc98GgvTmbcbhdabheinaeaepbbbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepkbbaeczfheadclfgdav6mbkkdnaval9pmbaialciGgdcdtgeVcbc;abae9R;8kbaiabavcdtfgvae;8qbbdnadTmbaiaipblbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepklbkavaiae;8qbbkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaikkkebcjwklz9Tbb";
    var wasmpack = new Uint8Array([
        32,
        0,
        65,
        2,
        1,
        106,
        34,
        33,
        3,
        128,
        11,
        4,
        13,
        64,
        6,
        253,
        10,
        7,
        15,
        116,
        127,
        5,
        8,
        12,
        40,
        16,
        19,
        54,
        20,
        9,
        27,
        255,
        113,
        17,
        42,
        67,
        24,
        23,
        146,
        148,
        18,
        14,
        22,
        45,
        70,
        69,
        56,
        114,
        101,
        21,
        25,
        63,
        75,
        136,
        108,
        28,
        118,
        29,
        73,
        115
    ]);
    // @ts-ignore
    var wasm = SystemInfo._detectSIMDSupported() ? wasm_simd : wasm_base;
    var instance;
    ready = WebAssembly.instantiate(unpack(wasm)).then(function(result) {
        instance = result.instance;
        instance.exports.__wasm_call_ctors();
    }).then(function() {
        return {
            workerCount: 4,
            ready: ready,
            useWorkers: function useWorkers(workerCount) {
                this.workerCount = workerCount != null ? workerCount : this.workerCount;
                initWorkers(this.workerCount);
            },
            decodeGltfBuffer: function decodeGltfBuffer(count, stride, source, mode, filter) {
                if (this.workerCount > 0 && workers.length === 0) this.useWorkers();
                if (workers.length > 0) return decodeWorker(count, stride, source, decoders[mode], filters[filter]);
                return ready.then(function() {
                    var target = new Uint8Array(count * stride);
                    decode(instance.exports[decoders[mode]], target, count, stride, source, instance.exports[filters[filter]]);
                    return target;
                });
            },
            release: function release() {
                for(var i = 0; i < workers.length; i++){
                    workers[i].object.terminate();
                }
            }
        };
    });
    function unpack(data) {
        var result = new Uint8Array(data.length);
        for(var i = 0; i < data.length; ++i){
            var ch = data.charCodeAt(i);
            result[i] = ch > 96 ? ch - 97 : ch > 64 ? ch - 39 : ch + 4;
        }
        var write = 0;
        for(var i1 = 0; i1 < data.length; ++i1){
            result[write++] = result[i1] < 60 ? wasmpack[result[i1]] : (result[i1] - 60) * 64 + result[++i1];
        }
        return result.buffer.slice(0, write);
    }
    function decode(fun, target, count, size, source, filter) {
        var sbrk = instance.exports.sbrk;
        var count4 = count + 3 & -4;
        var tp = sbrk(count4 * size);
        var sp = sbrk(source.length);
        var heap = new Uint8Array(instance.exports.memory.buffer);
        heap.set(source, sp);
        var res = fun(tp, count, size, sp, source.length);
        if (res == 0 && filter) {
            filter(tp, count4, size);
        }
        target.set(heap.subarray(tp, tp + count * size));
        sbrk(tp - sbrk(0));
        if (res != 0) {
            throw new Error("Malformed buffer data: " + res);
        }
    }
    var filters = {
        NONE: "",
        OCTAHEDRAL: "meshopt_decodeFilterOct",
        QUATERNION: "meshopt_decodeFilterQuat",
        EXPONENTIAL: "meshopt_decodeFilterExp"
    };
    var decoders = {
        ATTRIBUTES: "meshopt_decodeVertexBuffer",
        TRIANGLES: "meshopt_decodeIndexBuffer",
        INDICES: "meshopt_decodeIndexSequence"
    };
    var workers = [];
    var requestId = 0;
    function createWorker(url) {
        var worker = {
            object: new Worker(url),
            pending: 0,
            requests: {}
        };
        worker.object.onmessage = function(event) {
            var data = event.data;
            worker.pending -= data.count;
            worker.requests[data.id][data.action](data.value);
            delete worker.requests[data.id];
        };
        return worker;
    }
    function initWorkers(count) {
        var source = "var instance; var ready = WebAssembly.instantiate(new Uint8Array([" + new Uint8Array(unpack(wasm)) + "]), {})" + ".then(function(result) {instance = result.instance; instance.exports.__wasm_call_ctors();});\n" + "self.onmessage = workerProcess;\n" + 'function decode(fun, target, count, size, source, filter) {\n      const sbrk = instance.exports.sbrk;\n      const count4 = (count + 3) & ~3;\n      const tp = sbrk(count4 * size);\n      const sp = sbrk(source.length);\n      const heap = new Uint8Array(instance.exports.memory.buffer);\n      heap.set(source, sp);\n      const res = fun(tp, count, size, sp, source.length);\n      if (res == 0 && filter) {\n        filter(tp, count4, size);\n      }\n      target.set(heap.subarray(tp, tp + count * size));\n      sbrk(tp - sbrk(0));\n      if (res != 0) {\n        throw new Error("Malformed buffer data: " + res);\n      }\n    }\n' + 'function workerProcess(event) {\n      ready.then(function () {\n        const data = event.data;\n        try {\n          const target = new Uint8Array(data.count * data.size);\n          decode(instance.exports[data.mode], target, data.count, data.size, data.source, instance.exports[data.filter]);\n          self.postMessage({ id: data.id, count: data.count, action: "resolve", value: target }, [target.buffer]);\n        } catch (error) {\n          self.postMessage({\n            id: data.id,\n            count: data.count,\n            action: "reject",\n            value: error\n          });\n        }\n      });\n    }';
        var blob = new Blob([
            source
        ], {
            type: "text/javascript"
        });
        var url = URL.createObjectURL(blob);
        for(var i = 0; i < count; ++i){
            workers[i] = createWorker(url);
        }
        URL.revokeObjectURL(url);
    }
    function decodeWorker(count, size, source, mode, filter) {
        var worker = workers[0];
        for(var i = 1; i < workers.length; ++i){
            if (workers[i].pending < worker.pending) {
                worker = workers[i];
            }
        }
        return new Promise(function(resolve, reject) {
            var data = new Uint8Array(source);
            var id = requestId++;
            worker.pending += count;
            worker.requests[id] = {
                resolve: resolve,
                reject: reject
            };
            worker.object.postMessage({
                id: id,
                count: count,
                size: size,
                source: data,
                mode: mode,
                filter: filter
            }, [
                data.buffer
            ]);
        });
    }
    return ready;
}

/**
 * The glTF resource.
 */ var GLTFResource = /*#__PURE__*/ function(ReferResource) {
    _inherits(GLTFResource, ReferResource);
    function GLTFResource(engine, url) {
        var _this;
        _this = ReferResource.call(this, engine) || this;
        _this.url = url;
        return _this;
    }
    var _proto = GLTFResource.prototype;
    /**
   * Instantiate scene root entity.
   * @param sceneIndex - Scene index
   * @returns Root entity
   */ _proto.instantiateSceneRoot = function instantiateSceneRoot(sceneIndex) {
        var sceneRoot = sceneIndex === undefined ? this._defaultSceneRoot : this._sceneRoots[sceneIndex];
        return sceneRoot.clone();
    };
    _proto._onDestroy = function _onDestroy() {
        ReferResource.prototype._onDestroy.call(this);
        var _this = this, textures = _this.textures, materials = _this.materials, meshes = _this.meshes;
        textures && this._disassociationSuperResource(textures);
        materials && this._disassociationSuperResource(materials);
        if (meshes) {
            for(var i = 0, n = meshes.length; i < n; i++){
                var meshArr = meshes[i];
                meshArr && this._disassociationSuperResource(meshArr);
            }
        }
    };
    _proto._disassociationSuperResource = function _disassociationSuperResource(resources) {
        for(var i = 0, n = resources.length; i < n; i++){
            var // @ts-ignore
            _resources_i;
            (_resources_i = resources[i]) == null ? void 0 : _resources_i._disassociationSuperResource(this);
        }
    };
    _create_class(GLTFResource, [
        {
            key: "extensionsData",
            get: /**
   * Extensions data.
   */ function get() {
                return this._extensionsData;
            }
        },
        {
            key: "sceneRoots",
            get: /**
   * @deprecated Please use `instantiateSceneRoot` instead.
   * RootEntities after SceneParser.
   */ function get() {
                return this._sceneRoots;
            }
        },
        {
            key: "defaultSceneRoot",
            get: /**
   * @deprecated Please use `instantiateSceneRoot` instead.
   * RootEntity after SceneParser.
   */ function get() {
                return this._defaultSceneRoot;
            }
        }
    ]);
    return GLTFResource;
}(ReferResource);

/**
 * Module for glTF 2.0 Interface
 */ /**
 * The datatype of the components in the attribute
 */ var AccessorComponentType = /*#__PURE__*/ function(AccessorComponentType) {
    /**
   * Byte
   */ AccessorComponentType[AccessorComponentType["BYTE"] = 5120] = "BYTE";
    /**
   * Unsigned Byte
   */ AccessorComponentType[AccessorComponentType["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
    /**
   * Short
   */ AccessorComponentType[AccessorComponentType["SHORT"] = 5122] = "SHORT";
    /**
   * Unsigned Short
   */ AccessorComponentType[AccessorComponentType["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
    /**
   * Unsigned Int
   */ AccessorComponentType[AccessorComponentType["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
    /**
   * Float
   */ AccessorComponentType[AccessorComponentType["FLOAT"] = 5126] = "FLOAT";
    return AccessorComponentType;
}({});
/**
 * Specifies if the attirbute is a scalar, vector, or matrix
 */ var AccessorType = /*#__PURE__*/ function(AccessorType) {
    /**
   * Scalar
   */ AccessorType["SCALAR"] = "SCALAR";
    /**
   * Vector2
   */ AccessorType["VEC2"] = "VEC2";
    /**
   * Vector3
   */ AccessorType["VEC3"] = "VEC3";
    /**
   * Vector4
   */ AccessorType["VEC4"] = "VEC4";
    /**
   * Matrix2x2
   */ AccessorType["MAT2"] = "MAT2";
    /**
   * Matrix3x3
   */ AccessorType["MAT3"] = "MAT3";
    /**
   * Matrix4x4
   */ AccessorType["MAT4"] = "MAT4";
    return AccessorType;
}({});
/**
 * The name of the node's TRS property to modify, or the weights of the Morph Targets it instantiates
 */ var AnimationChannelTargetPath = /*#__PURE__*/ function(AnimationChannelTargetPath) {
    /**
   * Translation
   */ AnimationChannelTargetPath["TRANSLATION"] = "translation";
    /**
   * Rotation
   */ AnimationChannelTargetPath["ROTATION"] = "rotation";
    /**
   * Scale
   */ AnimationChannelTargetPath["SCALE"] = "scale";
    /**
   * Weights
   */ AnimationChannelTargetPath["WEIGHTS"] = "weights";
    return AnimationChannelTargetPath;
}({});
/**
 * Interpolation algorithm
 */ var AnimationSamplerInterpolation = /*#__PURE__*/ function(AnimationSamplerInterpolation) {
    /**
   * The animated values are linearly interpolated between keyframes
   */ AnimationSamplerInterpolation["Linear"] = "LINEAR";
    /**
   * The animated values remain constant to the output of the first keyframe, until the next keyframe
   */ AnimationSamplerInterpolation["Step"] = "STEP";
    /**
   * The animation's interpolation is computed using a cubic spline with specified tangents
   */ AnimationSamplerInterpolation["CubicSpine"] = "CUBICSPLINE";
    return AnimationSamplerInterpolation;
}({});
/**
 * A camera's projection.  A node can reference a camera to apply a transform to place the camera in the scene
 */ var CameraType = /*#__PURE__*/ function(CameraType) {
    /**
   * A perspective camera containing properties to create a perspective projection matrix
   */ CameraType["PERSPECTIVE"] = "perspective";
    /**
   * An orthographic camera containing properties to create an orthographic projection matrix
   */ CameraType["ORTHOGRAPHIC"] = "orthographic";
    return CameraType;
}({});
/**
 * The alpha rendering mode of the material
 */ var MaterialAlphaMode = /*#__PURE__*/ function(MaterialAlphaMode) {
    /**
   * The alpha value is ignored and the rendered output is fully opaque
   */ MaterialAlphaMode["OPAQUE"] = "OPAQUE";
    /**
   * The rendered output is either fully opaque or fully transparent depending on the alpha value and the specified alpha cutoff value
   */ MaterialAlphaMode["MASK"] = "MASK";
    /**
   * The alpha value is used to composite the source and destination areas. The rendered output is combined with the background using the normal painting operation (i.e. the Porter and Duff over operator)
   */ MaterialAlphaMode["BLEND"] = "BLEND";
    return MaterialAlphaMode;
}({});
/**
 * Magnification filter.  Valid values correspond to WebGL enums: 9728 (NEAREST) and 9729 (LINEAR)
 */ var TextureMagFilter = /*#__PURE__*/ function(TextureMagFilter) {
    /**
   * Nearest
   */ TextureMagFilter[TextureMagFilter["NEAREST"] = 9728] = "NEAREST";
    /**
   * Linear
   */ TextureMagFilter[TextureMagFilter["LINEAR"] = 9729] = "LINEAR";
    return TextureMagFilter;
}({});
/**
 * Minification filter.  All valid values correspond to WebGL enums
 */ var TextureMinFilter = /*#__PURE__*/ function(TextureMinFilter) {
    /**
   * Nearest
   */ TextureMinFilter[TextureMinFilter["NEAREST"] = 9728] = "NEAREST";
    /**
   * Linear
   */ TextureMinFilter[TextureMinFilter["LINEAR"] = 9729] = "LINEAR";
    /**
   * Nearest Mip-Map Nearest
   */ TextureMinFilter[TextureMinFilter["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
    /**
   * Linear Mipmap Nearest
   */ TextureMinFilter[TextureMinFilter["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
    /**
   * Nearest Mipmap Linear
   */ TextureMinFilter[TextureMinFilter["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
    /**
   * Linear Mipmap Linear
   */ TextureMinFilter[TextureMinFilter["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
    return TextureMinFilter;
}({});
/**
 * S (U) wrapping mode.  All valid values correspond to WebGL enums
 */ var TextureWrapMode = /*#__PURE__*/ function(TextureWrapMode) {
    /**
   * Clamp to Edge
   */ TextureWrapMode[TextureWrapMode["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
    /**
   * Mirrored Repeat
   */ TextureWrapMode[TextureWrapMode["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
    /**
   * Repeat
   */ TextureWrapMode[TextureWrapMode["REPEAT"] = 10497] = "REPEAT";
    return TextureWrapMode;
}({});

/**
 * @internal
 */ var GLTFParserContext = /*#__PURE__*/ function() {
    function GLTFParserContext(glTFResource, resourceManager, params) {
        var _this = this;
        this.glTFResource = glTFResource;
        this.resourceManager = resourceManager;
        this.params = params;
        this.accessorBufferCache = {};
        this.needAnimatorController = false;
        this./** @internal */ _getPromises = [];
        this._resourceCache = new Map();
        this._progress = {
            taskDetail: {},
            taskComplete: {
                loaded: 0,
                total: 0
            }
        };
        this./**
   * @internal
   */ _onTaskDetail = function(url, loaded, total) {
            var _this__progress_taskDetail, _url;
            var detail = (_this__progress_taskDetail = _this._progress.taskDetail)[_url = url] || (_this__progress_taskDetail[_url] = {});
            detail.loaded = loaded;
            detail.total = total;
            _this._setTaskDetailProgress(url, loaded, total);
        };
        this.contentRestorer = new GLTFContentRestorer(glTFResource);
    }
    var _proto = GLTFParserContext.prototype;
    _proto.get = function get(type, index) {
        var _this = this;
        var parser = GLTFParserContext._parsers[type];
        if (!parser) {
            return AssetPromise.resolve(null);
        }
        var cache = this._resourceCache;
        var cacheKey = index === undefined ? "" + type : type + ":" + index;
        var resource = cache.get(cacheKey);
        if (resource) {
            return resource;
        }
        var glTFSchemaKey = glTFSchemaMap[type];
        var isSubAsset = !!glTFResourceMap[type];
        if (glTFSchemaKey) {
            var glTFItems = this.glTF[glTFSchemaKey];
            if (glTFItems && (index === undefined || glTFItems[index])) {
                if (index === undefined) {
                    resource = type === 8 ? glTFItems.map(function(_, index) {
                        return _this.get(type, index);
                    }) : AssetPromise.all(glTFItems.map(function(_, index) {
                        return _this.get(type, index);
                    }));
                } else {
                    resource = parser.parse(this, index);
                    isSubAsset && this._handleSubAsset(resource, type, index);
                }
            } else {
                resource = AssetPromise.resolve(null);
            }
        } else {
            resource = parser.parse(this, index);
            isSubAsset && this._handleSubAsset(resource, type, index);
        }
        if (_instanceof$1(resource, AssetPromise)) {
            this._getPromises.push(resource);
        }
        cache.set(cacheKey, resource);
        return resource;
    };
    _proto.parse = function parse() {
        var _this = this;
        var promise = this.get(0).then(function(json) {
            _this.glTF = json;
            _this.needAnimatorController = !!(json.skins || json.animations);
            return AssetPromise.all([
                _this.get(1),
                _this.get(5),
                _this.get(6),
                _this.get(7),
                _this.get(9),
                _this.get(10),
                _this.get(11),
                _this.get(2)
            ]).then(function() {
                var glTFResource = _this.glTFResource;
                var animatorController = glTFResource.animatorController;
                if (animatorController) {
                    var animator = glTFResource._defaultSceneRoot.addComponent(Animator);
                    animator.animatorController = animatorController;
                }
                _this.resourceManager.addContentRestorer(_this.contentRestorer);
                return glTFResource;
            });
        });
        this._addTaskCompletePromise(promise);
        return promise;
    };
    /**
   * @internal
   */ _proto._addTaskCompletePromise = function _addTaskCompletePromise(taskPromise) {
        var _this = this;
        var task = this._progress.taskComplete;
        task.total += 1;
        taskPromise.then(function() {
            _this._setTaskCompleteProgress(++task.loaded, task.total);
        }, function() {});
    };
    _proto._handleSubAsset = function _handleSubAsset(resource, type, index) {
        var _this = this;
        var glTFResourceKey = glTFResourceMap[type];
        if (type === 8) {
            var _this_glTFResource, _glTFResourceKey;
            ((_this_glTFResource = this.glTFResource)[_glTFResourceKey = glTFResourceKey] || (_this_glTFResource[_glTFResourceKey] = []))[index] = resource;
        } else {
            var url = this.glTFResource.url;
            resource.then(function(item) {
                if (index == undefined) {
                    _this.glTFResource[glTFResourceKey] = item;
                } else {
                    var _this_glTFResource, _glTFResourceKey;
                    ((_this_glTFResource = _this.glTFResource)[_glTFResourceKey = glTFResourceKey] || (_this_glTFResource[_glTFResourceKey] = []))[index] = item;
                }
                if (type === 7) {
                    for(var i = 0, length = item.length; i < length; i++){
                        var mesh = item[i];
                        // @ts-ignore
                        _this.resourceManager._onSubAssetSuccess(url, glTFResourceKey + "[" + index + "][" + i + "]", mesh);
                    }
                } else {
                    // @ts-ignore
                    _this.resourceManager._onSubAssetSuccess(url, "" + glTFResourceKey + (index === undefined ? "" : "[" + index + "]"), item);
                    var _this_glTF_scene;
                    if (type === 2 && ((_this_glTF_scene = _this.glTF.scene) != null ? _this_glTF_scene : 0) === index) {
                        // @ts-ignore
                        _this.resourceManager._onSubAssetSuccess(url, "defaultSceneRoot", item);
                    }
                }
            }).catch(function(e) {
                Logger.error("GLTFParserContext", "Failed to load " + glTFResourceKey + " " + index + ": " + e);
            });
        }
    };
    GLTFParserContext.addParser = function addParser(parserType, parser) {
        this._parsers[parserType] = parser;
    };
    return GLTFParserContext;
}();
GLTFParserContext._parsers = {};
/**
 * @internal
 */ var BufferInfo = function BufferInfo(data, interleaved, stride) {
    this.data = data;
    this.interleaved = interleaved;
    this.stride = stride;
    this.vertexBindingInfos = {};
};
var GLTFParserType = /*#__PURE__*/ function(GLTFParserType) {
    GLTFParserType[GLTFParserType["Schema"] = 0] = "Schema";
    GLTFParserType[GLTFParserType["Validator"] = 1] = "Validator";
    GLTFParserType[GLTFParserType["Scene"] = 2] = "Scene";
    GLTFParserType[GLTFParserType["Buffer"] = 3] = "Buffer";
    GLTFParserType[GLTFParserType["BufferView"] = 4] = "BufferView";
    GLTFParserType[GLTFParserType["Texture"] = 5] = "Texture";
    GLTFParserType[GLTFParserType["Material"] = 6] = "Material";
    GLTFParserType[GLTFParserType["Mesh"] = 7] = "Mesh";
    GLTFParserType[GLTFParserType["Entity"] = 8] = "Entity";
    GLTFParserType[GLTFParserType["Skin"] = 9] = "Skin";
    GLTFParserType[GLTFParserType["Animation"] = 10] = "Animation";
    GLTFParserType[GLTFParserType["AnimatorController"] = 11] = "AnimatorController";
    return GLTFParserType;
}({});
var _obj$3;
var glTFSchemaMap = (_obj$3 = {}, _obj$3[2] = "scenes", _obj$3[3] = "buffers", _obj$3[5] = "textures", _obj$3[6] = "materials", _obj$3[7] = "meshes", _obj$3[8] = "nodes", _obj$3[9] = "skins", _obj$3[10] = "animations", _obj$3[4] = "bufferViews", _obj$3);
var _obj1$1;
var glTFResourceMap = (_obj1$1 = {}, _obj1$1[2] = "_sceneRoots", _obj1$1[5] = "textures", _obj1$1[6] = "materials", _obj1$1[7] = "meshes", _obj1$1[8] = "entities", _obj1$1[9] = "skins", _obj1$1[10] = "animations", _obj1$1[11] = "animatorController", _obj1$1);
function registerGLTFParser(pipeline) {
    return function(Parser) {
        var parser = new Parser();
        GLTFParserContext.addParser(pipeline, parser);
    };
}

/**
 * @internal
 */ var GLTFUtils = /*#__PURE__*/ function() {
    function GLTFUtils() {}
    GLTFUtils.floatBufferToVector2Array = function floatBufferToVector2Array(buffer) {
        var bufferLen = buffer.length;
        var array = new Array(bufferLen / 2);
        for(var i = 0; i < bufferLen; i += 2){
            array[i / 2] = new Vector2(buffer[i], buffer[i + 1]);
        }
        return array;
    };
    GLTFUtils.floatBufferToVector3Array = function floatBufferToVector3Array(buffer) {
        var bufferLen = buffer.length;
        var array = new Array(bufferLen / 3);
        for(var i = 0; i < bufferLen; i += 3){
            array[i / 3] = new Vector3(buffer[i], buffer[i + 1], buffer[i + 2]);
        }
        return array;
    };
    GLTFUtils.floatBufferToVector4Array = function floatBufferToVector4Array(buffer) {
        var bufferLen = buffer.length;
        var array = new Array(bufferLen / 4);
        for(var i = 0; i < bufferLen; i += 4){
            array[i / 4] = new Vector4(buffer[i], buffer[i + 1], buffer[i + 2], buffer[i + 3]);
        }
        return array;
    };
    GLTFUtils.floatBufferToColorArray = function floatBufferToColorArray(buffer, isColor3) {
        var bufferLen = buffer.length;
        var colors = new Array(bufferLen / (isColor3 ? 3 : 4));
        if (isColor3) {
            for(var i = 0; i < bufferLen; i += 3){
                colors[i / 3] = new Color(buffer[i], buffer[i + 1], buffer[i + 2], 1.0);
            }
        } else {
            for(var i1 = 0; i1 < bufferLen; i1 += 4){
                colors[i1 / 4] = new Color(buffer[i1], buffer[i1 + 1], buffer[i1 + 2], buffer[i1 + 3]);
            }
        }
        return colors;
    };
    /**
   * Get the number of bytes occupied by accessor type.
   */ GLTFUtils.getAccessorTypeSize = function getAccessorTypeSize(accessorType) {
        switch(accessorType){
            case AccessorType.SCALAR:
                return 1;
            case AccessorType.VEC2:
                return 2;
            case AccessorType.VEC3:
                return 3;
            case AccessorType.VEC4:
                return 4;
            case AccessorType.MAT2:
                return 4;
            case AccessorType.MAT3:
                return 9;
            case AccessorType.MAT4:
                return 16;
        }
    };
    /**
   * Get the TypedArray corresponding to the component type.
   */ GLTFUtils.getComponentType = function getComponentType(componentType) {
        switch(componentType){
            case AccessorComponentType.BYTE:
                return Int8Array;
            case AccessorComponentType.UNSIGNED_BYTE:
                return Uint8Array;
            case AccessorComponentType.SHORT:
                return Int16Array;
            case AccessorComponentType.UNSIGNED_SHORT:
                return Uint16Array;
            case AccessorComponentType.UNSIGNED_INT:
                return Uint32Array;
            case AccessorComponentType.FLOAT:
                return Float32Array;
        }
    };
    GLTFUtils.getNormalizedComponentScale = function getNormalizedComponentScale(componentType) {
        // Reference: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data
        switch(componentType){
            case AccessorComponentType.BYTE:
                return 1 / 127;
            case AccessorComponentType.UNSIGNED_BYTE:
                return 1 / 255;
            case AccessorComponentType.SHORT:
                return 1 / 32767;
            case AccessorComponentType.UNSIGNED_SHORT:
                return 1 / 65535;
            default:
                throw new Error("Galacean.GLTFLoader: Unsupported normalized accessor component type.");
        }
    };
    GLTFUtils.getAccessorBuffer = function getAccessorBuffer(context, bufferViews, accessor) {
        var componentType = accessor.componentType;
        var TypedArray = GLTFUtils.getComponentType(componentType);
        var dataElementSize = GLTFUtils.getAccessorTypeSize(accessor.type);
        var dataElementBytes = TypedArray.BYTES_PER_ELEMENT;
        var elementStride = dataElementSize * dataElementBytes;
        var accessorCount = accessor.count;
        var promise;
        if (accessor.bufferView !== undefined) {
            var bufferViewIndex = accessor.bufferView;
            var bufferView = bufferViews[bufferViewIndex];
            promise = context.get(GLTFParserType.BufferView, accessor.bufferView).then(function(bufferViewData) {
                var bufferIndex = bufferView.buffer;
                var _bufferViewData_byteOffset;
                var bufferByteOffset = (_bufferViewData_byteOffset = bufferViewData.byteOffset) != null ? _bufferViewData_byteOffset : 0;
                var _accessor_byteOffset;
                var byteOffset = (_accessor_byteOffset = accessor.byteOffset) != null ? _accessor_byteOffset : 0;
                var bufferStride = bufferView.byteStride;
                var bufferInfo;
                // According to the glTF official documentation only byteStride not undefined is allowed
                if (bufferStride !== undefined && bufferStride !== elementStride) {
                    var bufferSlice = Math.floor(byteOffset / bufferStride);
                    var bufferCacheKey = bufferViewIndex + ":" + componentType + ":" + bufferSlice + ":" + accessorCount;
                    var accessorBufferCache = context.accessorBufferCache;
                    bufferInfo = accessorBufferCache[bufferCacheKey];
                    if (!bufferInfo) {
                        var offset = bufferByteOffset + bufferSlice * bufferStride;
                        var count = accessorCount * (bufferStride / dataElementBytes);
                        var data = new TypedArray(bufferViewData.buffer, offset, count);
                        accessorBufferCache[bufferCacheKey] = bufferInfo = new BufferInfo(data, true, bufferStride);
                        bufferInfo.restoreInfo = new BufferDataRestoreInfo(new RestoreDataAccessor(bufferIndex, TypedArray, offset, count));
                    }
                } else {
                    var offset1 = bufferByteOffset + byteOffset;
                    var count1 = accessorCount * dataElementSize;
                    var data1 = new TypedArray(bufferViewData.buffer, offset1, count1);
                    bufferInfo = new BufferInfo(data1, false, elementStride);
                    bufferInfo.restoreInfo = new BufferDataRestoreInfo(new RestoreDataAccessor(bufferIndex, TypedArray, offset1, count1));
                }
                return bufferInfo;
            }).catch(function(e) {
                Logger.error("GLTFUtil getAccessorBuffer error", e);
            });
        } else {
            var count = accessorCount * dataElementSize;
            var data = new TypedArray(count);
            var bufferInfo = new BufferInfo(data, false, elementStride);
            bufferInfo.restoreInfo = new BufferDataRestoreInfo(new RestoreDataAccessor(undefined, TypedArray, undefined, count));
            promise = AssetPromise.resolve(bufferInfo);
        }
        return accessor.sparse ? promise.then(function(bufferInfo) {
            return GLTFUtils.processingSparseData(context, accessor, bufferInfo).then(function() {
                return bufferInfo;
            });
        }) : promise;
    };
    GLTFUtils.bufferToVector3Array = function bufferToVector3Array(buffer, byteOffset, count, normalized, componentType) {
        var baseOffset = byteOffset / buffer.BYTES_PER_ELEMENT;
        var stride = buffer.length / count;
        var vertices = new Array(count);
        var factor = normalized ? GLTFUtils.getNormalizedComponentScale(componentType) : 1;
        for(var i = 0; i < count; i++){
            var index = baseOffset + i * stride;
            vertices[i] = new Vector3(buffer[index] * factor, buffer[index + 1] * factor, buffer[index + 2] * factor);
        }
        return vertices;
    };
    GLTFUtils.getBufferViewData = function getBufferViewData(bufferView, buffers) {
        var _bufferView_byteOffset = bufferView.byteOffset, byteOffset = _bufferView_byteOffset === void 0 ? 0 : _bufferView_byteOffset;
        var arrayBuffer = buffers[bufferView.buffer];
        return arrayBuffer.slice(byteOffset, byteOffset + bufferView.byteLength);
    };
    /**
   * Get accessor data.
   */ GLTFUtils.processingSparseData = function processingSparseData(context, accessor, bufferInfo) {
        var restoreInfo = bufferInfo.restoreInfo;
        var bufferViews = context.glTF.bufferViews;
        var accessorTypeSize = GLTFUtils.getAccessorTypeSize(accessor.type);
        var TypedArray = GLTFUtils.getComponentType(accessor.componentType);
        var data = bufferInfo.data.slice();
        var _accessor_sparse = accessor.sparse, count = _accessor_sparse.count, indices = _accessor_sparse.indices, values = _accessor_sparse.values;
        var indicesBufferView = bufferViews[indices.bufferView];
        var valuesBufferView = bufferViews[values.bufferView];
        return AssetPromise.all([
            context.get(GLTFParserType.BufferView, indices.bufferView),
            context.get(GLTFParserType.BufferView, values.bufferView)
        ]).then(function(param) {
            var indicesUint8Array = param[0], valuesUin8Array = param[1];
            var _indices_byteOffset, _indicesUint8Array_byteOffset;
            var indicesByteOffset = ((_indices_byteOffset = indices.byteOffset) != null ? _indices_byteOffset : 0) + ((_indicesUint8Array_byteOffset = indicesUint8Array.byteOffset) != null ? _indicesUint8Array_byteOffset : 0);
            var indicesByteLength = indicesUint8Array.byteLength;
            var _values_byteOffset, _valuesUin8Array_byteOffset;
            var valuesByteOffset = ((_values_byteOffset = values.byteOffset) != null ? _values_byteOffset : 0) + ((_valuesUin8Array_byteOffset = valuesUin8Array.byteOffset) != null ? _valuesUin8Array_byteOffset : 0);
            var valuesByteLength = valuesUin8Array.byteLength;
            restoreInfo.typeSize = accessorTypeSize;
            restoreInfo.sparseCount = count;
            var IndexTypeArray = GLTFUtils.getComponentType(indices.componentType);
            var indexLength = indicesByteLength / IndexTypeArray.BYTES_PER_ELEMENT;
            var indicesArray = new IndexTypeArray(indicesUint8Array.buffer, indicesByteOffset, indexLength);
            restoreInfo.sparseIndices = new RestoreDataAccessor(indicesBufferView.buffer, IndexTypeArray, indicesByteOffset, indexLength);
            var valueLength = valuesByteLength / TypedArray.BYTES_PER_ELEMENT;
            var valuesArray = new TypedArray(valuesUin8Array.buffer, valuesByteOffset, valueLength);
            restoreInfo.sparseValues = new RestoreDataAccessor(valuesBufferView.buffer, TypedArray, valuesByteOffset, valueLength);
            for(var i = 0; i < count; i++){
                var replaceIndex = indicesArray[i];
                for(var j = 0; j < accessorTypeSize; j++){
                    data[replaceIndex * accessorTypeSize + j] = valuesArray[i * accessorTypeSize + j];
                }
            }
            bufferInfo.data = data;
        }).catch(function(e) {
            Logger.error("GLTFUtil processingSparseData error", e);
        });
    };
    GLTFUtils.getIndexFormat = function getIndexFormat(type) {
        switch(type){
            case AccessorComponentType.UNSIGNED_BYTE:
                return IndexFormat.UInt8;
            case AccessorComponentType.UNSIGNED_SHORT:
                return IndexFormat.UInt16;
            case AccessorComponentType.UNSIGNED_INT:
                return IndexFormat.UInt32;
        }
    };
    GLTFUtils.getElementFormat = function getElementFormat(type, size, normalized) {
        if (normalized === void 0) normalized = false;
        if (type == AccessorComponentType.FLOAT) {
            switch(size){
                case 1:
                    return VertexElementFormat.Float;
                case 2:
                    return VertexElementFormat.Vector2;
                case 3:
                    return VertexElementFormat.Vector3;
                case 4:
                    return VertexElementFormat.Vector4;
            }
        }
        if (type == AccessorComponentType.SHORT) {
            switch(size){
                case 2:
                    return normalized ? VertexElementFormat.NormalizedShort2 : VertexElementFormat.Short2;
                case 3:
                case 4:
                    return normalized ? VertexElementFormat.NormalizedShort4 : VertexElementFormat.Short4;
            }
        }
        if (type == AccessorComponentType.UNSIGNED_SHORT) {
            switch(size){
                case 2:
                    return normalized ? VertexElementFormat.NormalizedUShort2 : VertexElementFormat.UShort2;
                case 3:
                case 4:
                    return normalized ? VertexElementFormat.NormalizedUShort4 : VertexElementFormat.UShort4;
            }
        }
        if (type == AccessorComponentType.BYTE) {
            switch(size){
                case 2:
                case 3:
                case 4:
                    return normalized ? VertexElementFormat.NormalizedByte4 : VertexElementFormat.Byte4;
            }
        }
        if (type == AccessorComponentType.UNSIGNED_BYTE) {
            switch(size){
                case 2:
                case 3:
                case 4:
                    return normalized ? VertexElementFormat.NormalizedUByte4 : VertexElementFormat.UByte4;
            }
        }
    };
    /**
   * Load image buffer
   */ GLTFUtils.loadImageBuffer = function loadImageBuffer(imageBuffer, type) {
        return new Promise(function(resolve, reject) {
            var blob = new window.Blob([
                imageBuffer
            ], {
                type: type
            });
            var img = new Image();
            img.onerror = function() {
                reject(new Error("Failed to load image buffer"));
            };
            img.onload = function() {
                // Call requestAnimationFrame to avoid iOS's bug.
                requestAnimationFrame(function() {
                    resolve(img);
                    img.onload = null;
                    img.onerror = null;
                    img.onabort = null;
                });
            };
            img.crossOrigin = "anonymous";
            img.src = URL.createObjectURL(blob);
        });
    };
    /**
   * Parse the glb format.
   */ GLTFUtils.parseGLB = function parseGLB(context, originBuffer) {
        var UINT32_LENGTH = 4;
        var GLB_HEADER_MAGIC = 0x46546c67; // 'glTF'
        var GLB_HEADER_LENGTH = 12;
        var GLB_CHUNK_TYPES = {
            JSON: 0x4e4f534a,
            BIN: 0x004e4942
        };
        var dataView = new DataView(originBuffer);
        // Read header
        var header = {
            magic: dataView.getUint32(0, true),
            version: dataView.getUint32(UINT32_LENGTH, true),
            length: dataView.getUint32(2 * UINT32_LENGTH, true)
        };
        // Return the original buffer if it is not a glb
        if (header.magic !== GLB_HEADER_MAGIC) {
            return {
                originBuffer: originBuffer
            };
        }
        // Read main data
        var chunkLength = dataView.getUint32(GLB_HEADER_LENGTH, true);
        var chunkType = dataView.getUint32(GLB_HEADER_LENGTH + UINT32_LENGTH, true);
        // Read glTF json
        if (chunkType !== GLB_CHUNK_TYPES.JSON) {
            console.error("Invalid glb chunk type. Expected 0x4E4F534A, found 0x" + chunkType.toString(16));
            return null;
        }
        var glTFData = new Uint8Array(originBuffer, GLB_HEADER_LENGTH + 2 * UINT32_LENGTH, chunkLength);
        var glTF = JSON.parse(Utils.decodeText(glTFData));
        // Read all buffers
        var buffers = [];
        var byteOffset = GLB_HEADER_LENGTH + 2 * UINT32_LENGTH + chunkLength;
        var restoreGLBBufferSlice = context.contentRestorer.glbBufferSlices;
        while(byteOffset < header.length){
            chunkLength = dataView.getUint32(byteOffset, true);
            chunkType = dataView.getUint32(byteOffset + UINT32_LENGTH, true);
            if (chunkType !== GLB_CHUNK_TYPES.BIN) {
                console.error("Invalid glb chunk type. Expected 0x004E4942, found 0x" + chunkType.toString(16));
                return null;
            }
            var currentOffset = byteOffset + 2 * UINT32_LENGTH;
            var buffer = originBuffer.slice(currentOffset, currentOffset + chunkLength);
            buffers.push(buffer);
            restoreGLBBufferSlice.push(new Vector2(currentOffset, chunkLength));
            byteOffset += chunkLength + 2 * UINT32_LENGTH;
        }
        return {
            glTF: glTF,
            buffers: buffers
        };
    };
    GLTFUtils.parseSampler = function parseSampler(texture, samplerInfo) {
        var filterMode = samplerInfo.filterMode, wrapModeU = samplerInfo.wrapModeU, wrapModeV = samplerInfo.wrapModeV;
        if (filterMode !== undefined) {
            texture.filterMode = filterMode;
        }
        if (wrapModeU !== undefined) {
            texture.wrapModeU = wrapModeU;
        }
        if (wrapModeV !== undefined) {
            texture.wrapModeV = wrapModeV;
        }
    };
    GLTFUtils.getSamplerInfo = function getSamplerInfo(sampler) {
        var minFilter = sampler.minFilter, magFilter = sampler.magFilter, wrapS = sampler.wrapS, wrapT = sampler.wrapT;
        var info = {};
        if (minFilter || magFilter) {
            info.mipmap = minFilter >= TextureMinFilter.NEAREST_MIPMAP_NEAREST;
            if (magFilter === TextureMagFilter.NEAREST) {
                info.filterMode = TextureFilterMode.Point;
            } else {
                if (minFilter <= TextureMinFilter.LINEAR_MIPMAP_NEAREST) {
                    info.filterMode = TextureFilterMode.Bilinear;
                } else {
                    info.filterMode = TextureFilterMode.Trilinear;
                }
            }
        }
        if (wrapS) {
            info.wrapModeU = GLTFTextureParser._wrapMap[wrapS];
        }
        if (wrapT) {
            info.wrapModeV = GLTFTextureParser._wrapMap[wrapT];
        }
        return info;
    };
    return GLTFUtils;
}();

var DFDTransferFunction = /*#__PURE__*/ function(DFDTransferFunction) {
    DFDTransferFunction[DFDTransferFunction["linear"] = 1] = "linear";
    DFDTransferFunction[DFDTransferFunction["sRGB"] = 2] = "sRGB";
    return DFDTransferFunction;
}({});
var SupercompressionScheme = /*#__PURE__*/ function(SupercompressionScheme) {
    SupercompressionScheme[SupercompressionScheme["None"] = 0] = "None";
    SupercompressionScheme[SupercompressionScheme["BasisLZ"] = 1] = "BasisLZ";
    SupercompressionScheme[SupercompressionScheme["Zstd"] = 2] = "Zstd";
    SupercompressionScheme[SupercompressionScheme["ZLib"] = 3] = "ZLib";
    return SupercompressionScheme;
}({});
/** @internal */ var KTX2Container = /*#__PURE__*/ function() {
    function KTX2Container(buffer) {
        this.vkFormat = 0;
        this.typeSize = 1;
        this.pixelWidth = 0;
        this.pixelHeight = 0;
        this.pixelDepth = 0;
        this.layerCount = 0;
        this.faceCount = 1;
        this.supercompressionScheme = 0;
        this.levels = [];
        this.keyValue = {};
        this.globalData = null;
        this.parse(buffer);
    }
    var _proto = KTX2Container.prototype;
    _proto.parse = function parse(data) {
        var buffer = data.buffer;
        var byteOffset = data.byteOffset;
        var headerBufferReader = new BufferReader(data, 12);
        this.vkFormat = headerBufferReader.nextUint32();
        this.typeSize = headerBufferReader.nextUint32();
        this.pixelWidth = headerBufferReader.nextUint32();
        this.pixelHeight = headerBufferReader.nextUint32();
        this.pixelDepth = headerBufferReader.nextUint32();
        this.layerCount = headerBufferReader.nextUint32();
        this.faceCount = headerBufferReader.nextUint32();
        var levelCount = Math.max(1, headerBufferReader.nextUint32());
        this.supercompressionScheme = headerBufferReader.nextUint32();
        var dfdByteOffset = headerBufferReader.nextUint32();
        var dfdByteLength = headerBufferReader.nextUint32();
        var kvdByteOffset = headerBufferReader.nextUint32();
        var kvdByteLength = headerBufferReader.nextUint32();
        var sgdByteOffset = headerBufferReader.nextUint64();
        var sgdByteLength = headerBufferReader.nextUint64();
        // level index
        var ktxLevels = new Array(levelCount);
        var levelByteLength = levelCount * 3 * 8;
        var levelReader = new BufferReader(data, headerBufferReader.offset, levelByteLength);
        this.levels = ktxLevels;
        for(var i = 0; i < levelCount; i++){
            ktxLevels[i] = {
                levelData: new Uint8Array(buffer, byteOffset + levelReader.nextUint64(), levelReader.nextUint64()),
                uncompressedByteLength: levelReader.nextUint64()
            };
        }
        // Data Format Descriptor (DFD).
        var dfdReader = new BufferReader(data, dfdByteOffset, dfdByteLength);
        var dfd = {
            vendorId: dfdReader.skip(4 /* totalSize */ ).nextUint16(),
            descriptorType: dfdReader.nextUint16(),
            versionNumber: dfdReader.nextUint16(),
            descriptorBlockSize: dfdReader.nextUint16(),
            colorModel: dfdReader.nextUint8(),
            colorPrimaries: dfdReader.nextUint8(),
            transferFunction: dfdReader.nextUint8(),
            flags: dfdReader.nextUint8(),
            texelBlockDimension: [
                dfdReader.nextUint8(),
                dfdReader.nextUint8(),
                dfdReader.nextUint8(),
                dfdReader.nextUint8()
            ],
            bytesPlane: [
                dfdReader.nextUint8(),
                dfdReader.nextUint8(),
                dfdReader.nextUint8(),
                dfdReader.nextUint8(),
                dfdReader.nextUint8(),
                dfdReader.nextUint8(),
                dfdReader.nextUint8(),
                dfdReader.nextUint8()
            ],
            samples: []
        };
        this.dataFormatDescriptor = dfd;
        var sampleStart = 6;
        var sampleWords = 4;
        var numSamples = (dfd.descriptorBlockSize / 4 - sampleStart) / sampleWords;
        for(var i1 = 0; i1 < numSamples; i1++){
            var sample = {
                bitOffset: dfdReader.nextUint16(),
                bitLength: dfdReader.nextUint8(),
                channelType: dfdReader.nextUint8(),
                samplePosition: [
                    dfdReader.nextUint8(),
                    dfdReader.nextUint8(),
                    dfdReader.nextUint8(),
                    dfdReader.nextUint8()
                ],
                sampleLower: -Infinity,
                sampleUpper: Infinity
            };
            if (sample.channelType & 0x40) {
                sample.sampleLower = dfdReader.nextInt32();
                sample.sampleUpper = dfdReader.nextInt32();
            } else {
                sample.sampleLower = dfdReader.nextUint32();
                sample.sampleUpper = dfdReader.nextUint32();
            }
            dfd.samples[i1] = sample;
        }
        var kvdReader = new BufferReader(data, kvdByteOffset, kvdByteLength, true);
        while(kvdReader.position < kvdByteLength){
            var keyValueByteLength = kvdReader.nextUint32();
            var keyData = kvdReader.scan(keyValueByteLength);
            var key = Utils.decodeText(keyData);
            // 4-byte alignment.
            var valueData = kvdReader.nextUint8Array(keyValueByteLength - keyData.byteLength - 1);
            this.keyValue[key] = key.match(/^ktx/i) ? Utils.decodeText(valueData).replace(/^(.*)\x00$/, "$1") : valueData;
            var kvPadding = keyValueByteLength % 4 ? 4 - keyValueByteLength % 4 : 0; // align(4)
            // 4-byte alignment.
            kvdReader.skip(kvPadding);
        }
        if (sgdByteLength <= 0) return this;
        var sgdReader = new BufferReader(data, sgdByteOffset, sgdByteLength, true);
        var endpointCount = sgdReader.nextUint16();
        var selectorCount = sgdReader.nextUint16();
        var endpointsByteLength = sgdReader.nextUint32();
        var selectorsByteLength = sgdReader.nextUint32();
        var tablesByteLength = sgdReader.nextUint32();
        var extendedByteLength = sgdReader.nextUint32();
        var imageDescs = new Array(levelCount);
        for(var i2 = 0; i2 < levelCount; i2++){
            imageDescs[i2] = {
                imageFlags: sgdReader.nextUint32(),
                rgbSliceByteOffset: sgdReader.nextUint32(),
                rgbSliceByteLength: sgdReader.nextUint32(),
                alphaSliceByteOffset: sgdReader.nextUint32(),
                alphaSliceByteLength: sgdReader.nextUint32()
            };
        }
        var endpointsByteOffset = sgdByteOffset + sgdReader.position;
        var selectorsByteOffset = endpointsByteOffset + endpointsByteLength;
        var tablesByteOffset = selectorsByteOffset + selectorsByteLength;
        var extendedByteOffset = tablesByteOffset + tablesByteLength;
        var endpointsData = new Uint8Array(buffer, byteOffset + endpointsByteOffset, endpointsByteLength);
        var selectorsData = new Uint8Array(buffer, byteOffset + selectorsByteOffset, selectorsByteLength);
        var tablesData = new Uint8Array(buffer, byteOffset + tablesByteOffset, tablesByteLength);
        var extendedData = new Uint8Array(buffer, byteOffset + extendedByteOffset, extendedByteLength);
        this.globalData = {
            endpointCount: endpointCount,
            selectorCount: selectorCount,
            imageDescs: imageDescs,
            endpointsData: endpointsData,
            selectorsData: selectorsData,
            tablesData: tablesData,
            extendedData: extendedData
        };
    };
    _create_class(KTX2Container, [
        {
            key: "isSRGB",
            get: function get() {
                return this.dataFormatDescriptor.transferFunction === 2;
            }
        },
        {
            key: "isUASTC",
            get: function get() {
                return this.dataFormatDescriptor.colorModel === 166;
            }
        }
    ]);
    return KTX2Container;
}();

/**
 * KTX2 transcode target format.
 */ var KTX2TargetFormat = /*#__PURE__*/ function(KTX2TargetFormat) {
    /** RGB(A) compressed format, 128 bits per 4x4 pixel block. */ KTX2TargetFormat[KTX2TargetFormat["ASTC"] = 0] = "ASTC";
    /** RGB(A) compressed format, 128 bits per 4x4 pixel block. */ KTX2TargetFormat[KTX2TargetFormat["BC7"] = 1] = "BC7";
    /** RGB(A) compressed format, 4 bits per pixel if no alpha channel, 8 bits per pixel if has alpha channel. */ KTX2TargetFormat[KTX2TargetFormat["BC1_BC3"] = 2] = "BC1_BC3";
    /** RGB(A) compressed format, 4 bits per pixel. */ KTX2TargetFormat[KTX2TargetFormat["PVRTC"] = 3] = "PVRTC";
    /** RGB(A) compressed format, 4 bits per pixel if no alpha channel, 8 bits per pixel if has alpha channel. */ KTX2TargetFormat[KTX2TargetFormat["ETC"] = 4] = "ETC";
    /** R format, 8 bits per pixel. */ KTX2TargetFormat[KTX2TargetFormat["R8"] = 5] = "R8";
    /** RG format, 16 bits per pixel. */ KTX2TargetFormat[KTX2TargetFormat["R8G8"] = 6] = "R8G8";
    /** RGBA format, 32 bits per pixel. */ KTX2TargetFormat[KTX2TargetFormat["R8G8B8A8"] = 7] = "R8G8B8A8";
    return KTX2TargetFormat;
}({});

/**
 * @internal
 * WorkerPool, T is is post message type, U is return type.
 */ var WorkerPool = /*#__PURE__*/ function() {
    function WorkerPool(limitedCount, _workerCreator) {
        if (limitedCount === void 0) limitedCount = 4;
        this.limitedCount = limitedCount;
        this._workerCreator = _workerCreator;
        this._taskQueue = [];
        this._workerStatus = 0;
        this._workerItems = new Array(limitedCount);
    }
    var _proto = WorkerPool.prototype;
    _proto.prepareWorker = function prepareWorker() {
        var count = this.limitedCount;
        var promises = new Array(count);
        for(var i = 0; i < count; i++){
            promises.push(this._initWorker(i));
        }
        return Promise.all(promises);
    };
    /**
   * Post message to worker.
   * @param message - Message which posted to worker
   * @returns Return a promise of message
   */ _proto.postMessage = function postMessage(message) {
        var _this = this;
        return new Promise(function(resolve, reject) {
            var workerId = _this._getIdleWorkerId();
            if (workerId !== -1) {
                _this._workerStatus |= 1 << workerId;
                var workerItems = _this._workerItems;
                var _workerItems_workerId;
                Promise.resolve((_workerItems_workerId = workerItems[workerId]) != null ? _workerItems_workerId : _this._initWorker(workerId)).then(function() {
                    var workerItem = workerItems[workerId];
                    workerItem.resolve = resolve;
                    workerItem.reject = reject;
                    workerItem.worker.postMessage(message);
                }).catch(reject);
            } else {
                _this._taskQueue.push({
                    resolve: resolve,
                    reject: reject,
                    message: message
                });
            }
        });
    };
    /**
   * Destroy the worker pool.
   */ _proto.destroy = function destroy() {
        var workerItems = this._workerItems;
        for(var i = 0, n = workerItems.length; i < n; i++){
            var workerItem = workerItems[i];
            workerItem.worker.terminate();
            workerItem.reject = null;
            workerItem.resolve = null;
        }
        workerItems.length = 0;
        this._taskQueue.length = 0;
        this._workerStatus = 0;
    };
    _proto._initWorker = function _initWorker(workerId) {
        var _this = this;
        return Promise.resolve(this._workerCreator()).then(function(worker) {
            worker.addEventListener("message", _this._onMessage.bind(_this, workerId));
            _this._workerItems[workerId] = {
                worker: worker,
                resolve: null,
                reject: null
            };
            return worker;
        });
    };
    _proto._getIdleWorkerId = function _getIdleWorkerId() {
        for(var i = 0, count = this.limitedCount; i < count; i++){
            if (!(this._workerStatus & 1 << i)) return i;
        }
        return -1;
    };
    _proto._onMessage = function _onMessage(workerId, msg) {
        // onerror of web worker can't catch error in promise
        var error = msg.data.error;
        if (error) {
            this._workerItems[workerId].reject(error);
        } else {
            this._workerItems[workerId].resolve(msg.data);
        }
        this._nextTask(workerId);
    };
    _proto._nextTask = function _nextTask(workerId) {
        if (this._taskQueue.length) {
            var taskItem = this._taskQueue.shift();
            var workerItem = this._workerItems[workerId];
            workerItem.resolve = taskItem.resolve;
            workerItem.reject = taskItem.reject;
            workerItem.worker.postMessage(taskItem.message);
        } else {
            this._workerStatus ^= 1 << workerId;
        }
    };
    return WorkerPool;
}();

var AbstractTranscoder = /*#__PURE__*/ function() {
    function AbstractTranscoder(workerLimitCount) {
        this.workerLimitCount = workerLimitCount;
    }
    var _proto = AbstractTranscoder.prototype;
    _proto.init = function init() {
        if (!this._initPromise) {
            this._initPromise = this._initTranscodeWorkerPool();
        }
        return this._initPromise;
    };
    _proto.destroy = function destroy() {
        this._transcodeWorkerPool.destroy();
    };
    _proto._createTranscodePool = function _createTranscodePool(workerURL, wasmBuffer) {
        this._transcodeWorkerPool = new WorkerPool(this.workerLimitCount, function() {
            return new Promise(function(resolve, reject) {
                var onMessage = function onMessage(e) {
                    if (e.data.error) {
                        reject(e.data.error);
                    } else {
                        resolve(worker);
                    }
                };
                var worker = new Worker(workerURL);
                var msg = {
                    type: "init",
                    transcoderWasm: wasmBuffer
                };
                worker.addEventListener("message", onMessage);
                worker.postMessage(msg);
            });
        });
        return this._transcodeWorkerPool.prepareWorker();
    };
    return AbstractTranscoder;
}();

/** @internal */ function TranscodeWorkerCode$1() {
    var initPromise;
    var init = function init(wasmBinary) {
        if (!initPromise) {
            initPromise = new Promise(function(resolve, reject) {
                var BasisModule = {
                    wasmBinary: wasmBinary,
                    onRuntimeInitialized: function() {
                        return resolve(BasisModule);
                    },
                    onAbort: reject
                };
                self["BASIS"](BasisModule);
            }).then(function(BasisModule) {
                BasisModule.initializeBasis();
                return BasisModule.KTX2File;
            });
        }
        return initPromise;
    };
    self.onmessage = function onmessage(event) {
        var message = event.data;
        switch(message.type){
            case "init":
                init(message.transcoderWasm).then(function() {
                    self.postMessage("init-completed");
                }).catch(function(e) {
                    return self.postMessage({
                        error: e
                    });
                });
                break;
            case "transcode":
                init().then(function(KTX2File) {
                    var result = transcode(message.buffer, message.format, KTX2File);
                    // @ts-ignore
                    result.type = "transcoded";
                    self.postMessage(result);
                }).catch(function(e) {
                    return self.postMessage({
                        error: e
                    });
                });
                break;
        }
    };
}
var _init = function init() {
    var initPromise;
    return function init(wasmBinary) {
        if (!initPromise) {
            initPromise = new Promise(function(resolve, reject) {
                var BasisModule = {
                    wasmBinary: wasmBinary,
                    onRuntimeInitialized: function() {
                        return resolve(BasisModule);
                    },
                    onAbort: reject
                };
                self["BASIS"](BasisModule);
            }).then(function(BasisModule) {
                BasisModule.initializeBasis();
                return BasisModule.KTX2File;
            });
        }
        return initPromise;
    };
};
var init = _init();
function transcode(buffer, targetFormat, KTX2File) {
    function getTranscodeFormatFromTarget(target, hasAlpha) {
        switch(target){
            case 2:
                return hasAlpha ? 3 : 2;
            case 4:
                return hasAlpha ? 1 : 0;
            case 3:
                return hasAlpha ? 9 : 8;
            case 7:
                return 13;
            case 0:
                return 10;
            case 1:
                return 7;
        }
    }
    function concat(arrays) {
        if (arrays.length === 1) return arrays[0];
        var totalByteLength = 0;
        for(var i = 0; i < arrays.length; i++){
            totalByteLength += arrays[i].byteLength;
        }
        var result = new Uint8Array(totalByteLength);
        var byteOffset = 0;
        for(var i1 = 0; i1 < arrays.length; i1++){
            result.set(arrays[i1], byteOffset);
            byteOffset += arrays[i1].byteLength;
        }
        return result;
    }
    var ktx2File = new KTX2File(new Uint8Array(buffer));
    function cleanup() {
        ktx2File.close();
        ktx2File.delete();
    }
    if (!ktx2File.isValid()) {
        cleanup();
        throw new Error("Invalid or unsupported .ktx2 file");
    }
    if (!ktx2File.startTranscoding()) {
        cleanup();
        throw new Error("KTX2 startTranscoding failed");
    }
    var width = ktx2File.getWidth();
    var height = ktx2File.getHeight();
    var layerCount = ktx2File.getLayers() || 1;
    var levelCount = ktx2File.getLevels();
    var hasAlpha = ktx2File.getHasAlpha();
    var faceCount = ktx2File.getFaces();
    var format = getTranscodeFormatFromTarget(targetFormat, hasAlpha);
    var faces = new Array(faceCount);
    var isBC = format === 2 || format === 3 || format === 7;
    for(var face = 0; face < faceCount; face++){
        var mipmaps = new Array(levelCount);
        for(var mip = 0; mip < levelCount; mip++){
            var layerMips = new Array(layerCount);
            var mipWidth = void 0, mipHeight = void 0;
            for(var layer = 0; layer < layerCount; layer++){
                var levelInfo = ktx2File.getImageLevelInfo(mip, layer, face);
                // see: https://github.com/KhronosGroup/KTX-Software/issues/254
                if (isBC && mip === 0 && (width !== levelInfo.width || height !== levelInfo.height)) {
                    width = mipWidth = levelInfo.width;
                    height = mipHeight = levelInfo.height;
                    console.warn("KTX2 transcode to BC will resize to width: " + width + ", height: " + height + ". You'd better use an image whose size if multiple of 4.");
                } else {
                    mipWidth = levelInfo.origWidth;
                    mipHeight = levelInfo.origHeight;
                }
                var dst = new Uint8Array(ktx2File.getImageTranscodedSizeInBytes(mip, layer, 0, format));
                var status = ktx2File.transcodeImage(dst, mip, layer, face, format, 0, -1, -1);
                if (!status) {
                    cleanup();
                    throw new Error("transcodeImage failed.");
                }
                layerMips[layer] = dst;
            }
            mipmaps[mip] = {
                data: concat(layerMips),
                width: mipWidth,
                height: mipHeight
            };
        }
        faces[face] = mipmaps;
    }
    cleanup();
    return {
        faces: faces,
        width: width,
        height: height,
        hasAlpha: hasAlpha,
        faceCount: faceCount,
        format: format
    };
}

/** @internal */ var BinomialLLCTranscoder = /*#__PURE__*/ function(AbstractTranscoder) {
    _inherits(BinomialLLCTranscoder, AbstractTranscoder);
    function BinomialLLCTranscoder(workerLimitCount) {
        return AbstractTranscoder.call(this, workerLimitCount) || this;
    }
    var _proto = BinomialLLCTranscoder.prototype;
    _proto._initTranscodeWorkerPool = function _initTranscodeWorkerPool() {
        var _this = this;
        return Promise.all([
            fetch("https://mdn.alipayobjects.com/rms/afts/file/A*nG8SR6vCgXgAAAAAAAAAAAAAARQnAQ/basis_transcoder.js").then(function(res) {
                return res.text();
            }),
            fetch("https://mdn.alipayobjects.com/rms/afts/file/A*qEUfQ7317KsAAAAAAAAAAAAAARQnAQ/basis_transcoder.wasm").then(function(res) {
                return res.arrayBuffer();
            })
        ]).then(function(param) {
            var jsCode = param[0], wasmBuffer = param[1];
            if (_this.workerLimitCount === 0) {
                return new Promise(function(resolve, reject) {
                    var scriptDom = document.createElement("script");
                    scriptDom.src = URL.createObjectURL(new Blob([
                        jsCode
                    ], {
                        type: "application/javascript"
                    }));
                    document.body.appendChild(scriptDom);
                    scriptDom.onload = function() {
                        init(wasmBuffer).then(function() {
                            resolve(null);
                        });
                    };
                    scriptDom.onerror = function() {
                        reject();
                    };
                });
            } else {
                var funcCode = TranscodeWorkerCode$1.toString();
                var transcodeString = funcCode.substring(funcCode.indexOf("{"), funcCode.lastIndexOf("}") + 1);
                var workerCode = "\n        " + jsCode + "\n        " + transcode.toString() + "\n        " + transcodeString + "\n        ";
                var workerURL = URL.createObjectURL(new Blob([
                    workerCode
                ], {
                    type: "application/javascript"
                }));
                return _this._createTranscodePool(workerURL, wasmBuffer);
            }
        });
    };
    _proto.transcode = function transcode1(buffer, format) {
        if (this.workerLimitCount === 0) {
            return init().then(function(KTX2File) {
                return transcode(buffer, format, KTX2File);
            });
        } else {
            return this._transcodeWorkerPool.postMessage({
                buffer: buffer,
                format: format,
                type: "transcode"
            });
        }
    };
    return BinomialLLCTranscoder;
}(AbstractTranscoder);

function TranscodeWorkerCode() {
    var wasmPromise;
    /**
   * ZSTD (Zstandard) decoder.
   */ var ZSTDDecoder = /*#__PURE__*/ function() {
        function ZSTDDecoder() {}
        var _proto = ZSTDDecoder.prototype;
        _proto.init = function init() {
            if (!this._initPromise) {
                this._initPromise = fetch(ZSTDDecoder.WasmModuleURL).then(function(response) {
                    if (response.ok) {
                        return response.arrayBuffer();
                    }
                    throw new Error("Could not fetch the wasm component for the Zstandard decompression lib: " + response.status + " - " + response.statusText);
                }).then(function(arrayBuffer) {
                    return WebAssembly.instantiate(arrayBuffer, ZSTDDecoder.IMPORT_OBJECT);
                }).then(this._init);
            }
            return this._initPromise;
        };
        _proto._init = function _init(result) {
            ZSTDDecoder.instance = result.instance;
            ZSTDDecoder.IMPORT_OBJECT.env.emscripten_notify_memory_growth(); // initialize heap.
        };
        _proto.decode = function decode(array, uncompressedSize) {
            if (uncompressedSize === void 0) uncompressedSize = 0;
            if (!ZSTDDecoder.instance) {
                throw new Error("ZSTDDecoder: Await .init() before decoding.");
            }
            var exports = ZSTDDecoder.instance.exports;
            // Write compressed data into WASM memory
            var compressedSize = array.byteLength;
            var compressedPtr = exports.malloc(compressedSize);
            ZSTDDecoder.heap.set(array, compressedPtr);
            // Decompress into WASM memory
            uncompressedSize = uncompressedSize || Number(exports.ZSTD_findDecompressedSize(compressedPtr, compressedSize));
            var uncompressedPtr = exports.malloc(uncompressedSize);
            var actualSize = exports.ZSTD_decompress(uncompressedPtr, uncompressedSize, compressedPtr, compressedSize);
            // Read decompressed data and free WASM memory
            var dec = ZSTDDecoder.heap.slice(uncompressedPtr, uncompressedPtr + actualSize);
            exports.free(compressedPtr);
            exports.free(uncompressedPtr);
            return dec;
        };
        return ZSTDDecoder;
    }();
    ZSTDDecoder.IMPORT_OBJECT = {
        env: {
            emscripten_notify_memory_growth: function emscripten_notify_memory_growth() {
                ZSTDDecoder.heap = new Uint8Array(ZSTDDecoder.instance.exports.memory.buffer);
            }
        }
    };
    ZSTDDecoder.WasmModuleURL = "https://mdn.alipayobjects.com/rms/afts/file/A*awNJR7KqIAEAAAAAAAAAAAAAARQnAQ/zstddec.wasm";
    function transcodeASTCAndBC7(wasmTranscoder, compressedData, width, height) {
        var nBlocks = (width + 3 >> 2) * (height + 3 >> 2);
        var texMemoryPages = nBlocks * 16 + 65535 >> 16;
        var memory = wasmTranscoder.memory;
        var delta = texMemoryPages + 1 - (memory.buffer.byteLength >> 16);
        if (delta > 0) memory.grow(delta);
        var textureView = new Uint8Array(memory.buffer, 65536, nBlocks * 16);
        textureView.set(compressedData);
        return wasmTranscoder.transcode(nBlocks) === 0 ? textureView : null;
    }
    function initWasm(buffer) {
        wasmPromise = WebAssembly.instantiate(buffer, {
            env: {
                memory: new WebAssembly.Memory({
                    initial: 16
                })
            }
        }).then(function(moduleWrapper) {
            return moduleWrapper.instance.exports;
        });
        return wasmPromise;
    }
    var zstdDecoder = new ZSTDDecoder();
    function transcode(data, needZstd, wasmModule) {
        var faceCount = data.length;
        var result = new Array(faceCount);
        var promise = Promise.resolve();
        if (needZstd) {
            zstdDecoder.init();
            promise = zstdDecoder._initPromise;
        }
        return promise.then(function() {
            for(var faceIndex = 0; faceIndex < faceCount; faceIndex++){
                var mipmapCount = data[faceIndex].length;
                var decodedData = new Array(mipmapCount);
                for(var i = 0; i < mipmapCount; i++){
                    var _data_faceIndex_i = data[faceIndex][i], buffer = _data_faceIndex_i.buffer, levelHeight = _data_faceIndex_i.levelHeight, levelWidth = _data_faceIndex_i.levelWidth, uncompressedByteLength = _data_faceIndex_i.uncompressedByteLength;
                    if (needZstd) buffer = zstdDecoder.decode(buffer.slice(), uncompressedByteLength);
                    var faceByteLength = buffer.byteLength / faceCount;
                    var originByteOffset = buffer.byteOffset;
                    var decodedBuffer = transcodeASTCAndBC7(wasmModule, new Uint8Array(buffer.buffer, originByteOffset + faceIndex * faceByteLength, faceByteLength), levelWidth, levelHeight);
                    if (decodedBuffer) {
                        decodedData[i] = {
                            // use wasm memory as buffer, should slice to avoid duplicate
                            data: decodedBuffer.slice(),
                            width: levelWidth,
                            height: levelHeight
                        };
                    } else {
                        throw "buffer decoded error";
                    }
                }
                result[faceIndex] = decodedData;
            }
            return result;
        });
    }
    self.onmessage = function onmessage(event) {
        var message = event.data;
        switch(message.type){
            case "init":
                initWasm(message.transcoderWasm).then(function() {
                    self.postMessage("init-completed");
                }).catch(function(e) {
                    self.postMessage({
                        error: e
                    });
                });
                break;
            case "transcode":
                wasmPromise.then(function(module) {
                    transcode(message.data, message.needZstd, module).then(function(decodedData) {
                        self.postMessage(decodedData);
                    }).catch(function(e) {
                        return self.postMessage({
                            error: e
                        });
                    });
                });
                break;
        }
    };
}

/** @internal */ var KhronosTranscoder = /*#__PURE__*/ function(AbstractTranscoder) {
    _inherits(KhronosTranscoder, AbstractTranscoder);
    function KhronosTranscoder(workerLimitCount, type) {
        var _this;
        _this = AbstractTranscoder.call(this, workerLimitCount) || this, _this.type = type;
        return _this;
    }
    var _proto = KhronosTranscoder.prototype;
    _proto._initTranscodeWorkerPool = function _initTranscodeWorkerPool() {
        var _this = this;
        return fetch(KhronosTranscoder.transcoderMap[this.type]).then(function(res) {
            return res.arrayBuffer();
        }).then(function(wasmBuffer) {
            var funcCode = TranscodeWorkerCode.toString();
            var workerURL = URL.createObjectURL(new Blob([
                funcCode.substring(funcCode.indexOf("{") + 1, funcCode.lastIndexOf("}"))
            ], {
                type: "application/javascript"
            }));
            return _this._createTranscodePool(workerURL, wasmBuffer);
        });
    };
    _proto.transcode = function transcode(ktx2Container) {
        var needZstd = ktx2Container.supercompressionScheme === SupercompressionScheme.Zstd;
        var levelCount = ktx2Container.levels.length;
        var faceCount = ktx2Container.faceCount;
        var decodedData = {
            width: ktx2Container.pixelWidth,
            height: ktx2Container.pixelHeight,
            mipmaps: null
        };
        var postMessageData = {
            type: "transcode",
            format: 0,
            needZstd: needZstd,
            data: new Array(faceCount)
        };
        var messageData = postMessageData.data;
        for(var faceIndex = 0; faceIndex < faceCount; faceIndex++){
            var mipmapData = new Array(levelCount);
            for(var mipmapIndex = 0; mipmapIndex < levelCount; mipmapIndex++){
                var level = ktx2Container.levels[mipmapIndex];
                var levelWidth = Math.floor(ktx2Container.pixelWidth / (1 << mipmapIndex)) || 1;
                var levelHeight = Math.floor(ktx2Container.pixelHeight / (1 << mipmapIndex)) || 1;
                var originBuffer = level.levelData.buffer;
                var originOffset = level.levelData.byteOffset;
                var originByteLength = level.levelData.byteLength;
                mipmapData[mipmapIndex] = {
                    buffer: new Uint8Array(originBuffer, originOffset, originByteLength),
                    levelWidth: levelWidth,
                    levelHeight: levelHeight,
                    uncompressedByteLength: level.uncompressedByteLength
                };
            }
            messageData[faceIndex] = mipmapData;
        }
        return this._transcodeWorkerPool.postMessage(postMessageData).then(function(data) {
            decodedData.faces = data;
            decodedData.hasAlpha = true;
            return decodedData;
        });
    };
    return KhronosTranscoder;
}(AbstractTranscoder);
var _obj$2;
KhronosTranscoder.transcoderMap = (_obj$2 = {}, // TODO: support bc7
_obj$2[KTX2TargetFormat.ASTC] = "https://mdn.alipayobjects.com/rms/afts/file/A*0jiKRK6D1-kAAAAAAAAAAAAAARQnAQ/uastc_astc.wasm", _obj$2);

var KTX2Loader = /*#__PURE__*/ function(Loader) {
    _inherits(KTX2Loader, Loader);
    function KTX2Loader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = KTX2Loader.prototype;
    _proto.initialize = function initialize(_, configuration) {
        if (configuration.ktx2Loader) {
            var options = configuration.ktx2Loader;
            if (options.priorityFormats) {
                KTX2Loader._priorityFormats["etc1s"] = options.priorityFormats;
                KTX2Loader._priorityFormats["uastc"] = options.priorityFormats;
            }
            if (options.transcoder === 1) {
                return KTX2Loader._getKhronosTranscoder(options.workerCount).init();
            } else {
                return KTX2Loader._getBinomialLLCTranscoder(options.workerCount).init();
            }
        }
    };
    /**
   * @internal
   */ _proto.load = function load(item, resourceManager) {
        return new AssetPromise(function(resolve, reject, setTaskCompleteProgress, setTaskDetailProgress) {
            var requestConfig = _extends({}, item, {
                type: "arraybuffer"
            });
            var url = item.url;
            resourceManager// @ts-ignore
            ._request(url, requestConfig).onProgress(setTaskCompleteProgress, setTaskDetailProgress).then(function(buffer) {
                return KTX2Loader._parseBuffer(new Uint8Array(buffer), resourceManager.engine, item.params).then(function(param) {
                    var ktx2Container = param.ktx2Container, engine = param.engine, result = param.result, targetFormat = param.targetFormat, params = param.params;
                    return KTX2Loader._createTextureByBuffer(engine, ktx2Container.isSRGB, result, targetFormat, params);
                }).then(function(texture) {
                    resourceManager.addContentRestorer(new KTX2ContentRestorer(texture, url, requestConfig));
                    resolve(texture);
                });
            }).catch(reject);
        });
    };
    /**
   * Release ktx2 transcoder worker.
   * @remarks If use loader after releasing, we should release again.
   */ KTX2Loader.release = function release() {
        if (this._binomialLLCTranscoder) this._binomialLLCTranscoder.destroy();
        if (this._khronosTranscoder) this._khronosTranscoder.destroy();
        this._binomialLLCTranscoder = null;
        this._khronosTranscoder = null;
        this._isBinomialInit = false;
    };
    /** @internal */ KTX2Loader._parseBuffer = function _parseBuffer(buffer, engine, params) {
        var ktx2Container = new KTX2Container(buffer);
        var _params_priorityFormats;
        var formatPriorities = (_params_priorityFormats = params == null ? void 0 : params.priorityFormats) != null ? _params_priorityFormats : KTX2Loader._priorityFormats[ktx2Container.isUASTC ? "uastc" : "etc1s"];
        var targetFormat = KTX2Loader._decideTargetFormat(engine, ktx2Container, formatPriorities);
        var transcodeResultPromise;
        if (KTX2Loader._isBinomialInit || !KhronosTranscoder.transcoderMap[targetFormat] || !ktx2Container.isUASTC) {
            var binomialLLCWorker = KTX2Loader._getBinomialLLCTranscoder();
            transcodeResultPromise = binomialLLCWorker.init().then(function() {
                return binomialLLCWorker.transcode(buffer, targetFormat);
            });
        } else {
            var khronosWorker = KTX2Loader._getKhronosTranscoder();
            transcodeResultPromise = khronosWorker.init().then(function() {
                return khronosWorker.transcode(ktx2Container);
            });
        }
        return transcodeResultPromise.then(function(result) {
            return {
                ktx2Container: ktx2Container,
                engine: engine,
                result: result,
                targetFormat: targetFormat,
                params: ktx2Container.keyValue["GalaceanTextureParams"]
            };
        });
    };
    /** @internal */ KTX2Loader._createTextureByBuffer = function _createTextureByBuffer(engine, isSRGB, transcodeResult, targetFormat, params, restoredTexture) {
        var width = transcodeResult.width, height = transcodeResult.height, faces = transcodeResult.faces;
        var faceCount = faces.length;
        var mipmaps = faces[0];
        var mipmap = mipmaps.length > 1;
        var engineFormat = this._getEngineTextureFormat(targetFormat, transcodeResult);
        var texture;
        if (faceCount !== 6) {
            texture = restoredTexture || new Texture2D(engine, width, height, engineFormat, mipmap, isSRGB);
            for(var mipLevel = 0; mipLevel < mipmaps.length; mipLevel++){
                var data = mipmaps[mipLevel].data;
                texture.setPixelBuffer(data, mipLevel);
            }
        } else {
            texture = restoredTexture || new TextureCube(engine, height, engineFormat, mipmap, isSRGB);
            for(var i = 0; i < faces.length; i++){
                var faceData = faces[i];
                for(var mipLevel1 = 0; mipLevel1 < mipmaps.length; mipLevel1++){
                    texture.setPixelBuffer(TextureCubeFace.PositiveX + i, faceData[mipLevel1].data, mipLevel1);
                }
            }
        }
        if (params) {
            texture.wrapModeU = params[0];
            texture.wrapModeV = params[1];
            texture.filterMode = params[2];
            texture.anisoLevel = params[3];
        }
        return texture;
    };
    KTX2Loader._decideTargetFormat = function _decideTargetFormat(engine, ktx2Container, priorityFormats) {
        var renderer = engine._hardwareRenderer;
        var isSRGB = ktx2Container.isSRGB, pixelWidth = ktx2Container.pixelWidth, pixelHeight = ktx2Container.pixelHeight;
        var targetFormat = this._detectSupportedFormat(renderer, priorityFormats, isSRGB);
        if (targetFormat === KTX2TargetFormat.PVRTC && (!MathUtil.isPowerOf2(pixelWidth) || !MathUtil.isPowerOf2(pixelHeight) || pixelWidth !== pixelHeight)) {
            Logger.warn("PVRTC image need power of 2 and width===height, downgrade to RGBA8");
            return KTX2TargetFormat.R8G8B8A8;
        }
        if (targetFormat === null) {
            Logger.warn("Can't support any compressed texture, downgrade to RGBA8");
            return KTX2TargetFormat.R8G8B8A8;
        }
        return targetFormat;
    };
    KTX2Loader._detectSupportedFormat = function _detectSupportedFormat(renderer, priorityFormats, isSRGB) {
        for(var i = 0; i < priorityFormats.length; i++){
            var _this__capabilityMap_format;
            var format = priorityFormats[i];
            var capabilities = (_this__capabilityMap_format = this._capabilityMap[format]) == null ? void 0 : _this__capabilityMap_format[isSRGB ? DFDTransferFunction.sRGB : DFDTransferFunction.linear];
            if (capabilities) {
                for(var j = 0; j < capabilities.length; j++){
                    if (renderer.canIUse(capabilities[j])) {
                        return format;
                    }
                }
            } else {
                switch(priorityFormats[i]){
                    case KTX2TargetFormat.R8G8B8A8:
                        return format;
                    case KTX2TargetFormat.R8:
                    case KTX2TargetFormat.R8G8:
                        if (renderer.isWebGL2) return format;
                }
            }
        }
        return null;
    };
    KTX2Loader._getBinomialLLCTranscoder = function _getBinomialLLCTranscoder(workerCount) {
        if (workerCount === void 0) workerCount = 4;
        KTX2Loader._isBinomialInit = true;
        var _this__binomialLLCTranscoder;
        return (_this__binomialLLCTranscoder = this._binomialLLCTranscoder) != null ? _this__binomialLLCTranscoder : this._binomialLLCTranscoder = new BinomialLLCTranscoder(workerCount);
    };
    KTX2Loader._getKhronosTranscoder = function _getKhronosTranscoder(workerCount) {
        if (workerCount === void 0) workerCount = 4;
        var _this__khronosTranscoder;
        return (_this__khronosTranscoder = this._khronosTranscoder) != null ? _this__khronosTranscoder : this._khronosTranscoder = new KhronosTranscoder(workerCount, KTX2TargetFormat.ASTC);
    };
    KTX2Loader._getEngineTextureFormat = function _getEngineTextureFormat(basisFormat, transcodeResult) {
        var hasAlpha = transcodeResult.hasAlpha;
        switch(basisFormat){
            case KTX2TargetFormat.ASTC:
                return TextureFormat.ASTC_4x4;
            case KTX2TargetFormat.ETC:
                return hasAlpha ? TextureFormat.ETC2_RGBA8 : TextureFormat.ETC2_RGB;
            case KTX2TargetFormat.BC7:
                return TextureFormat.BC7;
            case KTX2TargetFormat.BC1_BC3:
                return hasAlpha ? TextureFormat.BC3 : TextureFormat.BC1;
            case KTX2TargetFormat.PVRTC:
                return hasAlpha ? TextureFormat.PVRTC_RGBA4 : TextureFormat.PVRTC_RGB4;
            case KTX2TargetFormat.R8G8B8A8:
                return TextureFormat.R8G8B8A8;
        }
    };
    return KTX2Loader;
}(Loader);
KTX2Loader._isBinomialInit = false;
KTX2Loader._priorityFormats = {
    etc1s: [
        KTX2TargetFormat.ETC,
        KTX2TargetFormat.BC7,
        KTX2TargetFormat.ASTC,
        KTX2TargetFormat.BC1_BC3,
        KTX2TargetFormat.PVRTC
    ],
    uastc: [
        KTX2TargetFormat.ASTC,
        KTX2TargetFormat.BC7,
        KTX2TargetFormat.ETC,
        KTX2TargetFormat.BC1_BC3,
        KTX2TargetFormat.PVRTC
    ]
};
var _obj$1, _obj1, _obj2, _obj3, _obj4, _obj5;
KTX2Loader._capabilityMap = (_obj5 = {}, _obj5[KTX2TargetFormat.ASTC] = (_obj$1 = {}, _obj$1[DFDTransferFunction.linear] = [
    GLCapabilityType.astc,
    GLCapabilityType.astc_webkit
], _obj$1[DFDTransferFunction.sRGB] = [
    GLCapabilityType.astc,
    GLCapabilityType.astc_webkit
], _obj$1), _obj5[KTX2TargetFormat.ETC] = (_obj1 = {}, _obj1[DFDTransferFunction.linear] = [
    GLCapabilityType.etc,
    GLCapabilityType.etc_webkit
], _obj1[DFDTransferFunction.sRGB] = [
    GLCapabilityType.etc,
    GLCapabilityType.etc_webkit
], _obj1), _obj5[KTX2TargetFormat.BC7] = (_obj2 = {}, _obj2[DFDTransferFunction.linear] = [
    GLCapabilityType.bptc
], _obj2[DFDTransferFunction.sRGB] = [
    GLCapabilityType.bptc
], _obj2), _obj5[KTX2TargetFormat.BC1_BC3] = (_obj3 = {}, _obj3[DFDTransferFunction.linear] = [
    GLCapabilityType.s3tc
], _obj3[DFDTransferFunction.sRGB] = [
    GLCapabilityType.s3tc_srgb
], _obj3), _obj5[KTX2TargetFormat.PVRTC] = (_obj4 = {}, _obj4[DFDTransferFunction.linear] = [
    GLCapabilityType.pvrtc,
    GLCapabilityType.pvrtc_webkit
], _obj4), _obj5);
KTX2Loader = __decorate([
    resourceLoader(AssetType.KTX2, [
        "ktx2"
    ])
], KTX2Loader);
var KTX2ContentRestorer = /*#__PURE__*/ function(ContentRestorer) {
    _inherits(KTX2ContentRestorer, ContentRestorer);
    function KTX2ContentRestorer(resource, url, requestConfig) {
        var _this;
        _this = ContentRestorer.call(this, resource) || this, _this.url = url, _this.requestConfig = requestConfig;
        return _this;
    }
    var _proto = KTX2ContentRestorer.prototype;
    _proto.restoreContent = function restoreContent() {
        var _this = this;
        var _this1 = this, resource = _this1.resource, requestConfig = _this1.requestConfig;
        var engine = resource.engine;
        return new AssetPromise(function(resolve, reject) {
            engine.resourceManager// @ts-ignore
            ._request(_this.url, requestConfig).then(function(buffer) {
                return KTX2Loader._parseBuffer(new Uint8Array(buffer), engine, requestConfig.params).then(function(param) {
                    var ktx2Container = param.ktx2Container, engine = param.engine, result = param.result, targetFormat = param.targetFormat, params = param.params;
                    return KTX2Loader._createTextureByBuffer(engine, ktx2Container.isSRGB, result, targetFormat, params, resource);
                });
            }).then(resolve).catch(reject);
        });
    };
    return KTX2ContentRestorer;
}(ContentRestorer);

/**
 * @internal
 */ var GLTFContentRestorer = /*#__PURE__*/ function(ContentRestorer) {
    _inherits(GLTFContentRestorer, ContentRestorer);
    function GLTFContentRestorer() {
        var _this;
        _this = ContentRestorer.apply(this, arguments) || this, _this.bufferRequests = [], _this.glbBufferSlices = [], _this.bufferTextures = [], _this.meshes = [];
        return _this;
    }
    var _proto = GLTFContentRestorer.prototype;
    _proto.restoreContent = function restoreContent() {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            Promise.all(_this.bufferRequests.map(function(bufferRequestInfo) {
                return request(bufferRequestInfo.url, bufferRequestInfo.config);
            })).then(function(buffers) {
                // Buffer parse
                if (_this.isGLB) {
                    var glbBufferSlice = _this.glbBufferSlices;
                    var bigBuffer = buffers[0];
                    var bufferCount = glbBufferSlice.length;
                    buffers.length = bufferCount;
                    for(var i = 0; i < bufferCount; i++){
                        var slice = glbBufferSlice[i];
                        buffers[i] = bigBuffer.slice(slice.x, slice.x + slice.y);
                    }
                }
                // Restore texture
                AssetPromise.all(_this.bufferTextures.map(function(textureRestoreInfo) {
                    var bufferView = textureRestoreInfo.bufferView;
                    var buffer = buffers[bufferView.buffer];
                    var _bufferView_byteOffset;
                    var bufferData = new Uint8Array(buffer, (_bufferView_byteOffset = bufferView.byteOffset) != null ? _bufferView_byteOffset : 0, bufferView.byteLength);
                    var texture = textureRestoreInfo.texture;
                    if (textureRestoreInfo.mimeType === "image/ktx2") {
                        return KTX2Loader._parseBuffer(bufferData, texture.engine).then(function(param) {
                            var result = param.result;
                            var faces = result.faces;
                            var mipmaps = faces[0];
                            for(var i = 0; i < mipmaps.length; i++){
                                texture.setPixelBuffer(mipmaps[i].data, i);
                            }
                        });
                    } else {
                        return GLTFUtils.loadImageBuffer(bufferData, textureRestoreInfo.mimeType).then(function(image) {
                            texture.setImageSource(image);
                            texture.generateMipmaps();
                        });
                    }
                })).then(function() {
                    // Restore mesh
                    for(var _iterator = _create_for_of_iterator_helper_loose(_this.meshes), _step; !(_step = _iterator()).done;){
                        var meshInfo = _step.value;
                        var mesh = meshInfo.mesh;
                        for(var _iterator1 = _create_for_of_iterator_helper_loose(meshInfo.vertexBuffers), _step1; !(_step1 = _iterator1()).done;){
                            var bufferRestoreInfo = _step1.value;
                            var vertexData = _this._getBufferData(buffers, bufferRestoreInfo.data);
                            bufferRestoreInfo.buffer.setData(vertexData);
                        }
                        if (meshInfo.indexBuffer) {
                            var indexData = _this._getBufferData(buffers, meshInfo.indexBuffer);
                            mesh.setIndices(indexData);
                        }
                        for(var _iterator2 = _create_for_of_iterator_helper_loose(meshInfo.blendShapes), _step2; !(_step2 = _iterator2()).done;){
                            var restoreInfo = _step2.value;
                            var frame = restoreInfo.blendShape.frames[0];
                            var position = restoreInfo.position;
                            var positionData = _this._getBufferData(buffers, position.buffer);
                            frame.deltaPositions = GLTFUtils.bufferToVector3Array(positionData, position.byteOffset, position.count, position.normalized, position.componentType);
                            if (restoreInfo.normal) {
                                var normal = restoreInfo.normal;
                                var normalData = _this._getBufferData(buffers, normal.buffer);
                                frame.deltaNormals = GLTFUtils.bufferToVector3Array(normalData, normal.byteOffset, normal.count, normal.normalized, normal.componentType);
                            }
                            if (restoreInfo.tangent) {
                                var tangent = restoreInfo.tangent;
                                var tangentData = _this._getBufferData(buffers, tangent.buffer);
                                frame.deltaTangents = GLTFUtils.bufferToVector3Array(tangentData, tangent.byteOffset, tangent.count, tangent.normalized, tangent.componentType);
                            }
                        }
                        mesh.uploadData(true);
                    }
                    resolve(_this.resource);
                }).catch(reject);
            }).catch(reject);
        });
    };
    _proto._getBufferData = function _getBufferData(buffers, restoreInfo) {
        var main = restoreInfo.main;
        var data;
        if (main) {
            var buffer = buffers[main.bufferIndex];
            data = new main.TypedArray(buffer, main.byteOffset, main.length);
        } else {
            data = new main.TypedArray(main.length);
        }
        var sparseCount = restoreInfo.sparseCount;
        if (sparseCount) {
            var sparseIndex = restoreInfo.sparseIndices;
            var sparseIndexBuffer = buffers[sparseIndex.bufferIndex];
            var sparseIndexData = new sparseIndex.TypedArray(sparseIndexBuffer, sparseIndex.byteOffset, sparseIndex.length);
            var sparseValue = restoreInfo.sparseValues;
            var sparseValueBuffer = buffers[sparseValue.bufferIndex];
            var sparseValueData = new sparseValue.TypedArray(sparseValueBuffer, sparseValue.byteOffset, sparseValue.length);
            var typeSize = restoreInfo.typeSize;
            for(var i = 0; i < sparseCount; i++){
                var replaceIndex = sparseIndexData[i];
                for(var j = 0; j < typeSize; j++){
                    data[replaceIndex * typeSize + j] = sparseValueData[i * typeSize + j];
                }
            }
        }
        return data;
    };
    return GLTFContentRestorer;
}(ContentRestorer);
/**
 * @internal
 */ var BufferRequestInfo = function BufferRequestInfo(url, config) {
    this.url = url;
    this.config = config;
};
/**
 * @internal
 */ var BufferTextureRestoreInfo = function BufferTextureRestoreInfo(texture, bufferView, mimeType) {
    this.texture = texture;
    this.bufferView = bufferView;
    this.mimeType = mimeType;
};
/**
 * @internal
 */ var ModelMeshRestoreInfo = function ModelMeshRestoreInfo() {
    this.vertexBuffers = [];
    this.blendShapes = [];
};
/**
 * @internal
 */ var BufferRestoreInfo = function BufferRestoreInfo(buffer, data) {
    this.buffer = buffer;
    this.data = data;
};
/**
 * @internal
 */ var BufferDataRestoreInfo = function BufferDataRestoreInfo(main, typeSize, sparseCount, sparseIndices, sparseValues) {
    this.main = main;
    this.typeSize = typeSize;
    this.sparseCount = sparseCount;
    this.sparseIndices = sparseIndices;
    this.sparseValues = sparseValues;
};
/**
 * @internal
 */ var RestoreDataAccessor = function RestoreDataAccessor(bufferIndex, TypedArray, byteOffset, length) {
    this.bufferIndex = bufferIndex;
    this.TypedArray = TypedArray;
    this.byteOffset = byteOffset;
    this.length = length;
};
/**
 * @internal
 */ var BlendShapeRestoreInfo = function BlendShapeRestoreInfo(blendShape, position, normal, tangent) {
    this.blendShape = blendShape;
    this.position = position;
    this.normal = normal;
    this.tangent = tangent;
};
/**
 * @internal
 */ var BlendShapeDataRestoreInfo = function BlendShapeDataRestoreInfo(buffer, byteOffset, count, normalized, componentType) {
    this.buffer = buffer;
    this.byteOffset = byteOffset;
    this.count = count;
    this.normalized = normalized;
    this.componentType = componentType;
};

/**
 * Base class of glTF extension parser.
 */ var GLTFExtensionParser = /*#__PURE__*/ function() {
    function GLTFExtensionParser() {}
    var _proto = GLTFExtensionParser.prototype;
    /**
   * Create and parse the resource.
   * @remarks This method overrides the default resource creation.
   * @param context - The parser context
   * @param extensionSchema - The extension schema
   * @param extensionOwnerSchema - The extension owner schema
   * @returns The resource or promise
   */ _proto.createAndParse = function createAndParse(context, extensionSchema, extensionOwnerSchema) {
        for(var _len = arguments.length, extra = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++){
            extra[_key - 3] = arguments[_key];
        }
        throw "Not implemented.";
    };
    /**
   * Additive parse to the resource.
   * @param context - The parser context
   * @param parseResource - The parsed resource
   * @param extensionSchema - The extension schema
   * @param extensionOwnerSchema - The extension owner schema
   * @returns The void or promise
   */ _proto.additiveParse = function additiveParse(context, parseResource, extensionSchema, extensionOwnerSchema) {
        for(var _len = arguments.length, extra = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++){
            extra[_key - 4] = arguments[_key];
        }
        throw "Not implemented.";
    };
    return GLTFExtensionParser;
}();
/**
 * glTF Extension mode.
 */ var GLTFExtensionMode = /*#__PURE__*/ function(GLTFExtensionMode) {
    /**
   * Cerate instance and parse mode.
   * @remarks
   * If the glTF property has multiple extensions of `CreateAndParse` mode, only execute the last one.
   * If this method is registered, the default pipeline processing will be ignored.
   */ GLTFExtensionMode[GLTFExtensionMode["CreateAndParse"] = 0] = "CreateAndParse";
    /** Additive parse mode. */ GLTFExtensionMode[GLTFExtensionMode["AdditiveParse"] = 1] = "AdditiveParse";
    return GLTFExtensionMode;
}({});

/**
 * Base class of glTF parser.
 */ var GLTFParser = /*#__PURE__*/ function() {
    function GLTFParser() {}
    /**
   * Execute all parses of extension to create resource.
   * @param extensions - Related extensions field
   * @param context - The parser context
   * @param ownerSchema - The extension owner schema
   * @param extra - Extra params
   * @returns
   */ GLTFParser.executeExtensionsCreateAndParse = function executeExtensionsCreateAndParse(extensions, context, ownerSchema) {
        if (extensions === void 0) extensions = {};
        for(var _len = arguments.length, extra = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++){
            extra[_key - 3] = arguments[_key];
        }
        var resource = null;
        var extensionArray = Object.keys(extensions);
        for(var i = extensionArray.length - 1; i >= 0; --i){
            var _GLTFParser;
            var extensionName = extensionArray[i];
            var extensionSchema = extensions[extensionName];
            resource = (_GLTFParser = GLTFParser)._createAndParse.apply(_GLTFParser, [].concat([
                extensionName,
                context,
                extensionSchema,
                ownerSchema
            ], extra));
            if (resource) {
                return resource;
            }
        }
    };
    /**
   * Execute all parses of extension to parse resource.
   * @param extensions - Related extensions field
   * @param context - The parser context
   * @param parseResource -  The parsed resource
   * @param ownerSchema - The extension owner schema
   * @param extra - Extra params
   */ GLTFParser.executeExtensionsAdditiveAndParse = function executeExtensionsAdditiveAndParse(extensions, context, parseResource, ownerSchema) {
        for(var _len = arguments.length, extra = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++){
            extra[_key - 4] = arguments[_key];
        }
        for(var extensionName in extensions){
            var _GLTFParser;
            var extensionSchema = extensions[extensionName];
            (_GLTFParser = GLTFParser)._additiveParse.apply(_GLTFParser, [].concat([
                extensionName,
                context,
                parseResource,
                extensionSchema,
                ownerSchema
            ], extra));
        }
    };
    /**
   * Whether the plugin is registered.
   * @param extensionName - Extension name
   * @returns Boolean
   */ GLTFParser.hasExtensionParser = function hasExtensionParser(extensionName) {
        var _GLTFParser__extensionParsers_extensionName;
        return !!((_GLTFParser__extensionParsers_extensionName = GLTFParser._extensionParsers[extensionName]) == null ? void 0 : _GLTFParser__extensionParsers_extensionName.length);
    };
    /**
   * Get the last plugin by glTF extension mode.
   * @param extensionName - Extension name
   * @param mode - GLTF extension mode
   * @returns GLTF extension parser
   */ GLTFParser.getExtensionParser = function getExtensionParser(extensionName, mode) {
        var parsers = GLTFParser._extensionParsers[extensionName];
        var length = parsers == null ? void 0 : parsers.length;
        if (length) {
            // only use the last parser.
            for(var i = length - 1; i >= 0; --i){
                var currentParser = parsers[i];
                if (currentParser._mode === mode) {
                    return currentParser;
                }
            }
        }
    };
    /**
   * @internal
   */ GLTFParser._addExtensionParser = function _addExtensionParser(extensionName, extensionParser) {
        if (!GLTFParser._extensionParsers[extensionName]) {
            GLTFParser._extensionParsers[extensionName] = [];
        }
        GLTFParser._extensionParsers[extensionName].push(extensionParser);
    };
    GLTFParser._createAndParse = function _createAndParse(extensionName, context, extensionSchema, ownerSchema) {
        for(var _len = arguments.length, extra = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++){
            extra[_key - 4] = arguments[_key];
        }
        var parser = GLTFParser.getExtensionParser(extensionName, GLTFExtensionMode.CreateAndParse);
        if (parser) {
            var _parser;
            return (_parser = parser).createAndParse.apply(_parser, [].concat([
                context,
                extensionSchema,
                ownerSchema
            ], extra));
        }
    };
    GLTFParser._additiveParse = function _additiveParse(extensionName, context, parseResource, extensionSchema, ownerSchema) {
        for(var _len = arguments.length, extra = new Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++){
            extra[_key - 5] = arguments[_key];
        }
        var _parser;
        var parser = GLTFParser.getExtensionParser(extensionName, GLTFExtensionMode.AdditiveParse);
        parser == null ? void 0 : (_parser = parser).additiveParse.apply(_parser, [].concat([
            context,
            parseResource,
            extensionSchema,
            ownerSchema
        ], extra));
    };
    return GLTFParser;
}();
GLTFParser._extensionParsers = {};
/**
 * Declare ExtensionParser's decorator.
 * @param extensionName - Extension name
 */ function registerGLTFExtension(extensionName, mode) {
    return function(parser) {
        var extensionParser = new parser();
        extensionParser._mode = mode;
        GLTFParser._addExtensionParser(extensionName, extensionParser);
    };
}

var GLTFSchemaParser = /*#__PURE__*/ function(GLTFParser) {
    _inherits(GLTFSchemaParser, GLTFParser);
    function GLTFSchemaParser() {
        return GLTFParser.apply(this, arguments) || this;
    }
    var _proto = GLTFSchemaParser.prototype;
    _proto.parse = function parse(context) {
        var glTFResource = context.glTFResource, contentRestorer = context.contentRestorer, resourceManager = context.resourceManager;
        var url = glTFResource.url;
        var restoreBufferRequests = contentRestorer.bufferRequests;
        var requestConfig = {
            type: "arraybuffer"
        };
        // @ts-ignore
        var remoteUrl = resourceManager._getRemoteUrl(url);
        return resourceManager// @ts-ignore
        ._requestByRemoteUrl(remoteUrl, requestConfig).onProgress(undefined, context._onTaskDetail).then(function(buffer) {
            var parseResult = GLTFUtils.parseGLB(context, buffer);
            // If the buffer is a GLB file, we need to restore the buffer data
            if (parseResult == null ? void 0 : parseResult.glTF) {
                restoreBufferRequests.push(new BufferRequestInfo(remoteUrl, requestConfig));
            }
            return parseResult;
        }).then(function(result) {
            if (result == null ? void 0 : result.glTF) {
                contentRestorer.isGLB = true;
                context.buffers = result.buffers;
                return result.glTF;
            } else {
                contentRestorer.isGLB = false;
                return JSON.parse(Utils.decodeText(new Uint8Array(result.originBuffer)));
            }
        });
    };
    return GLTFSchemaParser;
}(GLTFParser);
GLTFSchemaParser = __decorate([
    registerGLTFParser(GLTFParserType.Schema)
], GLTFSchemaParser);

var GLTFAnimationParser = /*#__PURE__*/ function(GLTFParser1) {
    _inherits(GLTFAnimationParser, GLTFParser1);
    function GLTFAnimationParser() {
        return GLTFParser1.apply(this, arguments) || this;
    }
    var _proto = GLTFAnimationParser.prototype;
    _proto.parse = function parse(context, index) {
        var animationInfo = context.glTF.animations[index];
        var _animationInfo_name = animationInfo.name, name = _animationInfo_name === void 0 ? "AnimationClip" + index : _animationInfo_name;
        var animationClipPromise = GLTFParser.executeExtensionsCreateAndParse(animationInfo.extensions, context, animationInfo) || GLTFAnimationParser._parseStandardProperty(context, new AnimationClip(name), animationInfo);
        return AssetPromise.resolve(animationClipPromise).then(function(animationClip) {
            GLTFParser.executeExtensionsAdditiveAndParse(animationInfo.extensions, context, animationClip, animationInfo);
            return animationClip;
        });
    };
    /**
   * @internal
   */ GLTFAnimationParser._parseStandardProperty = function _parseStandardProperty(context, animationClip, animationInfo) {
        var _loop = function(j, m) {
            var glTFSampler = samplers[j];
            var inputAccessor = accessors[glTFSampler.input];
            var outputAccessor = accessors[glTFSampler.output];
            var promise = AssetPromise.all([
                GLTFUtils.getAccessorBuffer(context, bufferViews, inputAccessor),
                GLTFUtils.getAccessorBuffer(context, bufferViews, outputAccessor)
            ]).then(function(bufferInfos) {
                var input = bufferInfos[0].data;
                var output = bufferInfos[1].data;
                if (outputAccessor.normalized) {
                    var scale = GLTFUtils.getNormalizedComponentScale(outputAccessor.componentType);
                    var scaled = new Float32Array(output.length);
                    for(var k = 0, v = output.length; k < v; k++){
                        scaled[k] = output[k] * scale;
                    }
                    output = scaled;
                }
                var outputStride = output.length / input.length;
                var _glTFSampler_interpolation;
                var interpolation = (_glTFSampler_interpolation = glTFSampler.interpolation) != null ? _glTFSampler_interpolation : AnimationSamplerInterpolation.Linear;
                var samplerInterpolation;
                switch(interpolation){
                    case AnimationSamplerInterpolation.CubicSpine:
                        samplerInterpolation = InterpolationType.CubicSpine;
                        break;
                    case AnimationSamplerInterpolation.Step:
                        samplerInterpolation = InterpolationType.Step;
                        break;
                    case AnimationSamplerInterpolation.Linear:
                        samplerInterpolation = InterpolationType.Linear;
                        break;
                }
                input[input.length - 1];
                sampleDataCollection[j] = {
                    type: outputAccessor.type,
                    interpolation: samplerInterpolation,
                    input: input,
                    output: output,
                    outputSize: outputStride
                };
            });
            promises.push(promise);
        };
        var _this = this;
        var glTF = context.glTF;
        var accessors = glTF.accessors, bufferViews = glTF.bufferViews;
        var channels = animationInfo.channels, samplers = animationInfo.samplers;
        var len = samplers.length;
        var sampleDataCollection = new Array(len);
        var entities = context.get(GLTFParserType.Entity);
        var promises = new Array();
        // parse samplers
        for(var j = 0, m = len; j < m; j++)_loop(j);
        promises.push(context.get(GLTFParserType.Scene));
        return AssetPromise.all(promises).then(function() {
            for(var j = 0, m = channels.length; j < m; j++){
                var glTFChannel = channels[j];
                var target = glTFChannel.target;
                var channelTargetEntity = entities[target.node];
                var relativePath = "";
                var entity = channelTargetEntity;
                while(entity.parent){
                    relativePath = relativePath === "" ? "" + entity.name : entity.name + "/" + relativePath;
                    entity = entity.parent;
                }
                // If the target node is in the default scene, relativePath will be empty
                if (context.glTFResource.sceneRoots.indexOf(entity) === -1) {
                    continue;
                }
                var ComponentType = void 0;
                var propertyName = void 0;
                switch(target.path){
                    case AnimationChannelTargetPath.TRANSLATION:
                        ComponentType = Transform;
                        propertyName = "position";
                        break;
                    case AnimationChannelTargetPath.ROTATION:
                        ComponentType = Transform;
                        propertyName = "rotationQuaternion";
                        break;
                    case AnimationChannelTargetPath.SCALE:
                        ComponentType = Transform;
                        propertyName = "scale";
                        break;
                    case AnimationChannelTargetPath.WEIGHTS:
                        ComponentType = SkinnedMeshRenderer;
                        propertyName = "blendShapeWeights";
                        break;
                }
                var curve = _this._addCurve(target.path, glTFChannel, sampleDataCollection);
                if (target.path === AnimationChannelTargetPath.WEIGHTS) {
                    var mesh = glTF.nodes[target.node].mesh;
                    for(var i = 0, n = glTF.meshes[mesh].primitives.length; i < n; i++){
                        animationClip.addCurveBinding(relativePath, ComponentType, i, propertyName, curve);
                    }
                } else {
                    animationClip.addCurveBinding(relativePath, ComponentType, propertyName, curve);
                }
            }
            return animationClip;
        });
    };
    GLTFAnimationParser._addCurve = function _addCurve(animationChannelTargetPath, glTFChannel, sampleDataCollection) {
        var sampleData = sampleDataCollection[glTFChannel.sampler];
        var input = sampleData.input, output = sampleData.output, outputSize = sampleData.outputSize;
        switch(animationChannelTargetPath){
            case AnimationChannelTargetPath.TRANSLATION:
            case AnimationChannelTargetPath.SCALE:
                {
                    var curve = new AnimationVector3Curve();
                    var interpolation = curve.interpolation = sampleData.interpolation;
                    var offset = 0;
                    for(var i = 0, n = input.length; i < n; i++){
                        var keyframe = new Keyframe();
                        keyframe.time = input[i];
                        if (interpolation === InterpolationType.CubicSpine) {
                            keyframe.inTangent = new Vector3(output[offset++], output[offset++], output[offset++]);
                            keyframe.value = new Vector3(output[offset++], output[offset++], output[offset++]);
                            keyframe.outTangent = new Vector3(output[offset++], output[offset++], output[offset++]);
                        } else {
                            keyframe.value = new Vector3(output[offset++], output[offset++], output[offset++]);
                        }
                        curve.addKey(keyframe);
                    }
                    return curve;
                }
            case AnimationChannelTargetPath.ROTATION:
                {
                    var curve1 = new AnimationQuaternionCurve();
                    var interpolation1 = curve1.interpolation = sampleData.interpolation;
                    var offset1 = 0;
                    for(var i1 = 0, n1 = input.length; i1 < n1; i1++){
                        var keyframe1 = new Keyframe();
                        keyframe1.time = input[i1];
                        if (interpolation1 === InterpolationType.CubicSpine) {
                            keyframe1.inTangent = new Vector4(output[offset1++], output[offset1++], output[offset1++], output[offset1++]);
                            keyframe1.value = new Quaternion(output[offset1++], output[offset1++], output[offset1++], output[offset1++]);
                            keyframe1.outTangent = new Vector4(output[offset1++], output[offset1++], output[offset1++], output[offset1++]);
                        } else {
                            keyframe1.value = new Quaternion(output[offset1++], output[offset1++], output[offset1++], output[offset1++]);
                        }
                        curve1.addKey(keyframe1);
                    }
                    return curve1;
                }
            case AnimationChannelTargetPath.WEIGHTS:
                {
                    var curve2 = new AnimationFloatArrayCurve();
                    curve2.interpolation = sampleData.interpolation;
                    var offset2 = 0;
                    for(var i2 = 0, n2 = input.length; i2 < n2; i2++){
                        var keyframe2 = new Keyframe();
                        keyframe2.time = input[i2];
                        if (curve2.interpolation === InterpolationType.CubicSpine) {
                            keyframe2.inTangent = Array.from(output.subarray(offset2, offset2 + outputSize));
                            offset2 += outputSize;
                            keyframe2.value = output.slice(offset2, offset2 + outputSize);
                            offset2 += outputSize;
                            keyframe2.outTangent = Array.from(output.subarray(offset2, offset2 + outputSize));
                            offset2 += outputSize;
                        } else {
                            keyframe2.value = output.slice(offset2, offset2 + outputSize);
                            offset2 += outputSize;
                        }
                        curve2.addKey(keyframe2);
                    }
                    return curve2;
                }
        }
    };
    return GLTFAnimationParser;
}(GLTFParser);
GLTFAnimationParser = __decorate([
    registerGLTFParser(GLTFParserType.Animation)
], GLTFAnimationParser);

var GLTFBufferParser = /*#__PURE__*/ function(GLTFParser) {
    _inherits(GLTFBufferParser, GLTFParser);
    function GLTFBufferParser() {
        return GLTFParser.apply(this, arguments) || this;
    }
    var _proto = GLTFBufferParser.prototype;
    _proto.parse = function parse(context, index) {
        var buffers = context.glTF.buffers;
        return context.buffers ? AssetPromise.resolve(context.buffers[index]) : this._parseSingleBuffer(context, buffers[index]);
    };
    _proto._parseSingleBuffer = function _parseSingleBuffer(context, bufferInfo) {
        var glTFResource = context.glTFResource, contentRestorer = context.contentRestorer, resourceManager = context.resourceManager;
        var url = glTFResource.url;
        // @ts-ignore
        var remoteUrl = resourceManager._getRemoteUrl(url);
        var restoreBufferRequests = contentRestorer.bufferRequests;
        var requestConfig = {
            type: "arraybuffer"
        };
        var absoluteUrl = Utils.resolveAbsoluteUrl(remoteUrl, bufferInfo.uri);
        restoreBufferRequests.push(new BufferRequestInfo(absoluteUrl, requestConfig));
        var promise = resourceManager// @ts-ignore
        ._requestByRemoteUrl(absoluteUrl, requestConfig).onProgress(undefined, context._onTaskDetail);
        context._addTaskCompletePromise(promise);
        return promise;
    };
    return GLTFBufferParser;
}(GLTFParser);
GLTFBufferParser = __decorate([
    registerGLTFParser(GLTFParserType.Buffer)
], GLTFBufferParser);

var GLTFEntityParser = /*#__PURE__*/ function(GLTFParser1) {
    _inherits(GLTFEntityParser, GLTFParser1);
    function GLTFEntityParser() {
        return GLTFParser1.apply(this, arguments) || this;
    }
    var _proto = GLTFEntityParser.prototype;
    _proto.parse = function parse(context, index) {
        var glTFResource = context.glTFResource;
        var entityInfo = context.glTF.nodes[index];
        var engine = glTFResource.engine;
        var matrix = entityInfo.matrix, translation = entityInfo.translation, rotation = entityInfo.rotation, scale = entityInfo.scale, extensions = entityInfo.extensions;
        var entity = new Entity(engine, entityInfo.name || "_GLTF_ENTITY_" + index);
        // @ts-ignore
        entity._markAsTemplate(glTFResource);
        var transform = entity.transform;
        if (matrix) {
            var localMatrix = transform.localMatrix;
            localMatrix.copyFromArray(matrix);
            transform.localMatrix = localMatrix;
        } else {
            if (translation) {
                transform.setPosition(translation[0], translation[1], translation[2]);
            }
            if (rotation) {
                transform.setRotationQuaternion(rotation[0], rotation[1], rotation[2], rotation[3]);
            }
            if (scale) {
                transform.setScale(scale[0], scale[1], scale[2]);
            }
        }
        var children = entityInfo.children;
        if (children) {
            for(var i = 0; i < children.length; i++){
                var childIndex = children[i];
                var childEntity = context.get(GLTFParserType.Entity, childIndex);
                entity.addChild(childEntity);
            }
        }
        GLTFParser.executeExtensionsAdditiveAndParse(extensions, context, entity, entityInfo);
        return entity;
    };
    return GLTFEntityParser;
}(GLTFParser);
GLTFEntityParser = __decorate([
    registerGLTFParser(GLTFParserType.Entity)
], GLTFEntityParser);

// @todo: remap plugin should have a higher priority storage location
var REMAP_NAME = "GALACEAN_materials_remap";
var GLTFMaterialParser = /*#__PURE__*/ function(GLTFParser1) {
    _inherits(GLTFMaterialParser, GLTFParser1);
    function GLTFMaterialParser() {
        return GLTFParser1.apply(this, arguments) || this;
    }
    var _proto = GLTFMaterialParser.prototype;
    _proto.parse = function parse(context, index) {
        var materialInfo = context.glTF.materials[index];
        var glTFResource = context.glTFResource;
        var engine = glTFResource.engine;
        var extensions = materialInfo.extensions || {};
        //Keep only the remap extension
        if (extensions[REMAP_NAME]) {
            var _obj;
            extensions = (_obj = {}, _obj[REMAP_NAME] = extensions[REMAP_NAME], _obj);
        }
        var material = GLTFParser.executeExtensionsCreateAndParse(extensions, context, materialInfo);
        if (!material) {
            material = new PBRMaterial(engine);
            material.name = materialInfo.name;
            GLTFMaterialParser._parseStandardProperty(context, material, materialInfo);
        }
        return AssetPromise.resolve(material).then(function(material) {
            // @ts-ignore
            material || (material = engine._basicResources._getBlinnPhongMaterial());
            GLTFParser.executeExtensionsAdditiveAndParse(extensions, context, material, materialInfo);
            // @ts-ignore
            material._associationSuperResource(glTFResource);
            return material;
        });
    };
    /**
   * @internal
   */ GLTFMaterialParser._checkOtherTextureTransform = function _checkOtherTextureTransform(texture, textureName) {
        var _texture_extensions;
        if ((_texture_extensions = texture.extensions) == null ? void 0 : _texture_extensions.KHR_texture_transform) {
            Logger.warn("" + textureName + " texture ignore KHR_texture_transform extension.");
        }
    };
    /**
   * @internal
   */ GLTFMaterialParser._parseStandardProperty = function _parseStandardProperty(context, material, materialInfo) {
        var pbrMetallicRoughness = materialInfo.pbrMetallicRoughness, normalTexture = materialInfo.normalTexture, occlusionTexture = materialInfo.occlusionTexture, emissiveTexture = materialInfo.emissiveTexture, emissiveFactor = materialInfo.emissiveFactor, alphaMode = materialInfo.alphaMode, alphaCutoff = materialInfo.alphaCutoff, doubleSided = materialInfo.doubleSided;
        if (pbrMetallicRoughness) {
            var baseColorFactor = pbrMetallicRoughness.baseColorFactor, baseColorTexture = pbrMetallicRoughness.baseColorTexture, metallicFactor = pbrMetallicRoughness.metallicFactor, roughnessFactor = pbrMetallicRoughness.roughnessFactor, metallicRoughnessTexture = pbrMetallicRoughness.metallicRoughnessTexture;
            if (baseColorFactor) {
                material.baseColor.copyFromArray(baseColorFactor);
            }
            if (baseColorTexture) {
                context.get(GLTFParserType.Texture, baseColorTexture.index).then(function(texture) {
                    material.baseTexture = texture;
                    GLTFParser.executeExtensionsAdditiveAndParse(baseColorTexture.extensions, context, material, baseColorTexture);
                }).catch(function(e) {
                    Logger.error("GLTFMaterialParser: baseColorTexture error", e);
                });
            }
            if (material.constructor === PBRMaterial) {
                material.metallic = metallicFactor != null ? metallicFactor : 1;
                material.roughness = roughnessFactor != null ? roughnessFactor : 1;
                if (metallicRoughnessTexture) {
                    GLTFMaterialParser._checkOtherTextureTransform(metallicRoughnessTexture, "Roughness metallic");
                    context.get(GLTFParserType.Texture, metallicRoughnessTexture.index).then(function(texture) {
                        material.roughnessMetallicTexture = texture;
                    }).catch(function(e) {
                        Logger.error("GLTFMaterialParser: metallicRoughnessTexture error", e);
                    });
                }
            }
        }
        if (material.constructor === PBRMaterial || material.constructor === PBRSpecularMaterial) {
            if (emissiveTexture) {
                GLTFMaterialParser._checkOtherTextureTransform(emissiveTexture, "Emissive");
                context.get(GLTFParserType.Texture, emissiveTexture.index).then(function(texture) {
                    material.emissiveTexture = texture;
                }).catch(function(e) {
                    Logger.error("GLTFMaterialParser: emissiveTexture error", e);
                });
            }
            if (emissiveFactor) {
                material.emissiveColor.set(emissiveFactor[0], emissiveFactor[1], emissiveFactor[2], 1.0);
            }
            if (normalTexture) {
                var index = normalTexture.index, scale = normalTexture.scale;
                GLTFMaterialParser._checkOtherTextureTransform(normalTexture, "Normal");
                context.get(GLTFParserType.Texture, index).then(function(texture) {
                    material.normalTexture = texture;
                }).catch(function(e) {
                    Logger.error("GLTFMaterialParser: emissiveTexture error", e);
                });
                if (scale !== undefined) {
                    material.normalTextureIntensity = scale;
                }
            }
            if (occlusionTexture) {
                var index1 = occlusionTexture.index, strength = occlusionTexture.strength, texCoord = occlusionTexture.texCoord;
                GLTFMaterialParser._checkOtherTextureTransform(occlusionTexture, "Occlusion");
                context.get(GLTFParserType.Texture, index1).then(function(texture) {
                    material.occlusionTexture = texture;
                }).catch(function(e) {
                    Logger.error("GLTFMaterialParser: occlusionTexture error", e);
                });
                if (strength !== undefined) {
                    material.occlusionTextureIntensity = strength;
                }
                if (texCoord === TextureCoordinate.UV1) {
                    material.occlusionTextureCoord = TextureCoordinate.UV1;
                } else if (texCoord > TextureCoordinate.UV1) {
                    Logger.warn("Occlusion texture uv coordinate must be UV0 or UV1.");
                }
            }
        }
        if (doubleSided) {
            material.renderFace = RenderFace.Double;
        } else {
            material.renderFace = RenderFace.Front;
        }
        switch(alphaMode){
            case MaterialAlphaMode.OPAQUE:
                material.isTransparent = false;
                break;
            case MaterialAlphaMode.BLEND:
                material.isTransparent = true;
                break;
            case MaterialAlphaMode.MASK:
                material.alphaCutoff = alphaCutoff != null ? alphaCutoff : 0.5;
                break;
        }
    };
    return GLTFMaterialParser;
}(GLTFParser);
GLTFMaterialParser = __decorate([
    registerGLTFParser(GLTFParserType.Material)
], GLTFMaterialParser);

var GLTFMeshParser = /*#__PURE__*/ function(GLTFParser1) {
    _inherits(GLTFMeshParser, GLTFParser1);
    function GLTFMeshParser() {
        return GLTFParser1.apply(this, arguments) || this;
    }
    var _proto = GLTFMeshParser.prototype;
    _proto.parse = function parse(context, index) {
        var _loop = function(i, length) {
            var gltfPrimitive = meshInfo.primitives[i];
            primitivePromises[i] = new AssetPromise(function(resolve, reject) {
                var mesh = GLTFParser.executeExtensionsCreateAndParse(gltfPrimitive.extensions, context, gltfPrimitive, meshInfo);
                if (mesh) {
                    if (_instanceof$1(mesh, ModelMesh)) {
                        // @ts-ignore
                        mesh._associationSuperResource(glTFResource);
                        resolve(mesh);
                    } else {
                        mesh.then(function(mesh) {
                            // @ts-ignore
                            mesh._associationSuperResource(glTFResource);
                            resolve(mesh);
                        });
                    }
                } else {
                    var mesh1 = new ModelMesh(engine, meshInfo.name || i + "");
                    // @ts-ignore
                    mesh1._associationSuperResource(glTFResource);
                    var meshRestoreInfo = new ModelMeshRestoreInfo();
                    meshRestoreInfo.mesh = mesh1;
                    context.contentRestorer.meshes.push(meshRestoreInfo);
                    GLTFMeshParser._parseMeshFromGLTFPrimitive(context, mesh1, meshRestoreInfo, meshInfo, gltfPrimitive, glTF, context.params.keepMeshData).then(resolve, reject);
                }
            });
        };
        var meshInfo = context.glTF.meshes[index];
        var glTF = context.glTF, glTFResource = context.glTFResource;
        var engine = glTFResource.engine;
        var primitivePromises = new Array();
        for(var i = 0, length = meshInfo.primitives.length; i < length; i++)_loop(i);
        return AssetPromise.all(primitivePromises);
    };
    /**
   * @internal
   */ GLTFMeshParser._parseMeshFromGLTFPrimitive = function _parseMeshFromGLTFPrimitive(context, mesh, meshRestoreInfo, gltfMesh, gltfPrimitive, gltf, keepMeshData) {
        var _loop = function(attribute) {
            var accessor = accessors[attributes[attribute]];
            var promise = GLTFUtils.getAccessorBuffer(context, gltf.bufferViews, accessor).then(function(accessorBuffer) {
                var dataElementSize = GLTFUtils.getAccessorTypeSize(accessor.type);
                var accessorCount = accessor.count;
                var vertices = accessorBuffer.data;
                var vertexElement;
                var meshId = mesh.instanceId;
                var vertexBindingInfos = accessorBuffer.vertexBindingInfos;
                var elementNormalized = accessor.normalized;
                var elementFormat = GLTFUtils.getElementFormat(accessor.componentType, dataElementSize, elementNormalized);
                var scaleFactor;
                elementNormalized && (scaleFactor = GLTFUtils.getNormalizedComponentScale(accessor.componentType));
                var elementOffset;
                if (accessorBuffer.interleaved) {
                    var byteOffset = accessor.byteOffset || 0;
                    var stride = accessorBuffer.stride;
                    elementOffset = byteOffset % stride;
                    if (vertexBindingInfos[meshId] === undefined) {
                        vertexElement = new VertexElement(attribute, elementOffset, elementFormat, bufferBindIndex);
                        var vertexBuffer = accessorBuffer.vertexBuffer;
                        if (!vertexBuffer) {
                            vertexBuffer = new Buffer(engine, BufferBindFlag.VertexBuffer, vertices, BufferUsage.Static, keepMeshData);
                            accessorBuffer.vertexBuffer = vertexBuffer;
                            meshRestoreInfo.vertexBuffers.push(new BufferRestoreInfo(vertexBuffer, accessorBuffer.restoreInfo));
                        }
                        mesh.setVertexBufferBinding(vertexBuffer, stride, bufferBindIndex);
                        vertexBindingInfos[meshId] = bufferBindIndex++;
                    } else {
                        vertexElement = new VertexElement(attribute, elementOffset, elementFormat, vertexBindingInfos[meshId]);
                    }
                } else {
                    elementOffset = 0;
                    vertexElement = new VertexElement(attribute, elementOffset, elementFormat, bufferBindIndex);
                    var vertexBuffer1 = accessorBuffer.vertexBuffer;
                    if (!vertexBuffer1) {
                        vertexBuffer1 = new Buffer(engine, BufferBindFlag.VertexBuffer, vertices, BufferUsage.Static, keepMeshData);
                        meshRestoreInfo.vertexBuffers.push(new BufferRestoreInfo(vertexBuffer1, accessorBuffer.restoreInfo));
                    }
                    mesh.setVertexBufferBinding(vertexBuffer1, accessorBuffer.stride, bufferBindIndex);
                    vertexBindingInfos[meshId] = bufferBindIndex++;
                }
                vertexElements.push(vertexElement);
                if (attribute === "POSITION") {
                    vertexCount = accessorCount;
                    var _mesh_bounds = mesh.bounds, min = _mesh_bounds.min, max = _mesh_bounds.max;
                    if (accessor.min && accessor.max) {
                        min.copyFromArray(accessor.min);
                        max.copyFromArray(accessor.max);
                    } else {
                        var position = GLTFMeshParser._tempVector3;
                        min.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
                        max.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
                        var baseOffset = elementOffset / vertices.BYTES_PER_ELEMENT;
                        var stride1 = vertices.length / accessorCount;
                        for(var j = 0; j < accessorCount; j++){
                            var offset = baseOffset + j * stride1;
                            position.copyFromArray(vertices, offset);
                            Vector3.min(min, position, min);
                            Vector3.max(max, position, max);
                        }
                    }
                    if (elementNormalized) {
                        min.scale(scaleFactor);
                        max.scale(scaleFactor);
                    }
                }
            });
            promises.push(promise);
        };
        var accessors = gltf.accessors;
        var attributes = gltfPrimitive.attributes, targets = gltfPrimitive.targets, indices = gltfPrimitive.indices, mode = gltfPrimitive.mode;
        var engine = mesh.engine;
        var vertexElements = new Array();
        var vertexCount;
        var bufferBindIndex = 0;
        var promises = new Array();
        for(var attribute in attributes)_loop(attribute);
        return AssetPromise.all(promises).then(function() {
            mesh.setVertexElements(vertexElements);
            // Indices
            if (indices !== undefined) {
                var indexAccessor = gltf.accessors[indices];
                var promise = GLTFUtils.getAccessorBuffer(context, gltf.bufferViews, indexAccessor).then(function(accessorBuffer) {
                    mesh.setIndices(accessorBuffer.data);
                    mesh.addSubMesh(0, indexAccessor.count, mode);
                    meshRestoreInfo.indexBuffer = accessorBuffer.restoreInfo;
                });
                promises.push(promise);
            } else {
                mesh.addSubMesh(0, vertexCount, mode);
            }
            // BlendShapes
            if (targets) {
                promises.push(GLTFMeshParser._createBlendShape(context, mesh, meshRestoreInfo, gltfMesh, gltfPrimitive, targets));
            }
            return Promise.all(promises).then(function() {
                mesh.uploadData(!keepMeshData);
                return mesh;
            });
        });
    };
    GLTFMeshParser._getBlendShapeData = function _getBlendShapeData(context, glTF, accessor) {
        return GLTFUtils.getAccessorBuffer(context, glTF.bufferViews, accessor).then(function(bufferInfo) {
            var buffer = bufferInfo.data;
            var _accessor_byteOffset;
            var byteOffset = bufferInfo.interleaved ? ((_accessor_byteOffset = accessor.byteOffset) != null ? _accessor_byteOffset : 0) % bufferInfo.stride : 0;
            var count = accessor.count, normalized = accessor.normalized, componentType = accessor.componentType;
            var vertices = GLTFUtils.bufferToVector3Array(buffer, byteOffset, count, normalized, componentType);
            var restoreInfo = new BlendShapeDataRestoreInfo(bufferInfo.restoreInfo, byteOffset, count, normalized, componentType);
            return {
                vertices: vertices,
                restoreInfo: restoreInfo
            };
        });
    };
    /**
   * @internal
   */ GLTFMeshParser._createBlendShape = function _createBlendShape(context, mesh, meshRestoreInfo, glTFMesh, gltfPrimitive, glTFTargets) {
        var _this, _loop = function(i) {
            var blendShapeData = {};
            blendShapeCollection[i] = blendShapeData;
            var name = blendShapeNames ? blendShapeNames[i] : "blendShape" + i;
            var targets = gltfPrimitive.targets[i];
            var normalTarget = targets["NORMAL"];
            var tangentTarget = targets["TANGENT"];
            var hasNormal = normalTarget !== undefined;
            var hasTangent = tangentTarget !== undefined;
            var promise = AssetPromise.all([
                _this._getBlendShapeData(context, glTF, accessors[targets["POSITION"]]),
                hasNormal ? _this._getBlendShapeData(context, glTF, accessors[normalTarget]) : null,
                hasTangent ? _this._getBlendShapeData(context, glTF, accessors[tangentTarget]) : null
            ]).then(function(vertices) {
                var positionData = vertices[0], normalData = vertices[1], tangentData = vertices[2];
                var blendShape = new BlendShape(name);
                blendShape.addFrame(1.0, positionData.vertices, hasNormal ? normalData.vertices : null, hasTangent ? tangentData.vertices : null);
                blendShapeData.blendShape = blendShape;
                blendShapeData.restoreInfo = new BlendShapeRestoreInfo(blendShape, positionData.restoreInfo, hasNormal ? normalData.restoreInfo : null, hasTangent ? tangentData == null ? void 0 : tangentData.restoreInfo : null);
            });
            promises.push(promise);
        };
        var glTF = context.glTF;
        var accessors = glTF.accessors;
        var blendShapeNames = glTFMesh.extras ? glTFMesh.extras.targetNames : null;
        var promises = new Array();
        var blendShapeCount = glTFTargets.length;
        var blendShapeCollection = new Array(blendShapeCount);
        for(var i = 0; i < blendShapeCount; i++)_this = this, _loop(i);
        return AssetPromise.all(promises).then(function() {
            for(var _iterator = _create_for_of_iterator_helper_loose(blendShapeCollection), _step; !(_step = _iterator()).done;){
                var blendShape = _step.value;
                mesh.addBlendShape(blendShape.blendShape);
                meshRestoreInfo.blendShapes.push(blendShape.restoreInfo);
            }
        });
    };
    return GLTFMeshParser;
}(GLTFParser);
GLTFMeshParser._tempVector3 = new Vector3();
GLTFMeshParser = __decorate([
    registerGLTFParser(GLTFParserType.Mesh)
], GLTFMeshParser);

var GLTFSceneParser = /*#__PURE__*/ function(GLTFParser1) {
    _inherits(GLTFSceneParser, GLTFParser1);
    function GLTFSceneParser() {
        return GLTFParser1.apply(this, arguments) || this;
    }
    var _proto = GLTFSceneParser.prototype;
    _proto.parse = function parse(context, index) {
        var _context_glTF = context.glTF, scenes = _context_glTF.scenes, _context_glTF_scene = _context_glTF.scene, scene = _context_glTF_scene === void 0 ? 0 : _context_glTF_scene, glTFResource = context.glTFResource;
        var sceneInfo = scenes[index];
        var sceneExtensions = sceneInfo.extensions;
        var engine = glTFResource.engine;
        var isDefaultScene = scene === index;
        var sceneNodes = sceneInfo.nodes || [];
        var sceneRoot;
        if (sceneNodes.length === 1) {
            sceneRoot = context.get(GLTFParserType.Entity, sceneNodes[0]);
        } else {
            sceneRoot = new Entity(engine, "GLTF_ROOT");
            // @ts-ignore
            sceneRoot._markAsTemplate(glTFResource);
            for(var i = 0; i < sceneNodes.length; i++){
                var childEntity = context.get(GLTFParserType.Entity, sceneNodes[i]);
                sceneRoot.addChild(childEntity);
            }
        }
        if (isDefaultScene) {
            glTFResource._defaultSceneRoot = sceneRoot;
        }
        var promises = new Array();
        for(var i1 = 0; i1 < sceneNodes.length; i1++){
            promises.push(this._parseEntityComponent(context, sceneNodes[i1]));
        }
        return AssetPromise.all(promises).then(function() {
            GLTFParser.executeExtensionsAdditiveAndParse(sceneExtensions, context, sceneRoot, sceneInfo);
            return sceneRoot;
        });
    };
    _proto._parseEntityComponent = function _parseEntityComponent(context, index) {
        var _this = this;
        var glTF = context.glTF, glTFResource = context.glTFResource;
        var entityInfo = glTF.nodes[index];
        var cameraID = entityInfo.camera, meshID = entityInfo.mesh;
        var entity = context.get(GLTFParserType.Entity, index);
        var promise;
        if (cameraID !== undefined) {
            this._createCamera(glTFResource, glTF.cameras[cameraID], entity);
        }
        if (meshID !== undefined) {
            promise = this._createRenderer(context, entityInfo, entity);
        }
        return AssetPromise.resolve(promise).then(function() {
            var promises = [];
            var children = entityInfo.children;
            if (children) {
                for(var i = 0; i < children.length; i++){
                    promises.push(_this._parseEntityComponent(context, children[i]));
                }
            }
            return AssetPromise.all(promises);
        });
    };
    _proto._createCamera = function _createCamera(resource, cameraSchema, entity) {
        var _resource;
        var orthographic = cameraSchema.orthographic, perspective = cameraSchema.perspective, type = cameraSchema.type;
        var camera = entity.addComponent(Camera);
        if (type === CameraType.ORTHOGRAPHIC) {
            var xmag = orthographic.xmag, ymag = orthographic.ymag, zfar = orthographic.zfar, znear = orthographic.znear;
            camera.isOrthographic = true;
            if (znear !== undefined) {
                camera.nearClipPlane = znear;
            }
            if (zfar !== undefined) {
                camera.farClipPlane = zfar;
            }
            camera.orthographicSize = Math.max(ymag != null ? ymag : 0, xmag != null ? xmag : 0) / 2;
        } else if (type === CameraType.PERSPECTIVE) {
            var aspectRatio = perspective.aspectRatio, yfov = perspective.yfov, zfar1 = perspective.zfar, znear1 = perspective.znear;
            if (aspectRatio !== undefined) {
                camera.aspectRatio = aspectRatio;
            }
            if (yfov !== undefined) {
                camera.fieldOfView = yfov * 180 / Math.PI;
            }
            if (zfar1 !== undefined) {
                camera.farClipPlane = zfar1;
            }
            if (znear1 !== undefined) {
                camera.nearClipPlane = znear1;
            }
        }
        (_resource = resource).cameras || (_resource.cameras = []);
        resource.cameras.push(camera);
        // @todo: use engine camera by default
        camera.enabled = false;
    };
    _proto._createRenderer = function _createRenderer(context, entityInfo, entity) {
        var _this = this;
        var meshID = entityInfo.mesh, skinID = entityInfo.skin;
        var glTFMesh = context.glTF.meshes[meshID];
        var glTFMeshPrimitives = glTFMesh.primitives;
        var rendererCount = glTFMeshPrimitives.length;
        var blendShapeWeights = entityInfo.weights || glTFMesh.weights;
        var materialPromises = new Array(rendererCount);
        for(var i = 0; i < rendererCount; i++){
            var _glTFMeshPrimitives_i_material;
            materialPromises[i] = context.get(GLTFParserType.Material, (_glTFMeshPrimitives_i_material = glTFMeshPrimitives[i].material) != null ? _glTFMeshPrimitives_i_material : -1);
        }
        return AssetPromise.all([
            context.get(GLTFParserType.Mesh, meshID),
            skinID !== undefined && context.get(GLTFParserType.Skin, skinID),
            AssetPromise.all(materialPromises)
        ]).then(function(param) {
            var _loop = function(i) {
                var material = materials[i] || basicResources._getBlinnPhongMaterial();
                var glTFPrimitive = glTFMeshPrimitives[i];
                var mesh = meshes[i];
                var renderer = void 0;
                if (skin || blendShapeWeights) {
                    var skinRenderer = entity.addComponent(SkinnedMeshRenderer);
                    skinRenderer.mesh = mesh;
                    if (skin) {
                        _this._computeLocalBounds(skinRenderer, mesh, skin.bones, skin.rootBone, skin.inverseBindMatrices);
                        skinRenderer.skin = skin;
                    }
                    if (blendShapeWeights) {
                        skinRenderer.blendShapeWeights = new Float32Array(blendShapeWeights);
                    }
                    renderer = skinRenderer;
                } else {
                    renderer = entity.addComponent(MeshRenderer);
                    renderer.mesh = mesh;
                }
                renderer.setMaterial(material);
                // Enable vertex color if mesh has COLOR_0 vertex element
                mesh.vertexElements.forEach(function(element) {
                    if (element.semantic === "COLOR_0") {
                        renderer.enableVertexColor = true;
                    }
                });
                GLTFParser.executeExtensionsAdditiveAndParse(glTFPrimitive.extensions, context, renderer, glTFPrimitive);
            };
            var meshes = param[0], skin = param[1], materials = param[2];
            // @ts-ignore
            var basicResources = context.glTFResource.engine._basicResources;
            for(var i = 0; i < rendererCount; i++)_loop(i);
        }).catch(function(e) {
            Logger.error("GLTFSceneParser: create renderer error", e);
        });
    };
    _proto._computeLocalBounds = function _computeLocalBounds(skinnedMeshRenderer, mesh, bones, rootBone, inverseBindMatrices) {
        var rootBoneIndex = bones.indexOf(rootBone);
        if (rootBoneIndex !== -1) {
            BoundingBox.transform(mesh.bounds, inverseBindMatrices[rootBoneIndex], skinnedMeshRenderer.localBounds);
        } else {
            // Root bone is not in joints list, we can only compute approximate inverse bind matrix
            // Average all root bone's children inverse bind matrix
            var approximateBindMatrix = new Matrix(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            var subRootBoneCount = this._computeApproximateBindMatrix(bones, inverseBindMatrices, rootBone, approximateBindMatrix);
            if (subRootBoneCount !== 0) {
                Matrix.multiplyScalar(approximateBindMatrix, 1.0 / subRootBoneCount, approximateBindMatrix);
                BoundingBox.transform(mesh.bounds, approximateBindMatrix, skinnedMeshRenderer.localBounds);
            } else {
                skinnedMeshRenderer.localBounds.copyFrom(mesh.bounds);
            }
        }
    };
    _proto._computeApproximateBindMatrix = function _computeApproximateBindMatrix(jointEntities, inverseBindMatrices, rootEntity, approximateBindMatrix) {
        var subRootBoneCount = 0;
        var children = rootEntity.children;
        for(var i = 0, n = children.length; i < n; i++){
            var rootChild = children[i];
            var index = jointEntities.indexOf(rootChild);
            if (index !== -1) {
                Matrix.add(approximateBindMatrix, inverseBindMatrices[index], approximateBindMatrix);
                subRootBoneCount++;
            } else {
                subRootBoneCount += this._computeApproximateBindMatrix(jointEntities, inverseBindMatrices, rootChild, approximateBindMatrix);
            }
        }
        return subRootBoneCount;
    };
    return GLTFSceneParser;
}(GLTFParser);
GLTFSceneParser = __decorate([
    registerGLTFParser(GLTFParserType.Scene)
], GLTFSceneParser);

var GLTFSkinParser = /*#__PURE__*/ function(GLTFParser) {
    _inherits(GLTFSkinParser, GLTFParser);
    function GLTFSkinParser() {
        return GLTFParser.apply(this, arguments) || this;
    }
    var _proto = GLTFSkinParser.prototype;
    _proto.parse = function parse(context, index) {
        var _this = this;
        var glTF = context.glTF;
        var skinInfo = glTF.skins[index];
        var inverseBindMatrices = skinInfo.inverseBindMatrices, skeleton = skinInfo.skeleton, joints = skinInfo.joints, _skinInfo_name = skinInfo.name, name = _skinInfo_name === void 0 ? "SKIN_" + index : _skinInfo_name;
        var jointCount = joints.length;
        var skin = new Skin(name);
        skin.inverseBindMatrices.length = jointCount;
        var bones = new Array(jointCount);
        // parse IBM
        var accessor = glTF.accessors[inverseBindMatrices];
        var skinPromise = GLTFUtils.getAccessorBuffer(context, glTF.bufferViews, accessor).then(function(bufferInfo) {
            var entities = context.get(GLTFParserType.Entity);
            var buffer = bufferInfo.data;
            for(var i = 0; i < jointCount; i++){
                var inverseBindMatrix = new Matrix();
                inverseBindMatrix.copyFromArray(buffer, i * 16);
                skin.inverseBindMatrices[i] = inverseBindMatrix;
                // Get bones
                var bone = entities[joints[i]];
                bones[i] = bone;
                skin.joints[i] = bone.name;
            }
            skin.bones = bones;
            // Get skeleton
            if (skeleton !== undefined) {
                var rootBone = entities[skeleton];
                skin.rootBone = rootBone;
            } else {
                var rootBone1 = _this._findSkeletonRootBone(joints, entities);
                if (rootBone1) {
                    skin.rootBone = rootBone1;
                } else {
                    throw "Failed to find skeleton root bone.";
                }
            }
            return skin;
        });
        return AssetPromise.resolve(skinPromise);
    };
    _proto._findSkeletonRootBone = function _findSkeletonRootBone(joints, entities) {
        var paths = {};
        for(var _iterator = _create_for_of_iterator_helper_loose(joints), _step; !(_step = _iterator()).done;){
            var index = _step.value;
            var path = new Array();
            var entity = entities[index];
            while(entity){
                path.unshift(entity);
                entity = entity.parent;
            }
            paths[index] = path;
        }
        var rootNode = null;
        for(var i = 0;; i++){
            var path1 = paths[joints[0]];
            if (i >= path1.length) {
                return rootNode;
            }
            var entity1 = path1[i];
            for(var j = 1, m = joints.length; j < m; j++){
                path1 = paths[joints[j]];
                if (i >= path1.length || entity1 !== path1[i]) {
                    return rootNode;
                }
            }
            rootNode = entity1;
        }
    };
    return GLTFSkinParser;
}(GLTFParser);
GLTFSkinParser = __decorate([
    registerGLTFParser(GLTFParserType.Skin)
], GLTFSkinParser);

var GLTFTextureParser = /*#__PURE__*/ function(GLTFParser1) {
    _inherits(GLTFTextureParser, GLTFParser1);
    function GLTFTextureParser() {
        return GLTFParser1.apply(this, arguments) || this;
    }
    var _proto = GLTFTextureParser.prototype;
    _proto.parse = function parse(context, textureIndex) {
        var textureInfo = context.glTF.textures[textureIndex];
        var glTFResource = context.glTFResource;
        var sampler = textureInfo.sampler, tmp = textureInfo.source, imageIndex = tmp === void 0 ? 0 : tmp, textureName = textureInfo.name, extensions = textureInfo.extensions;
        var isSRGBColorSpace = this._isSRGBColorSpace(textureIndex, context.glTF.materials);
        var texture = GLTFParser.executeExtensionsCreateAndParse(extensions, context, textureInfo, textureIndex, isSRGBColorSpace);
        if (!texture) {
            texture = GLTFTextureParser._parseTexture(context, imageIndex, textureIndex, sampler, textureName, isSRGBColorSpace);
        }
        return AssetPromise.resolve(texture).then(function(texture) {
            GLTFParser.executeExtensionsAdditiveAndParse(extensions, context, texture, textureInfo);
            // @ts-ignore
            texture._associationSuperResource(glTFResource);
            return texture;
        });
    };
    _proto._isSRGBColorSpace = function _isSRGBColorSpace(textureIndex, materials) {
        return materials == null ? void 0 : materials.some(function(material) {
            var _material_emissiveTexture, _material_pbrMetallicRoughness_baseColorTexture, _material_pbrMetallicRoughness, _material_extensions_KHR_materials_sheen_sheenColorTexture, _material_extensions_KHR_materials_sheen, _material_extensions, _material_extensions_KHR_materials_pbrSpecularGlossiness_diffuseTexture, _material_extensions_KHR_materials_pbrSpecularGlossiness, _material_extensions1, _material_extensions_KHR_materials_pbrSpecularGlossiness_specularGlossinessTexture, _material_extensions_KHR_materials_pbrSpecularGlossiness1, _material_extensions2;
            if (((_material_emissiveTexture = material.emissiveTexture) == null ? void 0 : _material_emissiveTexture.index) === textureIndex) {
                return true;
            }
            if (((_material_pbrMetallicRoughness = material.pbrMetallicRoughness) == null ? void 0 : (_material_pbrMetallicRoughness_baseColorTexture = _material_pbrMetallicRoughness.baseColorTexture) == null ? void 0 : _material_pbrMetallicRoughness_baseColorTexture.index) === textureIndex) {
                return true;
            }
            if (((_material_extensions = material.extensions) == null ? void 0 : (_material_extensions_KHR_materials_sheen = _material_extensions.KHR_materials_sheen) == null ? void 0 : (_material_extensions_KHR_materials_sheen_sheenColorTexture = _material_extensions_KHR_materials_sheen.sheenColorTexture) == null ? void 0 : _material_extensions_KHR_materials_sheen_sheenColorTexture.index) === textureIndex) {
                return true;
            }
            if (((_material_extensions1 = material.extensions) == null ? void 0 : (_material_extensions_KHR_materials_pbrSpecularGlossiness = _material_extensions1.KHR_materials_pbrSpecularGlossiness) == null ? void 0 : (_material_extensions_KHR_materials_pbrSpecularGlossiness_diffuseTexture = _material_extensions_KHR_materials_pbrSpecularGlossiness.diffuseTexture) == null ? void 0 : _material_extensions_KHR_materials_pbrSpecularGlossiness_diffuseTexture.index) === textureIndex) {
                return true;
            }
            if (((_material_extensions2 = material.extensions) == null ? void 0 : (_material_extensions_KHR_materials_pbrSpecularGlossiness1 = _material_extensions2.KHR_materials_pbrSpecularGlossiness) == null ? void 0 : (_material_extensions_KHR_materials_pbrSpecularGlossiness_specularGlossinessTexture = _material_extensions_KHR_materials_pbrSpecularGlossiness1.specularGlossinessTexture) == null ? void 0 : _material_extensions_KHR_materials_pbrSpecularGlossiness_specularGlossinessTexture.index) === textureIndex) {
                return true;
            }
        });
    };
    /** @internal */ GLTFTextureParser._parseTexture = function _parseTexture(context, imageIndex, textureIndex, sampler, textureName, isSRGBColorSpace) {
        var glTFResource = context.glTFResource, glTF = context.glTF;
        var engine = glTFResource.engine, url = glTFResource.url;
        var _glTF_images_imageIndex = glTF.images[imageIndex], uri = _glTF_images_imageIndex.uri, bufferViewIndex = _glTF_images_imageIndex.bufferView, mimeType = _glTF_images_imageIndex.mimeType, imageName = _glTF_images_imageIndex.name;
        var useSampler = sampler !== undefined;
        var samplerInfo = useSampler && GLTFUtils.getSamplerInfo(glTF.samplers[sampler]);
        var texture;
        if (uri) {
            var extIndex = uri.lastIndexOf(".");
            var ext = uri.substring(extIndex + 1);
            var type = ext.startsWith("ktx") ? AssetType.KTX : AssetType.Texture2D;
            texture = engine.resourceManager.load({
                url: Utils.resolveAbsoluteUrl(url, uri),
                type: type,
                params: {
                    mipmap: samplerInfo == null ? void 0 : samplerInfo.mipmap,
                    isSRGBColorSpace: isSRGBColorSpace
                }
            }).onProgress(undefined, context._onTaskDetail).then(function(texture) {
                texture.name = textureName || imageName || texture.name || "texture_" + textureIndex;
                useSampler && GLTFUtils.parseSampler(texture, samplerInfo);
                return texture;
            });
            context._addTaskCompletePromise(texture);
        } else {
            var bufferView = glTF.bufferViews[bufferViewIndex];
            texture = context.get(GLTFParserType.Buffer).then(function(buffers) {
                var buffer = buffers[bufferView.buffer];
                var imageBuffer = new Uint8Array(buffer, bufferView.byteOffset, bufferView.byteLength);
                return GLTFUtils.loadImageBuffer(imageBuffer, mimeType).then(function(image) {
                    var texture = new Texture2D(engine, image.width, image.height, undefined, samplerInfo == null ? void 0 : samplerInfo.mipmap, isSRGBColorSpace);
                    texture.setImageSource(image);
                    texture.generateMipmaps();
                    texture.name = textureName || imageName || "texture_" + textureIndex;
                    useSampler && GLTFUtils.parseSampler(texture, samplerInfo);
                    var bufferTextureRestoreInfo = new BufferTextureRestoreInfo(texture, bufferView, mimeType);
                    context.contentRestorer.bufferTextures.push(bufferTextureRestoreInfo);
                    return texture;
                });
            }).catch(function(e) {
                Logger.error("GLTFTextureParser: image buffer error", e);
            });
        }
        return texture;
    };
    return GLTFTextureParser;
}(GLTFParser);
var _obj;
/** @internal */ GLTFTextureParser._wrapMap = (_obj = {}, _obj[TextureWrapMode.CLAMP_TO_EDGE] = TextureWrapMode$1.Clamp, _obj[TextureWrapMode.MIRRORED_REPEAT] = TextureWrapMode$1.Mirror, _obj[TextureWrapMode.REPEAT] = TextureWrapMode$1.Repeat, _obj);
GLTFTextureParser = __decorate([
    registerGLTFParser(GLTFParserType.Texture)
], GLTFTextureParser);

var GLTFValidator = /*#__PURE__*/ function(GLTFParser1) {
    _inherits(GLTFValidator, GLTFParser1);
    function GLTFValidator() {
        return GLTFParser1.apply(this, arguments) || this;
    }
    var _proto = GLTFValidator.prototype;
    _proto.parse = function parse(context) {
        var _context_glTF = context.glTF, version = _context_glTF.asset.version, extensionsUsed = _context_glTF.extensionsUsed, extensionsRequired = _context_glTF.extensionsRequired;
        var glTFVersion = Number(version);
        if (!(glTFVersion >= 2 && glTFVersion < 3)) {
            throw "Only support glTF 2.x.";
        }
        if (extensionsUsed) {
            Logger.info("extensionsUsed: ", extensionsUsed);
            for(var i = 0; i < extensionsUsed.length; i++){
                var extensionUsed = extensionsUsed[i];
                if (!GLTFParser.hasExtensionParser(extensionUsed)) {
                    Logger.warn("Extension " + extensionUsed + " is not implemented, you can customize this extension in gltf.");
                }
            }
        }
        if (extensionsRequired) {
            Logger.info("extensionsRequired: " + extensionsRequired);
            for(var i1 = 0; i1 < extensionsRequired.length; i1++){
                var extensionRequired = extensionsRequired[i1];
                if (!GLTFParser.hasExtensionParser(extensionRequired)) {
                    Logger.error("GLTF parser has not supported required extension " + extensionRequired + ".");
                }
            }
        }
        return AssetPromise.resolve(null);
    };
    return GLTFValidator;
}(GLTFParser);
GLTFValidator = __decorate([
    registerGLTFParser(GLTFParserType.Validator)
], GLTFValidator);

var GLTFBufferViewParser = /*#__PURE__*/ function(GLTFParser1) {
    _inherits(GLTFBufferViewParser, GLTFParser1);
    function GLTFBufferViewParser() {
        return GLTFParser1.apply(this, arguments) || this;
    }
    var _proto = GLTFBufferViewParser.prototype;
    _proto.parse = function parse(context, index) {
        var bufferView = context.glTF.bufferViews[index];
        var extensions = bufferView.extensions, _bufferView_byteOffset = bufferView.byteOffset, byteOffset = _bufferView_byteOffset === void 0 ? 0 : _bufferView_byteOffset, byteLength = bufferView.byteLength, bufferIndex = bufferView.buffer;
        return extensions ? GLTFParser.executeExtensionsCreateAndParse(extensions, context, bufferView) : context.get(GLTFParserType.Buffer, bufferIndex).then(function(buffer) {
            return new Uint8Array(buffer, byteOffset, byteLength);
        }).catch(function(e) {
            Logger.error("GLTFBufferViewParser: buffer error", e);
        });
    };
    return GLTFBufferViewParser;
}(GLTFParser);
GLTFBufferViewParser = __decorate([
    registerGLTFParser(GLTFParserType.BufferView)
], GLTFBufferViewParser);

var GLTFAnimatorControllerParser = /*#__PURE__*/ function(GLTFParser) {
    _inherits(GLTFAnimatorControllerParser, GLTFParser);
    function GLTFAnimatorControllerParser() {
        return GLTFParser.apply(this, arguments) || this;
    }
    var _proto = GLTFAnimatorControllerParser.prototype;
    _proto.parse = function parse(context) {
        var _this = this;
        if (!context.needAnimatorController) {
            return AssetPromise.resolve(null);
        }
        return context.get(GLTFParserType.Animation).then(function(animations) {
            var animatorController = _this._createAnimatorController(context, animations);
            return AssetPromise.resolve(animatorController);
        }).catch(function(e) {
            Logger.error("GLTFAnimatorControllerParser: animator controller error", e);
        });
    };
    _proto._createAnimatorController = function _createAnimatorController(context, animations) {
        var glTFResource = context.glTFResource;
        var engine = glTFResource.engine;
        var animatorController = new AnimatorController(engine);
        var layer = new AnimatorControllerLayer("layer");
        var animatorStateMachine = new AnimatorStateMachine();
        animatorController.addLayer(layer);
        layer.stateMachine = animatorStateMachine;
        if (animations) {
            for(var i = 0; i < animations.length; i++){
                var animationClip = animations[i];
                var name = animationClip.name;
                var uniqueName = animatorStateMachine.makeUniqueStateName(name);
                if (uniqueName !== name) {
                    console.warn("AnimatorState name is existed, name: " + name + " reset to " + uniqueName);
                }
                var animatorState = animatorStateMachine.addState(uniqueName);
                animatorState.clip = animationClip;
            }
        }
        return animatorController;
    };
    return GLTFAnimatorControllerParser;
}(GLTFParser);
GLTFAnimatorControllerParser = __decorate([
    registerGLTFParser(GLTFParserType.AnimatorController)
], GLTFAnimatorControllerParser);

var GLTFLoader = /*#__PURE__*/ function(Loader) {
    _inherits(GLTFLoader, Loader);
    function GLTFLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = GLTFLoader.prototype;
    _proto.initialize = function initialize(_, configuration) {
        var _configuration_glTFLoader, _configuration_glTF;
        var _configuration_glTFLoader_meshOpt;
        var meshOptOptions = (_configuration_glTFLoader_meshOpt = (_configuration_glTFLoader = configuration.glTFLoader) == null ? void 0 : _configuration_glTFLoader.meshOpt) != null ? _configuration_glTFLoader_meshOpt : (_configuration_glTF = configuration.glTF) == null ? void 0 : _configuration_glTF.meshOpt;
        if (meshOptOptions) {
            return getMeshoptDecoder().then(function(meshoptDecoder) {
                meshoptDecoder.useWorkers(meshOptOptions.workerCount);
            });
        }
        return Promise.resolve();
    };
    _proto.load = function load(item, resourceManager) {
        var params = item.params;
        var glTFResource = new GLTFResource(resourceManager.engine, item.url);
        var context = new GLTFParserContext(glTFResource, resourceManager, _extends({
            keepMeshData: false
        }, params));
        return new AssetPromise(function(resolve, reject, setTaskCompleteProgress, setTaskDetailProgress, onTaskCancel) {
            context._setTaskCompleteProgress = setTaskCompleteProgress;
            context._setTaskDetailProgress = setTaskDetailProgress;
            onTaskCancel(function() {
                var getPromises = context._getPromises;
                for(var i = 0, n = getPromises.length; i < n; i++){
                    getPromises[i].cancel();
                }
            });
            context.parse().then(resolve).catch(function(e) {
                glTFResource.destroy();
                reject(e);
            });
        });
    };
    /**
   * Release glTF loader memory(includes meshopt workers).
   * @remarks If use loader after releasing, we should release again.
   */ GLTFLoader.release = function release() {
        if (ready) {
            getMeshoptDecoder().then(function(meshoptDecoder) {
                meshoptDecoder.release();
            });
        }
    };
    return GLTFLoader;
}(Loader);
GLTFLoader = __decorate([
    resourceLoader(AssetType.GLTF, [
        "gltf",
        "glb"
    ])
], GLTFLoader);

var PrefabParser = /*#__PURE__*/ function(HierarchyParser) {
    _inherits(PrefabParser, HierarchyParser);
    function PrefabParser(data, context, prefabResource) {
        var _this;
        _this = HierarchyParser.call(this, data, context) || this, _this.prefabResource = prefabResource;
        return _this;
    }
    var _proto = PrefabParser.prototype;
    _proto._handleRootEntity = function _handleRootEntity(id) {
        this.prefabResource._root = this.context.entityMap.get(id);
    };
    _proto._clearAndResolve = function _clearAndResolve() {
        this.context.clear();
        return this.prefabResource;
    };
    PrefabParser.parse = function parse(engine, url, data) {
        var prefabResource = new PrefabResource(engine, url);
        var context = new ParserContext(engine, ParserType.Prefab, prefabResource);
        var parser = new PrefabParser(data, context, prefabResource);
        parser.start();
        return parser.promise.then(function() {
            return prefabResource;
        });
    };
    return PrefabParser;
}(HierarchyParser);

var PrefabLoader = /*#__PURE__*/ function(Loader) {
    _inherits(PrefabLoader, Loader);
    function PrefabLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = PrefabLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var engine = resourceManager.engine;
        return new AssetPromise(function(resolve, reject) {
            resourceManager// @ts-ignore
            ._request(item.url, _extends({}, item, {
                type: "json"
            })).then(function(data) {
                PrefabParser.parse(engine, item.url, data).then(resolve).catch(reject);
            });
        });
    };
    return PrefabLoader;
}(Loader);
PrefabLoader = __decorate([
    resourceLoader(AssetType.Prefab, [
        "prefab"
    ])
], PrefabLoader);

var PI = Math.PI;
// referenece: https://www.flipcode.com/archives/HDR_Image_Reader.shtml
var HDRLoader = /*#__PURE__*/ function(Loader) {
    _inherits(HDRLoader, Loader);
    function HDRLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = HDRLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        return new AssetPromise(function(resolve, reject) {
            var engine = resourceManager.engine;
            var requestConfig = _extends({}, item, {
                type: "arraybuffer"
            });
            var url = item.url;
            resourceManager// @ts-ignore
            ._request(url, requestConfig).then(function(buffer) {
                var texture = HDRLoader._setTextureByBuffer(engine, buffer);
                engine.resourceManager.addContentRestorer(new HDRContentRestorer(texture, url, requestConfig));
                resolve(texture);
            }).catch(reject);
        });
    };
    /**
   * @internal
   */ HDRLoader._setTextureByBuffer = function _setTextureByBuffer(engine, buffer, texture) {
        var bufferArray = new Uint8Array(buffer);
        var _HDRLoader__parseHeader = HDRLoader._parseHeader(bufferArray), width = _HDRLoader__parseHeader.width, height = _HDRLoader__parseHeader.height, dataPosition = _HDRLoader__parseHeader.dataPosition;
        var cubeSize = height >> 1;
        texture || (texture = new TextureCube(engine, cubeSize, undefined, undefined, false));
        var pixels = HDRLoader._readPixels(bufferArray.subarray(dataPosition), width, height);
        var cubeMapData = HDRLoader._convertToCubemap(pixels, width, height, cubeSize);
        for(var faceIndex = 0; faceIndex < 6; faceIndex++){
            texture.setPixelBuffer(TextureCubeFace.PositiveX + faceIndex, cubeMapData[faceIndex], 0);
        }
        texture.generateMipmaps();
        return texture;
    };
    HDRLoader._convertToCubemap = function _convertToCubemap(pixels, inputWidth, inputHeight, size) {
        if (!pixels) {
            throw "ConvertPanoramaToCubemap: input cannot be null";
        }
        if (pixels.length != inputWidth * inputHeight * 4) {
            throw "ConvertPanoramaToCubemap: input size is wrong";
        }
        var textureRight = this._createCubemapData(size, this._faceRight, pixels, inputWidth, inputHeight);
        var textureLeft = this._createCubemapData(size, this._faceLeft, pixels, inputWidth, inputHeight);
        var textureUp = this._createCubemapData(size, this._faceUp, pixels, inputWidth, inputHeight);
        var textureDown = this._createCubemapData(size, this._faceBottom, pixels, inputWidth, inputHeight);
        var textureFront = this._createCubemapData(size, this._faceFront, pixels, inputWidth, inputHeight);
        var textureBack = this._createCubemapData(size, this._faceBack, pixels, inputWidth, inputHeight);
        return [
            textureRight,
            textureLeft,
            textureUp,
            textureDown,
            textureFront,
            textureBack
        ];
    };
    HDRLoader._createCubemapData = function _createCubemapData(texSize, faceData, pixels, inputWidth, inputHeight) {
        var textureArray = new Uint8ClampedArray(texSize * texSize * 4);
        var rotDX1 = this._tempVector3.set(0, 0, 0).add(faceData[1]).subtract(faceData[0]).scale(1 / texSize);
        var rotDX2 = this._temp2Vector3.set(0, 0, 0).add(faceData[3]).subtract(faceData[2]).scale(1 / texSize);
        var dy = 1 / texSize;
        var fy = 0;
        for(var y = 0; y < texSize; y++){
            var xv1 = this._temp3Vector3.set(0, 0, 0).add(faceData[0]);
            var xv2 = this._temp4Vector3.set(0, 0, 0).add(faceData[2]);
            for(var x = 0; x < texSize; x++){
                var v = this._temp5Vector3.set(0, 0, 0).add(xv2).subtract(xv1).scale(fy).add(xv1);
                v.normalize();
                var color = this._calcProjectionSpherical(v, pixels, inputWidth, inputHeight);
                this._RGBEToLinear(color);
                this._linearToRGBM(color, 5);
                // 4 channels per pixels
                var index = y * texSize * 4 + x * 4;
                textureArray[index] = color.r;
                textureArray[index + 1] = color.g;
                textureArray[index + 2] = color.b;
                textureArray[index + 3] = color.a;
                xv1.add(rotDX1);
                xv2.add(rotDX2);
            }
            fy += dy;
        }
        return textureArray;
    };
    HDRLoader._calcProjectionSpherical = function _calcProjectionSpherical(vDir, pixels, inputWidth, inputHeight) {
        var theta = Math.atan2(vDir.z, vDir.x);
        var phi = Math.acos(vDir.y);
        while(theta < -PI){
            theta += 2 * PI;
        }
        while(theta > PI){
            theta -= 2 * PI;
        }
        var dx = theta / PI;
        var dy = phi / PI;
        // recenter.
        dx = dx * 0.5 + 0.5;
        var px = Math.round(dx * inputWidth);
        if (px < 0) {
            px = 0;
        } else if (px >= inputWidth) {
            px = inputWidth - 1;
        }
        var py = Math.round(dy * inputHeight);
        if (py < 0) {
            py = 0;
        } else if (py >= inputHeight) {
            py = inputHeight - 1;
        }
        var inputY = inputHeight - py - 1;
        var index = inputY * inputWidth * 4 + px * 4;
        var r = pixels[index];
        var g = pixels[index + 1];
        var b = pixels[index + 2];
        var a = pixels[index + 3];
        return new Color(r, g, b, a);
    };
    HDRLoader._readStringLine = function _readStringLine(uint8array, startIndex) {
        var line = "";
        var character = "";
        for(var i = startIndex; i < uint8array.length - startIndex; i++){
            character = String.fromCharCode(uint8array[i]);
            if (character == "\n") {
                break;
            }
            line += character;
        }
        return line;
    };
    HDRLoader._parseHeader = function _parseHeader(uint8array) {
        var height = 0;
        var width = 0;
        var line = this._readStringLine(uint8array, 0);
        if (line[0] != "#" || line[1] != "?") {
            throw "Bad HDR Format.";
        }
        var endOfHeader = false;
        var findFormat = false;
        var lineIndex = 0;
        do {
            lineIndex += line.length + 1;
            line = this._readStringLine(uint8array, lineIndex);
            if (line == "FORMAT=32-bit_rle_rgbe") {
                findFormat = true;
            } else if (line.length == 0) {
                endOfHeader = true;
            }
        }while (!endOfHeader);
        if (!findFormat) {
            throw "HDR Bad header format, unsupported FORMAT";
        }
        lineIndex += line.length + 1;
        line = this._readStringLine(uint8array, lineIndex);
        var sizeRegexp = /^\-Y (.*) \+X (.*)$/g;
        var match = sizeRegexp.exec(line);
        // TODO. Support +Y and -X if needed.
        if (!match || match.length < 3) {
            throw "HDR Bad header format, no size";
        }
        width = parseInt(match[2]);
        height = parseInt(match[1]);
        if (width < 8 || width > 0x7fff) {
            throw "HDR Bad header format, unsupported size";
        }
        lineIndex += line.length + 1;
        return {
            height: height,
            width: width,
            dataPosition: lineIndex
        };
    };
    HDRLoader._readPixels = function _readPixels(buffer, width, height) {
        var scanLineWidth = width;
        var byteLength = buffer.byteLength;
        var dataRGBA = new Uint8Array(4 * width * height);
        var offset = 0, pos = 0;
        var ptrEnd = 4 * scanLineWidth;
        var scanLineBuffer = new Uint8Array(ptrEnd);
        var numScanLines = height; // read in each successive scanLine
        while(numScanLines > 0 && pos < byteLength){
            var a = buffer[pos++];
            var b = buffer[pos++];
            var c = buffer[pos++];
            var d = buffer[pos++];
            if (a != 2 || b != 2 || c & 0x80 || width < 8 || width > 32767) {
                // this file is not run length encoded
                // read values sequentially
                return buffer;
            }
            if ((c << 8 | d) != scanLineWidth) {
                // eslint-disable-next-line no-throw-literal
                throw "HDR Bad header format, wrong scan line width";
            }
            // read each of the four channels for the scanline into the buffer
            // first red, then green, then blue, then exponent
            var ptr = 0, count = void 0;
            while(ptr < ptrEnd && pos < byteLength){
                count = buffer[pos++];
                var isEncodedRun = count > 128;
                if (isEncodedRun) count -= 128;
                if (0 === count || ptr + count > ptrEnd) {
                    throw "HDR Bad Format, bad scanline data (run)";
                }
                if (isEncodedRun) {
                    // a (encoded) run of the same value
                    var byteValue = buffer[pos++];
                    for(var i = 0; i < count; i++){
                        scanLineBuffer[ptr++] = byteValue;
                    } //ptr += count;
                } else {
                    // a literal-run
                    scanLineBuffer.set(buffer.subarray(pos, pos + count), ptr);
                    ptr += count;
                    pos += count;
                }
            } // now convert data from buffer into rgba
            // first red, then green, then blue, then exponent (alpha)
            var l = scanLineWidth; //scanLine_buffer.byteLength;
            for(var i1 = 0; i1 < l; i1++){
                var off = 0;
                dataRGBA[offset] = scanLineBuffer[i1 + off];
                off += scanLineWidth;
                dataRGBA[offset + 1] = scanLineBuffer[i1 + off];
                off += scanLineWidth;
                dataRGBA[offset + 2] = scanLineBuffer[i1 + off];
                off += scanLineWidth;
                dataRGBA[offset + 3] = scanLineBuffer[i1 + off];
                offset += 4;
            }
            numScanLines--;
        }
        return dataRGBA;
    };
    HDRLoader._RGBEToLinear = function _RGBEToLinear(color) {
        var scaleFactor = Math.pow(2, color.a - 128) / 255;
        color.r *= scaleFactor;
        color.g *= scaleFactor;
        color.b *= scaleFactor;
        color.a = 1;
    };
    HDRLoader._linearToRGBM = function _linearToRGBM(color, maxRange) {
        var maxRGB = Math.max(color.r, Math.max(color.g, color.b));
        var M = Math.min(maxRGB / maxRange, 1);
        M = Math.ceil(M * 255);
        var scaleFactor = 65025 / (M * maxRange); // 255 * (255 / (M * maxRange) )
        color.r *= scaleFactor;
        color.g *= scaleFactor;
        color.b *= scaleFactor;
        color.a *= M;
    };
    return HDRLoader;
}(Loader);
HDRLoader._rightBottomBack = new Vector3(1.0, -1, -1);
HDRLoader._rightBottomFront = new Vector3(1.0, -1, 1.0);
HDRLoader._rightUpBack = new Vector3(1.0, 1.0, -1);
HDRLoader._rightUpFront = new Vector3(1.0, 1.0, 1.0);
HDRLoader._leftBottomBack = new Vector3(-1, -1, -1);
HDRLoader._leftBottomFront = new Vector3(-1, -1, 1.0);
HDRLoader._leftUpBack = new Vector3(-1, 1.0, -1);
HDRLoader._leftUpFront = new Vector3(-1, 1.0, 1.0);
HDRLoader._faceRight = [
    HDRLoader._rightBottomBack,
    HDRLoader._rightBottomFront,
    HDRLoader._rightUpBack,
    HDRLoader._rightUpFront
];
HDRLoader._faceLeft = [
    HDRLoader._leftBottomFront,
    HDRLoader._leftBottomBack,
    HDRLoader._leftUpFront,
    HDRLoader._leftUpBack
];
HDRLoader._faceUp = [
    HDRLoader._leftBottomFront,
    HDRLoader._rightBottomFront,
    HDRLoader._leftBottomBack,
    HDRLoader._rightBottomBack
];
HDRLoader._faceBottom = [
    HDRLoader._leftUpBack,
    HDRLoader._rightUpBack,
    HDRLoader._leftUpFront,
    HDRLoader._rightUpFront
];
HDRLoader._faceFront = [
    HDRLoader._leftBottomBack,
    HDRLoader._rightBottomBack,
    HDRLoader._leftUpBack,
    HDRLoader._rightUpBack
];
HDRLoader._faceBack = [
    HDRLoader._rightBottomFront,
    HDRLoader._leftBottomFront,
    HDRLoader._rightUpFront,
    HDRLoader._leftUpFront
];
HDRLoader._tempVector3 = new Vector3();
HDRLoader._temp2Vector3 = new Vector3();
HDRLoader._temp3Vector3 = new Vector3();
HDRLoader._temp4Vector3 = new Vector3();
HDRLoader._temp5Vector3 = new Vector3();
HDRLoader = __decorate([
    resourceLoader(AssetType.HDR, [
        "hdr"
    ])
], HDRLoader);
/**
 * @internal
 */ var HDRContentRestorer = /*#__PURE__*/ function(ContentRestorer) {
    _inherits(HDRContentRestorer, ContentRestorer);
    function HDRContentRestorer(resource, url, requestConfig) {
        var _this;
        _this = ContentRestorer.call(this, resource) || this, _this.url = url, _this.requestConfig = requestConfig;
        return _this;
    }
    var _proto = HDRContentRestorer.prototype;
    _proto.restoreContent = function restoreContent() {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            var resource = _this.resource;
            var engine = resource.engine;
            engine.resourceManager// @ts-ignore
            ._request(_this.url, _this.requestConfig).then(function(buffer) {
                HDRLoader._setTextureByBuffer(engine, buffer, resource);
                resolve(resource);
            }).catch(reject);
        });
    };
    return HDRContentRestorer;
}(ContentRestorer);

var JSONLoader = /*#__PURE__*/ function(Loader) {
    _inherits(JSONLoader, Loader);
    function JSONLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = JSONLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        // @ts-ignore
        return resourceManager._request(item.url, _extends({}, item, {
            type: "json"
        }));
    };
    return JSONLoader;
}(Loader);
JSONLoader = __decorate([
    resourceLoader(AssetType.JSON, [
        "json"
    ], false)
], JSONLoader);

var HEADER_LEN = 12 + 13 * 4; // identifier + header elements (not including key value meta-data pairs)
// load types
var COMPRESSED_2D = 0; // uses a gl.compressedTexImage2D()
function getMipmaps(ktxContainer, loadMipmaps) {
    var mipmaps = [];
    // initialize width & height for level 1
    var dataOffset = HEADER_LEN + ktxContainer.bytesOfKeyValueData;
    var width = ktxContainer.pixelWidth;
    var height = ktxContainer.pixelHeight;
    var mipmapCount = ktxContainer.numberOfMipmapLevels ;
    for(var level = 0; level < mipmapCount; level++){
        var imageSize = new Int32Array(ktxContainer.buffer, dataOffset, 1)[0]; // size per face, since not supporting array cubemaps
        dataOffset += 4; // size of the image + 4 for the imageSize field
        for(var face = 0; face < ktxContainer.numberOfFaces; face++){
            var byteArray = new Uint8Array(ktxContainer.buffer, dataOffset, imageSize);
            mipmaps.push({
                data: byteArray,
                width: width,
                height: height
            });
            dataOffset += imageSize;
            dataOffset += 3 - (imageSize + 3) % 4; // add padding for odd sized image
        }
        width = Math.max(1.0, width * 0.5);
        height = Math.max(1.0, height * 0.5);
    }
    return mipmaps;
}
/**
 * Checks if the given data starts with a KTX file identifier.
 * @param data the data to check
 * @returns true if the data is a KTX file or false otherwise
 */ function isValid(data) {
    if (data.byteLength >= 12) {
        // '«', 'K', 'T', 'X', ' ', '1', '1', '»', '\r', '\n', '\x1A', '\n'
        var identifier = new Uint8Array(data, 0, 12);
        if (identifier[0] === 0xab && identifier[1] === 0x4b && identifier[2] === 0x54 && identifier[3] === 0x58 && identifier[4] === 0x20 && identifier[5] === 0x31 && identifier[6] === 0x31 && identifier[7] === 0xbb && identifier[8] === 0x0d && identifier[9] === 0x0a && identifier[10] === 0x1a && identifier[11] === 0x0a) {
            return true;
        }
    }
    return false;
}
function getEngineFormat(internalFormat) {
    switch(internalFormat){
        // case GLCompressedTextureInternalFormat.RGBA_S3TC_DXT3_EXT:
        // case GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT:
        // break;
        case GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT:
            return TextureFormat.BC1;
        case GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT:
            return TextureFormat.BC3;
        case GLCompressedTextureInternalFormat.RGBA_BPTC_UNORM_EXT:
            return TextureFormat.BC7;
        case GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL:
            return TextureFormat.ETC1_RGB;
        case GLCompressedTextureInternalFormat.RGB8_ETC2:
            return TextureFormat.ETC2_RGB;
        case GLCompressedTextureInternalFormat.RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
            return TextureFormat.ETC2_RGBA5;
        case GLCompressedTextureInternalFormat.RGBA8_ETC2_EAC:
            return TextureFormat.ETC2_RGBA8;
        case GLCompressedTextureInternalFormat.RGB_PVRTC_2BPPV1_IMG:
            return TextureFormat.PVRTC_RGB2;
        case GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG:
            return TextureFormat.PVRTC_RGBA2;
        case GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG:
            return TextureFormat.PVRTC_RGB4;
        case GLCompressedTextureInternalFormat.RGBA_PVRTC_4BPPV1_IMG:
            return TextureFormat.PVRTC_RGBA4;
        case GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR:
            return TextureFormat.ASTC_4x4;
        case GLCompressedTextureInternalFormat.RGBA_ASTC_5X5_KHR:
            return TextureFormat.ASTC_5x5;
        case GLCompressedTextureInternalFormat.RGBA_ASTC_6X6_KHR:
            return TextureFormat.ASTC_6x6;
        case GLCompressedTextureInternalFormat.RGBA_ASTC_8X8_KHR:
            return TextureFormat.ASTC_8x8;
        case GLCompressedTextureInternalFormat.RGBA_ASTC_10X10_KHR:
            return TextureFormat.ASTC_10x10;
        case GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR:
            return TextureFormat.ASTC_12x12;
        default:
            var formatName = GLCompressedTextureInternalFormat[internalFormat];
            throw new Error("this format is not supported in Galacean Engine: " + formatName);
    }
}
/**
 * for description see https://www.khronos.org/opengles/sdk/tools/KTX/
 * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/
 */ var khronosTextureContainerParser = {
    /**
   *
   * @param buffer contents of the KTX container file
   * @param facesExpected should be either 1 or 6, based whether a cube texture or or
   * @param threeDExpected provision for indicating that data should be a 3D texture, not implemented
   * @param textureArrayExpected provision for indicating that data should be a texture array, not implemented
   * @param mapEngineFormat get Galacean Engine native TextureFormat?
   */ parse: function parse(buffer, facesExpected, withMipmaps, mapEngineFormat) {
        if (mapEngineFormat === void 0) mapEngineFormat = false;
        if (!isValid(buffer)) {
            throw new Error("khronosTextureContainerParser: invalid KTX file, texture missing KTX identifier");
        }
        // load the reset of the header in native 32 bit uint
        var dataSize = Uint32Array.BYTES_PER_ELEMENT;
        var headerDataView = new DataView(buffer, 12, 13 * dataSize);
        var endianness = headerDataView.getUint32(0, true);
        var littleEndian = endianness === 0x04030201;
        var parsedResult = {
            buffer: buffer,
            glType: headerDataView.getUint32(1 * dataSize, littleEndian),
            glTypeSize: headerDataView.getUint32(2 * dataSize, littleEndian),
            glFormat: headerDataView.getUint32(3 * dataSize, littleEndian),
            glInternalFormat: headerDataView.getUint32(4 * dataSize, littleEndian),
            glBaseInternalFormat: headerDataView.getUint32(5 * dataSize, littleEndian),
            pixelWidth: headerDataView.getUint32(6 * dataSize, littleEndian),
            pixelHeight: headerDataView.getUint32(7 * dataSize, littleEndian),
            pixelDepth: headerDataView.getUint32(8 * dataSize, littleEndian),
            numberOfArrayElements: headerDataView.getUint32(9 * dataSize, littleEndian),
            numberOfFaces: headerDataView.getUint32(10 * dataSize, littleEndian),
            numberOfMipmapLevels: headerDataView.getUint32(11 * dataSize, littleEndian),
            bytesOfKeyValueData: headerDataView.getUint32(12 * dataSize, littleEndian),
            // would need to make this more elaborate & adjust checks above to support more than one load type
            loadType: COMPRESSED_2D
        };
        // Make sure we have a compressed type.  Not only reduces work, but probably better to let dev know they are not compressing.
        if (parsedResult.glType !== 0) {
            throw new Error("only compressed formats currently supported");
        } else {
            // value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.
            parsedResult.numberOfMipmapLevels = Math.max(1, parsedResult.numberOfMipmapLevels);
        }
        if (parsedResult.pixelHeight === 0 || parsedResult.pixelDepth !== 0) {
            throw new Error("only 2D textures currently supported");
        }
        if (parsedResult.numberOfArrayElements !== 0) {
            throw new Error("texture arrays not currently supported");
        }
        if (parsedResult.numberOfFaces !== facesExpected) {
            throw new Error("number of faces expected" + facesExpected + ", but found " + parsedResult.numberOfFaces);
        }
        if (withMipmaps) {
            parsedResult.mipmaps = getMipmaps(parsedResult);
        }
        if (mapEngineFormat) {
            parsedResult.engineFormat = getEngineFormat(parsedResult.glInternalFormat);
        }
        return parsedResult;
    }
};

function parseSingleKTX(data) {
    var ktx = khronosTextureContainerParser.parse(data, 1, true, true);
    return {
        mipmaps: ktx.mipmaps,
        engineFormat: ktx.engineFormat,
        internalFormat: ktx.glInternalFormat,
        width: ktx.pixelWidth,
        height: ktx.pixelHeight
    };
}
function parseCubeKTX(dataArray) {
    var mipmapsFaces = [];
    var internalFormat;
    var engineFormat;
    var width;
    var height;
    for(var i = 0; i < dataArray.length; i++){
        var ktx = khronosTextureContainerParser.parse(dataArray[i], 1, true, true);
        mipmapsFaces.push(ktx.mipmaps);
        if (i === 0) {
            width = ktx.pixelWidth;
            height = ktx.pixelHeight;
            internalFormat = ktx.glInternalFormat;
            engineFormat = ktx.engineFormat;
        }
    }
    return {
        mipmapsFaces: mipmapsFaces,
        engineFormat: engineFormat,
        internalFormat: internalFormat,
        width: width,
        height: height
    };
}

var KTXCubeLoader = /*#__PURE__*/ function(Loader) {
    _inherits(KTXCubeLoader, Loader);
    function KTXCubeLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = KTXCubeLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        return new AssetPromise(function(resolve, reject) {
            Promise.all(item.urls.map(function(url) {
                return(// @ts-ignore
                resourceManager._request(url, _extends({}, item, {
                    type: "arraybuffer"
                })));
            })).then(function(data) {
                var parsedData = parseCubeKTX(data);
                var width = parsedData.width, mipmapsFaces = parsedData.mipmapsFaces, engineFormat = parsedData.engineFormat;
                var mipmap = mipmapsFaces[0].length > 1;
                var texture = new TextureCube(resourceManager.engine, width, engineFormat, mipmap);
                for(var face = 0; face < 6; face++){
                    var length = mipmapsFaces[face].length;
                    for(var miplevel = 0; miplevel < length; miplevel++){
                        var _mipmapsFaces_face_miplevel = mipmapsFaces[face][miplevel], _$data = _mipmapsFaces_face_miplevel.data, width1 = _mipmapsFaces_face_miplevel.width, height = _mipmapsFaces_face_miplevel.height;
                        texture.setPixelBuffer(TextureCubeFace.PositiveX + face, _$data, miplevel, 0, 0, width1, height);
                    }
                }
                resolve(texture);
            }).catch(function(e) {
                reject(e);
            });
        });
    };
    return KTXCubeLoader;
}(Loader);
KTXCubeLoader = __decorate([
    resourceLoader(AssetType.KTXCube, [])
], KTXCubeLoader);

var KTXLoader = /*#__PURE__*/ function(Loader) {
    _inherits(KTXLoader, Loader);
    function KTXLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = KTXLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var requestConfig = _extends({}, item, {
            type: "arraybuffer"
        });
        return new AssetPromise(function(resolve, reject) {
            resourceManager// @ts-ignore
            ._request(item.url, requestConfig).then(function(bin) {
                var parsedData = parseSingleKTX(bin);
                var width = parsedData.width, height = parsedData.height, mipmaps = parsedData.mipmaps, engineFormat = parsedData.engineFormat;
                var mipmap = mipmaps.length > 1;
                var texture = new Texture2D(resourceManager.engine, width, height, engineFormat, mipmap, false);
                for(var miplevel = 0; miplevel < mipmaps.length; miplevel++){
                    var _mipmaps_miplevel = mipmaps[miplevel], width1 = _mipmaps_miplevel.width, height1 = _mipmaps_miplevel.height, data = _mipmaps_miplevel.data;
                    texture.setPixelBuffer(data, miplevel, 0, 0, width1, height1);
                }
                resourceManager.addContentRestorer(new KTXContentRestorer(texture, item.url, requestConfig));
                resolve(texture);
            }).catch(function(e) {
                reject(e);
            });
        });
    };
    return KTXLoader;
}(Loader);
KTXLoader = __decorate([
    resourceLoader(AssetType.KTX, [
        "ktx"
    ])
], KTXLoader);
var KTXContentRestorer = /*#__PURE__*/ function(ContentRestorer) {
    _inherits(KTXContentRestorer, ContentRestorer);
    function KTXContentRestorer(resource, url, requestConfig) {
        var _this;
        _this = ContentRestorer.call(this, resource) || this, _this.url = url, _this.requestConfig = requestConfig;
        return _this;
    }
    var _proto = KTXContentRestorer.prototype;
    _proto.restoreContent = function restoreContent() {
        var _this = this;
        var resource = this.resource;
        var engine = resource.engine;
        return new AssetPromise(function(resolve, reject) {
            engine.resourceManager// @ts-ignore
            ._request(_this.url, _this.requestConfig).then(function(bin) {
                var mipmaps = parseSingleKTX(bin).mipmaps;
                for(var miplevel = 0; miplevel < mipmaps.length; miplevel++){
                    var _mipmaps_miplevel = mipmaps[miplevel], width = _mipmaps_miplevel.width, height = _mipmaps_miplevel.height, data = _mipmaps_miplevel.data;
                    resource.setPixelBuffer(data, miplevel, 0, 0, width, height);
                }
                resolve(resource);
            }).catch(function(e) {
                reject(e);
            });
        });
    };
    return KTXContentRestorer;
}(ContentRestorer);

function parseProperty(object, key, value) {
    if ((typeof value === "undefined" ? "undefined" : _type_of(value)) === "object") {
        for(var subKey in value){
            parseProperty(object[key], subKey, value[subKey]);
        }
    } else {
        object[key] = value;
    }
}
var MaterialLoader = /*#__PURE__*/ function(Loader) {
    _inherits(MaterialLoader, Loader);
    function MaterialLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = MaterialLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            resourceManager// @ts-ignore
            ._request(item.url, _extends({}, item, {
                type: "json"
            })).then(function(materialSchema) {
                var engine = resourceManager.engine;
                var shaderRef = materialSchema.shaderRef, shaderName = materialSchema.shader;
                var shader = Shader.find(shaderName);
                if (shader) {
                    resolve(_this._getMaterialByShader(materialSchema, shader, engine));
                } else if (shaderRef) {
                    resolve(resourceManager// @ts-ignore
                    .getResourceByRef(shaderRef).then(function(shader) {
                        return _this._getMaterialByShader(materialSchema, shader, engine);
                    }));
                }
            }).catch(reject);
        });
    };
    _proto._getMaterialByShader = function _getMaterialByShader(materialSchema, shader, engine) {
        var _loop = function(key) {
            var _shaderData_key = shaderData[key], type = _shaderData_key.type, value = _shaderData_key.value;
            switch(type){
                case MaterialLoaderType.Vector2:
                    materialShaderData.setVector2(key, new Vector2(value.x, value.y));
                    break;
                case MaterialLoaderType.Vector3:
                    materialShaderData.setVector3(key, new Vector3(value.x, value.y, value.z));
                    break;
                case MaterialLoaderType.Vector4:
                    materialShaderData.setVector4(key, new Vector4(value.x, value.y, value.z, value.w));
                    break;
                case MaterialLoaderType.Color:
                    materialShaderData.setColor(key, new Color(value.r, value.g, value.b, value.a));
                    break;
                case MaterialLoaderType.Float:
                    materialShaderData.setFloat(key, value);
                    break;
                case MaterialLoaderType.Texture:
                    texturePromises.push(// @ts-ignore
                    engine.resourceManager.getResourceByRef(value).then(function(texture) {
                        materialShaderData.setTexture(key, texture);
                    }));
                    break;
                case MaterialLoaderType.Boolean:
                    materialShaderData.setInt(key, value ? 1 : 0);
                    break;
                case MaterialLoaderType.Integer:
                    materialShaderData.setInt(key, Number(value));
                    break;
            }
        };
        var name = materialSchema.name, shaderData = materialSchema.shaderData, macros = materialSchema.macros, renderState = materialSchema.renderState;
        var material = new Material(engine, shader);
        material.name = name;
        var texturePromises = new Array();
        var materialShaderData = material.shaderData;
        for(var key in shaderData)_loop(key);
        for(var i = 0, length = macros.length; i < length; i++){
            var _macros_i = macros[i], name1 = _macros_i.name, value = _macros_i.value;
            if (value == undefined) {
                materialShaderData.enableMacro(name1);
            } else {
                materialShaderData.enableMacro(name1, value);
            }
        }
        parseProperty(material, "renderState", renderState);
        return Promise.all(texturePromises).then(function() {
            return material;
        });
    };
    return MaterialLoader;
}(Loader);
MaterialLoader = __decorate([
    resourceLoader(AssetType.Material, [
        "json"
    ])
], MaterialLoader);

var MeshLoader = /*#__PURE__*/ function(Loader) {
    _inherits(MeshLoader, Loader);
    function MeshLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = MeshLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var requestConfig = _extends({}, item, {
            type: "arraybuffer"
        });
        var url = item.url;
        return new AssetPromise(function(resolve, reject) {
            resourceManager// @ts-ignore
            ._request(url, requestConfig).then(function(data) {
                return decode(data, resourceManager.engine);
            }).then(function(mesh) {
                resourceManager.addContentRestorer(new MeshContentRestorer(mesh, url, requestConfig));
                resolve(mesh);
            }).catch(reject);
        });
    };
    return MeshLoader;
}(Loader);
MeshLoader = __decorate([
    resourceLoader(AssetType.Mesh, [
        "mesh"
    ])
], MeshLoader);
var MeshContentRestorer = /*#__PURE__*/ function(ContentRestorer) {
    _inherits(MeshContentRestorer, ContentRestorer);
    function MeshContentRestorer(resource, url, requestConfig) {
        var _this;
        _this = ContentRestorer.call(this, resource) || this, _this.url = url, _this.requestConfig = requestConfig;
        return _this;
    }
    var _proto = MeshContentRestorer.prototype;
    _proto.restoreContent = function restoreContent() {
        var _this = this;
        var resource = this.resource;
        var engine = resource.engine;
        return new AssetPromise(function(resolve, reject) {
            engine.resourceManager// @ts-ignore
            ._request(_this.url, _this.requestConfig).then(function(data) {
                return decode(data, engine, resource);
            }).then(function(mesh) {
                resolve(mesh);
            }).catch(reject);
        });
    };
    return MeshContentRestorer;
}(ContentRestorer);

var PrimitiveMeshLoader = /*#__PURE__*/ function(Loader) {
    _inherits(PrimitiveMeshLoader, Loader);
    function PrimitiveMeshLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = PrimitiveMeshLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var engine = resourceManager.engine;
        return resourceManager// @ts-ignore
        ._request(item.url, _extends({}, item, {
            type: "json"
        })).then(function(data) {
            switch(data.type){
                case "sphere":
                    return PrimitiveMesh.createSubdivisionSurfaceSphere(engine, data.sphereRadius, data.sphereStep);
                case "capsule":
                    return PrimitiveMesh.createCapsule(engine, data.capsuleRadius, data.capsuleHeight, data.capsuleRadialSegments, data.capsuleHeightSegments);
                case "cone":
                    return PrimitiveMesh.createCone(engine, data.coneRadius, data.coneHeight, data.coneRadialSegment, data.coneHeightSegment);
                case "cuboid":
                    return PrimitiveMesh.createCuboid(engine, data.cuboidWidth, data.cuboidHeight, data.cuboidDepth);
                case "cylinder":
                    return PrimitiveMesh.createCylinder(engine, data.cylinderRadiusTop, data.cylinderRadiusBottom, data.cylinderHeight, data.cylinderRadialSegment, data.cylinderHeightSegment);
                case "plane":
                    return PrimitiveMesh.createPlane(engine, data.planeWidth, data.planeHeight, data.planeHorizontalSegments, data.planeVerticalSegments);
                case "torus":
                    return PrimitiveMesh.createTorus(engine, data.torusRadius, data.torusTubeRadius, data.torusRadialSegments, data.torusTubularSegments, data.torusArc);
            }
        });
    };
    return PrimitiveMeshLoader;
}(Loader);
PrimitiveMeshLoader = __decorate([
    resourceLoader(AssetType.PrimitiveMesh, [
        "mesh"
    ], false)
], PrimitiveMeshLoader);

var ProjectLoader = /*#__PURE__*/ function(Loader) {
    _inherits(ProjectLoader, Loader);
    function ProjectLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = ProjectLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var engine = resourceManager.engine;
        return new AssetPromise(function(resolve, reject) {
            resourceManager// @ts-ignore
            ._request(item.url, _extends({}, item, {
                type: "json"
            })).then(function(data) {
                // @ts-ignore
                engine.resourceManager.initVirtualResources(data.files);
                return resourceManager.load({
                    type: AssetType.Scene,
                    url: data.scene
                }).then(function(scene) {
                    engine.sceneManager.activeScene = scene;
                    resolve();
                });
            }).catch(reject);
        });
    };
    return ProjectLoader;
}(Loader);
ProjectLoader = __decorate([
    resourceLoader(AssetType.Project, [
        "proj"
    ], false)
], ProjectLoader);

var SourceFontLoader = /*#__PURE__*/ function(Loader) {
    _inherits(SourceFontLoader, Loader);
    function SourceFontLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = SourceFontLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            // @ts-ignore
            var url = resourceManager._getRemoteUrl(item.url);
            _this._registerFont(url, url).then(function() {
                var font = new Font(resourceManager.engine, url);
                resolve(font);
            }).catch(function(e) {
                reject("load font " + url + " fail");
            });
        });
    };
    _proto._registerFont = function _registerFont(fontName, fontUrl) {
        return _async_to_generator(function() {
            var fontFace;
            return __generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        fontFace = new FontFace(fontName, "url(" + fontUrl + ")");
                        return [
                            4,
                            fontFace.load()
                        ];
                    case 1:
                        _state.sent();
                        document.fonts.add(fontFace);
                        return [
                            2
                        ];
                }
            });
        })();
    };
    return SourceFontLoader;
}(Loader);
SourceFontLoader = __decorate([
    resourceLoader(AssetType.SourceFont, [
        "ttf",
        "otf",
        "woff"
    ], false)
], SourceFontLoader);

var SpriteAtlasLoader = /*#__PURE__*/ function(Loader) {
    _inherits(SpriteAtlasLoader, Loader);
    function SpriteAtlasLoader() {
        var _this;
        _this = Loader.apply(this, arguments) || this, _this._tempRect = new Rect(), _this._tempVec2 = new Vector2(), _this._tempVec4 = new Vector4();
        return _this;
    }
    var _proto = SpriteAtlasLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject, _, __, onCancel) {
            var chainPromises = [];
            onCancel(function() {
                for(var i = 0; i < chainPromises.length; i++){
                    chainPromises[i].cancel();
                }
            });
            // @ts-ignore
            var configPromise = resourceManager._request(item.url, _extends({}, item, {
                type: "json"
            }));
            chainPromises.push(configPromise);
            configPromise.then(function(atlasData) {
                var _loop = function(i) {
                    var atlasItem = atlasItems[i];
                    if (atlasItem.img) {
                        var _atlasItem_type;
                        chainPromises.push(resourceManager.load({
                            url: Utils.resolveAbsoluteUrl(item.url, atlasItem.img),
                            type: (_atlasItem_type = atlasItem.type) != null ? _atlasItem_type : AssetType.Texture2D,
                            params: {
                                format: format,
                                mipmap: mipmap
                            }
                        }).then(function(texture) {
                            anisoLevel && (texture.anisoLevel = anisoLevel);
                            filterMode !== undefined && (texture.filterMode = filterMode);
                            wrapModeU !== undefined && (texture.wrapModeU = wrapModeU);
                            wrapModeV !== undefined && (texture.wrapModeV = wrapModeV);
                            for(var i = 0; i < atlasItem.sprites.length; i++){
                                // @ts-ignore
                                spriteAtlas._addSprite(_this._makeSprite(engine, atlasItem.sprites[i], texture));
                            }
                        }).catch(reject));
                    } else {
                        for(var i1 = 0; i1 < atlasItem.sprites.length; i1++){
                            // @ts-ignore
                            spriteAtlas._addSprite(_this._makeSprite(engine, atlasItem.sprites[i1]));
                        }
                    }
                };
                var atlasItems = atlasData.atlasItems, mipmap = atlasData.mipmap, anisoLevel = atlasData.anisoLevel, filterMode = atlasData.filterMode, wrapModeU = atlasData.wrapModeU, wrapModeV = atlasData.wrapModeV, format = atlasData.format;
                var atlasItemsLen = atlasItems ? atlasItems.length : 0;
                var engine = resourceManager.engine;
                var spriteAtlas = new SpriteAtlas(engine);
                if (atlasItemsLen <= 0) {
                    resolve(spriteAtlas);
                    return;
                }
                chainPromises.length = 0;
                for(var i = 0; i < atlasItemsLen; i++)_loop(i);
                AssetPromise.all(chainPromises).then(function() {
                    resolve(spriteAtlas);
                }).catch(reject);
            }).catch(reject);
        });
    };
    _proto._makeSprite = function _makeSprite(engine, config, texture) {
        // Generate a SpriteAtlas object.
        var region = config.region, atlasRegionOffset = config.atlasRegionOffset, atlasRegion = config.atlasRegion, pivot = config.pivot, border = config.border, width = config.width, height = config.height;
        var sprite = new Sprite(engine, texture, region ? this._tempRect.set(region.x, region.y, region.w, region.h) : undefined, pivot ? this._tempVec2.set(pivot.x, pivot.y) : undefined, border ? this._tempVec4.set(border.x, border.y, border.z, border.w) : undefined, config.name);
        if (texture) {
            var invW = 1 / texture.width;
            var invH = 1 / texture.height;
            sprite.atlasRegion.set(atlasRegion.x * invW, atlasRegion.y * invH, atlasRegion.w * invW, atlasRegion.h * invH);
            if (atlasRegionOffset) {
                var offsetLeft = atlasRegionOffset.x, offsetTop = atlasRegionOffset.y, offsetRight = atlasRegionOffset.z, offsetBottom = atlasRegionOffset.w;
                sprite.atlasRegionOffset.set(offsetLeft * invW, offsetTop * invH, offsetRight * invW, offsetBottom * invH);
            }
            config.atlasRotated && (sprite.atlasRotated = true);
        }
        width === undefined || (sprite.width = width);
        height === undefined || (sprite.height = height);
        return sprite;
    };
    return SpriteAtlasLoader;
}(Loader);
SpriteAtlasLoader = __decorate([
    resourceLoader(AssetType.SpriteAtlas, [
        "atlas"
    ], false)
], SpriteAtlasLoader);

var SpriteLoader = /*#__PURE__*/ function(Loader) {
    _inherits(SpriteLoader, Loader);
    function SpriteLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = SpriteLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return resourceManager// @ts-ignore
        ._request(item.url, _extends({}, item, {
            type: "json"
        })).then(function(data) {
            return data.belongToAtlas ? _this._loadFromAtlas(resourceManager, data) : _this._loadFromTexture(resourceManager, data);
        });
    };
    _proto._loadFromAtlas = function _loadFromAtlas(resourceManager, data) {
        var _this = this;
        return resourceManager// @ts-ignore
        .getResourceByRef(data.belongToAtlas).then(function(atlas) {
            return atlas.getSprite(data.fullPath) || _this._loadFromTexture(resourceManager, data);
        });
    };
    _proto._loadFromTexture = function _loadFromTexture(resourceManager, data) {
        if (data.texture) {
            return resourceManager// @ts-ignore
            .getResourceByRef(data.texture).then(function(texture) {
                var sprite = new Sprite(resourceManager.engine, texture, data.region, data.pivot, data.border);
                var width = data.width, height = data.height;
                width === undefined || (sprite.width = width);
                height === undefined || (sprite.height = height);
                return sprite;
            });
        } else {
            return new AssetPromise(function(resolve) {
                var sprite = new Sprite(resourceManager.engine, null, data.region, data.pivot, data.border);
                var width = data.width, height = data.height;
                width === undefined || (sprite.width = width);
                height === undefined || (sprite.height = height);
                resolve(sprite);
            });
        }
    };
    return SpriteLoader;
}(Loader);
SpriteLoader = __decorate([
    resourceLoader(AssetType.Sprite, [
        "sprite"
    ], false)
], SpriteLoader);

/**
 * @internal
 */ var Texture2DContentRestorer = /*#__PURE__*/ function(ContentRestorer) {
    _inherits(Texture2DContentRestorer, ContentRestorer);
    function Texture2DContentRestorer(resource, url, requestConfig) {
        var _this;
        _this = ContentRestorer.call(this, resource) || this, _this.url = url, _this.requestConfig = requestConfig;
        return _this;
    }
    var _proto = Texture2DContentRestorer.prototype;
    _proto.restoreContent = function restoreContent() {
        var _this = this;
        return request(this.url, this.requestConfig).then(function(image) {
            var resource = _this.resource;
            resource.setImageSource(image);
            resource.generateMipmaps();
            return resource;
        });
    };
    return Texture2DContentRestorer;
}(ContentRestorer);

var Texture2DLoader = /*#__PURE__*/ function(Loader) {
    _inherits(Texture2DLoader, Loader);
    function Texture2DLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = Texture2DLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        return new AssetPromise(function(resolve, reject, setTaskCompleteProgress, setTaskDetailProgress) {
            var url = item.url;
            var requestConfig = _extends({}, item, {
                type: "image"
            });
            resourceManager// @ts-ignore
            ._request(url, requestConfig).onProgress(setTaskCompleteProgress, setTaskDetailProgress).then(function(image) {
                var _item_params;
                var _ref = (_item_params = item.params) != null ? _item_params : {}, _ref_format = _ref.format, format = _ref_format === void 0 ? TextureFormat.R8G8B8A8 : _ref_format, anisoLevel = _ref.anisoLevel, wrapModeU = _ref.wrapModeU, wrapModeV = _ref.wrapModeV, filterMode = _ref.filterMode, _ref_isSRGBColorSpace = _ref.isSRGBColorSpace, isSRGBColorSpace = _ref_isSRGBColorSpace === void 0 ? true : _ref_isSRGBColorSpace, _ref_mipmap = _ref.mipmap, mipmap = _ref_mipmap === void 0 ? true : _ref_mipmap;
                var width = image.width, height = image.height;
                // @ts-ignore
                var isWebGL2 = resourceManager.engine._hardwareRenderer._isWebGL2;
                var generateMipmap = TextureUtils.supportGenerateMipmapsWithCorrection(width, height, format, mipmap, isSRGBColorSpace, isWebGL2);
                var texture = new Texture2D(resourceManager.engine, width, height, format, generateMipmap, isSRGBColorSpace);
                texture.anisoLevel = anisoLevel != null ? anisoLevel : texture.anisoLevel;
                texture.filterMode = filterMode != null ? filterMode : texture.filterMode;
                texture.wrapModeU = wrapModeU != null ? wrapModeU : texture.wrapModeU;
                texture.wrapModeV = wrapModeV != null ? wrapModeV : texture.wrapModeV;
                texture.setImageSource(image);
                generateMipmap && texture.generateMipmaps();
                if (url.indexOf("data:") !== 0) {
                    var index = url.lastIndexOf("/");
                    texture.name = url.substring(index + 1);
                }
                resourceManager.addContentRestorer(new Texture2DContentRestorer(texture, url, requestConfig));
                resolve(texture);
            }).catch(function(e) {
                reject(e);
            });
        });
    };
    return Texture2DLoader;
}(Loader);
Texture2DLoader = __decorate([
    resourceLoader(AssetType.Texture2D, [
        "png",
        "jpg",
        "webp",
        "jpeg"
    ])
], Texture2DLoader);

/**
 * @internal
 */ var TextureCubeContentRestorer = /*#__PURE__*/ function(ContentRestorer) {
    _inherits(TextureCubeContentRestorer, ContentRestorer);
    function TextureCubeContentRestorer(resource, urls, requestConfig) {
        var _this;
        _this = ContentRestorer.call(this, resource) || this, _this.urls = urls, _this.requestConfig = requestConfig;
        return _this;
    }
    var _proto = TextureCubeContentRestorer.prototype;
    _proto.restoreContent = function restoreContent() {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            Promise.all(_this.urls.map(function(url) {
                return request(url, _this.requestConfig);
            })).then(function(images) {
                var resource = _this.resource;
                for(var faceIndex = 0; faceIndex < 6; faceIndex++){
                    resource.setImageSource(TextureCubeFace.PositiveX + faceIndex, images[faceIndex], 0);
                }
                resource.generateMipmaps();
                resolve(resource);
            }).catch(function(e) {
                reject(e);
            });
        });
    };
    return TextureCubeContentRestorer;
}(ContentRestorer);

var TextureCubeLoader = /*#__PURE__*/ function(Loader) {
    _inherits(TextureCubeLoader, Loader);
    function TextureCubeLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = TextureCubeLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        return new AssetPromise(function(resolve, reject) {
            var urls = item.urls;
            var requestConfig = _extends({}, item, {
                type: "image"
            });
            // @ts-ignore
            Promise.all(urls.map(function(url) {
                return resourceManager._request(url, requestConfig);
            })).then(function(images) {
                var _item_params;
                var _ref = (_item_params = item.params) != null ? _item_params : {}, _ref_format = _ref.format, format = _ref_format === void 0 ? TextureFormat.R8G8B8A8 : _ref_format, anisoLevel = _ref.anisoLevel, wrapModeU = _ref.wrapModeU, wrapModeV = _ref.wrapModeV, filterMode = _ref.filterMode, _ref_isSRGBColorSpace = _ref.isSRGBColorSpace, isSRGBColorSpace = _ref_isSRGBColorSpace === void 0 ? true : _ref_isSRGBColorSpace, _ref_mipmap = _ref.mipmap, mipmap = _ref_mipmap === void 0 ? true : _ref_mipmap;
                var _images_ = images[0], width = _images_.width, height = _images_.height;
                // @ts-ignore
                var isWebGL2 = resourceManager.engine._hardwareRenderer._isWebGL2;
                if (width !== height) {
                    console.error("The cube texture must have the same width and height");
                    return;
                }
                var generateMipmap = TextureUtils.supportGenerateMipmapsWithCorrection(width, height, format, mipmap, isSRGBColorSpace, isWebGL2);
                var texture = new TextureCube(resourceManager.engine, width, format, generateMipmap, isSRGBColorSpace);
                texture.anisoLevel = anisoLevel != null ? anisoLevel : texture.anisoLevel;
                texture.filterMode = filterMode != null ? filterMode : texture.filterMode;
                texture.wrapModeU = wrapModeU != null ? wrapModeU : texture.wrapModeU;
                texture.wrapModeV = wrapModeV != null ? wrapModeV : texture.wrapModeV;
                for(var faceIndex = 0; faceIndex < 6; faceIndex++){
                    texture.setImageSource(TextureCubeFace.PositiveX + faceIndex, images[faceIndex], 0);
                }
                generateMipmap && texture.generateMipmaps();
                resourceManager.addContentRestorer(new TextureCubeContentRestorer(texture, urls, requestConfig));
                resolve(texture);
            }).catch(function(e) {
                reject(e);
            });
        });
    };
    return TextureCubeLoader;
}(Loader);
TextureCubeLoader = __decorate([
    resourceLoader(AssetType.TextureCube, [
        ""
    ])
], TextureCubeLoader);

var AudioLoader = /*#__PURE__*/ function(Loader) {
    _inherits(AudioLoader, Loader);
    function AudioLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = AudioLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        return new AssetPromise(function(resolve, reject) {
            var url = item.url;
            var requestConfig = _extends({}, item, {
                type: "arraybuffer"
            });
            // @ts-ignore
            resourceManager._request(url, requestConfig).then(function(arrayBuffer) {
                var audioClip = new AudioClip(resourceManager.engine);
                AudioManager.getContext().decodeAudioData(arrayBuffer).then(function(result) {
                    // @ts-ignore
                    audioClip._setAudioSource(result);
                    if (url.indexOf("data:") !== 0) {
                        var index = url.lastIndexOf("/");
                        audioClip.name = url.substring(index + 1);
                    }
                    resolve(audioClip);
                }).catch(function(e) {
                    reject(e);
                });
            });
        });
    };
    return AudioLoader;
}(Loader);
AudioLoader = __decorate([
    resourceLoader(AssetType.Audio, [
        "mp3",
        "ogg",
        "wav"
    ])
], AudioLoader);

var ShaderChunkLoader = /*#__PURE__*/ function(Loader) {
    _inherits(ShaderChunkLoader, Loader);
    function ShaderChunkLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = ShaderChunkLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var url = item.url;
        // @ts-ignore
        return resourceManager._request(url, _extends({}, item, {
            type: "text"
        })).then(function(code) {
            ShaderFactory.registerInclude(url.substring(1), code);
            return ShaderChunkLoader._loadChunksInCode(code, url, resourceManager);
        });
    };
    /**
   * @internal
   */ ShaderChunkLoader._loadChunksInCode = function _loadChunksInCode(code, basePath, resourceManager) {
        var shaderChunkPaths = new Array();
        var matches = code.matchAll(ShaderChunkLoader._shaderIncludeRegex);
        for(var _iterator = _create_for_of_iterator_helper_loose(matches), _step; !(_step = _iterator()).done;){
            var match = _step.value;
            var chunkPath = Utils.resolveAbsoluteUrl(basePath, match[1]);
            if (!ShaderLib[chunkPath.substring(1)]) {
                shaderChunkPaths.push(chunkPath);
            }
        }
        return Promise.all(shaderChunkPaths.map(function(chunkPath) {
            return resourceManager.load({
                type: "ShaderChunk",
                url: chunkPath
            });
        }));
    };
    return ShaderChunkLoader;
}(Loader);
ShaderChunkLoader._shaderIncludeRegex = /#include\s+"([./][^\\"]+)"/gm;
ShaderChunkLoader = __decorate([
    resourceLoader("ShaderChunk", [
        "glsl"
    ])
], ShaderChunkLoader);

var ShaderLoader = /*#__PURE__*/ function(Loader) {
    _inherits(ShaderLoader, Loader);
    function ShaderLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = ShaderLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        var url = item.url;
        // @ts-ignore
        return resourceManager._request(url, _extends({}, item, {
            type: "text"
        })).then(function(code) {
            var builtinShader = _this._getBuiltinShader(code);
            if (builtinShader) {
                return Shader.find(builtinShader);
            }
            return ShaderChunkLoader._loadChunksInCode(code, url, resourceManager).then(function() {
                var shader = Shader.create(code);
                // @ts-ignore
                shader._registerPath(url);
                return shader;
            });
        });
    };
    _proto._getBuiltinShader = function _getBuiltinShader(code) {
        var match = code.match(ShaderLoader._builtinRegex);
        if (match && match[1]) return match[1];
    };
    return ShaderLoader;
}(Loader);
ShaderLoader._builtinRegex = /^\s*\/\/\s*@builtin\s+(\w+)/;
ShaderLoader = __decorate([
    resourceLoader(AssetType.Shader, [
        "gs",
        "gsl"
    ])
], ShaderLoader);

var PhysicsMaterialLoader = /*#__PURE__*/ function(Loader) {
    _inherits(PhysicsMaterialLoader, Loader);
    function PhysicsMaterialLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = PhysicsMaterialLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        return resourceManager// @ts-ignore
        ._request(item.url, _extends({}, item, {
            type: "json"
        })).then(function(data) {
            var physicsMaterial = new PhysicsMaterial();
            physicsMaterial.bounciness = data.bounciness;
            physicsMaterial.dynamicFriction = data.dynamicFriction;
            physicsMaterial.staticFriction = data.staticFriction;
            physicsMaterial.bounceCombine = data.bounceCombine;
            physicsMaterial.frictionCombine = data.frictionCombine;
            return physicsMaterial;
        });
    };
    return PhysicsMaterialLoader;
}(Loader);
PhysicsMaterialLoader = __decorate([
    resourceLoader(AssetType.PhysicsMaterial, [
        "mesh"
    ])
], PhysicsMaterialLoader);

var SceneLoader = /*#__PURE__*/ function(Loader) {
    _inherits(SceneLoader, Loader);
    function SceneLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = SceneLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var engine = resourceManager.engine;
        return new AssetPromise(function(resolve, reject) {
            resourceManager// @ts-ignore
            ._request(item.url, _extends({}, item, {
                type: "json"
            })).then(function(data) {
                return SceneParser.parse(engine, data).then(function(scene) {
                    var promises = [];
                    // parse ambient light
                    var ambient = data.scene.ambient;
                    if (ambient) {
                        var useCustomAmbient = ambient.specularMode === SpecularMode.Custom;
                        var useSH = ambient.diffuseMode === DiffuseMode.SphericalHarmonics;
                        scene.ambientLight.diffuseIntensity = ambient.diffuseIntensity;
                        scene.ambientLight.specularIntensity = ambient.specularIntensity;
                        scene.ambientLight.diffuseMode = ambient.diffuseMode;
                        scene.ambientLight.diffuseSolidColor.copyFrom(ambient.diffuseSolidColor);
                        scene.ambientLight.specularTextureDecodeRGBM = true;
                        if (useCustomAmbient && ambient.customAmbientLight) {
                            promises.push(// @ts-ignore
                            resourceManager.getResourceByRef(ambient.customAmbientLight).then(function(ambientLight) {
                                scene.ambientLight.specularTexture = ambientLight == null ? void 0 : ambientLight.specularTexture;
                            }));
                        }
                        if (ambient.ambientLight && (!useCustomAmbient || useSH)) {
                            promises.push(// @ts-ignore
                            resourceManager.getResourceByRef(ambient.ambientLight).then(function(ambientLight) {
                                if (!useCustomAmbient) {
                                    scene.ambientLight.specularTexture = ambientLight == null ? void 0 : ambientLight.specularTexture;
                                }
                                if (useSH) {
                                    scene.ambientLight.diffuseSphericalHarmonics = ambientLight == null ? void 0 : ambientLight.diffuseSphericalHarmonics;
                                }
                            }));
                        }
                    }
                    // parse background
                    var background = data.scene.background;
                    scene.background.mode = background.mode;
                    switch(scene.background.mode){
                        case BackgroundMode.SolidColor:
                            scene.background.solidColor.copyFrom(background.color);
                            break;
                        case BackgroundMode.Sky:
                            if (background.skyMesh && background.skyMaterial) {
                                // @ts-ignore
                                var skyMeshPromise = resourceManager.getResourceByRef(background.skyMesh).then(function(mesh) {
                                    scene.background.sky.mesh = mesh;
                                });
                                // @ts-ignore
                                // prettier-ignore
                                var skyMaterialPromise = resourceManager.getResourceByRef(background.skyMaterial).then(function(material) {
                                    scene.background.sky.material = material;
                                });
                                promises.push(skyMeshPromise, skyMaterialPromise);
                            } else {
                                Logger.warn("Sky background mode requires skyMesh and skyMaterial");
                            }
                            break;
                        case BackgroundMode.Texture:
                            if (background.texture) {
                                // @ts-ignore
                                // prettier-ignore
                                var backgroundPromise = resourceManager.getResourceByRef(background.texture).then(function(texture) {
                                    scene.background.texture = texture;
                                });
                                promises.push(backgroundPromise);
                                var _background_textureFillMode;
                                scene.background.textureFillMode = (_background_textureFillMode = background.textureFillMode) != null ? _background_textureFillMode : scene.background.textureFillMode;
                            }
                            break;
                    }
                    // parse shadow
                    var shadow = data.scene.shadow;
                    if (shadow) {
                        if (shadow.castShadows != undefined) scene.castShadows = shadow.castShadows;
                        if (shadow.shadowResolution != undefined) scene.shadowResolution = shadow.shadowResolution;
                        if (shadow.shadowDistance != undefined) scene.shadowDistance = shadow.shadowDistance;
                        if (shadow.shadowCascades != undefined) scene.shadowCascades = shadow.shadowCascades;
                        if (shadow.enableTransparentShadow != undefined) {
                            scene.enableTransparentShadow = shadow.enableTransparentShadow;
                        }
                        var _shadow_shadowTwoCascadeSplits;
                        scene.shadowTwoCascadeSplits = (_shadow_shadowTwoCascadeSplits = shadow.shadowTwoCascadeSplits) != null ? _shadow_shadowTwoCascadeSplits : scene.shadowTwoCascadeSplits;
                        shadow.shadowFourCascadeSplits && scene.shadowFourCascadeSplits.copyFrom(shadow.shadowFourCascadeSplits);
                        var _shadow_shadowFadeBorder;
                        scene.shadowFadeBorder = (_shadow_shadowFadeBorder = shadow.shadowFadeBorder) != null ? _shadow_shadowFadeBorder : scene.shadowFadeBorder;
                    }
                    // parse fog
                    var fog = data.scene.fog;
                    if (fog) {
                        if (fog.fogMode != undefined) scene.fogMode = fog.fogMode;
                        if (fog.fogStart != undefined) scene.fogStart = fog.fogStart;
                        if (fog.fogEnd != undefined) scene.fogEnd = fog.fogEnd;
                        if (fog.fogDensity != undefined) scene.fogDensity = fog.fogDensity;
                        if (fog.fogColor != undefined) scene.fogColor.copyFrom(fog.fogColor);
                    }
                    // Post Process
                    var postProcessData = data.scene.postProcess;
                    if (postProcessData) {
                        Logger.warn("Post Process is not supported in scene yet, please add PostProcess component in entity instead.");
                    }
                    return Promise.all(promises).then(function() {
                        resolve(scene);
                    });
                });
            }).catch(reject);
        });
    };
    return SceneLoader;
}(Loader);
SceneLoader = __decorate([
    resourceLoader(AssetType.Scene, [
        "scene"
    ], true)
], SceneLoader);
ReflectionParser.registerCustomParseComponent("TextRenderer", /*#__PURE__*/ _async_to_generator(function(instance, item) {
    var props;
    return __generator(this, function(_state) {
        props = item.props;
        if (!props.font) {
            // @ts-ignore
            instance.font = Font.createFromOS(instance.engine, props.fontFamily || "Arial");
        }
        return [
            2,
            instance
        ];
    });
}));

var KHR_lights_punctual = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(KHR_lights_punctual, GLTFExtensionParser);
    function KHR_lights_punctual() {
        return GLTFExtensionParser.apply(this, arguments) || this;
    }
    var _proto = KHR_lights_punctual.prototype;
    _proto.additiveParse = function additiveParse(context, entity, extensionSchema) {
        var _glTFResource;
        var lightsSchema = context.glTF.extensions.KHR_lights_punctual.lights;
        var lightSchema = lightsSchema[extensionSchema.light];
        var color = lightSchema.color, _lightSchema_intensity = lightSchema.intensity, intensity = _lightSchema_intensity === void 0 ? 1 : _lightSchema_intensity, type = lightSchema.type, range = lightSchema.range, spot = lightSchema.spot;
        var glTFResource = context.glTFResource;
        var light;
        if (type === "directional") {
            light = entity.addComponent(DirectLight);
        } else if (type === "point") {
            light = entity.addComponent(PointLight);
        } else if (type === "spot") {
            light = entity.addComponent(SpotLight);
        }
        if (color) {
            light.color.set(color[0] * intensity, color[1] * intensity, color[2] * intensity, 1);
        }
        if (range && !_instanceof$1(light, DirectLight)) {
            light.distance = range;
        }
        if (spot && _instanceof$1(light, SpotLight)) {
            var _spot_innerConeAngle = spot.innerConeAngle, innerConeAngle = _spot_innerConeAngle === void 0 ? 0 : _spot_innerConeAngle, _spot_outerConeAngle = spot.outerConeAngle, outerConeAngle = _spot_outerConeAngle === void 0 ? Math.PI / 4 : _spot_outerConeAngle;
            light.angle = innerConeAngle;
            light.penumbra = outerConeAngle - innerConeAngle;
        }
        (_glTFResource = glTFResource).lights || (_glTFResource.lights = []);
        glTFResource.lights.push(light);
    };
    return KHR_lights_punctual;
}(GLTFExtensionParser);
KHR_lights_punctual = __decorate([
    registerGLTFExtension("KHR_lights_punctual", GLTFExtensionMode.AdditiveParse)
], KHR_lights_punctual);

var KHR_materials_clearcoat = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(KHR_materials_clearcoat, GLTFExtensionParser);
    function KHR_materials_clearcoat() {
        return GLTFExtensionParser.apply(this, arguments) || this;
    }
    var _proto = KHR_materials_clearcoat.prototype;
    _proto.additiveParse = function additiveParse(context, material, schema) {
        var _schema_clearcoatFactor = schema.clearcoatFactor, clearcoatFactor = _schema_clearcoatFactor === void 0 ? 0 : _schema_clearcoatFactor, clearcoatTexture = schema.clearcoatTexture, _schema_clearcoatRoughnessFactor = schema.clearcoatRoughnessFactor, clearcoatRoughnessFactor = _schema_clearcoatRoughnessFactor === void 0 ? 0 : _schema_clearcoatRoughnessFactor, clearcoatRoughnessTexture = schema.clearcoatRoughnessTexture, clearcoatNormalTexture = schema.clearcoatNormalTexture;
        material.clearCoat = clearcoatFactor;
        material.clearCoatRoughness = clearcoatRoughnessFactor;
        if (clearcoatTexture) {
            GLTFMaterialParser._checkOtherTextureTransform(clearcoatTexture, "Clear coat");
            context.get(GLTFParserType.Texture, clearcoatTexture.index).then(function(texture) {
                material.clearCoatTexture = texture;
            }).catch(function(e) {
                Logger.error("KHR_materials_clearcoat: clearcoat texture error", e);
            });
        }
        if (clearcoatRoughnessTexture) {
            GLTFMaterialParser._checkOtherTextureTransform(clearcoatRoughnessTexture, "Clear coat roughness");
            context.get(GLTFParserType.Texture, clearcoatRoughnessTexture.index).then(function(texture) {
                material.clearCoatRoughnessTexture = texture;
            }).catch(function(e) {
                Logger.error("KHR_materials_clearcoat: clearcoat roughness texture error", e);
            });
        }
        if (clearcoatNormalTexture) {
            GLTFMaterialParser._checkOtherTextureTransform(clearcoatNormalTexture, "Clear coat normal");
            context.get(GLTFParserType.Texture, clearcoatNormalTexture.index).then(function(texture) {
                material.clearCoatNormalTexture = texture;
            }).catch(function(e) {
                Logger.error("KHR_materials_clearcoat: clearcoat normal texture error", e);
            });
        }
    };
    return KHR_materials_clearcoat;
}(GLTFExtensionParser);
KHR_materials_clearcoat = __decorate([
    registerGLTFExtension("KHR_materials_clearcoat", GLTFExtensionMode.AdditiveParse)
], KHR_materials_clearcoat);

var KHR_materials_ior = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(KHR_materials_ior, GLTFExtensionParser);
    function KHR_materials_ior() {
        return GLTFExtensionParser.apply(this, arguments) || this;
    }
    var _proto = KHR_materials_ior.prototype;
    _proto.additiveParse = function additiveParse(context, material, schema) {
        var _schema_ior = schema.ior, ior = _schema_ior === void 0 ? 1.5 : _schema_ior;
        material.ior = ior;
    };
    return KHR_materials_ior;
}(GLTFExtensionParser);
KHR_materials_ior = __decorate([
    registerGLTFExtension("KHR_materials_ior", GLTFExtensionMode.AdditiveParse)
], KHR_materials_ior);

var KHR_materials_pbrSpecularGlossiness = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(KHR_materials_pbrSpecularGlossiness, GLTFExtensionParser);
    function KHR_materials_pbrSpecularGlossiness() {
        return GLTFExtensionParser.apply(this, arguments) || this;
    }
    var _proto = KHR_materials_pbrSpecularGlossiness.prototype;
    _proto.createAndParse = function createAndParse(context, schema, ownerSchema) {
        var engine = context.glTFResource.engine;
        var material = new PBRSpecularMaterial(engine);
        var diffuseFactor = schema.diffuseFactor, diffuseTexture = schema.diffuseTexture, specularFactor = schema.specularFactor, glossinessFactor = schema.glossinessFactor, specularGlossinessTexture = schema.specularGlossinessTexture;
        if (diffuseFactor) {
            material.baseColor.copyFromArray(diffuseFactor);
        }
        if (diffuseTexture) {
            context.get(GLTFParserType.Texture, diffuseTexture.index).then(function(texture) {
                material.baseTexture = texture;
                GLTFParser.executeExtensionsAdditiveAndParse(diffuseTexture.extensions, context, material, diffuseTexture);
            }).catch(function(e) {
                Logger.error("KHR_materials_pbrSpecularGlossiness: diffuse texture error", e);
            });
        }
        if (specularFactor) {
            material.specularColor.set(specularFactor[0], specularFactor[1], specularFactor[2], 1.0);
        }
        if (glossinessFactor !== undefined) {
            material.glossiness = glossinessFactor;
        }
        if (specularGlossinessTexture) {
            GLTFMaterialParser._checkOtherTextureTransform(specularGlossinessTexture, "Specular glossiness");
            context.get(GLTFParserType.Texture, specularGlossinessTexture.index).then(function(texture) {
                material.specularGlossinessTexture = texture;
            }).catch(function(e) {
                Logger.error("KHR_materials_pbrSpecularGlossiness: specular glossiness texture error", e);
            });
        }
        material.name = ownerSchema.name;
        GLTFMaterialParser._parseStandardProperty(context, material, ownerSchema);
        return material;
    };
    return KHR_materials_pbrSpecularGlossiness;
}(GLTFExtensionParser);
KHR_materials_pbrSpecularGlossiness = __decorate([
    registerGLTFExtension("KHR_materials_pbrSpecularGlossiness", GLTFExtensionMode.CreateAndParse)
], KHR_materials_pbrSpecularGlossiness);

var KHR_materials_sheen = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(KHR_materials_sheen, GLTFExtensionParser);
    function KHR_materials_sheen() {
        return GLTFExtensionParser.apply(this, arguments) || this;
    }
    var _proto = KHR_materials_sheen.prototype;
    _proto.additiveParse = function additiveParse(context, material, schema) {
        var sheenColorFactor = schema.sheenColorFactor, sheenColorTexture = schema.sheenColorTexture, _schema_sheenRoughnessFactor = schema.sheenRoughnessFactor, sheenRoughnessFactor = _schema_sheenRoughnessFactor === void 0 ? 0 : _schema_sheenRoughnessFactor, sheenRoughnessTexture = schema.sheenRoughnessTexture;
        if (sheenColorFactor) {
            material.sheenColor.set(sheenColorFactor[0], sheenColorFactor[1], sheenColorFactor[2], undefined);
        }
        material.sheenRoughness = sheenRoughnessFactor;
        if (sheenColorTexture) {
            GLTFMaterialParser._checkOtherTextureTransform(sheenColorTexture, "Sheen texture");
            context.get(GLTFParserType.Texture, sheenColorTexture.index).then(function(texture) {
                material.sheenColorTexture = texture;
            }).catch(function(e) {
                Logger.error("KHR_materials_sheen: sheenColorTexture error", e);
            });
        }
        if (sheenRoughnessTexture) {
            GLTFMaterialParser._checkOtherTextureTransform(sheenRoughnessTexture, "SheenRoughness texture");
            context.get(GLTFParserType.Texture, sheenRoughnessTexture.index).then(function(texture) {
                material.sheenRoughnessTexture = texture;
            }).catch(function(e) {
                Logger.error("KHR_materials_sheen: sheenRoughnessTexture error", e);
            });
        }
    };
    return KHR_materials_sheen;
}(GLTFExtensionParser);
KHR_materials_sheen = __decorate([
    registerGLTFExtension("KHR_materials_sheen", GLTFExtensionMode.AdditiveParse)
], KHR_materials_sheen);

var KHR_materials_transmission = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(KHR_materials_transmission, GLTFExtensionParser);
    function KHR_materials_transmission() {
        return GLTFExtensionParser.apply(this, arguments) || this;
    }
    var _proto = KHR_materials_transmission.prototype;
    _proto.additiveParse = function additiveParse(context, material, schema) {
        var _schema_transmissionFactor = schema.transmissionFactor, transmissionFactor = _schema_transmissionFactor === void 0 ? 0 : _schema_transmissionFactor, transmissionTexture = schema.transmissionTexture;
        material.transmission = transmissionFactor;
        if (transmissionTexture) {
            GLTFMaterialParser._checkOtherTextureTransform(transmissionTexture, "Transmission texture");
            context.get(GLTFParserType.Texture, transmissionTexture.index).then(function(texture) {
                material.transmissionTexture = texture;
            }).catch(function(e) {
                Logger.error("KHR_materials_transmission: transmission texture error", e);
            });
        }
    };
    return KHR_materials_transmission;
}(GLTFExtensionParser);
KHR_materials_transmission = __decorate([
    registerGLTFExtension("KHR_materials_transmission", GLTFExtensionMode.AdditiveParse)
], KHR_materials_transmission);

var KHR_materials_unlit = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(KHR_materials_unlit, GLTFExtensionParser);
    function KHR_materials_unlit() {
        return GLTFExtensionParser.apply(this, arguments) || this;
    }
    var _proto = KHR_materials_unlit.prototype;
    _proto.createAndParse = function createAndParse(context, _, ownerSchema) {
        var engine = context.glTFResource.engine;
        var material = new UnlitMaterial(engine);
        material.name = ownerSchema.name;
        GLTFMaterialParser._parseStandardProperty(context, material, ownerSchema);
        return material;
    };
    return KHR_materials_unlit;
}(GLTFExtensionParser);
KHR_materials_unlit = __decorate([
    registerGLTFExtension("KHR_materials_unlit", GLTFExtensionMode.CreateAndParse)
], KHR_materials_unlit);

var KHR_materials_variants = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(KHR_materials_variants, GLTFExtensionParser);
    function KHR_materials_variants() {
        return GLTFExtensionParser.apply(this, arguments) || this;
    }
    var _proto = KHR_materials_variants.prototype;
    _proto.additiveParse = function additiveParse(context, renderer, schema) {
        var _loop = function(i) {
            var _mappings_i = mappings[i], materialIndex = _mappings_i.material, variants = _mappings_i.variants;
            context.get(GLTFParserType.Material, materialIndex).then(function(material) {
                extensionData.push({
                    renderer: renderer,
                    material: material,
                    variants: variants.map(function(index) {
                        return variantNames[index].name;
                    })
                });
            }).catch(function(e) {
                Logger.error("KHR_materials_variants: material error", e);
            });
        };
        var _glTFResource;
        var _context_glTF = context.glTF, _context_glTF_extensions = _context_glTF.extensions, _context_glTF_extensions_KHR_materials_variants = _context_glTF_extensions.KHR_materials_variants, variantNames = _context_glTF_extensions_KHR_materials_variants.variants, glTFResource = context.glTFResource;
        var mappings = schema.mappings;
        (_glTFResource = glTFResource)._extensionsData || (_glTFResource._extensionsData = {});
        var extensionData = [];
        glTFResource.extensionsData.variants = extensionData;
        for(var i = 0; i < mappings.length; i++)_loop(i);
    };
    return KHR_materials_variants;
}(GLTFExtensionParser);
KHR_materials_variants = __decorate([
    registerGLTFExtension("KHR_materials_variants", GLTFExtensionMode.AdditiveParse)
], KHR_materials_variants);

var KHR_materials_volume = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(KHR_materials_volume, GLTFExtensionParser);
    function KHR_materials_volume() {
        return GLTFExtensionParser.apply(this, arguments) || this;
    }
    var _proto = KHR_materials_volume.prototype;
    _proto.additiveParse = function additiveParse(context, material, schema) {
        var _schema_thicknessFactor = schema.thicknessFactor, thicknessFactor = _schema_thicknessFactor === void 0 ? 0 : _schema_thicknessFactor, thicknessTexture = schema.thicknessTexture, _schema_attenuationDistance = schema.attenuationDistance, attenuationDistance = _schema_attenuationDistance === void 0 ? Infinity : _schema_attenuationDistance, attenuationColor = schema.attenuationColor;
        material.thickness = thicknessFactor;
        material.attenuationDistance = attenuationDistance;
        if (attenuationColor) {
            material.attenuationColor.set(attenuationColor[0], attenuationColor[1], attenuationColor[2], undefined);
        }
        if (thicknessTexture) {
            GLTFMaterialParser._checkOtherTextureTransform(thicknessTexture, "Thickness texture");
            context.get(GLTFParserType.Texture, thicknessTexture.index).then(function(texture) {
                material.thicknessTexture = texture;
            }).catch(function(e) {
                Logger.error("KHR_materials_volume: thickness texture error", e);
            });
        }
    };
    return KHR_materials_volume;
}(GLTFExtensionParser);
KHR_materials_volume = __decorate([
    registerGLTFExtension("KHR_materials_volume", GLTFExtensionMode.AdditiveParse)
], KHR_materials_volume);

var KHR_mesh_quantization = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(KHR_mesh_quantization, GLTFExtensionParser);
    function KHR_mesh_quantization() {
        return GLTFExtensionParser.apply(this, arguments) || this;
    }
    return KHR_mesh_quantization;
}(GLTFExtensionParser);
KHR_mesh_quantization = __decorate([
    registerGLTFExtension("KHR_mesh_quantization", GLTFExtensionMode.AdditiveParse)
], KHR_mesh_quantization);

var KHR_texture_basisu = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(KHR_texture_basisu, GLTFExtensionParser);
    function KHR_texture_basisu() {
        return GLTFExtensionParser.apply(this, arguments) || this;
    }
    var _proto = KHR_texture_basisu.prototype;
    _proto.createAndParse = function createAndParse(context, schema, textureInfo) {
        var glTF = context.glTF, glTFResource = context.glTFResource;
        var engine = glTFResource.engine, url = glTFResource.url;
        var sampler = textureInfo.sampler, textureName = textureInfo.name;
        var source = schema.source;
        var _glTF_images_source = glTF.images[source], uri = _glTF_images_source.uri, bufferViewIndex = _glTF_images_source.bufferView, mimeType = _glTF_images_source.mimeType, imageName = _glTF_images_source.name;
        var samplerInfo = sampler !== undefined && GLTFUtils.getSamplerInfo(glTF.samplers[sampler]);
        if (uri) {
            var index = uri.lastIndexOf(".");
            var promise = engine.resourceManager.load({
                url: Utils.resolveAbsoluteUrl(url, uri),
                type: AssetType.KTX2
            }).onProgress(undefined, context._onTaskDetail).then(function(texture) {
                if (!texture.name) {
                    texture.name = textureName || imageName || "texture_" + index;
                }
                if (sampler !== undefined) {
                    GLTFUtils.parseSampler(texture, samplerInfo);
                }
                return texture;
            });
            context._addTaskCompletePromise(promise);
            return promise;
        } else {
            var bufferView = glTF.bufferViews[bufferViewIndex];
            return context.get(GLTFParserType.Buffer, bufferView.buffer).then(function(buffer) {
                var imageBuffer = new Uint8Array(buffer, bufferView.byteOffset, bufferView.byteLength);
                return KTX2Loader._parseBuffer(imageBuffer, engine).then(function(param) {
                    var ktx2Container = param.ktx2Container, engine = param.engine, result = param.result, targetFormat = param.targetFormat, params = param.params;
                    return KTX2Loader._createTextureByBuffer(engine, ktx2Container.isSRGB, result, targetFormat, params);
                }).then(function(texture) {
                    texture.name = textureName || imageName || "texture_" + bufferViewIndex;
                    if (sampler !== undefined) {
                        GLTFUtils.parseSampler(texture, samplerInfo);
                    }
                    var bufferTextureRestoreInfo = new BufferTextureRestoreInfo(texture, bufferView, mimeType);
                    context.contentRestorer.bufferTextures.push(bufferTextureRestoreInfo);
                    return texture;
                });
            }).catch(function(e) {
                Logger.error("KHR_texture_basisu: buffer error", e);
            });
        }
    };
    return KHR_texture_basisu;
}(GLTFExtensionParser);
KHR_texture_basisu = __decorate([
    registerGLTFExtension("KHR_texture_basisu", GLTFExtensionMode.CreateAndParse)
], KHR_texture_basisu);

var KHR_texture_transform = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(KHR_texture_transform, GLTFExtensionParser);
    function KHR_texture_transform() {
        return GLTFExtensionParser.apply(this, arguments) || this;
    }
    var _proto = KHR_texture_transform.prototype;
    _proto.additiveParse = function additiveParse(context, material, schema) {
        var offset = schema.offset, rotation = schema.rotation, scale = schema.scale, texCoord = schema.texCoord;
        if (offset) {
            material.tilingOffset.z = offset[0];
            material.tilingOffset.w = offset[1];
        }
        if (scale) {
            material.tilingOffset.x = scale[0];
            material.tilingOffset.y = scale[1];
        }
        if (rotation) {
            Logger.warn("rotation in KHR_texture_transform is not supported now");
        }
        if (texCoord) {
            Logger.warn("texCoord in KHR_texture_transform is not supported now");
        }
    };
    return KHR_texture_transform;
}(GLTFExtensionParser);
KHR_texture_transform = __decorate([
    registerGLTFExtension("KHR_texture_transform", GLTFExtensionMode.AdditiveParse)
], KHR_texture_transform);

var GALACEAN_materials_remap = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(GALACEAN_materials_remap, GLTFExtensionParser);
    function GALACEAN_materials_remap() {
        return GLTFExtensionParser.apply(this, arguments) || this;
    }
    var _proto = GALACEAN_materials_remap.prototype;
    _proto.createAndParse = function createAndParse(context, schema) {
        var engine = context.glTFResource.engine;
        // @ts-ignore
        var promise = engine.resourceManager.getResourceByRef(schema);
        context._addTaskCompletePromise(promise);
        return promise;
    };
    return GALACEAN_materials_remap;
}(GLTFExtensionParser);
GALACEAN_materials_remap = __decorate([
    registerGLTFExtension("GALACEAN_materials_remap", GLTFExtensionMode.CreateAndParse)
], GALACEAN_materials_remap);

var GALACEAN_animation_event = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(GALACEAN_animation_event, GLTFExtensionParser);
    function GALACEAN_animation_event() {
        return GLTFExtensionParser.apply(this, arguments) || this;
    }
    var _proto = GALACEAN_animation_event.prototype;
    _proto.additiveParse = function additiveParse(context, animationClip, schema) {
        context.glTFResource.engine;
        var events = schema.events;
        events.map(function(eventData) {
            var event = new AnimationEvent();
            event.functionName = eventData.functionName;
            event.time = eventData.time;
            event.parameter = eventData.parameter;
            animationClip.addEvent(event);
        });
    };
    return GALACEAN_animation_event;
}(GLTFExtensionParser);
GALACEAN_animation_event = __decorate([
    registerGLTFExtension("GALACEAN_animation_event", GLTFExtensionMode.AdditiveParse)
], GALACEAN_animation_event);

var EXT_meshopt_compression = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(EXT_meshopt_compression, GLTFExtensionParser);
    function EXT_meshopt_compression() {
        return GLTFExtensionParser.apply(this, arguments) || this;
    }
    var _proto = EXT_meshopt_compression.prototype;
    _proto.createAndParse = function createAndParse(context, schema) {
        return context.get(GLTFParserType.Buffer, schema.buffer).then(function(arrayBuffer) {
            return getMeshoptDecoder().then(function(decoder) {
                return decoder.decodeGltfBuffer(schema.count, schema.byteStride, new Uint8Array(arrayBuffer, schema.byteOffset, schema.byteLength), schema.mode, schema.filter);
            });
        }).catch(function(e) {
            Logger.error("EXT_meshopt_compression: buffer error", e);
        });
    };
    return EXT_meshopt_compression;
}(GLTFExtensionParser);
EXT_meshopt_compression = __decorate([
    registerGLTFExtension("EXT_meshopt_compression", GLTFExtensionMode.CreateAndParse)
], EXT_meshopt_compression);

var KHR_materials_anisotropy = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(KHR_materials_anisotropy, GLTFExtensionParser);
    function KHR_materials_anisotropy() {
        return GLTFExtensionParser.apply(this, arguments) || this;
    }
    var _proto = KHR_materials_anisotropy.prototype;
    _proto.additiveParse = function additiveParse(context, material, schema) {
        var _schema_anisotropyStrength = schema.anisotropyStrength, anisotropyStrength = _schema_anisotropyStrength === void 0 ? 0 : _schema_anisotropyStrength, _schema_anisotropyRotation = schema.anisotropyRotation, anisotropyRotation = _schema_anisotropyRotation === void 0 ? 0 : _schema_anisotropyRotation, anisotropyTexture = schema.anisotropyTexture;
        material.anisotropy = anisotropyStrength;
        material.anisotropyRotation = anisotropyRotation;
        if (anisotropyTexture) {
            GLTFMaterialParser._checkOtherTextureTransform(anisotropyTexture, "Anisotropy texture");
            context.get(GLTFParserType.Texture, anisotropyTexture.index).then(function(texture) {
                material.anisotropyTexture = texture;
            }).catch(function(e) {
                Logger.error("KHR_materials_anisotropy: anisotropy texture error", e);
            });
        }
    };
    return KHR_materials_anisotropy;
}(GLTFExtensionParser);
KHR_materials_anisotropy = __decorate([
    registerGLTFExtension("KHR_materials_anisotropy", GLTFExtensionMode.AdditiveParse)
], KHR_materials_anisotropy);

var KHR_materials_iridescence = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(KHR_materials_iridescence, GLTFExtensionParser);
    function KHR_materials_iridescence() {
        return GLTFExtensionParser.apply(this, arguments) || this;
    }
    var _proto = KHR_materials_iridescence.prototype;
    _proto.additiveParse = function additiveParse(context, material, schema) {
        var _schema_iridescenceFactor = schema.iridescenceFactor, iridescenceFactor = _schema_iridescenceFactor === void 0 ? 0 : _schema_iridescenceFactor, iridescenceTexture = schema.iridescenceTexture, _schema_iridescenceIor = schema.iridescenceIor, iridescenceIor = _schema_iridescenceIor === void 0 ? 1.3 : _schema_iridescenceIor, _schema_iridescenceThicknessMinimum = schema.iridescenceThicknessMinimum, iridescenceThicknessMinimum = _schema_iridescenceThicknessMinimum === void 0 ? 100 : _schema_iridescenceThicknessMinimum, _schema_iridescenceThicknessMaximum = schema.iridescenceThicknessMaximum, iridescenceThicknessMaximum = _schema_iridescenceThicknessMaximum === void 0 ? 400 : _schema_iridescenceThicknessMaximum, iridescenceThicknessTexture = schema.iridescenceThicknessTexture;
        material.iridescence = iridescenceFactor;
        material.iridescenceIOR = iridescenceIor;
        material.iridescenceThicknessRange.set(iridescenceThicknessMinimum, iridescenceThicknessMaximum);
        if (iridescenceTexture) {
            GLTFMaterialParser._checkOtherTextureTransform(iridescenceTexture, "Iridescence texture");
            context.get(GLTFParserType.Texture, iridescenceTexture.index).then(function(texture) {
                material.iridescenceTexture = texture;
            }).catch(function(e) {
                Logger.error("KHR_materials_iridescence: iridescence texture error", e);
            });
        }
        if (iridescenceThicknessTexture) {
            GLTFMaterialParser._checkOtherTextureTransform(iridescenceThicknessTexture, "IridescenceThickness texture");
            context.get(GLTFParserType.Texture, iridescenceThicknessTexture.index).then(function(texture) {
                material.iridescenceThicknessTexture = texture;
            }).catch(function(e) {
                Logger.error("KHR_materials_iridescence: iridescence thickness error", e);
            });
        }
    };
    return KHR_materials_iridescence;
}(GLTFExtensionParser);
KHR_materials_iridescence = __decorate([
    registerGLTFExtension("KHR_materials_iridescence", GLTFExtensionMode.AdditiveParse)
], KHR_materials_iridescence);

var EXT_texture_webp = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(EXT_texture_webp, GLTFExtensionParser);
    function EXT_texture_webp() {
        return GLTFExtensionParser.apply(this, arguments) || this;
    }
    var _proto = EXT_texture_webp.prototype;
    _proto.createAndParse = function createAndParse(context, schema, textureInfo, textureIndex, isSRGBColorSpace) {
        var webPIndex = schema.source;
        var sampler = textureInfo.sampler, tmp = textureInfo.source, fallbackIndex = tmp === void 0 ? 0 : tmp, textureName = textureInfo.name;
        return SystemInfo._checkWebpSupported().then(function(supportWebP) {
            return GLTFTextureParser._parseTexture(context, supportWebP ? webPIndex : fallbackIndex, textureIndex, sampler, textureName, isSRGBColorSpace);
        });
    };
    return EXT_texture_webp;
}(GLTFExtensionParser);
EXT_texture_webp = __decorate([
    registerGLTFExtension("EXT_texture_webp", GLTFExtensionMode.CreateAndParse)
], EXT_texture_webp);

//@ts-ignore
var version = "1.5.7";
console.log("Galacean Engine Version: " + version);
for(var key in CoreObjects){
    Loader.registerClass(key, CoreObjects[key]);
}

ShaderProperty.getByName("u_width");
ShaderProperty.getByName("u_min");
ShaderProperty.getByName("u_max");
ShaderProperty.getByName("u_boxColor");
ShaderProperty.getByName("u_borderColor");
Shader.create("box", "\n#include <common>\n#include <common_vert>\n\nvoid main() {\n  gl_Position = vec4(POSITION, 1.0);\n}", "\nuniform vec2 u_min;\nuniform vec2 u_max;\nuniform vec4 u_boxColor;\nuniform vec4 u_borderColor;\nuniform float u_width;\n\nvoid main() {\n  float vColor = step(u_min.x + u_width, gl_FragCoord.x) * step(gl_FragCoord.x, u_max.x - u_width) * step(u_min.y + u_width, gl_FragCoord.y) * step(gl_FragCoord.y, u_max.y - u_width);\n  float vBorder = step(u_min.x, gl_FragCoord.x) * step(gl_FragCoord.x, u_max.x) * step(u_min.y, gl_FragCoord.y) * step(gl_FragCoord.y, u_max.y);\n  gl_FragColor = u_boxColor * vColor + (1. - vColor) * vBorder * u_borderColor;\n}\n");

new BoundingFrustum();
new Vector3();
new Vector2();
new Vector3();
new Vector3();
new Vector3();
new Vector3();
new Vector3();
new Vector3();
new Vector3();
new Vector3();
new Vector3();
new Vector3();
new Vector3();
new Vector3();
new Matrix();

var ControlHandlerType = /*#__PURE__*/ function(ControlHandlerType) {
    ControlHandlerType[ControlHandlerType["None"] = 0] = "None";
    ControlHandlerType[ControlHandlerType["ROTATE"] = 1] = "ROTATE";
    ControlHandlerType[ControlHandlerType["ZOOM"] = 2] = "ZOOM";
    ControlHandlerType[ControlHandlerType["PAN"] = 4] = "PAN";
    ControlHandlerType[ControlHandlerType["All"] = 7] = "All";
    return ControlHandlerType;
}({});

// Prevent gimbal lock.
var ESP = MathUtil.zeroTolerance;
// Spherical.
var Spherical = /*#__PURE__*/ function() {
    function Spherical(radius, phi, theta) {
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
        this._matrix = new Matrix();
        this._matrixInv = new Matrix();
        this.radius = radius !== undefined ? radius : 1.0;
        this.phi = phi !== undefined ? phi : 0;
        this.theta = theta !== undefined ? theta : 0;
    }
    var _proto = Spherical.prototype;
    _proto.makeSafe = function makeSafe() {
        var count = Math.floor(this.phi / Math.PI);
        this.phi = MathUtil.clamp(this.phi, count * Math.PI + ESP, (count + 1) * Math.PI - ESP);
        return this;
    };
    _proto.set = function set(radius, phi, theta) {
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
        return this;
    };
    _proto.setYAxis = function setYAxis(up) {
        var xAxis = Spherical._xAxis, yAxis = Spherical._yAxis, zAxis = Spherical._zAxis;
        if (Vector3.equals(xAxis.set(1, 0, 0), yAxis.copyFrom(up).normalize())) {
            xAxis.set(0, 1, 0);
        }
        Vector3.cross(xAxis, yAxis, zAxis);
        zAxis.normalize();
        Vector3.cross(yAxis, zAxis, xAxis);
        var _this__matrix = this._matrix, es = _this__matrix.elements;
        es[0] = xAxis.x, es[1] = xAxis.y, es[2] = xAxis.z;
        es[4] = yAxis.x, es[5] = yAxis.y, es[6] = yAxis.z;
        es[8] = zAxis.x, es[9] = zAxis.y, es[10] = zAxis.z;
        var _this__matrixInv = this._matrixInv, eInv = _this__matrixInv.elements;
        eInv[0] = xAxis.x, eInv[4] = xAxis.y, eInv[8] = xAxis.z;
        eInv[1] = yAxis.x, eInv[5] = yAxis.y, eInv[9] = yAxis.z;
        eInv[2] = zAxis.x, eInv[6] = zAxis.y, eInv[10] = zAxis.z;
    };
    _proto.setFromVec3 = function setFromVec3(value, atTheBack) {
        if (atTheBack === void 0) atTheBack = false;
        value.transformNormal(this._matrixInv);
        this.radius = value.length();
        if (this.radius === 0) {
            this.theta = 0;
            this.phi = 0;
        } else {
            if (atTheBack) {
                this.phi = 2 * Math.PI - Math.acos(MathUtil.clamp(value.y / this.radius, -1, 1));
                this.theta = Math.atan2(-value.x, -value.z);
            } else {
                this.phi = Math.acos(MathUtil.clamp(value.y / this.radius, -1, 1));
                this.theta = Math.atan2(value.x, value.z);
            }
        }
        return this;
    };
    _proto.setToVec3 = function setToVec3(value) {
        var _this = this, radius = _this.radius, phi = _this.phi, theta = _this.theta;
        var sinPhiRadius = Math.sin(phi) * radius;
        this.phi -= Math.floor(this.phi / Math.PI / 2) * Math.PI * 2;
        value.set(sinPhiRadius * Math.sin(theta), radius * Math.cos(phi), sinPhiRadius * Math.cos(theta));
        value.transformNormal(this._matrix);
        return this.phi > Math.PI;
    };
    return Spherical;
}();
Spherical._xAxis = new Vector3();
Spherical._yAxis = new Vector3();
Spherical._zAxis = new Vector3();

var ControlKeyboard = /*#__PURE__*/ function() {
    function ControlKeyboard() {}
    var _proto = ControlKeyboard.prototype;
    _proto.onUpdateHandler = function onUpdateHandler(input) {
        if (input.isKeyHeldDown(Keys.ArrowLeft) || input.isKeyHeldDown(Keys.ArrowRight) || input.isKeyHeldDown(Keys.ArrowUp) || input.isKeyHeldDown(Keys.ArrowDown)) {
            return ControlHandlerType.PAN;
        } else {
            return ControlHandlerType.None;
        }
    };
    _proto.onUpdateDelta = function onUpdateDelta(control, outDelta) {
        var keyPanSpeed = control.keyPanSpeed, input = control.input;
        outDelta.x = outDelta.y = 0;
        if (input.isKeyHeldDown(Keys.ArrowLeft)) {
            outDelta.x += keyPanSpeed;
        }
        if (input.isKeyHeldDown(Keys.ArrowRight)) {
            outDelta.x -= keyPanSpeed;
        }
        if (input.isKeyHeldDown(Keys.ArrowUp)) {
            outDelta.y += keyPanSpeed;
        }
        if (input.isKeyHeldDown(Keys.ArrowDown)) {
            outDelta.y -= keyPanSpeed;
        }
    };
    return ControlKeyboard;
}();

var ControlPointer = /*#__PURE__*/ function() {
    function ControlPointer() {
        this._deltaType = 2;
        this._handlerType = ControlHandlerType.None;
        this._frameIndex = 0;
        this._lastUsefulFrameIndex = -1;
        this._distanceOfPointers = 0;
    }
    var _proto = ControlPointer.prototype;
    _proto.onUpdateHandler = function onUpdateHandler(input) {
        ++this._frameIndex;
        var pointers = input.pointers;
        switch(pointers.length){
            case 1:
                if (input.isPointerHeldDown(PointerButton.Secondary)) {
                    this._updateType(ControlHandlerType.PAN, 0);
                } else if (input.isPointerHeldDown(PointerButton.Auxiliary)) {
                    this._updateType(ControlHandlerType.ZOOM, 0);
                } else if (input.isPointerHeldDown(PointerButton.Primary)) {
                    this._updateType(ControlHandlerType.ROTATE, 0);
                } else {
                    // When `onPointerMove` happens on the same frame as `onPointerUp`
                    // Need to record the movement of this frame
                    var deltaPosition = input.pointers[0].deltaPosition;
                    if (deltaPosition.x !== 0 && deltaPosition.y !== 0) {
                        if (input.isPointerUp(PointerButton.Secondary)) {
                            this._updateType(ControlHandlerType.PAN, 0);
                        } else if (input.isPointerUp(PointerButton.Auxiliary)) {
                            this._updateType(ControlHandlerType.ZOOM, 0);
                        } else if (input.isPointerUp(PointerButton.Primary)) {
                            this._updateType(ControlHandlerType.ROTATE, 0);
                        } else {
                            this._updateType(ControlHandlerType.None, 2);
                        }
                    } else {
                        this._updateType(ControlHandlerType.None, 2);
                    }
                }
                break;
            case 2:
                this._updateType(ControlHandlerType.ZOOM, 1);
                break;
            case 3:
                this._updateType(ControlHandlerType.PAN, 0);
                break;
            default:
                this._updateType(ControlHandlerType.None, 2);
                break;
        }
        return this._handlerType;
    };
    _proto.onUpdateDelta = function onUpdateDelta(control, outDelta) {
        var _this = this, frameIndex = _this._frameIndex;
        switch(this._deltaType){
            case 0:
                outDelta.x = 0;
                outDelta.y = 0;
                if (this._lastUsefulFrameIndex === frameIndex - 1) {
                    var pointers = control.input.pointers;
                    var length = pointers.length;
                    for(var i = length - 1; i >= 0; i--){
                        var deltaPosition = pointers[i].deltaPosition;
                        outDelta.x += deltaPosition.x;
                        outDelta.y += deltaPosition.y;
                    }
                    outDelta.x /= length;
                    outDelta.y /= length;
                }
                break;
            case 1:
                var pointers1 = control.input.pointers;
                var pointer1 = pointers1[0];
                var pointer2 = pointers1[1];
                var curDistance = Vector2.distance(pointer1.position, pointer2.position);
                if (this._lastUsefulFrameIndex === frameIndex - 1) {
                    outDelta.set(0, this._distanceOfPointers - curDistance, 0);
                } else {
                    outDelta.set(0, 0, 0);
                }
                this._distanceOfPointers = curDistance;
                break;
        }
        this._lastUsefulFrameIndex = frameIndex;
    };
    _proto._updateType = function _updateType(handlerType, deltaType) {
        if (this._handlerType !== handlerType || this._deltaType !== deltaType) {
            this._handlerType = handlerType;
            this._deltaType = deltaType;
            this._lastUsefulFrameIndex = -1;
        }
    };
    return ControlPointer;
}();

var ControlWheel = /*#__PURE__*/ function() {
    function ControlWheel() {}
    var _proto = ControlWheel.prototype;
    _proto.onUpdateHandler = function onUpdateHandler(input) {
        var wheelDelta = input.wheelDelta;
        if (wheelDelta.x === 0 && wheelDelta.y === 0 && wheelDelta.z === 0) {
            return ControlHandlerType.None;
        } else {
            return ControlHandlerType.ZOOM;
        }
    };
    _proto.onUpdateDelta = function onUpdateDelta(control, outDelta) {
        outDelta.copyFrom(control.input.wheelDelta);
    };
    return ControlWheel;
}();

function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else return left instanceof right;
}

/**
 * The camera's track controller, can rotate, zoom, pan, support mouse and touch events.
 */ var OrbitControl = /*#__PURE__*/ function(Script) {
    _inherits$3(OrbitControl, Script);
    function OrbitControl() {
        var _this;
        _this = Script.apply(this, arguments) || this, _this.inputDevices = [
            new ControlKeyboard(),
            new ControlPointer(),
            new ControlWheel()
        ], /** Whether to automatically rotate the camera, the default is false. */ _this.autoRotate = false, /** The radian of automatic rotation per second. */ _this.autoRotateSpeed = Math.PI, /** Whether to enable camera damping, the default is true. */ _this.enableDamping = true, /** Rotation speed, default is 1.0 . */ _this.rotateSpeed = 1.0, /** Camera zoom speed, the default is 1.0. */ _this.zoomSpeed = 1.0, /** Keyboard translation speed, the default is 7.0 . */ _this.keyPanSpeed = 7.0, /** Rotation damping parameter, default is 0.1 . */ _this.dampingFactor = 0.1, /** Zoom damping parameter, default is 0.2 . */ _this.zoomFactor = 0.2, /**  The minimum distance, the default is 0.1, should be greater than 0. */ _this.minDistance = 0.1, /** The maximum distance, the default is infinite, should be greater than the minimum distance. */ _this.maxDistance = Infinity, /** Minimum zoom speed, the default is 0.0. */ _this.minZoom = 0.0, /** Maximum zoom speed, the default is positive infinity. */ _this.maxZoom = Infinity, /** The minimum radian in the vertical direction, the default is 1 degree. */ _this.minPolarAngle = 1 / 180 * Math.PI, /** The maximum radian in the vertical direction,  the default is 179 degree.  */ _this.maxPolarAngle = 179 / 180 * Math.PI, /** The minimum radian in the horizontal direction, the default is negative infinity. */ _this.minAzimuthAngle = -Infinity, /** The maximum radian in the horizontal direction, the default is positive infinity.  */ _this.maxAzimuthAngle = Infinity, _this._enableKeys = true, _this._up = new Vector3(0, 1, 0), _this._target = new Vector3(), _this._atTheBack = false, _this._spherical = new Spherical(), _this._sphericalDelta = new Spherical(), _this._sphericalDump = new Spherical(), _this._zoomFrag = 0, _this._scale = 1, _this._panOffset = new Vector3(), _this._tempVec3 = new Vector3(), _this._enableHandler = ControlHandlerType.All;
        return _this;
    }
    var _proto = OrbitControl.prototype;
    _proto.onAwake = function onAwake() {
        var _this = this, engine = _this.engine, entity = _this.entity;
        this.canvas = engine.canvas;
        this.input = engine.inputManager;
        this.camera = entity.getComponent(Camera);
        this.cameraTransform = entity.transform;
        this._spherical.setYAxis(this._up);
        this._atTheBack = false;
    };
    _proto.onLateUpdate = function onLateUpdate(deltaTime) {
        /** Update this._sphericalDelta, this._scale and this._panOffset. */ this._updateInputDelta(deltaTime);
        /** Update camera's transform. */ this._updateTransform();
    };
    _proto._updateInputDelta = function _updateInputDelta(deltaTime) {
        var curHandlerType = ControlHandlerType.None;
        var _this = this, delta = _this._tempVec3, enableHandler = _this._enableHandler;
        var _this1 = this, inputDevices = _this1.inputDevices, input = _this1.input;
        for(var i = inputDevices.length - 1; i >= 0; i--){
            var handler = inputDevices[i];
            var handlerType = handler.onUpdateHandler(input);
            if (handlerType & enableHandler) {
                curHandlerType |= handlerType;
                handler.onUpdateDelta(this, delta);
                switch(handlerType){
                    case ControlHandlerType.ROTATE:
                        this._rotate(delta);
                        break;
                    case ControlHandlerType.ZOOM:
                        this._zoom(delta);
                        break;
                    case ControlHandlerType.PAN:
                        this._pan(delta);
                        break;
                }
            }
        }
        var _this2 = this, _sphericalDump = _this2._sphericalDump, _sphericalDelta = _this2._sphericalDelta;
        if (this.enableDamping) {
            if (enableHandler & ControlHandlerType.ZOOM && curHandlerType ^ ControlHandlerType.ZOOM) {
                this._zoomFrag *= 1 - this.zoomFactor;
            }
            if (enableHandler & ControlHandlerType.ROTATE && curHandlerType ^ ControlHandlerType.ROTATE) {
                _sphericalDelta.theta = _sphericalDump.theta *= 1 - this.dampingFactor;
                _sphericalDelta.phi = _sphericalDump.phi *= 1 - this.dampingFactor;
            }
        }
        if (curHandlerType === ControlHandlerType.None && this.autoRotate) {
            var rotateAngle = this.autoRotateSpeed * deltaTime;
            _sphericalDelta.theta -= rotateAngle;
        }
    };
    _proto._rotate = function _rotate(delta) {
        var radianLeft = 2 * Math.PI * delta.x / this.canvas.width * this.rotateSpeed;
        this._sphericalDelta.theta -= radianLeft;
        var radianUp = 2 * Math.PI * delta.y / this.canvas.height * this.rotateSpeed;
        this._sphericalDelta.phi -= radianUp;
        if (this.enableDamping) {
            this._sphericalDump.theta = -radianLeft;
            this._sphericalDump.phi = -radianUp;
        }
    };
    _proto._zoom = function _zoom(delta) {
        if (delta.y > 0) {
            this._scale /= Math.pow(0.95, this.zoomSpeed);
        } else if (delta.y < 0) {
            this._scale *= Math.pow(0.95, this.zoomSpeed);
        }
    };
    _proto._pan = function _pan(delta) {
        var cameraTransform = this.cameraTransform;
        var elements = cameraTransform.worldMatrix.elements;
        var height = this.canvas.height;
        var targetDistance = Vector3.distance(cameraTransform.position, this.target) * (this.camera.fieldOfView / 2) * (Math.PI / 180);
        var distanceLeft = -2 * delta.x * (targetDistance / height);
        var distanceUp = 2 * delta.y * (targetDistance / height);
        this._panOffset.x += elements[0] * distanceLeft + elements[4] * distanceUp;
        this._panOffset.y += elements[1] * distanceLeft + elements[5] * distanceUp;
        this._panOffset.z += elements[2] * distanceLeft + elements[6] * distanceUp;
    };
    _proto._updateTransform = function _updateTransform() {
        var _this = this, cameraTransform = _this.cameraTransform, target = _this.target, _tempVec3 = _this._tempVec3, _spherical = _this._spherical, _sphericalDelta = _this._sphericalDelta, _panOffset = _this._panOffset;
        _tempVec3.copyFrom(cameraTransform.worldUp);
        this._atTheBack = _tempVec3.y <= 0;
        Vector3.subtract(cameraTransform.position, target, _tempVec3);
        _spherical.setFromVec3(_tempVec3, this._atTheBack);
        _spherical.theta += _sphericalDelta.theta;
        _spherical.phi += _sphericalDelta.phi;
        _spherical.theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, _spherical.theta));
        _spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, _spherical.phi));
        _spherical.makeSafe();
        if (this._scale !== 1) {
            this._zoomFrag = _spherical.radius * (this._scale - 1);
        }
        _spherical.radius += this._zoomFrag;
        _spherical.radius = Math.max(this.minDistance, Math.min(this.maxDistance, _spherical.radius));
        this._atTheBack = _spherical.setToVec3(_tempVec3);
        Vector3.add(target.add(_panOffset), _tempVec3, cameraTransform.worldPosition);
        cameraTransform.lookAt(target, _tempVec3.copyFrom(this.up).scale(this._atTheBack ? -1 : 1));
        /** Reset cache value. */ this._zoomFrag = 0;
        this._scale = 1;
        _sphericalDelta.set(0, 0, 0);
        _panOffset.set(0, 0, 0);
    };
    _create_class$4(OrbitControl, [
        {
            key: "enableKeys",
            get: /**
   * Return whether to enable keyboard.
   */ function get() {
                return this._enableKeys;
            },
            set: function set(value) {
                if (this._enableKeys !== value) {
                    this._enableKeys = value;
                    var inputDevices = this.inputDevices;
                    if (value) {
                        inputDevices.push(new ControlKeyboard());
                    } else {
                        for(var i = inputDevices.length - 1; i >= 0; i--){
                            if (_instanceof(inputDevices[i], ControlKeyboard)) {
                                inputDevices.splice(i, 1);
                                break;
                            }
                        }
                    }
                }
            }
        },
        {
            key: "up",
            get: /*
   * Return up vector.
   */ function get() {
                return this._up;
            },
            set: function set(value) {
                this._up.copyFrom(value);
                this._spherical.setYAxis(value);
                this._atTheBack = false;
            }
        },
        {
            key: "target",
            get: /**
   * Return target position.
   * */ function get() {
                return this._target;
            },
            set: function set(value) {
                this._target.copyFrom(value);
                this._atTheBack = false;
            }
        },
        {
            key: "enableRotate",
            get: /**
   *  Return Whether to enable rotation, the default is true.
   */ function get() {
                return (this._enableHandler & ControlHandlerType.ROTATE) !== 0;
            },
            set: function set(value) {
                if (value) {
                    this._enableHandler |= ControlHandlerType.ROTATE;
                } else {
                    this._enableHandler &= ~ControlHandlerType.ROTATE;
                }
            }
        },
        {
            key: "enableZoom",
            get: /**
   *  Whether to enable camera damping, the default is true.
   */ function get() {
                return (this._enableHandler & ControlHandlerType.ZOOM) !== 0;
            },
            set: function set(value) {
                if (value) {
                    this._enableHandler |= ControlHandlerType.ZOOM;
                } else {
                    this._enableHandler &= ~ControlHandlerType.ZOOM;
                }
            }
        },
        {
            key: "enablePan",
            get: /**
   *  Whether to enable translation, the default is true.
   */ function get() {
                return (this._enableHandler & ControlHandlerType.PAN) !== 0;
            },
            set: function set(value) {
                if (value) {
                    this._enableHandler |= ControlHandlerType.PAN;
                } else {
                    this._enableHandler &= ~ControlHandlerType.PAN;
                }
            }
        }
    ]);
    return OrbitControl;
}(Script);

WebGLEngine.create({ canvas: "canvas-id" }).then((engine) => {
  engine.canvas.resizeByClientSize();
  const scene = engine.sceneManager.activeScene;
  const rootEntity = scene.createRootEntity("Root");
  const shader = initCustomShader();
  const cameraEntity = rootEntity.createChild("Camera");
  const camera = cameraEntity.addComponent(Camera);
  cameraEntity.addComponent(OrbitControl);
  cameraEntity.transform.setPosition(0, 10, 160);
  cameraEntity.transform.lookAt(new Vector3(0, 0, 0));
  camera.farClipPlane = 300;
  const cubeEntity = rootEntity.createChild("Cube");
  const cubeRenderer = cubeEntity.addComponent(MeshRenderer);
  const material = new Material(engine, shader);
  cubeEntity.transform.rotate(0, 60, 0);
  cubeRenderer.mesh = createCustomMesh(engine, 1);
  cubeRenderer.setMaterial(material);
  engine.run();
});
function createCustomMesh(engine, size) {
  const geometry = new BufferMesh(engine, "CustomCubeGeometry");
  const vertices = new Float32Array([
    // Up
    -1,
    size,
    -1,
    0,
    1,
    0,
    size,
    size,
    -1,
    0,
    1,
    0,
    size,
    size,
    size,
    0,
    1,
    0,
    -1,
    size,
    size,
    0,
    1,
    0,
    // Down
    -1,
    -1,
    -1,
    0,
    -1,
    0,
    size,
    -1,
    -1,
    0,
    -1,
    0,
    size,
    -1,
    size,
    0,
    -1,
    0,
    -1,
    -1,
    size,
    0,
    -1,
    0,
    // Left
    -1,
    size,
    -1,
    -1,
    0,
    0,
    -1,
    size,
    size,
    -1,
    0,
    0,
    -1,
    -1,
    size,
    -1,
    0,
    0,
    -1,
    -1,
    -1,
    -1,
    0,
    0,
    // Right
    size,
    size,
    -1,
    1,
    0,
    0,
    size,
    size,
    size,
    1,
    0,
    0,
    size,
    -1,
    size,
    1,
    0,
    0,
    size,
    -1,
    -1,
    1,
    0,
    0,
    // Front
    -1,
    size,
    size,
    0,
    0,
    1,
    size,
    size,
    size,
    0,
    0,
    1,
    size,
    -1,
    size,
    0,
    0,
    1,
    -1,
    -1,
    size,
    0,
    0,
    1,
    // Back
    -1,
    size,
    -1,
    0,
    0,
    -1,
    size,
    size,
    -1,
    0,
    0,
    -1,
    size,
    -1,
    -1,
    0,
    0,
    -1,
    -1,
    -1,
    -1,
    0,
    0,
    -1
  ]);
  const instanceCount = 4e3;
  const instanceStride = 6;
  const instanceData = new Float32Array(
    instanceCount * instanceStride
  );
  for (let i = 0; i < instanceCount; i++) {
    const offset = i * instanceStride;
    instanceData[offset] = (Math.random() - 0.5) * 60;
    instanceData[offset + 1] = (Math.random() - 0.5) * 60;
    instanceData[offset + 2] = (Math.random() - 0.5) * 60;
    instanceData[offset + 3] = Math.random();
    instanceData[offset + 4] = Math.random();
    instanceData[offset + 5] = Math.random();
  }
  const indices = new Uint16Array([
    // Up
    0,
    2,
    1,
    2,
    0,
    3,
    // Down
    4,
    6,
    7,
    6,
    4,
    5,
    // Left
    8,
    10,
    9,
    10,
    8,
    11,
    // Right
    12,
    14,
    15,
    14,
    12,
    13,
    // Front
    16,
    18,
    17,
    18,
    16,
    19,
    // Back
    20,
    22,
    23,
    22,
    20,
    21
  ]);
  const vertexBuffer = new Buffer(
    engine,
    BufferBindFlag.VertexBuffer,
    vertices,
    BufferUsage.Static
  );
  const instanceVertexBuffer = new Buffer(
    engine,
    BufferBindFlag.VertexBuffer,
    instanceData,
    BufferUsage.Static
  );
  const indexBuffer = new Buffer(
    engine,
    BufferBindFlag.IndexBuffer,
    indices,
    BufferUsage.Static
  );
  geometry.setVertexBufferBinding(vertexBuffer, 24, 0);
  geometry.setVertexBufferBinding(instanceVertexBuffer, 24, 1);
  geometry.setIndexBufferBinding(indexBuffer, IndexFormat.UInt16);
  geometry.setVertexElements([
    new VertexElement("POSITION", 0, VertexElementFormat.Vector3, 0, 0),
    // Bind to VertexBuffer 0
    new VertexElement("NORMAL", 12, VertexElementFormat.Vector3, 0, 0),
    // Bind to VertexBuffer 0
    new VertexElement("INSTANCE_OFFSET", 0, VertexElementFormat.Vector3, 1, 1),
    // Bind instance offset to VertexBuffer 1, and enable instance by set instanceStepRate with 1
    new VertexElement("INSTANCE_COLOR", 12, VertexElementFormat.Vector3, 1, 1)
    // Bind instance color to VertexBuffer 1, and enable instance by set instanceStepRate with 1
  ]);
  geometry.addSubMesh(0, indices.length);
  geometry.instanceCount = instanceCount;
  return geometry;
}
function initCustomShader() {
  const shader = Shader.create(
    "CustomShader",
    `uniform mat4 renderer_MVPMat;
      attribute vec4 POSITION;
      attribute vec3 INSTANCE_OFFSET;
      attribute vec3 INSTANCE_COLOR;
      
      uniform mat4 renderer_MVMat;
      
      varying vec3 v_position;
      varying vec3 v_color;
      
      void main() {
        vec4 position = POSITION;
        position.xyz += INSTANCE_OFFSET;
        gl_Position = renderer_MVPMat * position;

        v_color = INSTANCE_COLOR;
      }`,
    `
      varying vec3 v_color;
      uniform vec4 u_color;
      
      void main() {
        vec4 color = vec4(v_color,1.0);
        gl_FragColor = color;
      }
      `
  );
  return shader;
}
